import { renderToString } from "react-dom/server";
import { QueryClient, QueryClientProvider, useSuspenseQuery } from "@tanstack/react-query";
import { BrowserRouter, Link, NavLink, Route, Routes, StaticRouter, useLocation, useParams } from "react-router";
import { BookOpen, Calendar, Clock, Github, PanelLeftIcon, Users, XIcon } from "lucide-react";
import * as React$1 from "react";
import React, { Suspense, createContext, useCallback, useContext, useEffect, useImperativeHandle, useMemo, useRef, useState } from "react";
import { Fragment, jsx, jsxs } from "react/jsx-runtime";
import { pick } from "es-toolkit/compat";
import { Slot } from "@radix-ui/react-slot";
import { cva } from "class-variance-authority";
import { clsx } from "clsx";
import { twMerge } from "tailwind-merge";
import * as SheetPrimitive from "@radix-ui/react-dialog";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
import minpath from "node:path";
import minproc from "node:process";
import { fileURLToPath as urlToPath } from "node:url";
import escape from "escape-string-regexp";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all$6) => {
	for (var name$2 in all$6) __defProp(target, name$2, {
		get: all$6[name$2],
		enumerable: true
	});
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys$1 = __getOwnPropNames(from), i = 0, n$1 = keys$1.length, key; i < n$1; i++) {
		key = keys$1[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
const queryClient = new QueryClient();
const fetchUsers = async () => {
	const { default: users } = await import("./assets/users-CwrbY1vH.js");
	return users;
};
const PageContext = createContext({
	title: "항해플러스 프론트엔드 6기",
	data: null
});
function usePageContext() {
	const context = useContext(PageContext);
	return context;
}
function usePageData() {
	const pageContext = usePageContext();
	return pageContext.data;
}
function usePageTitle() {
	const pageContext = usePageContext();
	return pageContext.title;
}
function PageProvider({ children,...props }) {
	return jsx(PageContext, {
		value: props,
		children
	});
}
const AppDataContext = createContext({});
function useAppDataContext() {
	return useContext(AppDataContext);
}
function AppDataProvider({ children, data }) {
	return jsx(AppDataContext, {
		value: data,
		children
	});
}
const queryKey = ["users"];
const useUsers = () => {
	const initData = useAppDataContext();
	const users = useSuspenseQuery({
		queryKey,
		queryFn: fetchUsers,
		initialData: initData
	});
	const items = useMemo(() => Object.values(users.data ?? {}), [users.data]);
	return {
		...users,
		items
	};
};
const useUser = (id$1) => {
	const users = useUsers();
	return users.data?.[id$1];
};
const useUserIdByParam = () => {
	const { id: id$1 } = useParams();
	if (!id$1) throw new Error("User ID is required");
	return id$1.slice(1);
};
var dynamic_import_helper_default = (glob$1, path$12, segs) => {
	const v$1 = glob$1[path$12];
	if (v$1) return typeof v$1 === "function" ? v$1() : Promise.resolve(v$1);
	return new Promise((_$1, reject) => {
		(typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(reject.bind(null, new Error("Unknown variable dynamic import: " + path$12 + (path$12.split("/").length !== segs ? ". Note that variables only represent file names one level deep." : ""))));
	});
};
const assignments = [
	{
		label: "Chapter 1-1. 프레임워크 없이 SPA 만들기 (1)",
		path: "front_6th_chapter1-1"
	},
	{
		label: "Chapter 1-2. 프레임워크 없이 SPA 만들기 (2)",
		path: "front_6th_chapter1-2"
	},
	{
		label: "Chapter 1-3. React, Beyond the Basics",
		path: "front_6th_chapter1-3"
	},
	{
		label: "Chapter 2-1. 클린코드와 리팩토링",
		path: "front_6th_chapter2-1"
	}
];
const fetchAssignments = async (path$1) => {
	const { default: data } = await dynamic_import_helper_default(Object.assign({
		"../../../../../docs/data/front_6th_chapter1-1/pulls.json": () => import("./assets/pulls-dTntISaN.js"),
		"../../../../../docs/data/front_6th_chapter1-2/pulls.json": () => import("./assets/pulls-CiVBaHK0.js"),
		"../../../../../docs/data/front_6th_chapter1-3/pulls.json": () => import("./assets/pulls-FlXI1B60.js"),
		"../../../../../docs/data/front_6th_chapter2-1/pulls.json": () => import("./assets/pulls-B_LWmVQe.js")
	}), `../../../../../docs/data/${path$1}/pulls.json`, 9);
	return data.map((item) => ({
		...pick(item, [
			"id",
			"user",
			"title",
			"body"
		]),
		url: item.html_url,
		createdAt: new Date(item.created_at),
		updatedAt: new Date(item.updated_at)
	}));
};
const fetchAllAssignments = async () => {
	const results = await Promise.all(assignments.map(({ path: path$1 }) => fetchAssignments(path$1)));
	return results.flat();
};
const fetchAssignmentsByUser = async (userId) => {
	const assignments$1 = await fetchAllAssignments();
	return assignments$1.filter((assignment) => assignment.user.login === userId);
};
const useAllAssignments = () => {
	const appData = useAppDataContext();
	return useSuspenseQuery({
		queryKey: ["assignments"],
		queryFn: fetchAllAssignments,
		initialData: Object.values(appData).flatMap((user) => user.assignments)
	});
};
const useAssignmentsByUser = (userId) => {
	const appData = useAppDataContext();
	return useSuspenseQuery({
		queryKey: ["assignments", userId],
		queryFn: () => fetchAssignmentsByUser(userId),
		initialData: appData[userId].assignments
	});
};
const useAssignmentById = (id$1, assignmentId) => {
	const appData = useAppDataContext();
	return useSuspenseQuery({
		queryKey: ["assignment-detail", id$1],
		queryFn: async () => {
			const userWithAssignments = await fetchAssignmentsByUser(id$1);
			return userWithAssignments.find((v$1) => v$1.id === Number(assignmentId));
		},
		initialData: appData[id$1]?.assignments?.find((v$1) => v$1.id === Number(assignmentId))
	});
};
const fetchUsersWithAssignments = async () => {
	const users = await fetchUsers();
	const assignments$1 = await fetchAllAssignments();
	return assignments$1.reduce((acc, assignment) => {
		const user = acc[assignment.user.login] ?? {
			...users[assignment.user.login],
			assignments: []
		};
		user.assignments.push(assignment);
		acc[assignment.user.login] = user;
		return acc;
	}, {});
};
function cn(...inputs) {
	return twMerge(clsx(inputs));
}
const formatDate = (dateString) => {
	return new Date(dateString).toLocaleDateString("ko-KR", {
		year: "numeric",
		month: "long",
		day: "numeric"
	});
};
const buttonVariants = cva("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", {
	variants: {
		variant: {
			default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
			destructive: "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
			outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
			secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
			ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
			link: "text-primary underline-offset-4 hover:underline cursor-pointer"
		},
		size: {
			default: "h-9 px-4 py-2 has-[>svg]:px-3",
			sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
			lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
			icon: "size-9"
		}
	},
	defaultVariants: {
		variant: "default",
		size: "default"
	}
});
function Button({ className: className$1, variant, size, asChild = false,...props }) {
	const Comp = asChild ? Slot : "button";
	return jsx(Comp, {
		"data-slot": "button",
		className: cn(buttonVariants({
			variant,
			size,
			className: className$1
		})),
		...props
	});
}
function CardRoot({ className: className$1,...props }) {
	return jsx("div", {
		"data-slot": "card",
		className: cn("card bg-background-card text-card-foreground flex flex-col gap-6 rounded-xl py-6 shadow-sm", className$1),
		...props
	});
}
function CardHeader({ className: className$1,...props }) {
	return jsx("div", {
		"data-slot": "card-header",
		className: cn("@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6", className$1),
		...props
	});
}
function CardTitle({ className: className$1,...props }) {
	return jsx("div", {
		"data-slot": "card-title",
		className: cn("leading-none font-semibold", className$1),
		...props
	});
}
function CardDescription({ className: className$1,...props }) {
	return jsx("div", {
		"data-slot": "card-description",
		className: cn("text-muted-foreground text-sm", className$1),
		...props
	});
}
function CardAction({ className: className$1,...props }) {
	return jsx("div", {
		"data-slot": "card-action",
		className: cn("col-start-2 row-span-2 row-start-1 self-start justify-self-end", className$1),
		...props
	});
}
function CardContent({ className: className$1,...props }) {
	return jsx("div", {
		"data-slot": "card-content",
		className: cn("px-6", className$1),
		...props
	});
}
function CardFooter({ className: className$1,...props }) {
	return jsx("div", {
		"data-slot": "card-footer",
		className: cn("flex items-center px-6 [.border-t]:pt-6", className$1),
		...props
	});
}
const Card = Object.assign(CardRoot, {
	Header: CardHeader,
	Title: CardTitle,
	Description: CardDescription,
	Action: CardAction,
	Content: CardContent,
	Footer: CardFooter
});
const badgeVariants = cva("inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden", {
	variants: { variant: {
		default: "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
		secondary: "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
		destructive: "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
		outline: "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground"
	} },
	defaultVariants: { variant: "default" }
});
function Badge({ className: className$1, variant, asChild = false,...props }) {
	const Comp = asChild ? Slot : "span";
	return jsx(Comp, {
		"data-slot": "badge",
		className: cn(badgeVariants({ variant }), className$1),
		...props
	});
}
function Sheet({ ...props }) {
	return jsx(SheetPrimitive.Root, {
		"data-slot": "sheet",
		...props
	});
}
function SheetPortal({ ...props }) {
	return jsx(SheetPrimitive.Portal, {
		"data-slot": "sheet-portal",
		...props
	});
}
function SheetOverlay({ className: className$1,...props }) {
	return jsx(SheetPrimitive.Overlay, {
		"data-slot": "sheet-overlay",
		className: cn("data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50", className$1),
		...props
	});
}
function SheetContent({ className: className$1, children, side = "right",...props }) {
	return jsxs(SheetPortal, { children: [jsx(SheetOverlay, {}), jsxs(SheetPrimitive.Content, {
		"data-slot": "sheet-content",
		className: cn("bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500", side === "right" && "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm", side === "left" && "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm", side === "top" && "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b", side === "bottom" && "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t", className$1),
		...props,
		children: [children, jsxs(SheetPrimitive.Close, {
			className: "ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none",
			children: [jsx(XIcon, { className: "size-4" }), jsx("span", {
				className: "sr-only",
				children: "Close"
			})]
		})]
	})] });
}
function SheetHeader({ className: className$1,...props }) {
	return jsx("div", {
		"data-slot": "sheet-header",
		className: cn("flex flex-col gap-1.5 p-4", className$1),
		...props
	});
}
function SheetTitle({ className: className$1,...props }) {
	return jsx(SheetPrimitive.Title, {
		"data-slot": "sheet-title",
		className: cn("text-foreground font-semibold", className$1),
		...props
	});
}
function SheetDescription({ className: className$1,...props }) {
	return jsx(SheetPrimitive.Description, {
		"data-slot": "sheet-description",
		className: cn("text-muted-foreground text-sm", className$1),
		...props
	});
}
function TooltipProvider({ delayDuration = 0,...props }) {
	return jsx(TooltipPrimitive.Provider, {
		"data-slot": "tooltip-provider",
		delayDuration,
		...props
	});
}
function Tooltip({ ...props }) {
	return jsx(TooltipProvider, { children: jsx(TooltipPrimitive.Root, {
		"data-slot": "tooltip",
		...props
	}) });
}
function TooltipTrigger({ ...props }) {
	return jsx(TooltipPrimitive.Trigger, {
		"data-slot": "tooltip-trigger",
		...props
	});
}
function TooltipContent({ className: className$1, sideOffset = 0, children,...props }) {
	return jsx(TooltipPrimitive.Portal, { children: jsxs(TooltipPrimitive.Content, {
		"data-slot": "tooltip-content",
		sideOffset,
		className: cn("bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance", className$1),
		...props,
		children: [children, jsx(TooltipPrimitive.Arrow, { className: "bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" })]
	}) });
}
const MOBILE_BREAKPOINT = 768;
function useMobile() {
	const [mobile, setMobile] = useState(false);
	useEffect(() => {
		const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
		const onChange = () => {
			setMobile(window.innerWidth < MOBILE_BREAKPOINT);
		};
		mql.addEventListener("change", onChange);
		setMobile(window.innerWidth < MOBILE_BREAKPOINT);
		return () => mql.removeEventListener("change", onChange);
	}, []);
	return mobile;
}
const SIDEBAR_COOKIE_NAME = "sidebar_state";
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = "16rem";
const SIDEBAR_WIDTH_MOBILE = "18rem";
const SIDEBAR_WIDTH_ICON = "3rem";
const SIDEBAR_KEYBOARD_SHORTCUT = "b";
const SidebarContext = createContext(null);
function useSidebar() {
	const context = useContext(SidebarContext);
	if (!context) throw new Error("useSidebar must be used within a SidebarProvider.");
	return context;
}
function SidebarProvider({ defaultOpen = true, open: openProp, onOpenChange: setOpenProp, className: className$1, style: style$2, children,...props }) {
	const mobile = useMobile();
	const [openMobile, setOpenMobile] = useState(false);
	const [_open, _setOpen] = useState(defaultOpen);
	const open = openProp ?? _open;
	const setOpen = useCallback((value) => {
		const openState = typeof value === "function" ? value(open) : value;
		if (setOpenProp) setOpenProp(openState);
		else _setOpen(openState);
		document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;
	}, [setOpenProp, open]);
	const toggleSidebar = useCallback(() => {
		return mobile ? setOpenMobile((open$1) => !open$1) : setOpen((open$1) => !open$1);
	}, [
		mobile,
		setOpen,
		setOpenMobile
	]);
	useEffect(() => {
		const handleKeyDown = (event) => {
			if (event.key === SIDEBAR_KEYBOARD_SHORTCUT && (event.metaKey || event.ctrlKey)) {
				event.preventDefault();
				toggleSidebar();
			}
		};
		window.addEventListener("keydown", handleKeyDown);
		return () => window.removeEventListener("keydown", handleKeyDown);
	}, [toggleSidebar]);
	const state = open ? "expanded" : "collapsed";
	const contextValue = useMemo(() => ({
		state,
		open,
		setOpen,
		mobile,
		openMobile,
		setOpenMobile,
		toggleSidebar
	}), [
		state,
		open,
		setOpen,
		mobile,
		openMobile,
		setOpenMobile,
		toggleSidebar
	]);
	return jsx(SidebarContext.Provider, {
		value: contextValue,
		children: jsx(TooltipProvider, {
			delayDuration: 0,
			children: jsx("div", {
				"data-slot": "sidebar-wrapper",
				style: {
					"--sidebar-width": SIDEBAR_WIDTH,
					"--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
					...style$2
				},
				className: cn("group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full", className$1),
				...props,
				children
			})
		})
	});
}
function Sidebar({ side = "left", variant = "sidebar", collapsible = "offcanvas", className: className$1, children,...props }) {
	const { mobile, state, openMobile, setOpenMobile } = useSidebar();
	if (collapsible === "none") return jsx("div", {
		"data-slot": "sidebar",
		className: cn("bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col", className$1),
		...props,
		children
	});
	if (mobile) return jsx(Sheet, {
		open: openMobile,
		onOpenChange: setOpenMobile,
		...props,
		children: jsxs(SheetContent, {
			"data-sidebar": "sidebar",
			"data-slot": "sidebar",
			"data-mobile": "true",
			className: "bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden",
			style: { "--sidebar-width": SIDEBAR_WIDTH_MOBILE },
			side,
			children: [jsxs(SheetHeader, {
				className: "sr-only",
				children: [jsx(SheetTitle, { children: "Sidebar" }), jsx(SheetDescription, { children: "Displays the mobile sidebar." })]
			}), jsx("div", {
				className: "flex h-full w-full flex-col",
				children
			})]
		})
	});
	return jsxs("div", {
		className: "group peer text-sidebar-foreground hidden md:block",
		"data-state": state,
		"data-collapsible": state === "collapsed" ? collapsible : "",
		"data-variant": variant,
		"data-side": side,
		"data-slot": "sidebar",
		children: [jsx("div", {
			"data-slot": "sidebar-gap",
			className: cn("relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear", "group-data-[collapsible=offcanvas]:w-0", "group-data-[side=right]:rotate-180", variant === "floating" || variant === "inset" ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]" : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)")
		}), jsx("div", {
			"data-slot": "sidebar-container",
			className: cn("fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex", side === "left" ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]" : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]", variant === "floating" || variant === "inset" ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]" : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l", className$1),
			...props,
			children: jsx("div", {
				"data-sidebar": "sidebar",
				"data-slot": "sidebar-inner",
				className: "bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm",
				children
			})
		})]
	});
}
function SidebarTrigger({ className: className$1, onClick,...props }) {
	const { toggleSidebar } = useSidebar();
	return jsxs(Button, {
		"data-sidebar": "trigger",
		"data-slot": "sidebar-trigger",
		variant: "ghost",
		size: "icon",
		className: cn("size-7", className$1),
		onClick: (event) => {
			onClick?.(event);
			toggleSidebar();
		},
		...props,
		children: [jsx(PanelLeftIcon, {}), jsx("span", {
			className: "sr-only",
			children: "Toggle Sidebar"
		})]
	});
}
function SidebarContent({ className: className$1,...props }) {
	return jsx("div", {
		"data-slot": "sidebar-content",
		"data-sidebar": "content",
		className: cn("flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden", className$1),
		...props
	});
}
function SidebarGroup({ className: className$1,...props }) {
	return jsx("div", {
		"data-slot": "sidebar-group",
		"data-sidebar": "group",
		className: cn("relative flex w-full min-w-0 flex-col p-2", className$1),
		...props
	});
}
function SidebarGroupLabel({ className: className$1, asChild = false,...props }) {
	const Comp = asChild ? Slot : "div";
	return jsx(Comp, {
		"data-slot": "sidebar-group-label",
		"data-sidebar": "group-label",
		className: cn("text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0", "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0", className$1),
		...props
	});
}
function SidebarGroupContent({ className: className$1,...props }) {
	return jsx("div", {
		"data-slot": "sidebar-group-content",
		"data-sidebar": "group-content",
		className: cn("w-full text-sm", className$1),
		...props
	});
}
function SidebarMenu({ className: className$1,...props }) {
	return jsx("ul", {
		"data-slot": "sidebar-menu",
		"data-sidebar": "menu",
		className: cn("flex w-full min-w-0 flex-col gap-1", className$1),
		...props
	});
}
function SidebarMenuItem({ className: className$1,...props }) {
	return jsx("li", {
		"data-slot": "sidebar-menu-item",
		"data-sidebar": "menu-item",
		className: cn("group/menu-item relative", className$1),
		...props
	});
}
const sidebarMenuButtonVariants = cva("peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0", {
	variants: {
		variant: {
			default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
			outline: "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]"
		},
		size: {
			default: "h-8 text-sm",
			sm: "h-7 text-xs",
			lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!"
		}
	},
	defaultVariants: {
		variant: "default",
		size: "default"
	}
});
function SidebarMenuButton({ asChild = false, isActive = false, variant = "default", size = "default", tooltip, className: className$1,...props }) {
	const Comp = asChild ? Slot : "button";
	const { mobile, state } = useSidebar();
	const button = jsx(Comp, {
		"data-slot": "sidebar-menu-button",
		"data-sidebar": "menu-button",
		"data-size": size,
		"data-active": isActive,
		className: cn(sidebarMenuButtonVariants({
			variant,
			size
		}), className$1),
		...props
	});
	if (!tooltip) return button;
	if (typeof tooltip === "string") tooltip = { children: tooltip };
	return jsxs(Tooltip, { children: [jsx(TooltipTrigger, {
		asChild: true,
		children: button
	}), jsx(TooltipContent, {
		side: "right",
		align: "center",
		hidden: state !== "collapsed" || mobile,
		...tooltip
	})] });
}
const navigationItems = [{
	title: "수강생 목록",
	url: "/",
	icon: Users
}, {
	title: "과제 목록",
	url: "/assignments",
	icon: BookOpen
}];
function AppSidebar() {
	const { state } = useSidebar();
	const location$1 = useLocation();
	const currentPath = location$1.pathname;
	const collapsed = state === "collapsed";
	const isActive = (path$1) => currentPath === path$1;
	const getActiveClassName = (path$1) => isActive(path$1) ? "bg-primary text-primary-foreground shadow-glow font-medium" : "text-foreground hover:bg-secondary hover:text-secondary-foreground";
	return jsx(Sidebar, {
		className: collapsed ? "w-16" : "w-64",
		children: jsxs(SidebarContent, {
			className: "bg-card border-r border-border",
			children: [jsx(NavLink, {
				to: "/",
				className: "p-4",
				children: jsx("div", {
					className: "flex items-center space-x-2 mb-6",
					children: !collapsed && jsxs(Fragment, { children: [jsx("div", {
						className: "w-8 h-8 bg-gradient-primary rounded-lg flex items-center justify-center",
						children: jsx("span", {
							className: "text-white font-bold text-sm",
							children: "6기"
						})
					}), jsx("h4", {
						className: "text-lg font-bold text-primary",
						children: "항해플러스 프론트엔드"
					})] })
				})
			}), jsxs(SidebarGroup, { children: [jsx(SidebarGroupLabel, {
				className: "text-muted-foreground px-4",
				children: !collapsed && "학습 관리"
			}), jsx(SidebarGroupContent, { children: jsx(SidebarMenu, {
				className: "px-2",
				children: navigationItems.map((item) => jsx(SidebarMenuItem, { children: jsx(SidebarMenuButton, {
					asChild: true,
					className: "h-12",
					children: jsxs(NavLink, {
						to: item.url,
						className: cn(getActiveClassName(item.url), "rounded-lg transition-all duration-300"),
						children: [jsx(item.icon, { className: "h-5 w-5" }), !collapsed && jsx("span", {
							className: "ml-3",
							children: item.title
						})]
					})
				}) }, item.title))
			}) })] })]
		})
	});
}
function BaseLayout({ children }) {
	const title = usePageTitle();
	return jsx(SidebarProvider, { children: jsxs("div", {
		className: "min-h-screen flex w-full",
		children: [jsx(AppSidebar, {}), jsxs("div", {
			className: "flex-1 min-w-0",
			children: [jsxs("header", {
				className: "h-12 flex items-center border-b border-border bg-card px-4",
				children: [jsx(SidebarTrigger, { className: "mr-4 text-white" }), jsx("h4", {
					className: "text-lg font-semibold ",
					children: title
				})]
			}), jsx("main", {
				className: "p-6",
				children
			})]
		})]
	}) });
}
const DefaultProvider = ({ children }) => {
	return jsx(Fragment, { children });
};
function withBaseLayout(Component) {
	return function WrappedComponent(props) {
		const Provider = Component.Provider ?? DefaultProvider;
		return jsx(Provider, { children: jsx(BaseLayout, { children: jsx(Component, { ...props }) }) });
	};
}
const UserCard = ({ id: id$1, link: link$2, image: image$2, assignments: assignments$1 }) => {
	return jsx(Card, {
		className: "hover:shadow-glow transition-all duration-300 cursor-pointer animate-fade-in hover:scale-[1.02] group bg-card border border-border",
		children: jsx(Link, {
			to: `/@${id$1}/`,
			className: "block",
			children: jsx("div", {
				className: "p-3",
				children: jsxs("div", {
					className: "flex flex-col items-center text-center space-y-2",
					children: [
						jsxs("div", {
							className: "relative",
							children: [jsx("div", {
								className: "w-12 h-12 rounded-full overflow-hidden ring-2 ring-orange-500/30 group-hover:ring-orange-400/50 transition-all",
								children: jsx("img", {
									src: image$2,
									alt: id$1,
									className: "w-full h-full object-cover"
								})
							}), jsx("div", { className: "absolute -bottom-0.5 -right-0.5 w-3 h-3 bg-green-500 rounded-full border border-slate-800" })]
						}),
						jsxs("div", {
							className: "w-full",
							children: [jsx("h3", {
								className: "text-sm font-semibold text-white group-hover:text-orange-300 transition-colors break-words leading-tight",
								children: id$1
							}), jsx("p", { children: jsxs("span", {
								className: "text-xs text-slate-400",
								children: [
									"과제 제출: ",
									assignments$1,
									"개"
								]
							}) })]
						}),
						jsx(Badge, {
							variant: "secondary",
							className: "text-xs bg-slate-700 hover:bg-slate-600 cursor-pointer transition-colors px-2 py-1",
							onClick: (e) => {
								e.preventDefault();
								window.open(link$2, "_blank");
							},
							children: jsx(Github, { className: "w-4 h-4" })
						})
					]
				})
			})
		})
	});
};
const UsersGrid = ({ users, assignments: assignments$1 }) => {
	const usersWithAssignments = useMemo(() => users.map((user) => {
		const userAssignments = assignments$1.filter((assignment) => assignment.user.login === user.id);
		return {
			...user,
			assignments: userAssignments
		};
	}), [assignments$1, users]);
	return jsx("div", {
		className: "grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4",
		children: usersWithAssignments.map(({ assignments: assignments$2,...user }) => jsx(UserCard, {
			...user,
			assignments: assignments$2.length
		}, user.id))
	});
};
const HomeProvider = ({ children }) => {
	const users = useUsers();
	const assignments$1 = useAllAssignments();
	const contextValue = useMemo(() => ({
		users: users.items,
		assignments: assignments$1.data
	}), [users, assignments$1]);
	return jsx(PageProvider, {
		title: "수강생 목록",
		data: contextValue,
		children
	});
};
const HomePage = () => {
	const { users, assignments: assignments$1 } = usePageData();
	return jsxs("div", {
		className: "px-4 py-6",
		children: [jsxs("div", {
			className: "mb-6 space-y-4",
			children: [jsxs("div", {
				className: "flex items-center justify-between",
				children: [jsx("h2", {
					className: "text-2xl font-bold text-white",
					children: "수강생 명단"
				}), jsxs(Badge, {
					variant: "secondary",
					className: "text-sm bg-slate-700",
					children: [
						"총 ",
						users.length,
						"명"
					]
				})]
			}), jsxs("div", {
				className: "grid grid-cols-1 md:grid-cols-2 gap-4",
				children: [jsx(Card, {
					className: "p-4 bg-slate-800/50 border-slate-700",
					children: jsxs("div", {
						className: "flex items-center space-x-3",
						children: [jsx("div", {
							className: "w-10 h-10 bg-orange-500/20 rounded-lg flex items-center justify-center",
							children: jsx(Users, { className: "w-5 h-5 text-orange-400" })
						}), jsxs("div", { children: [jsx("div", {
							className: "text-2xl font-bold text-white",
							children: users.length
						}), jsx("div", {
							className: "text-sm text-slate-400",
							children: "총 수강생"
						})] })]
					})
				}), jsx(Card, {
					className: "p-4 bg-slate-800/50 border-slate-700",
					children: jsxs("div", {
						className: "flex items-center space-x-3",
						children: [jsx("div", {
							className: "w-10 h-10 bg-green-500/20 rounded-lg flex items-center justify-center",
							children: jsx(BookOpen, { className: "w-5 h-5 text-green-400" })
						}), jsxs("div", { children: [jsx("div", {
							className: "text-2xl font-bold text-white",
							children: "6기"
						}), jsx("div", {
							className: "text-sm text-slate-400",
							children: "현재 기수"
						})] })]
					})
				})]
			})]
		}), jsx(Suspense, { children: jsx(UsersGrid, {
			users,
			assignments: assignments$1
		}) })]
	});
};
const Home$1 = Object.assign(HomePage, { Provider: HomeProvider });
const UserProfile = ({ id: id$1, image: image$2, link: link$2 }) => {
	return jsx("div", {
		className: "sticky top-6",
		children: jsx("a", {
			href: link$2,
			target: "_blank",
			children: jsx(Card, {
				className: "p-6",
				children: jsxs("div", {
					className: "flex flex-col items-center text-center space-y-4",
					children: [jsx("div", {
						className: "relative",
						children: jsx("div", {
							className: "w-48 h-48 rounded-full overflow-hidden ring-4 ring-orange-500/30",
							children: jsx("img", {
								src: image$2,
								alt: id$1,
								className: "w-full h-full object-cover"
							})
						})
					}), jsx("div", {
						className: "w-full",
						children: jsx("h3", {
							className: "text-2xl font-bold text-white mb-2",
							children: id$1
						})
					})]
				})
			})
		})
	});
};
const AssignmentCard = ({ id: id$1, title, url, createdAt }) => {
	return jsx(Card, {
		className: "hover:shadow-glow transition-all duration-300 cursor-pointer group bg-card border border-border",
		children: jsx(Link, {
			to: `./assignment/${id$1}/`,
			className: "block",
			children: jsx("div", {
				className: "p-6",
				children: jsxs("div", {
					className: "flex flex-col space-y-3",
					children: [jsx("h3", {
						className: "text-lg font-semibold text-white group-hover:text-orange-300 transition-colors leading-tight",
						children: title
					}), jsx("div", {
						className: "flex items-center justify-between",
						children: jsxs("div", {
							className: "flex items-center space-x-4 text-xs text-slate-500",
							children: [
								jsxs(Link, {
									to: url,
									className: "text-xs text-slate-400 flex items-center space-x-1 hover:underline underline-offset-4",
									target: "_blank",
									onClick: (e) => e.stopPropagation(),
									children: [jsx(Github, { className: "w-3 h-3" }), jsx("span", { children: "Pull Request" })]
								}),
								jsxs("div", {
									className: "flex items-center space-x-1",
									children: [jsx(Calendar, { className: "w-3 h-3" }), jsx("span", { children: formatDate(createdAt) })]
								}),
								jsxs("div", {
									className: "flex items-center space-x-1",
									children: [jsx(Clock, { className: "w-3 h-3" }), jsx("span", { children: "5분 읽기" })]
								})
							]
						})
					})]
				})
			})
		})
	});
};
const AssignmentsList = ({ items }) => {
	const sortedAssignments = useMemo(() => {
		return [...items].sort((a$1, b) => a$1.title.localeCompare(b.title));
	}, [items]);
	return jsx("div", {
		className: "space-y-4",
		children: sortedAssignments.map((assignment) => jsx(AssignmentCard, { ...assignment }, assignment.id))
	});
};
const UserStats = ({ assignmentCount }) => {
	return jsxs("div", {
		className: "mb-6",
		children: [jsxs("div", {
			className: "flex items-center justify-between mb-4",
			children: [jsx("h2", {
				className: "text-xl font-bold text-white",
				children: "제출한 과제"
			}), jsxs(Badge, {
				variant: "secondary",
				className: "text-sm bg-slate-700",
				children: [
					"총 ",
					assignmentCount,
					"개"
				]
			})]
		}), jsxs("div", {
			className: "grid grid-cols-1 md:grid-cols-3 gap-4",
			children: [
				jsxs(Card, {
					className: "p-4 bg-slate-800/50 border-slate-700",
					children: [jsx("div", {
						className: "text-2xl font-bold text-white",
						children: assignmentCount
					}), jsx("div", {
						className: "text-sm text-slate-400",
						children: "총 과제 수"
					})]
				}),
				jsxs(Card, {
					className: "p-4 bg-slate-800/50 border-slate-700",
					children: [jsx("div", {
						className: "text-2xl font-bold text-green-400",
						children: assignmentCount
					}), jsx("div", {
						className: "text-sm text-slate-400",
						children: "완료한 과제"
					})]
				}),
				jsxs(Card, {
					className: "p-4 bg-slate-800/50 border-slate-700",
					children: [jsx("div", {
						className: "text-2xl font-bold text-orange-400",
						children: "100%"
					}), jsx("div", {
						className: "text-sm text-slate-400",
						children: "완성도"
					})]
				})
			]
		})]
	});
};
const UserProvider = ({ children }) => {
	const userId = useUserIdByParam();
	const assignments$1 = useAssignmentsByUser(userId);
	const user = useUser(userId);
	const contextValue = useMemo(() => ({
		...user,
		assignments: assignments$1.data ?? []
	}), [user, assignments$1]);
	return jsx(PageProvider, {
		title: `${user.id} 님의 상세페이지`,
		data: contextValue,
		children
	});
};
const User$1 = Object.assign(() => {
	const { assignments: assignments$1,...user } = usePageData();
	return jsx("div", {
		className: "px-4 py-6",
		children: jsxs("div", {
			className: "lg:flex lg:gap-8",
			children: [jsx("div", {
				className: "lg:w-[300px]",
				children: jsx(UserProfile, { ...user })
			}), jsxs("div", {
				className: "lg:flex-1",
				children: [jsx(UserStats, { assignmentCount: assignments$1.length }), jsx(AssignmentsList, { items: assignments$1 })]
			})]
		})
	});
}, { Provider: UserProvider });
const convert = function(test$1) {
	if (test$1 === null || test$1 === void 0) return ok$1;
	if (typeof test$1 === "function") return castFactory$1(test$1);
	if (typeof test$1 === "object") return Array.isArray(test$1) ? anyFactory$1(test$1) : propsFactory(test$1);
	if (typeof test$1 === "string") return typeFactory(test$1);
	throw new Error("Expected function, string, or object as test");
};
function anyFactory$1(tests) {
	const checks$2 = [];
	let index$1 = -1;
	while (++index$1 < tests.length) checks$2[index$1] = convert(tests[index$1]);
	return castFactory$1(any);
	function any(...parameters) {
		let index$2 = -1;
		while (++index$2 < checks$2.length) if (checks$2[index$2].apply(this, parameters)) return true;
		return false;
	}
}
function propsFactory(check) {
	const checkAsRecord = check;
	return castFactory$1(all$6);
	function all$6(node$1) {
		const nodeAsRecord = node$1;
		let key;
		for (key in check) if (nodeAsRecord[key] !== checkAsRecord[key]) return false;
		return true;
	}
}
function typeFactory(check) {
	return castFactory$1(type);
	function type(node$1) {
		return node$1 && node$1.type === check;
	}
}
function castFactory$1(testFunction) {
	return check;
	function check(value, index$1, parent$1) {
		return Boolean(looksLikeANode(value) && testFunction.call(this, value, typeof index$1 === "number" ? index$1 : void 0, parent$1 || void 0));
	}
}
function ok$1() {
	return true;
}
function looksLikeANode(value) {
	return value !== null && typeof value === "object" && "type" in value;
}
function color(d$1) {
	return "\x1B[33m" + d$1 + "\x1B[39m";
}
const empty$3 = [];
const CONTINUE = true;
const EXIT = false;
const SKIP = "skip";
function visitParents(tree, test$1, visitor, reverse) {
	let check;
	if (typeof test$1 === "function" && typeof visitor !== "function") {
		reverse = visitor;
		visitor = test$1;
	} else check = test$1;
	const is$1 = convert(check);
	const step = reverse ? -1 : 1;
	factory$1(tree, void 0, [])();
	function factory$1(node$1, index$1, parents) {
		const value = node$1 && typeof node$1 === "object" ? node$1 : {};
		if (typeof value.type === "string") {
			const name$2 = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
			Object.defineProperty(visit$1, "name", { value: "node (" + color(node$1.type + (name$2 ? "<" + name$2 + ">" : "")) + ")" });
		}
		return visit$1;
		function visit$1() {
			let result = empty$3;
			let subresult;
			let offset;
			let grandparents;
			if (!test$1 || is$1(node$1, index$1, parents[parents.length - 1] || void 0)) {
				result = toResult(visitor(node$1, parents));
				if (result[0] === EXIT) return result;
			}
			if ("children" in node$1 && node$1.children) {
				const nodeAsParent = node$1;
				if (nodeAsParent.children && result[0] !== SKIP) {
					offset = (reverse ? nodeAsParent.children.length : -1) + step;
					grandparents = parents.concat(nodeAsParent);
					while (offset > -1 && offset < nodeAsParent.children.length) {
						const child = nodeAsParent.children[offset];
						subresult = factory$1(child, offset, grandparents)();
						if (subresult[0] === EXIT) return subresult;
						offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
					}
				}
			}
			return result;
		}
	}
}
function toResult(value) {
	if (Array.isArray(value)) return value;
	if (typeof value === "number") return [CONTINUE, value];
	return value === null || value === void 0 ? empty$3 : [value];
}
function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
	let reverse;
	let test$1;
	let visitor;
	if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
		test$1 = void 0;
		visitor = testOrVisitor;
		reverse = visitorOrReverse;
	} else {
		test$1 = testOrVisitor;
		visitor = visitorOrReverse;
		reverse = maybeReverse;
	}
	visitParents(tree, test$1, overload, reverse);
	function overload(node$1, parents) {
		const parent$1 = parents[parents.length - 1];
		const index$1 = parent$1 ? parent$1.children.indexOf(node$1) : void 0;
		return visitor(node$1, index$1, parent$1);
	}
}
function toString(node$1) {
	if ("children" in node$1) return all$5(node$1);
	return "value" in node$1 ? node$1.value : "";
}
function one$5(node$1) {
	if (node$1.type === "text") return node$1.value;
	return "children" in node$1 ? all$5(node$1) : "";
}
function all$5(node$1) {
	let index$1 = -1;
	const result = [];
	while (++index$1 < node$1.children.length) result[index$1] = one$5(node$1.children[index$1]);
	return result.join("");
}
const own$13 = {}.hasOwnProperty;
function filter(tree, options, test$1) {
	const is$1 = convert(test$1 || options);
	const cascadeRaw = options && typeof options === "object" && "cascade" in options ? options.cascade : void 0;
	const cascade = cascadeRaw === void 0 || cascadeRaw === null ? true : cascadeRaw;
	return preorder(tree);
	function preorder(node$1, index$1, parentNode) {
		const children = [];
		if (!is$1(node$1, index$1, parentNode)) return void 0;
		if (parent(node$1)) {
			let childIndex = -1;
			while (++childIndex < node$1.children.length) {
				const result = preorder(node$1.children[childIndex], childIndex, node$1);
				if (result) children.push(result);
			}
			if (cascade && node$1.children.length > 0 && children.length === 0) return void 0;
		}
		const next$1 = {};
		let key;
		for (key in node$1) if (own$13.call(node$1, key)) next$1[key] = key === "children" ? children : node$1[key];
		return next$1;
	}
}
function parent(node$1) {
	return "children" in node$1 && node$1.children !== void 0;
}
var require_parse_numeric_range = __commonJSMin((exports, module) => {
	function parsePart(string$2) {
		let res = [];
		let m;
		for (let str of string$2.split(",").map((str$1) => str$1.trim())) if (/^-?\d+$/.test(str)) res.push(parseInt(str, 10));
		else if (m = str.match(/^(-?\d+)(-|\.\.\.?|\u2025|\u2026|\u22EF)(-?\d+)$/)) {
			let [_$1, lhs, sep, rhs] = m;
			if (lhs && rhs) {
				lhs = parseInt(lhs);
				rhs = parseInt(rhs);
				const incr = lhs < rhs ? 1 : -1;
				if (sep === "-" || sep === ".." || sep === "‥") rhs += incr;
				for (let i = lhs; i !== rhs; i += incr) res.push(i);
			}
		}
		return res;
	}
	exports.default = parsePart;
	module.exports = parsePart;
});
clike.displayName = "clike";
clike.aliases = [];
function clike(Prism$1) {
	Prism$1.languages.clike = {
		comment: [{
			pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
			lookbehind: true,
			greedy: true
		}, {
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true,
			greedy: true
		}],
		string: {
			pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
			greedy: true
		},
		"class-name": {
			pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
			lookbehind: true,
			inside: { punctuation: /[.\\]/ }
		},
		keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
		boolean: /\b(?:false|true)\b/,
		function: /\b\w+(?=\()/,
		number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
		operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
		punctuation: /[{}[\];(),.:]/
	};
}
c$1.displayName = "c";
c$1.aliases = [];
function c$1(Prism$1) {
	Prism$1.register(clike);
	Prism$1.languages.c = Prism$1.languages.extend("clike", {
		comment: {
			pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
			greedy: true
		},
		string: {
			pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
			greedy: true
		},
		"class-name": {
			pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
			lookbehind: true
		},
		keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
		function: /\b[a-z_]\w*(?=\s*\()/i,
		number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
		operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
	});
	Prism$1.languages.insertBefore("c", "string", { char: {
		pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
		greedy: true
	} });
	Prism$1.languages.insertBefore("c", "string", { macro: {
		pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
		lookbehind: true,
		greedy: true,
		alias: "property",
		inside: {
			string: [{
				pattern: /^(#\s*include\s*)<[^>]+>/,
				lookbehind: true
			}, Prism$1.languages.c["string"]],
			char: Prism$1.languages.c["char"],
			comment: Prism$1.languages.c["comment"],
			"macro-name": [{
				pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
				lookbehind: true
			}, {
				pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
				lookbehind: true,
				alias: "function"
			}],
			directive: {
				pattern: /^(#\s*)[a-z]+/,
				lookbehind: true,
				alias: "keyword"
			},
			"directive-hash": /^#/,
			punctuation: /##|\\(?=[\r\n])/,
			expression: {
				pattern: /\S[\s\S]*/,
				inside: Prism$1.languages.c
			}
		}
	} });
	Prism$1.languages.insertBefore("c", "function", { constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/ });
	delete Prism$1.languages.c["boolean"];
}
cpp.displayName = "cpp";
cpp.aliases = [];
function cpp(Prism$1) {
	Prism$1.register(c$1);
	(function(Prism$2) {
		var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
		var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
			return keyword.source;
		});
		Prism$2.languages.cpp = Prism$2.languages.extend("c", {
			"class-name": [
				{
					pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
						return keyword.source;
					})),
					lookbehind: true
				},
				/\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
				/\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
				/\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
			],
			keyword,
			number: {
				pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
				greedy: true
			},
			operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
			boolean: /\b(?:false|true)\b/
		});
		Prism$2.languages.insertBefore("cpp", "string", {
			module: {
				pattern: RegExp(/(\b(?:import|module)\s+)/.source + "(?:" + /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
					return modName;
				}) + ")"),
				lookbehind: true,
				greedy: true,
				inside: {
					string: /^[<"][\s\S]+/,
					operator: /:/,
					punctuation: /\./
				}
			},
			"raw-string": {
				pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
				alias: "string",
				greedy: true
			}
		});
		Prism$2.languages.insertBefore("cpp", "keyword", { "generic-function": {
			pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
			inside: {
				function: /^\w+/,
				generic: {
					pattern: /<[\s\S]+/,
					alias: "class-name",
					inside: Prism$2.languages.cpp
				}
			}
		} });
		Prism$2.languages.insertBefore("cpp", "operator", { "double-colon": {
			pattern: /::/,
			alias: "punctuation"
		} });
		Prism$2.languages.insertBefore("cpp", "class-name", { "base-clause": {
			pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
			lookbehind: true,
			greedy: true,
			inside: Prism$2.languages.extend("cpp", {})
		} });
		Prism$2.languages.insertBefore("inside", "double-colon", { "class-name": /\b[a-z_]\w*\b(?!\s*::)/i }, Prism$2.languages.cpp["base-clause"]);
	})(Prism$1);
}
arduino.displayName = "arduino";
arduino.aliases = ["ino"];
function arduino(Prism$1) {
	Prism$1.register(cpp);
	Prism$1.languages.arduino = Prism$1.languages.extend("cpp", {
		keyword: /\b(?:String|array|bool|boolean|break|byte|case|catch|continue|default|do|double|else|finally|for|function|goto|if|in|instanceof|int|integer|long|loop|new|null|return|setup|string|switch|throw|try|void|while|word)\b/,
		constant: /\b(?:ANALOG_MESSAGE|DEFAULT|DIGITAL_MESSAGE|EXTERNAL|FIRMATA_STRING|HIGH|INPUT|INPUT_PULLUP|INTERNAL|INTERNAL1V1|INTERNAL2V56|LED_BUILTIN|LOW|OUTPUT|REPORT_ANALOG|REPORT_DIGITAL|SET_PIN_MODE|SYSEX_START|SYSTEM_RESET)\b/,
		builtin: /\b(?:Audio|BSSID|Bridge|Client|Console|EEPROM|Esplora|EsploraTFT|Ethernet|EthernetClient|EthernetServer|EthernetUDP|File|FileIO|FileSystem|Firmata|GPRS|GSM|GSMBand|GSMClient|GSMModem|GSMPIN|GSMScanner|GSMServer|GSMVoiceCall|GSM_SMS|HttpClient|IPAddress|IRread|Keyboard|KeyboardController|LiquidCrystal|LiquidCrystal_I2C|Mailbox|Mouse|MouseController|PImage|Process|RSSI|RobotControl|RobotMotor|SD|SPI|SSID|Scheduler|Serial|Server|Servo|SoftwareSerial|Stepper|Stream|TFT|Task|USBHost|WiFi|WiFiClient|WiFiServer|WiFiUDP|Wire|YunClient|YunServer|abs|addParameter|analogRead|analogReadResolution|analogReference|analogWrite|analogWriteResolution|answerCall|attach|attachGPRS|attachInterrupt|attached|autoscroll|available|background|beep|begin|beginPacket|beginSD|beginSMS|beginSpeaker|beginTFT|beginTransmission|beginWrite|bit|bitClear|bitRead|bitSet|bitWrite|blink|blinkVersion|buffer|changePIN|checkPIN|checkPUK|checkReg|circle|cityNameRead|cityNameWrite|clear|clearScreen|click|close|compassRead|config|connect|connected|constrain|cos|countryNameRead|countryNameWrite|createChar|cursor|debugPrint|delay|delayMicroseconds|detach|detachInterrupt|digitalRead|digitalWrite|disconnect|display|displayLogos|drawBMP|drawCompass|encryptionType|end|endPacket|endSMS|endTransmission|endWrite|exists|exitValue|fill|find|findUntil|flush|gatewayIP|get|getAsynchronously|getBand|getButton|getCurrentCarrier|getIMEI|getKey|getModifiers|getOemKey|getPINUsed|getResult|getSignalStrength|getSocket|getVoiceCallStatus|getXChange|getYChange|hangCall|height|highByte|home|image|interrupts|isActionDone|isDirectory|isListening|isPIN|isPressed|isValid|keyPressed|keyReleased|keyboardRead|knobRead|leftToRight|line|lineFollowConfig|listen|listenOnLocalhost|loadImage|localIP|lowByte|macAddress|maintain|map|max|messageAvailable|micros|millis|min|mkdir|motorsStop|motorsWrite|mouseDragged|mouseMoved|mousePressed|mouseReleased|move|noAutoscroll|noBlink|noBuffer|noCursor|noDisplay|noFill|noInterrupts|noListenOnLocalhost|noStroke|noTone|onReceive|onRequest|open|openNextFile|overflow|parseCommand|parseFloat|parseInt|parsePacket|pauseMode|peek|pinMode|playFile|playMelody|point|pointTo|position|pow|prepare|press|print|printFirmwareVersion|printVersion|println|process|processInput|pulseIn|put|random|randomSeed|read|readAccelerometer|readBlue|readButton|readBytes|readBytesUntil|readGreen|readJoystickButton|readJoystickSwitch|readJoystickX|readJoystickY|readLightSensor|readMessage|readMicrophone|readNetworks|readRed|readSlider|readString|readStringUntil|readTemperature|ready|rect|release|releaseAll|remoteIP|remoteNumber|remotePort|remove|requestFrom|retrieveCallingNumber|rewindDirectory|rightToLeft|rmdir|robotNameRead|robotNameWrite|run|runAsynchronously|runShellCommand|runShellCommandAsynchronously|running|scanNetworks|scrollDisplayLeft|scrollDisplayRight|seek|sendAnalog|sendDigitalPortPair|sendDigitalPorts|sendString|sendSysex|serialEvent|setBand|setBitOrder|setClockDivider|setCursor|setDNS|setDataMode|setFirmwareVersion|setMode|setPINUsed|setSpeed|setTextSize|setTimeout|shiftIn|shiftOut|shutdown|sin|size|sqrt|startLoop|step|stop|stroke|subnetMask|switchPIN|tan|tempoWrite|text|tone|transfer|tuneWrite|turn|updateIR|userNameRead|userNameWrite|voiceCall|waitContinue|width|write|writeBlue|writeGreen|writeJSON|writeMessage|writeMicroseconds|writeRGB|writeRed|yield)\b/
	});
	Prism$1.languages.ino = Prism$1.languages.arduino;
}
bash.displayName = "bash";
bash.aliases = ["sh", "shell"];
function bash(Prism$1) {
	(function(Prism$2) {
		var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
		var commandAfterHeredoc = {
			pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
			lookbehind: true,
			alias: "punctuation",
			inside: null
		};
		var insideString = {
			bash: commandAfterHeredoc,
			environment: {
				pattern: RegExp("\\$" + envVars),
				alias: "constant"
			},
			variable: [
				{
					pattern: /\$?\(\([\s\S]+?\)\)/,
					greedy: true,
					inside: {
						variable: [{
							pattern: /(^\$\(\([\s\S]+)\)\)/,
							lookbehind: true
						}, /^\$\(\(/],
						number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
						operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
						punctuation: /\(\(?|\)\)?|,|;/
					}
				},
				{
					pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
					greedy: true,
					inside: { variable: /^\$\(|^`|\)$|`$/ }
				},
				{
					pattern: /\$\{[^}]+\}/,
					greedy: true,
					inside: {
						operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
						punctuation: /[\[\]]/,
						environment: {
							pattern: RegExp("(\\{)" + envVars),
							lookbehind: true,
							alias: "constant"
						}
					}
				},
				/\$(?:\w+|[#?*!@$])/
			],
			entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
		};
		Prism$2.languages.bash = {
			shebang: {
				pattern: /^#!\s*\/.*/,
				alias: "important"
			},
			comment: {
				pattern: /(^|[^"{\\$])#.*/,
				lookbehind: true
			},
			"function-name": [{
				pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
				lookbehind: true,
				alias: "function"
			}, {
				pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
				alias: "function"
			}],
			"for-or-select": {
				pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
				alias: "variable",
				lookbehind: true
			},
			"assign-left": {
				pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
				inside: { environment: {
					pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
					lookbehind: true,
					alias: "constant"
				} },
				alias: "variable",
				lookbehind: true
			},
			parameter: {
				pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
				alias: "variable",
				lookbehind: true
			},
			string: [
				{
					pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
					lookbehind: true,
					greedy: true,
					inside: insideString
				},
				{
					pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
					lookbehind: true,
					greedy: true,
					inside: { bash: commandAfterHeredoc }
				},
				{
					pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
					lookbehind: true,
					greedy: true,
					inside: insideString
				},
				{
					pattern: /(^|[^$\\])'[^']*'/,
					lookbehind: true,
					greedy: true
				},
				{
					pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
					greedy: true,
					inside: { entity: insideString.entity }
				}
			],
			environment: {
				pattern: RegExp("\\$?" + envVars),
				alias: "constant"
			},
			variable: insideString.variable,
			function: {
				pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
				lookbehind: true
			},
			keyword: {
				pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
				lookbehind: true
			},
			builtin: {
				pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
				lookbehind: true,
				alias: "class-name"
			},
			boolean: {
				pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
				lookbehind: true
			},
			"file-descriptor": {
				pattern: /\B&\d\b/,
				alias: "important"
			},
			operator: {
				pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
				inside: { "file-descriptor": {
					pattern: /^\d/,
					alias: "important"
				} }
			},
			punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
			number: {
				pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
				lookbehind: true
			}
		};
		commandAfterHeredoc.inside = Prism$2.languages.bash;
		var toBeCopied = [
			"comment",
			"function-name",
			"for-or-select",
			"assign-left",
			"parameter",
			"string",
			"environment",
			"function",
			"keyword",
			"builtin",
			"boolean",
			"file-descriptor",
			"operator",
			"punctuation",
			"number"
		];
		var inside = insideString.variable[1].inside;
		for (var i = 0; i < toBeCopied.length; i++) inside[toBeCopied[i]] = Prism$2.languages.bash[toBeCopied[i]];
		Prism$2.languages.sh = Prism$2.languages.bash;
		Prism$2.languages.shell = Prism$2.languages.bash;
	})(Prism$1);
}
csharp.displayName = "csharp";
csharp.aliases = ["cs", "dotnet"];
function csharp(Prism$1) {
	Prism$1.register(clike);
	(function(Prism$2) {
		function replace$1(pattern, replacements) {
			return pattern.replace(/<<(\d+)>>/g, function(m, index$1) {
				return "(?:" + replacements[+index$1] + ")";
			});
		}
		function re$1(pattern, replacements, flags) {
			return RegExp(replace$1(pattern, replacements), flags || "");
		}
		function nested(pattern, depthLog2) {
			for (var i = 0; i < depthLog2; i++) pattern = pattern.replace(/<<self>>/g, function() {
				return "(?:" + pattern + ")";
			});
			return pattern.replace(/<<self>>/g, "[^\\s\\S]");
		}
		var keywordKinds = {
			type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
			typeDeclaration: "class enum interface record struct",
			contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
			other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
		};
		function keywordsToPattern(words) {
			return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
		}
		var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);
		var keywords = RegExp(keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other));
		var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other);
		var nonContextualKeywords = keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.other);
		var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2);
		var nestedRound = nested(/\((?:[^()]|<<self>>)*\)/.source, 2);
		var name$2 = /@?\b[A-Za-z_]\w*\b/.source;
		var genericName = replace$1(/<<0>>(?:\s*<<1>>)?/.source, [name$2, generic]);
		var identifier = replace$1(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [nonTypeKeywords, genericName]);
		var array = /\[\s*(?:,\s*)*\]/.source;
		var typeExpressionWithoutTuple = replace$1(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [identifier, array]);
		var tupleElement = replace$1(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [
			generic,
			nestedRound,
			array
		]);
		var tuple = replace$1(/\(<<0>>+(?:,<<0>>+)+\)/.source, [tupleElement]);
		var typeExpression = replace$1(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [
			tuple,
			identifier,
			array
		]);
		var typeInside = {
			keyword: keywords,
			punctuation: /[<>()?,.:[\]]/
		};
		var character = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source;
		var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
		var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
		Prism$2.languages.csharp = Prism$2.languages.extend("clike", {
			string: [{
				pattern: re$1(/(^|[^$\\])<<0>>/.source, [verbatimString]),
				lookbehind: true,
				greedy: true
			}, {
				pattern: re$1(/(^|[^@$\\])<<0>>/.source, [regularString]),
				lookbehind: true,
				greedy: true
			}],
			"class-name": [
				{
					pattern: re$1(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [identifier]),
					lookbehind: true,
					inside: typeInside
				},
				{
					pattern: re$1(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [name$2, typeExpression]),
					lookbehind: true,
					inside: typeInside
				},
				{
					pattern: re$1(/(\busing\s+)<<0>>(?=\s*=)/.source, [name$2]),
					lookbehind: true
				},
				{
					pattern: re$1(/(\b<<0>>\s+)<<1>>/.source, [typeDeclarationKeywords, genericName]),
					lookbehind: true,
					inside: typeInside
				},
				{
					pattern: re$1(/(\bcatch\s*\(\s*)<<0>>/.source, [identifier]),
					lookbehind: true,
					inside: typeInside
				},
				{
					pattern: re$1(/(\bwhere\s+)<<0>>/.source, [name$2]),
					lookbehind: true
				},
				{
					pattern: re$1(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [typeExpressionWithoutTuple]),
					lookbehind: true,
					inside: typeInside
				},
				{
					pattern: re$1(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [
						typeExpression,
						nonContextualKeywords,
						name$2
					]),
					inside: typeInside
				}
			],
			keyword: keywords,
			number: /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
			operator: />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
			punctuation: /\?\.?|::|[{}[\];(),.:]/
		});
		Prism$2.languages.insertBefore("csharp", "number", { range: {
			pattern: /\.\./,
			alias: "operator"
		} });
		Prism$2.languages.insertBefore("csharp", "punctuation", { "named-parameter": {
			pattern: re$1(/([(,]\s*)<<0>>(?=\s*:)/.source, [name$2]),
			lookbehind: true,
			alias: "punctuation"
		} });
		Prism$2.languages.insertBefore("csharp", "class-name", {
			namespace: {
				pattern: re$1(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [name$2]),
				lookbehind: true,
				inside: { punctuation: /\./ }
			},
			"type-expression": {
				pattern: re$1(/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [nestedRound]),
				lookbehind: true,
				alias: "class-name",
				inside: typeInside
			},
			"return-type": {
				pattern: re$1(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [typeExpression, identifier]),
				inside: typeInside,
				alias: "class-name"
			},
			"constructor-invocation": {
				pattern: re$1(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [typeExpression]),
				lookbehind: true,
				inside: typeInside,
				alias: "class-name"
			},
			"generic-method": {
				pattern: re$1(/<<0>>\s*<<1>>(?=\s*\()/.source, [name$2, generic]),
				inside: {
					function: re$1(/^<<0>>/.source, [name$2]),
					generic: {
						pattern: RegExp(generic),
						alias: "class-name",
						inside: typeInside
					}
				}
			},
			"type-list": {
				pattern: re$1(/\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source, [
					typeDeclarationKeywords,
					genericName,
					name$2,
					typeExpression,
					keywords.source,
					nestedRound,
					/\bnew\s*\(\s*\)/.source
				]),
				lookbehind: true,
				inside: {
					"record-arguments": {
						pattern: re$1(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [genericName, nestedRound]),
						lookbehind: true,
						greedy: true,
						inside: Prism$2.languages.csharp
					},
					keyword: keywords,
					"class-name": {
						pattern: RegExp(typeExpression),
						greedy: true,
						inside: typeInside
					},
					punctuation: /[,()]/
				}
			},
			preprocessor: {
				pattern: /(^[\t ]*)#.*/m,
				lookbehind: true,
				alias: "property",
				inside: { directive: {
					pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
					lookbehind: true,
					alias: "keyword"
				} }
			}
		});
		var regularStringOrCharacter = regularString + "|" + character;
		var regularStringCharacterOrComment = replace$1(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [regularStringOrCharacter]);
		var roundExpression = nested(replace$1(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
		var attrTarget = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source;
		var attr = replace$1(/<<0>>(?:\s*\(<<1>>*\))?/.source, [identifier, roundExpression]);
		Prism$2.languages.insertBefore("csharp", "class-name", { attribute: {
			pattern: re$1(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [attrTarget, attr]),
			lookbehind: true,
			greedy: true,
			inside: {
				target: {
					pattern: re$1(/^<<0>>(?=\s*:)/.source, [attrTarget]),
					alias: "keyword"
				},
				"attribute-arguments": {
					pattern: re$1(/\(<<0>>*\)/.source, [roundExpression]),
					inside: Prism$2.languages.csharp
				},
				"class-name": {
					pattern: RegExp(identifier),
					inside: { punctuation: /\./ }
				},
				punctuation: /[:,]/
			}
		} });
		var formatString = /:[^}\r\n]+/.source;
		var mInterpolationRound = nested(replace$1(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
		var mInterpolation = replace$1(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [mInterpolationRound, formatString]);
		var sInterpolationRound = nested(replace$1(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [regularStringOrCharacter]), 2);
		var sInterpolation = replace$1(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [sInterpolationRound, formatString]);
		function createInterpolationInside(interpolation, interpolationRound) {
			return {
				interpolation: {
					pattern: re$1(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [interpolation]),
					lookbehind: true,
					inside: {
						"format-string": {
							pattern: re$1(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [interpolationRound, formatString]),
							lookbehind: true,
							inside: { punctuation: /^:/ }
						},
						punctuation: /^\{|\}$/,
						expression: {
							pattern: /[\s\S]+/,
							alias: "language-csharp",
							inside: Prism$2.languages.csharp
						}
					}
				},
				string: /[\s\S]+/
			};
		}
		Prism$2.languages.insertBefore("csharp", "string", {
			"interpolation-string": [{
				pattern: re$1(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [mInterpolation]),
				lookbehind: true,
				greedy: true,
				inside: createInterpolationInside(mInterpolation, mInterpolationRound)
			}, {
				pattern: re$1(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [sInterpolation]),
				lookbehind: true,
				greedy: true,
				inside: createInterpolationInside(sInterpolation, sInterpolationRound)
			}],
			char: {
				pattern: RegExp(character),
				greedy: true
			}
		});
		Prism$2.languages.dotnet = Prism$2.languages.cs = Prism$2.languages.csharp;
	})(Prism$1);
}
markup.displayName = "markup";
markup.aliases = [
	"atom",
	"html",
	"mathml",
	"rss",
	"ssml",
	"svg",
	"xml"
];
function markup(Prism$1) {
	Prism$1.languages.markup = {
		comment: {
			pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
			greedy: true
		},
		prolog: {
			pattern: /<\?[\s\S]+?\?>/,
			greedy: true
		},
		doctype: {
			pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
			greedy: true,
			inside: {
				"internal-subset": {
					pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
					lookbehind: true,
					greedy: true,
					inside: null
				},
				string: {
					pattern: /"[^"]*"|'[^']*'/,
					greedy: true
				},
				punctuation: /^<!|>$|[[\]]/,
				"doctype-tag": /^DOCTYPE/i,
				name: /[^\s<>'"]+/
			}
		},
		cdata: {
			pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
			greedy: true
		},
		tag: {
			pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
			greedy: true,
			inside: {
				tag: {
					pattern: /^<\/?[^\s>\/]+/,
					inside: {
						punctuation: /^<\/?/,
						namespace: /^[^\s>\/:]+:/
					}
				},
				"special-attr": [],
				"attr-value": {
					pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
					inside: { punctuation: [{
						pattern: /^=/,
						alias: "attr-equals"
					}, {
						pattern: /^(\s*)["']|["']$/,
						lookbehind: true
					}] }
				},
				punctuation: /\/?>/,
				"attr-name": {
					pattern: /[^\s>\/]+/,
					inside: { namespace: /^[^\s>\/:]+:/ }
				}
			}
		},
		entity: [{
			pattern: /&[\da-z]{1,8};/i,
			alias: "named-entity"
		}, /&#x?[\da-f]{1,8};/i]
	};
	Prism$1.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism$1.languages.markup["entity"];
	Prism$1.languages.markup["doctype"].inside["internal-subset"].inside = Prism$1.languages.markup;
	Prism$1.hooks.add("wrap", function(env$1) {
		if (env$1.type === "entity") env$1.attributes["title"] = env$1.content.value.replace(/&amp;/, "&");
	});
	Object.defineProperty(Prism$1.languages.markup.tag, "addInlined", { value: function addInlined(tagName, lang$1) {
		var includedCdataInside = {};
		includedCdataInside["language-" + lang$1] = {
			pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
			lookbehind: true,
			inside: Prism$1.languages[lang$1]
		};
		includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
		var inside = { "included-cdata": {
			pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
			inside: includedCdataInside
		} };
		inside["language-" + lang$1] = {
			pattern: /[\s\S]+/,
			inside: Prism$1.languages[lang$1]
		};
		var def = {};
		def[tagName] = {
			pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
				return tagName;
			}), "i"),
			lookbehind: true,
			greedy: true,
			inside
		};
		Prism$1.languages.insertBefore("markup", "cdata", def);
	} });
	Object.defineProperty(Prism$1.languages.markup.tag, "addAttribute", { value: function(attrName, lang$1) {
		Prism$1.languages.markup.tag.inside["special-attr"].push({
			pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
			lookbehind: true,
			inside: {
				"attr-name": /^[^\s=]+/,
				"attr-value": {
					pattern: /=[\s\S]+/,
					inside: {
						value: {
							pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
							lookbehind: true,
							alias: [lang$1, "language-" + lang$1],
							inside: Prism$1.languages[lang$1]
						},
						punctuation: [{
							pattern: /^=/,
							alias: "attr-equals"
						}, /"|'/]
					}
				}
			}
		});
	} });
	Prism$1.languages.html = Prism$1.languages.markup;
	Prism$1.languages.mathml = Prism$1.languages.markup;
	Prism$1.languages.svg = Prism$1.languages.markup;
	Prism$1.languages.xml = Prism$1.languages.extend("markup", {});
	Prism$1.languages.ssml = Prism$1.languages.xml;
	Prism$1.languages.atom = Prism$1.languages.xml;
	Prism$1.languages.rss = Prism$1.languages.xml;
}
css.displayName = "css";
css.aliases = [];
function css(Prism$1) {
	(function(Prism$2) {
		var string$2 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
		Prism$2.languages.css = {
			comment: /\/\*[\s\S]*?\*\//,
			atrule: {
				pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string$2.source + ")*?" + /(?:;|(?=\s*\{))/.source),
				inside: {
					rule: /^@[\w-]+/,
					"selector-function-argument": {
						pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
						lookbehind: true,
						alias: "selector"
					},
					keyword: {
						pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
						lookbehind: true
					}
				}
			},
			url: {
				pattern: RegExp("\\burl\\((?:" + string$2.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
				greedy: true,
				inside: {
					function: /^url/i,
					punctuation: /^\(|\)$/,
					string: {
						pattern: RegExp("^" + string$2.source + "$"),
						alias: "url"
					}
				}
			},
			selector: {
				pattern: RegExp("(^|[{}\\s])[^{}\\s](?:[^{};\"'\\s]|\\s+(?![\\s{])|" + string$2.source + ")*(?=\\s*\\{)"),
				lookbehind: true
			},
			string: {
				pattern: string$2,
				greedy: true
			},
			property: {
				pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
				lookbehind: true
			},
			important: /!important\b/i,
			function: {
				pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
				lookbehind: true
			},
			punctuation: /[(){};:,]/
		};
		Prism$2.languages.css["atrule"].inside.rest = Prism$2.languages.css;
		var markup$1 = Prism$2.languages.markup;
		if (markup$1) {
			markup$1.tag.addInlined("style", "css");
			markup$1.tag.addAttribute("style", "css");
		}
	})(Prism$1);
}
diff.displayName = "diff";
diff.aliases = [];
function diff(Prism$1) {
	(function(Prism$2) {
		Prism$2.languages.diff = { coord: [
			/^(?:\*{3}|-{3}|\+{3}).*$/m,
			/^@@.*@@$/m,
			/^\d.*$/m
		] };
		var PREFIXES = {
			"deleted-sign": "-",
			"deleted-arrow": "<",
			"inserted-sign": "+",
			"inserted-arrow": ">",
			unchanged: " ",
			diff: "!"
		};
		Object.keys(PREFIXES).forEach(function(name$2) {
			var prefix = PREFIXES[name$2];
			var alias$1 = [];
			if (!/^\w+$/.test(name$2)) alias$1.push(/\w+/.exec(name$2)[0]);
			if (name$2 === "diff") alias$1.push("bold");
			Prism$2.languages.diff[name$2] = {
				pattern: RegExp("^(?:[" + prefix + "].*(?:\r\n?|\n|(?![\\s\\S])))+", "m"),
				alias: alias$1,
				inside: {
					line: {
						pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
						lookbehind: true
					},
					prefix: {
						pattern: /[\s\S]/,
						alias: /\w+/.exec(name$2)[0]
					}
				}
			};
		});
		Object.defineProperty(Prism$2.languages.diff, "PREFIXES", { value: PREFIXES });
	})(Prism$1);
}
go.displayName = "go";
go.aliases = [];
function go(Prism$1) {
	Prism$1.register(clike);
	Prism$1.languages.go = Prism$1.languages.extend("clike", {
		string: {
			pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
			lookbehind: true,
			greedy: true
		},
		keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
		boolean: /\b(?:_|false|iota|nil|true)\b/,
		number: [
			/\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
			/\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
			/(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
		],
		operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
		builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
	});
	Prism$1.languages.insertBefore("go", "string", { char: {
		pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
		greedy: true
	} });
	delete Prism$1.languages.go["class-name"];
}
ini.displayName = "ini";
ini.aliases = [];
function ini(Prism$1) {
	Prism$1.languages.ini = {
		comment: {
			pattern: /(^[ \f\t\v]*)[#;][^\n\r]*/m,
			lookbehind: true
		},
		section: {
			pattern: /(^[ \f\t\v]*)\[[^\n\r\]]*\]?/m,
			lookbehind: true,
			inside: {
				"section-name": {
					pattern: /(^\[[ \f\t\v]*)[^ \f\t\v\]]+(?:[ \f\t\v]+[^ \f\t\v\]]+)*/,
					lookbehind: true,
					alias: "selector"
				},
				punctuation: /\[|\]/
			}
		},
		key: {
			pattern: /(^[ \f\t\v]*)[^ \f\n\r\t\v=]+(?:[ \f\t\v]+[^ \f\n\r\t\v=]+)*(?=[ \f\t\v]*=)/m,
			lookbehind: true,
			alias: "attr-name"
		},
		value: {
			pattern: /(=[ \f\t\v]*)[^ \f\n\r\t\v]+(?:[ \f\t\v]+[^ \f\n\r\t\v]+)*/,
			lookbehind: true,
			alias: "attr-value",
			inside: { "inner-value": {
				pattern: /^("|').+(?=\1$)/,
				lookbehind: true
			} }
		},
		punctuation: /=/
	};
}
java.displayName = "java";
java.aliases = [];
function java(Prism$1) {
	Prism$1.register(clike);
	(function(Prism$2) {
		var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
		var classNamePrefix = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
		var className$1 = {
			pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
			lookbehind: true,
			inside: {
				namespace: {
					pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
					inside: { punctuation: /\./ }
				},
				punctuation: /\./
			}
		};
		Prism$2.languages.java = Prism$2.languages.extend("clike", {
			string: {
				pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
				lookbehind: true,
				greedy: true
			},
			"class-name": [
				className$1,
				{
					pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
					lookbehind: true,
					inside: className$1.inside
				},
				{
					pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix + /[A-Z]\w*\b/.source),
					lookbehind: true,
					inside: className$1.inside
				}
			],
			keyword: keywords,
			function: [Prism$2.languages.clike.function, {
				pattern: /(::\s*)[a-z_]\w*/,
				lookbehind: true
			}],
			number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
			operator: {
				pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
				lookbehind: true
			},
			constant: /\b[A-Z][A-Z_\d]+\b/
		});
		Prism$2.languages.insertBefore("java", "string", {
			"triple-quoted-string": {
				pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
				greedy: true,
				alias: "string"
			},
			char: {
				pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
				greedy: true
			}
		});
		Prism$2.languages.insertBefore("java", "class-name", {
			annotation: {
				pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
				lookbehind: true,
				alias: "punctuation"
			},
			generics: {
				pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
				inside: {
					"class-name": className$1,
					keyword: keywords,
					punctuation: /[<>(),.:]/,
					operator: /[?&|]/
				}
			},
			import: [{
				pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
				lookbehind: true,
				inside: {
					namespace: className$1.inside.namespace,
					punctuation: /\./,
					operator: /\*/,
					"class-name": /\w+/
				}
			}, {
				pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix + /(?:\w+|\*)(?=\s*;)/.source),
				lookbehind: true,
				alias: "static",
				inside: {
					namespace: className$1.inside.namespace,
					static: /\b\w+$/,
					punctuation: /\./,
					operator: /\*/,
					"class-name": /\w+/
				}
			}],
			namespace: {
				pattern: RegExp(/(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
					return keywords.source;
				})),
				lookbehind: true,
				inside: { punctuation: /\./ }
			}
		});
	})(Prism$1);
}
regex$1.displayName = "regex";
regex$1.aliases = [];
function regex$1(Prism$1) {
	(function(Prism$2) {
		var specialEscape = {
			pattern: /\\[\\(){}[\]^$+*?|.]/,
			alias: "escape"
		};
		var escape$1 = /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/;
		var charSet = {
			pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i,
			alias: "class-name"
		};
		var charSetWithoutDot = {
			pattern: /\\[wsd]|\\p\{[^{}]+\}/i,
			alias: "class-name"
		};
		var rangeChar = "(?:[^\\\\-]|" + escape$1.source + ")";
		var range = RegExp(rangeChar + "-" + rangeChar);
		var groupName = {
			pattern: /(<|')[^<>']+(?=[>']$)/,
			lookbehind: true,
			alias: "variable"
		};
		Prism$2.languages.regex = {
			"char-class": {
				pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/,
				lookbehind: true,
				inside: {
					"char-class-negation": {
						pattern: /(^\[)\^/,
						lookbehind: true,
						alias: "operator"
					},
					"char-class-punctuation": {
						pattern: /^\[|\]$/,
						alias: "punctuation"
					},
					range: {
						pattern: range,
						inside: {
							escape: escape$1,
							"range-punctuation": {
								pattern: /-/,
								alias: "operator"
							}
						}
					},
					"special-escape": specialEscape,
					"char-set": charSetWithoutDot,
					escape: escape$1
				}
			},
			"special-escape": specialEscape,
			"char-set": charSet,
			backreference: [{
				pattern: /\\(?![123][0-7]{2})[1-9]/,
				alias: "keyword"
			}, {
				pattern: /\\k<[^<>']+>/,
				alias: "keyword",
				inside: { "group-name": groupName }
			}],
			anchor: {
				pattern: /[$^]|\\[ABbGZz]/,
				alias: "function"
			},
			escape: escape$1,
			group: [{
				pattern: /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,
				alias: "punctuation",
				inside: { "group-name": groupName }
			}, {
				pattern: /\)/,
				alias: "punctuation"
			}],
			quantifier: {
				pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/,
				alias: "number"
			},
			alternation: {
				pattern: /\|/,
				alias: "keyword"
			}
		};
	})(Prism$1);
}
javascript.displayName = "javascript";
javascript.aliases = ["js"];
function javascript(Prism$1) {
	Prism$1.register(clike);
	Prism$1.languages.javascript = Prism$1.languages.extend("clike", {
		"class-name": [Prism$1.languages.clike["class-name"], {
			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
			lookbehind: true
		}],
		keyword: [{
			pattern: /((?:^|\})\s*)catch\b/,
			lookbehind: true
		}, {
			pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
			lookbehind: true
		}],
		function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
		number: {
			pattern: RegExp(/(^|[^\w$])/.source + "(?:" + (/NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
			lookbehind: true
		},
		operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
	});
	Prism$1.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
	Prism$1.languages.insertBefore("javascript", "keyword", {
		regex: {
			pattern: RegExp(/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source),
			lookbehind: true,
			greedy: true,
			inside: {
				"regex-source": {
					pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
					lookbehind: true,
					alias: "language-regex",
					inside: Prism$1.languages.regex
				},
				"regex-delimiter": /^\/|\/$/,
				"regex-flags": /^[a-z]+$/
			}
		},
		"function-variable": {
			pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
			alias: "function"
		},
		parameter: [
			{
				pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
				lookbehind: true,
				inside: Prism$1.languages.javascript
			},
			{
				pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
				lookbehind: true,
				inside: Prism$1.languages.javascript
			},
			{
				pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
				lookbehind: true,
				inside: Prism$1.languages.javascript
			},
			{
				pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
				lookbehind: true,
				inside: Prism$1.languages.javascript
			}
		],
		constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
	});
	Prism$1.languages.insertBefore("javascript", "string", {
		hashbang: {
			pattern: /^#!.*/,
			greedy: true,
			alias: "comment"
		},
		"template-string": {
			pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
			greedy: true,
			inside: {
				"template-punctuation": {
					pattern: /^`|`$/,
					alias: "string"
				},
				interpolation: {
					pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
					lookbehind: true,
					inside: {
						"interpolation-punctuation": {
							pattern: /^\$\{|\}$/,
							alias: "punctuation"
						},
						rest: Prism$1.languages.javascript
					}
				},
				string: /[\s\S]+/
			}
		},
		"string-property": {
			pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
			lookbehind: true,
			greedy: true,
			alias: "property"
		}
	});
	Prism$1.languages.insertBefore("javascript", "operator", { "literal-property": {
		pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
		lookbehind: true,
		alias: "property"
	} });
	if (Prism$1.languages.markup) {
		Prism$1.languages.markup.tag.addInlined("script", "javascript");
		Prism$1.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
	}
	Prism$1.languages.js = Prism$1.languages.javascript;
}
json.displayName = "json";
json.aliases = ["webmanifest"];
function json(Prism$1) {
	Prism$1.languages.json = {
		property: {
			pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
			lookbehind: true,
			greedy: true
		},
		string: {
			pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
			lookbehind: true,
			greedy: true
		},
		comment: {
			pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
			greedy: true
		},
		number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
		punctuation: /[{}[\],]/,
		operator: /:/,
		boolean: /\b(?:false|true)\b/,
		null: {
			pattern: /\bnull\b/,
			alias: "keyword"
		}
	};
	Prism$1.languages.webmanifest = Prism$1.languages.json;
}
kotlin.displayName = "kotlin";
kotlin.aliases = ["kt", "kts"];
function kotlin(Prism$1) {
	Prism$1.register(clike);
	(function(Prism$2) {
		Prism$2.languages.kotlin = Prism$2.languages.extend("clike", {
			keyword: {
				pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,
				lookbehind: true
			},
			function: [{
				pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/,
				greedy: true
			}, {
				pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/,
				lookbehind: true,
				greedy: true
			}],
			number: /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/,
			operator: /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/
		});
		delete Prism$2.languages.kotlin["class-name"];
		var interpolationInside = {
			"interpolation-punctuation": {
				pattern: /^\$\{?|\}$/,
				alias: "punctuation"
			},
			expression: {
				pattern: /[\s\S]+/,
				inside: Prism$2.languages.kotlin
			}
		};
		Prism$2.languages.insertBefore("kotlin", "string", {
			"string-literal": [{
				pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/,
				alias: "multiline",
				inside: {
					interpolation: {
						pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i,
						inside: interpolationInside
					},
					string: /[\s\S]+/
				}
			}, {
				pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/,
				alias: "singleline",
				inside: {
					interpolation: {
						pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i,
						lookbehind: true,
						inside: interpolationInside
					},
					string: /[\s\S]+/
				}
			}],
			char: {
				pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/,
				greedy: true
			}
		});
		delete Prism$2.languages.kotlin["string"];
		Prism$2.languages.insertBefore("kotlin", "keyword", { annotation: {
			pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,
			alias: "builtin"
		} });
		Prism$2.languages.insertBefore("kotlin", "function", { label: {
			pattern: /\b\w+@|@\w+\b/,
			alias: "symbol"
		} });
		Prism$2.languages.kt = Prism$2.languages.kotlin;
		Prism$2.languages.kts = Prism$2.languages.kotlin;
	})(Prism$1);
}
less.displayName = "less";
less.aliases = [];
function less(Prism$1) {
	Prism$1.register(css);
	Prism$1.languages.less = Prism$1.languages.extend("css", {
		comment: [/\/\*[\s\S]*?\*\//, {
			pattern: /(^|[^\\])\/\/.*/,
			lookbehind: true
		}],
		atrule: {
			pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
			inside: { punctuation: /[:()]/ }
		},
		selector: {
			pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
			inside: { variable: /@+[\w-]+/ }
		},
		property: /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
		operator: /[+\-*\/]/
	});
	Prism$1.languages.insertBefore("less", "property", {
		variable: [{
			pattern: /@[\w-]+\s*:/,
			inside: { punctuation: /:/ }
		}, /@@?[\w-]+/],
		"mixin-usage": {
			pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
			lookbehind: true,
			alias: "function"
		}
	});
}
lua.displayName = "lua";
lua.aliases = [];
function lua(Prism$1) {
	Prism$1.languages.lua = {
		comment: /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
		string: {
			pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
			greedy: true
		},
		number: /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
		keyword: /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
		function: /(?!\d)\w+(?=\s*(?:[({]))/,
		operator: [/[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/, {
			pattern: /(^|[^.])\.\.(?!\.)/,
			lookbehind: true
		}],
		punctuation: /[\[\](){},;]|\.+|:+/
	};
}
makefile.displayName = "makefile";
makefile.aliases = [];
function makefile(Prism$1) {
	Prism$1.languages.makefile = {
		comment: {
			pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
			lookbehind: true
		},
		string: {
			pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
			greedy: true
		},
		"builtin-target": {
			pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
			alias: "builtin"
		},
		target: {
			pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
			alias: "symbol",
			inside: { variable: /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/ }
		},
		variable: /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
		keyword: /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
		function: {
			pattern: /(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
			lookbehind: true
		},
		operator: /(?:::|[?:+!])?=|[|@]/,
		punctuation: /[:;(){}]/
	};
}
yaml.displayName = "yaml";
yaml.aliases = ["yml"];
function yaml(Prism$1) {
	(function(Prism$2) {
		var anchorOrAlias = /[*&][^\s[\]{},]+/;
		var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
		var properties$1 = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)";
		var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
			return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
		});
		var string$2 = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
		function createValuePattern(value, flags) {
			flags = (flags || "").replace(/m/g, "") + "m";
			var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
				return properties$1;
			}).replace(/<<value>>/g, function() {
				return value;
			});
			return RegExp(pattern, flags);
		}
		Prism$2.languages.yaml = {
			scalar: {
				pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
					return properties$1;
				})),
				lookbehind: true,
				alias: "string"
			},
			comment: /#.*/,
			key: {
				pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
					return properties$1;
				}).replace(/<<key>>/g, function() {
					return "(?:" + plainKey + "|" + string$2 + ")";
				})),
				lookbehind: true,
				greedy: true,
				alias: "atrule"
			},
			directive: {
				pattern: /(^[ \t]*)%.+/m,
				lookbehind: true,
				alias: "important"
			},
			datetime: {
				pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
				lookbehind: true,
				alias: "number"
			},
			boolean: {
				pattern: createValuePattern(/false|true/.source, "i"),
				lookbehind: true,
				alias: "important"
			},
			null: {
				pattern: createValuePattern(/null|~/.source, "i"),
				lookbehind: true,
				alias: "important"
			},
			string: {
				pattern: createValuePattern(string$2),
				lookbehind: true,
				greedy: true
			},
			number: {
				pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
				lookbehind: true
			},
			tag,
			important: anchorOrAlias,
			punctuation: /---|[:[\]{}\-,|>?]|\.\.\./
		};
		Prism$2.languages.yml = Prism$2.languages.yaml;
	})(Prism$1);
}
markdown.displayName = "markdown";
markdown.aliases = ["md"];
function markdown(Prism$1) {
	Prism$1.register(markup);
	(function(Prism$2) {
		var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
		function createInline(pattern) {
			pattern = pattern.replace(/<inner>/g, function() {
				return inner;
			});
			return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
		}
		var tableCell$1 = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
		var tableRow$1 = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
			return tableCell$1;
		});
		var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
		Prism$2.languages.markdown = Prism$2.languages.extend("markup", {});
		Prism$2.languages.insertBefore("markdown", "prolog", {
			"front-matter-block": {
				pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
				lookbehind: true,
				greedy: true,
				inside: {
					punctuation: /^---|---$/,
					"front-matter": {
						pattern: /\S+(?:\s+\S+)*/,
						alias: ["yaml", "language-yaml"],
						inside: Prism$2.languages.yaml
					}
				}
			},
			blockquote: {
				pattern: /^>(?:[\t ]*>)*/m,
				alias: "punctuation"
			},
			table: {
				pattern: RegExp("^" + tableRow$1 + tableLine + "(?:" + tableRow$1 + ")*", "m"),
				inside: {
					"table-data-rows": {
						pattern: RegExp("^(" + tableRow$1 + tableLine + ")(?:" + tableRow$1 + ")*$"),
						lookbehind: true,
						inside: {
							"table-data": {
								pattern: RegExp(tableCell$1),
								inside: Prism$2.languages.markdown
							},
							punctuation: /\|/
						}
					},
					"table-line": {
						pattern: RegExp("^(" + tableRow$1 + ")" + tableLine + "$"),
						lookbehind: true,
						inside: { punctuation: /\||:?-{3,}:?/ }
					},
					"table-header-row": {
						pattern: RegExp("^" + tableRow$1 + "$"),
						inside: {
							"table-header": {
								pattern: RegExp(tableCell$1),
								alias: "important",
								inside: Prism$2.languages.markdown
							},
							punctuation: /\|/
						}
					}
				}
			},
			code: [{
				pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
				lookbehind: true,
				alias: "keyword"
			}, {
				pattern: /^```[\s\S]*?^```$/m,
				greedy: true,
				inside: {
					"code-block": {
						pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
						lookbehind: true
					},
					"code-language": {
						pattern: /^(```).+/,
						lookbehind: true
					},
					punctuation: /```/
				}
			}],
			title: [{
				pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
				alias: "important",
				inside: { punctuation: /==+$|--+$/ }
			}, {
				pattern: /(^\s*)#.+/m,
				lookbehind: true,
				alias: "important",
				inside: { punctuation: /^#+|#+$/ }
			}],
			hr: {
				pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
				lookbehind: true,
				alias: "punctuation"
			},
			list: {
				pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
				lookbehind: true,
				alias: "punctuation"
			},
			"url-reference": {
				pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
				inside: {
					variable: {
						pattern: /^(!?\[)[^\]]+/,
						lookbehind: true
					},
					string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
					punctuation: /^[\[\]!:]|[<>]/
				},
				alias: "url"
			},
			bold: {
				pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
				lookbehind: true,
				greedy: true,
				inside: {
					content: {
						pattern: /(^..)[\s\S]+(?=..$)/,
						lookbehind: true,
						inside: {}
					},
					punctuation: /\*\*|__/
				}
			},
			italic: {
				pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
				lookbehind: true,
				greedy: true,
				inside: {
					content: {
						pattern: /(^.)[\s\S]+(?=.$)/,
						lookbehind: true,
						inside: {}
					},
					punctuation: /[*_]/
				}
			},
			strike: {
				pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
				lookbehind: true,
				greedy: true,
				inside: {
					content: {
						pattern: /(^~~?)[\s\S]+(?=\1$)/,
						lookbehind: true,
						inside: {}
					},
					punctuation: /~~?/
				}
			},
			"code-snippet": {
				pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
				lookbehind: true,
				greedy: true,
				alias: ["code", "keyword"]
			},
			url: {
				pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
				lookbehind: true,
				greedy: true,
				inside: {
					operator: /^!/,
					content: {
						pattern: /(^\[)[^\]]+(?=\])/,
						lookbehind: true,
						inside: {}
					},
					variable: {
						pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
						lookbehind: true
					},
					url: {
						pattern: /(^\]\()[^\s)]+/,
						lookbehind: true
					},
					string: {
						pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
						lookbehind: true
					}
				}
			}
		});
		[
			"url",
			"bold",
			"italic",
			"strike"
		].forEach(function(token) {
			[
				"url",
				"bold",
				"italic",
				"strike",
				"code-snippet"
			].forEach(function(inside) {
				if (token !== inside) Prism$2.languages.markdown[token].inside.content.inside[inside] = Prism$2.languages.markdown[inside];
			});
		});
		Prism$2.hooks.add("after-tokenize", function(env$1) {
			if (env$1.language !== "markdown" && env$1.language !== "md") return;
			function walkTokens(tokens) {
				if (!tokens || typeof tokens === "string") return;
				for (var i = 0, l$1 = tokens.length; i < l$1; i++) {
					var token = tokens[i];
					if (token.type !== "code") {
						walkTokens(token.content);
						continue;
					}
					var codeLang = token.content[1];
					var codeBlock = token.content[3];
					if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
						var lang$1 = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
						lang$1 = (/[a-z][\w-]*/i.exec(lang$1) || [""])[0].toLowerCase();
						var alias$1 = "language-" + lang$1;
						if (!codeBlock.alias) codeBlock.alias = [alias$1];
						else if (typeof codeBlock.alias === "string") codeBlock.alias = [codeBlock.alias, alias$1];
						else codeBlock.alias.push(alias$1);
					}
				}
			}
			walkTokens(env$1.tokens);
		});
		Prism$2.hooks.add("wrap", function(env$1) {
			if (env$1.type !== "code-block") return;
			var codeLang = "";
			for (var i = 0, l$1 = env$1.classes.length; i < l$1; i++) {
				var cls = env$1.classes[i];
				var match = /language-(.+)/.exec(cls);
				if (match) {
					codeLang = match[1];
					break;
				}
			}
			var grammar = Prism$2.languages[codeLang];
			if (!grammar) {
				if (codeLang && codeLang !== "none" && Prism$2.plugins.autoloader) {
					var id$1 = "md-" + new Date().valueOf() + "-" + Math.floor(Math.random() * 1e16);
					env$1.attributes["id"] = id$1;
					Prism$2.plugins.autoloader.loadLanguages(codeLang, function() {
						var ele = document.getElementById(id$1);
						if (ele) ele.innerHTML = Prism$2.highlight(ele.textContent, Prism$2.languages[codeLang], codeLang);
					});
				}
			} else env$1.content = Prism$2.highlight(env$1.content.value, grammar, codeLang);
		});
		var tagPattern = RegExp(Prism$2.languages.markup.tag.pattern.source, "gi");
		var KNOWN_ENTITY_NAMES = {
			amp: "&",
			lt: "<",
			gt: ">",
			quot: "\""
		};
		var fromCodePoint$1 = String.fromCodePoint || String.fromCharCode;
		function textContent(html$6) {
			var text$8 = html$6.replace(tagPattern, "");
			text$8 = text$8.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m, code$3) {
				code$3 = code$3.toLowerCase();
				if (code$3[0] === "#") {
					var value;
					if (code$3[1] === "x") value = parseInt(code$3.slice(2), 16);
					else value = Number(code$3.slice(1));
					return fromCodePoint$1(value);
				} else {
					var known = KNOWN_ENTITY_NAMES[code$3];
					if (known) return known;
					return m;
				}
			});
			return text$8;
		}
		Prism$2.languages.md = Prism$2.languages.markdown;
	})(Prism$1);
}
objectivec.displayName = "objectivec";
objectivec.aliases = ["objc"];
function objectivec(Prism$1) {
	Prism$1.register(c$1);
	Prism$1.languages.objectivec = Prism$1.languages.extend("c", {
		string: {
			pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
			greedy: true
		},
		keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
		operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
	});
	delete Prism$1.languages.objectivec["class-name"];
	Prism$1.languages.objc = Prism$1.languages.objectivec;
}
perl.displayName = "perl";
perl.aliases = [];
function perl(Prism$1) {
	(function(Prism$2) {
		var brackets = /(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/.source;
		Prism$2.languages.perl = {
			comment: [{
				pattern: /(^\s*)=\w[\s\S]*?=cut.*/m,
				lookbehind: true,
				greedy: true
			}, {
				pattern: /(^|[^\\$])#.*/,
				lookbehind: true,
				greedy: true
			}],
			string: [
				{
					pattern: RegExp(/\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
						/([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
						/([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
						brackets
					].join("|") + ")"),
					greedy: true
				},
				{
					pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
					greedy: true
				},
				{
					pattern: /'(?:[^'\\\r\n]|\\.)*'/,
					greedy: true
				}
			],
			regex: [
				{
					pattern: RegExp(/\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
						/([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
						/([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
						brackets
					].join("|") + ")" + /[msixpodualngc]*/.source),
					greedy: true
				},
				{
					pattern: RegExp(/(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
						/([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
						/([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
						brackets + /\s*/.source + brackets
					].join("|") + ")" + /[msixpodualngcer]*/.source),
					lookbehind: true,
					greedy: true
				},
				{
					pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
					greedy: true
				}
			],
			variable: [
				/[&*$@%]\{\^[A-Z]+\}/,
				/[&*$@%]\^[A-Z_]/,
				/[&*$@%]#?(?=\{)/,
				/[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
				/[&*$@%]\d+/,
				/(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
			],
			filehandle: {
				pattern: /<(?![<=])\S*?>|\b_\b/,
				alias: "symbol"
			},
			"v-string": {
				pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
				alias: "string"
			},
			function: {
				pattern: /(\bsub[ \t]+)\w+/,
				lookbehind: true
			},
			keyword: /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
			number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
			operator: /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
			punctuation: /[{}[\];(),:]/
		};
	})(Prism$1);
}
markupTemplating.displayName = "markup-templating";
markupTemplating.aliases = [];
function markupTemplating(Prism$1) {
	Prism$1.register(markup);
	(function(Prism$2) {
		function getPlaceholder(language, index$1) {
			return "___" + language.toUpperCase() + index$1 + "___";
		}
		Object.defineProperties(Prism$2.languages["markup-templating"] = {}, {
			buildPlaceholders: { value: function(env$1, language, placeholderPattern, replaceFilter) {
				if (env$1.language !== language) return;
				var tokenStack = env$1.tokenStack = [];
				env$1.code = env$1.code.replace(placeholderPattern, function(match) {
					if (typeof replaceFilter === "function" && !replaceFilter(match)) return match;
					var i = tokenStack.length;
					var placeholder;
					while (env$1.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) ++i;
					tokenStack[i] = match;
					return placeholder;
				});
				env$1.grammar = Prism$2.languages.markup;
			} },
			tokenizePlaceholders: { value: function(env$1, language) {
				if (env$1.language !== language || !env$1.tokenStack) return;
				env$1.grammar = Prism$2.languages[language];
				var j$1 = 0;
				var keys$1 = Object.keys(env$1.tokenStack);
				function walkTokens(tokens) {
					for (var i = 0; i < tokens.length; i++) {
						if (j$1 >= keys$1.length) break;
						var token = tokens[i];
						if (typeof token === "string" || token.content && typeof token.content === "string") {
							var k = keys$1[j$1];
							var t = env$1.tokenStack[k];
							var s$2 = typeof token === "string" ? token : token.content;
							var placeholder = getPlaceholder(language, k);
							var index$1 = s$2.indexOf(placeholder);
							if (index$1 > -1) {
								++j$1;
								var before = s$2.substring(0, index$1);
								var middle = new Prism$2.Token(language, Prism$2.tokenize(t, env$1.grammar), "language-" + language, t);
								var after = s$2.substring(index$1 + placeholder.length);
								var replacement = [];
								if (before) replacement.push.apply(replacement, walkTokens([before]));
								replacement.push(middle);
								if (after) replacement.push.apply(replacement, walkTokens([after]));
								if (typeof token === "string") tokens.splice.apply(tokens, [i, 1].concat(replacement));
								else token.content = replacement;
							}
						} else if (token.content) walkTokens(token.content);
					}
					return tokens;
				}
				walkTokens(env$1.tokens);
			} }
		});
	})(Prism$1);
}
php.displayName = "php";
php.aliases = [];
function php(Prism$1) {
	Prism$1.register(markupTemplating);
	(function(Prism$2) {
		var comment$2 = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/;
		var constant = [
			{
				pattern: /\b(?:false|true)\b/i,
				alias: "boolean"
			},
			{
				pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
				greedy: true,
				lookbehind: true
			},
			/\b(?:null)\b/i,
			/\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/
		];
		var number$2 = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i;
		var operator = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;
		var punctuation = /[{}\[\](),:;]/;
		Prism$2.languages.php = {
			delimiter: {
				pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
				alias: "important"
			},
			comment: comment$2,
			variable: /\$+(?:\w+\b|(?=\{))/,
			package: {
				pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
				lookbehind: true,
				inside: { punctuation: /\\/ }
			},
			"class-name-definition": {
				pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
				lookbehind: true,
				alias: "class-name"
			},
			"function-definition": {
				pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
				lookbehind: true,
				alias: "function"
			},
			keyword: [
				{
					pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
					alias: "type-casting",
					greedy: true,
					lookbehind: true
				},
				{
					pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
					alias: "type-hint",
					greedy: true,
					lookbehind: true
				},
				{
					pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|never|object|self|static|string|void)\b/i,
					alias: "return-type",
					greedy: true,
					lookbehind: true
				},
				{
					pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
					alias: "type-declaration",
					greedy: true
				},
				{
					pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
					alias: "type-declaration",
					greedy: true,
					lookbehind: true
				},
				{
					pattern: /\b(?:parent|self|static)(?=\s*::)/i,
					alias: "static-context",
					greedy: true
				},
				{
					pattern: /(\byield\s+)from\b/i,
					lookbehind: true
				},
				/\bclass\b/i,
				{
					pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
					lookbehind: true
				}
			],
			"argument-name": {
				pattern: /([(,]\s*)\b[a-z_]\w*(?=\s*:(?!:))/i,
				lookbehind: true
			},
			"class-name": [
				{
					pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
					greedy: true,
					lookbehind: true
				},
				{
					pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
					greedy: true,
					lookbehind: true
				},
				{
					pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
					greedy: true
				},
				{
					pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
					alias: "class-name-fully-qualified",
					greedy: true,
					lookbehind: true,
					inside: { punctuation: /\\/ }
				},
				{
					pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
					alias: "class-name-fully-qualified",
					greedy: true,
					inside: { punctuation: /\\/ }
				},
				{
					pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
					alias: "class-name-fully-qualified",
					greedy: true,
					lookbehind: true,
					inside: { punctuation: /\\/ }
				},
				{
					pattern: /\b[a-z_]\w*(?=\s*\$)/i,
					alias: "type-declaration",
					greedy: true
				},
				{
					pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
					alias: ["class-name-fully-qualified", "type-declaration"],
					greedy: true,
					inside: { punctuation: /\\/ }
				},
				{
					pattern: /\b[a-z_]\w*(?=\s*::)/i,
					alias: "static-context",
					greedy: true
				},
				{
					pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
					alias: ["class-name-fully-qualified", "static-context"],
					greedy: true,
					inside: { punctuation: /\\/ }
				},
				{
					pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
					alias: "type-hint",
					greedy: true,
					lookbehind: true
				},
				{
					pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
					alias: ["class-name-fully-qualified", "type-hint"],
					greedy: true,
					lookbehind: true,
					inside: { punctuation: /\\/ }
				},
				{
					pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
					alias: "return-type",
					greedy: true,
					lookbehind: true
				},
				{
					pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
					alias: ["class-name-fully-qualified", "return-type"],
					greedy: true,
					lookbehind: true,
					inside: { punctuation: /\\/ }
				}
			],
			constant,
			function: {
				pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
				lookbehind: true,
				inside: { punctuation: /\\/ }
			},
			property: {
				pattern: /(->\s*)\w+/,
				lookbehind: true
			},
			number: number$2,
			operator,
			punctuation
		};
		var string_interpolation = {
			pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
			lookbehind: true,
			inside: Prism$2.languages.php
		};
		var string$2 = [
			{
				pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
				alias: "nowdoc-string",
				greedy: true,
				inside: { delimiter: {
					pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
					alias: "symbol",
					inside: { punctuation: /^<<<'?|[';]$/ }
				} }
			},
			{
				pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
				alias: "heredoc-string",
				greedy: true,
				inside: {
					delimiter: {
						pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
						alias: "symbol",
						inside: { punctuation: /^<<<"?|[";]$/ }
					},
					interpolation: string_interpolation
				}
			},
			{
				pattern: /`(?:\\[\s\S]|[^\\`])*`/,
				alias: "backtick-quoted-string",
				greedy: true
			},
			{
				pattern: /'(?:\\[\s\S]|[^\\'])*'/,
				alias: "single-quoted-string",
				greedy: true
			},
			{
				pattern: /"(?:\\[\s\S]|[^\\"])*"/,
				alias: "double-quoted-string",
				greedy: true,
				inside: { interpolation: string_interpolation }
			}
		];
		Prism$2.languages.insertBefore("php", "variable", {
			string: string$2,
			attribute: {
				pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
				greedy: true,
				inside: {
					"attribute-content": {
						pattern: /^(#\[)[\s\S]+(?=\]$)/,
						lookbehind: true,
						inside: {
							comment: comment$2,
							string: string$2,
							"attribute-class-name": [{
								pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
								alias: "class-name",
								greedy: true,
								lookbehind: true
							}, {
								pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
								alias: ["class-name", "class-name-fully-qualified"],
								greedy: true,
								lookbehind: true,
								inside: { punctuation: /\\/ }
							}],
							constant,
							number: number$2,
							operator,
							punctuation
						}
					},
					delimiter: {
						pattern: /^#\[|\]$/,
						alias: "punctuation"
					}
				}
			}
		});
		Prism$2.hooks.add("before-tokenize", function(env$1) {
			if (!/<\?/.test(env$1.code)) return;
			var phpPattern = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
			Prism$2.languages["markup-templating"].buildPlaceholders(env$1, "php", phpPattern);
		});
		Prism$2.hooks.add("after-tokenize", function(env$1) {
			Prism$2.languages["markup-templating"].tokenizePlaceholders(env$1, "php");
		});
	})(Prism$1);
}
python.displayName = "python";
python.aliases = ["py"];
function python(Prism$1) {
	Prism$1.languages.python = {
		comment: {
			pattern: /(^|[^\\])#.*/,
			lookbehind: true,
			greedy: true
		},
		"string-interpolation": {
			pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
			greedy: true,
			inside: {
				interpolation: {
					pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
					lookbehind: true,
					inside: {
						"format-spec": {
							pattern: /(:)[^:(){}]+(?=\}$)/,
							lookbehind: true
						},
						"conversion-option": {
							pattern: /![sra](?=[:}]$)/,
							alias: "punctuation"
						},
						rest: null
					}
				},
				string: /[\s\S]+/
			}
		},
		"triple-quoted-string": {
			pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
			greedy: true,
			alias: "string"
		},
		string: {
			pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
			greedy: true
		},
		function: {
			pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
			lookbehind: true
		},
		"class-name": {
			pattern: /(\bclass\s+)\w+/i,
			lookbehind: true
		},
		decorator: {
			pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
			lookbehind: true,
			alias: ["annotation", "punctuation"],
			inside: { punctuation: /\./ }
		},
		keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
		builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
		boolean: /\b(?:False|None|True)\b/,
		number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
		operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
		punctuation: /[{}[\];(),.:]/
	};
	Prism$1.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism$1.languages.python;
	Prism$1.languages.py = Prism$1.languages.python;
}
r.displayName = "r";
r.aliases = [];
function r(Prism$1) {
	Prism$1.languages.r = {
		comment: /#.*/,
		string: {
			pattern: /(['"])(?:\\.|(?!\1)[^\\\r\n])*\1/,
			greedy: true
		},
		"percent-operator": {
			pattern: /%[^%\s]*%/,
			alias: "operator"
		},
		boolean: /\b(?:FALSE|TRUE)\b/,
		ellipsis: /\.\.(?:\.|\d+)/,
		number: [/\b(?:Inf|NaN)\b/, /(?:\b0x[\dA-Fa-f]+(?:\.\d*)?|\b\d+(?:\.\d*)?|\B\.\d+)(?:[EePp][+-]?\d+)?[iL]?/],
		keyword: /\b(?:NA|NA_character_|NA_complex_|NA_integer_|NA_real_|NULL|break|else|for|function|if|in|next|repeat|while)\b/,
		operator: /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,
		punctuation: /[(){}\[\],;]/
	};
}
ruby.displayName = "ruby";
ruby.aliases = ["rb"];
function ruby(Prism$1) {
	Prism$1.register(clike);
	(function(Prism$2) {
		Prism$2.languages.ruby = Prism$2.languages.extend("clike", {
			comment: {
				pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
				greedy: true
			},
			"class-name": {
				pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
				lookbehind: true,
				inside: { punctuation: /[.\\]/ }
			},
			keyword: /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
			operator: /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
			punctuation: /[(){}[\].,;]/
		});
		Prism$2.languages.insertBefore("ruby", "operator", { "double-colon": {
			pattern: /::/,
			alias: "punctuation"
		} });
		var interpolation = {
			pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
			lookbehind: true,
			inside: {
				content: {
					pattern: /^(#\{)[\s\S]+(?=\}$)/,
					lookbehind: true,
					inside: Prism$2.languages.ruby
				},
				delimiter: {
					pattern: /^#\{|\}$/,
					alias: "punctuation"
				}
			}
		};
		delete Prism$2.languages.ruby.function;
		var percentExpression = "(?:" + [
			/([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
			/\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
			/\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source,
			/\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source,
			/<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source
		].join("|") + ")";
		var symbolName = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
		Prism$2.languages.insertBefore("ruby", "keyword", {
			"regex-literal": [{
				pattern: RegExp(/%r/.source + percentExpression + /[egimnosux]{0,6}/.source),
				greedy: true,
				inside: {
					interpolation,
					regex: /[\s\S]+/
				}
			}, {
				pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
				lookbehind: true,
				greedy: true,
				inside: {
					interpolation,
					regex: /[\s\S]+/
				}
			}],
			variable: /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
			symbol: [{
				pattern: RegExp(/(^|[^:]):/.source + symbolName),
				lookbehind: true,
				greedy: true
			}, {
				pattern: RegExp(/([\r\n{(,][ \t]*)/.source + symbolName + /(?=:(?!:))/.source),
				lookbehind: true,
				greedy: true
			}],
			"method-definition": {
				pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
				lookbehind: true,
				inside: {
					function: /\b\w+$/,
					keyword: /^self\b/,
					"class-name": /^\w+/,
					punctuation: /\./
				}
			}
		});
		Prism$2.languages.insertBefore("ruby", "string", {
			"string-literal": [
				{
					pattern: RegExp(/%[qQiIwWs]?/.source + percentExpression),
					greedy: true,
					inside: {
						interpolation,
						string: /[\s\S]+/
					}
				},
				{
					pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
					greedy: true,
					inside: {
						interpolation,
						string: /[\s\S]+/
					}
				},
				{
					pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
					alias: "heredoc-string",
					greedy: true,
					inside: {
						delimiter: {
							pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
							inside: {
								symbol: /\b\w+/,
								punctuation: /^<<[-~]?/
							}
						},
						interpolation,
						string: /[\s\S]+/
					}
				},
				{
					pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
					alias: "heredoc-string",
					greedy: true,
					inside: {
						delimiter: {
							pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
							inside: {
								symbol: /\b\w+/,
								punctuation: /^<<[-~]?'|'$/
							}
						},
						string: /[\s\S]+/
					}
				}
			],
			"command-literal": [{
				pattern: RegExp(/%x/.source + percentExpression),
				greedy: true,
				inside: {
					interpolation,
					command: {
						pattern: /[\s\S]+/,
						alias: "string"
					}
				}
			}, {
				pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
				greedy: true,
				inside: {
					interpolation,
					command: {
						pattern: /[\s\S]+/,
						alias: "string"
					}
				}
			}]
		});
		delete Prism$2.languages.ruby.string;
		Prism$2.languages.insertBefore("ruby", "number", {
			builtin: /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
			constant: /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
		});
		Prism$2.languages.rb = Prism$2.languages.ruby;
	})(Prism$1);
}
rust.displayName = "rust";
rust.aliases = [];
function rust(Prism$1) {
	(function(Prism$2) {
		var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
		for (var i = 0; i < 2; i++) multilineComment = multilineComment.replace(/<self>/g, function() {
			return multilineComment;
		});
		multilineComment = multilineComment.replace(/<self>/g, function() {
			return /[^\s\S]/.source;
		});
		Prism$2.languages.rust = {
			comment: [{
				pattern: RegExp(/(^|[^\\])/.source + multilineComment),
				lookbehind: true,
				greedy: true
			}, {
				pattern: /(^|[^\\:])\/\/.*/,
				lookbehind: true,
				greedy: true
			}],
			string: {
				pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
				greedy: true
			},
			char: {
				pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
				greedy: true
			},
			attribute: {
				pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
				greedy: true,
				alias: "attr-name",
				inside: { string: null }
			},
			"closure-params": {
				pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
				lookbehind: true,
				greedy: true,
				inside: {
					"closure-punctuation": {
						pattern: /^\||\|$/,
						alias: "punctuation"
					},
					rest: null
				}
			},
			"lifetime-annotation": {
				pattern: /'\w+/,
				alias: "symbol"
			},
			"fragment-specifier": {
				pattern: /(\$\w+:)[a-z]+/,
				lookbehind: true,
				alias: "punctuation"
			},
			variable: /\$\w+/,
			"function-definition": {
				pattern: /(\bfn\s+)\w+/,
				lookbehind: true,
				alias: "function"
			},
			"type-definition": {
				pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
				lookbehind: true,
				alias: "class-name"
			},
			"module-declaration": [{
				pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
				lookbehind: true,
				alias: "namespace"
			}, {
				pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
				lookbehind: true,
				alias: "namespace",
				inside: { punctuation: /::/ }
			}],
			keyword: [/\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/, /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/],
			function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
			macro: {
				pattern: /\b\w+!/,
				alias: "property"
			},
			constant: /\b[A-Z_][A-Z_\d]+\b/,
			"class-name": /\b[A-Z]\w*\b/,
			namespace: {
				pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
				inside: { punctuation: /::/ }
			},
			number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
			boolean: /\b(?:false|true)\b/,
			punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
			operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
		};
		Prism$2.languages.rust["closure-params"].inside.rest = Prism$2.languages.rust;
		Prism$2.languages.rust["attribute"].inside["string"] = Prism$2.languages.rust["string"];
	})(Prism$1);
}
sass.displayName = "sass";
sass.aliases = [];
function sass(Prism$1) {
	Prism$1.register(css);
	(function(Prism$2) {
		Prism$2.languages.sass = Prism$2.languages.extend("css", { comment: {
			pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
			lookbehind: true,
			greedy: true
		} });
		Prism$2.languages.insertBefore("sass", "atrule", { "atrule-line": {
			pattern: /^(?:[ \t]*)[@+=].+/m,
			greedy: true,
			inside: { atrule: /(?:@[\w-]+|[+=])/ }
		} });
		delete Prism$2.languages.sass.atrule;
		var variable = /\$[-\w]+|#\{\$[-\w]+\}/;
		var operator = [/[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/, {
			pattern: /(\s)-(?=\s)/,
			lookbehind: true
		}];
		Prism$2.languages.insertBefore("sass", "property", {
			"variable-line": {
				pattern: /^[ \t]*\$.+/m,
				greedy: true,
				inside: {
					punctuation: /:/,
					variable,
					operator
				}
			},
			"property-line": {
				pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
				greedy: true,
				inside: {
					property: [/[^:\s]+(?=\s*:)/, {
						pattern: /(:)[^:\s]+/,
						lookbehind: true
					}],
					punctuation: /:/,
					variable,
					operator,
					important: Prism$2.languages.sass.important
				}
			}
		});
		delete Prism$2.languages.sass.property;
		delete Prism$2.languages.sass.important;
		Prism$2.languages.insertBefore("sass", "punctuation", { selector: {
			pattern: /^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
			lookbehind: true,
			greedy: true
		} });
	})(Prism$1);
}
scss.displayName = "scss";
scss.aliases = [];
function scss(Prism$1) {
	Prism$1.register(css);
	Prism$1.languages.scss = Prism$1.languages.extend("css", {
		comment: {
			pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
			lookbehind: true
		},
		atrule: {
			pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
			inside: { rule: /@[\w-]+/ }
		},
		url: /(?:[-a-z]+-)?url(?=\()/i,
		selector: {
			pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
			inside: {
				parent: {
					pattern: /&/,
					alias: "important"
				},
				placeholder: /%[-\w]+/,
				variable: /\$[-\w]+|#\{\$[-\w]+\}/
			}
		},
		property: {
			pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
			inside: { variable: /\$[-\w]+|#\{\$[-\w]+\}/ }
		}
	});
	Prism$1.languages.insertBefore("scss", "atrule", { keyword: [/@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i, {
		pattern: /( )(?:from|through)(?= )/,
		lookbehind: true
	}] });
	Prism$1.languages.insertBefore("scss", "important", { variable: /\$[-\w]+|#\{\$[-\w]+\}/ });
	Prism$1.languages.insertBefore("scss", "function", {
		"module-modifier": {
			pattern: /\b(?:as|hide|show|with)\b/i,
			alias: "keyword"
		},
		placeholder: {
			pattern: /%[-\w]+/,
			alias: "selector"
		},
		statement: {
			pattern: /\B!(?:default|optional)\b/i,
			alias: "keyword"
		},
		boolean: /\b(?:false|true)\b/,
		null: {
			pattern: /\bnull\b/,
			alias: "keyword"
		},
		operator: {
			pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
			lookbehind: true
		}
	});
	Prism$1.languages.scss["atrule"].inside.rest = Prism$1.languages.scss;
}
sql.displayName = "sql";
sql.aliases = [];
function sql(Prism$1) {
	Prism$1.languages.sql = {
		comment: {
			pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
			lookbehind: true
		},
		variable: [{
			pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
			greedy: true
		}, /@[\w.$]+/],
		string: {
			pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
			greedy: true,
			lookbehind: true
		},
		identifier: {
			pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
			greedy: true,
			lookbehind: true,
			inside: { punctuation: /^`|`$/ }
		},
		function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
		keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
		boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
		number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
		operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
		punctuation: /[;[\]()`,.]/
	};
}
swift.displayName = "swift";
swift.aliases = [];
function swift(Prism$1) {
	Prism$1.languages.swift = {
		comment: {
			pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
			lookbehind: true,
			greedy: true
		},
		"string-literal": [{
			pattern: RegExp(/(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source),
			lookbehind: true,
			greedy: true,
			inside: {
				interpolation: {
					pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
					lookbehind: true,
					inside: null
				},
				"interpolation-punctuation": {
					pattern: /^\)|\\\($/,
					alias: "punctuation"
				},
				punctuation: /\\(?=[\r\n])/,
				string: /[\s\S]+/
			}
		}, {
			pattern: RegExp(/(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"),
			lookbehind: true,
			greedy: true,
			inside: {
				interpolation: {
					pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
					lookbehind: true,
					inside: null
				},
				"interpolation-punctuation": {
					pattern: /^\)|\\#+\($/,
					alias: "punctuation"
				},
				string: /[\s\S]+/
			}
		}],
		directive: {
			pattern: RegExp(/#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"),
			alias: "property",
			inside: {
				"directive-name": /^#\w+/,
				boolean: /\b(?:false|true)\b/,
				number: /\b\d+(?:\.\d+)*\b/,
				operator: /!|&&|\|\||[<>]=?/,
				punctuation: /[(),]/
			}
		},
		literal: {
			pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
			alias: "constant"
		},
		"other-directive": {
			pattern: /#\w+\b/,
			alias: "property"
		},
		attribute: {
			pattern: /@\w+/,
			alias: "atrule"
		},
		"function-definition": {
			pattern: /(\bfunc\s+)\w+/,
			lookbehind: true,
			alias: "function"
		},
		label: {
			pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
			lookbehind: true,
			alias: "important"
		},
		keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
		boolean: /\b(?:false|true)\b/,
		nil: {
			pattern: /\bnil\b/,
			alias: "constant"
		},
		"short-argument": /\$\d+\b/,
		omit: {
			pattern: /\b_\b/,
			alias: "keyword"
		},
		number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
		"class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
		function: /\b[a-z_]\w*(?=\s*\()/i,
		constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
		operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
		punctuation: /[{}[\]();,.:\\]/
	};
	Prism$1.languages.swift["string-literal"].forEach(function(rule) {
		rule.inside["interpolation"].inside = Prism$1.languages.swift;
	});
}
typescript.displayName = "typescript";
typescript.aliases = ["ts"];
function typescript(Prism$1) {
	Prism$1.register(javascript);
	(function(Prism$2) {
		Prism$2.languages.typescript = Prism$2.languages.extend("javascript", {
			"class-name": {
				pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
				lookbehind: true,
				greedy: true,
				inside: null
			},
			builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
		});
		Prism$2.languages.typescript.keyword.push(/\b(?:abstract|declare|is|keyof|readonly|require)\b/, /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/, /\btype\b(?=\s*(?:[\{*]|$))/);
		delete Prism$2.languages.typescript["parameter"];
		delete Prism$2.languages.typescript["literal-property"];
		var typeInside = Prism$2.languages.extend("typescript", {});
		delete typeInside["class-name"];
		Prism$2.languages.typescript["class-name"].inside = typeInside;
		Prism$2.languages.insertBefore("typescript", "function", {
			decorator: {
				pattern: /@[$\w\xA0-\uFFFF]+/,
				inside: {
					at: {
						pattern: /^@/,
						alias: "operator"
					},
					function: /^[\s\S]+/
				}
			},
			"generic-function": {
				pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
				greedy: true,
				inside: {
					function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
					generic: {
						pattern: /<[\s\S]+/,
						alias: "class-name",
						inside: typeInside
					}
				}
			}
		});
		Prism$2.languages.ts = Prism$2.languages.typescript;
	})(Prism$1);
}
basic.displayName = "basic";
basic.aliases = [];
function basic(Prism$1) {
	Prism$1.languages.basic = {
		comment: {
			pattern: /(?:!|REM\b).+/i,
			inside: { keyword: /^REM/i }
		},
		string: {
			pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
			greedy: true
		},
		number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
		keyword: /\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SELECT CASE|SHARED|SHELL|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,
		function: /\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,
		operator: /<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,
		punctuation: /[,;:()]/
	};
}
vbnet.displayName = "vbnet";
vbnet.aliases = [];
function vbnet(Prism$1) {
	Prism$1.register(basic);
	Prism$1.languages.vbnet = Prism$1.languages.extend("basic", {
		comment: [{
			pattern: /(?:!|REM\b).+/i,
			inside: { keyword: /^REM/i }
		}, {
			pattern: /(^|[^\\:])'.*/,
			lookbehind: true,
			greedy: true
		}],
		string: {
			pattern: /(^|[^"])"(?:""|[^"])*"(?!")/,
			lookbehind: true,
			greedy: true
		},
		keyword: /(?:\b(?:ADDHANDLER|ADDRESSOF|ALIAS|AND|ANDALSO|AS|BEEP|BLOAD|BOOLEAN|BSAVE|BYREF|BYTE|BYVAL|CALL(?: ABSOLUTE)?|CASE|CATCH|CBOOL|CBYTE|CCHAR|CDATE|CDBL|CDEC|CHAIN|CHAR|CHDIR|CINT|CLASS|CLEAR|CLNG|CLOSE|CLS|COBJ|COM|COMMON|CONST|CONTINUE|CSBYTE|CSHORT|CSNG|CSTR|CTYPE|CUINT|CULNG|CUSHORT|DATA|DATE|DECIMAL|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DEFAULT|DELEGATE|DIM|DIRECTCAST|DO|DOUBLE|ELSE|ELSEIF|END|ENUM|ENVIRON|ERASE|ERROR|EVENT|EXIT|FALSE|FIELD|FILES|FINALLY|FOR(?: EACH)?|FRIEND|FUNCTION|GET|GETTYPE|GETXMLNAMESPACE|GLOBAL|GOSUB|GOTO|HANDLES|IF|IMPLEMENTS|IMPORTS|IN|INHERITS|INPUT|INTEGER|INTERFACE|IOCTL|IS|ISNOT|KEY|KILL|LET|LIB|LIKE|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|ME|MKDIR|MOD|MODULE|MUSTINHERIT|MUSTOVERRIDE|MYBASE|MYCLASS|NAME|NAMESPACE|NARROWING|NEW|NEXT|NOT|NOTHING|NOTINHERITABLE|NOTOVERRIDABLE|OBJECT|OF|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPERATOR|OPTION(?: BASE)?|OPTIONAL|OR|ORELSE|OUT|OVERLOADS|OVERRIDABLE|OVERRIDES|PARAMARRAY|PARTIAL|POKE|PRIVATE|PROPERTY|PROTECTED|PUBLIC|PUT|RAISEEVENT|READ|READONLY|REDIM|REM|REMOVEHANDLER|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SBYTE|SELECT(?: CASE)?|SET|SHADOWS|SHARED|SHELL|SHORT|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|STRUCTURE|SUB|SWAP|SYNCLOCK|SYSTEM|THEN|THROW|TIMER|TO|TROFF|TRON|TRUE|TRY|TRYCAST|TYPE|TYPEOF|UINTEGER|ULONG|UNLOCK|UNTIL|USHORT|USING|VIEW PRINT|WAIT|WEND|WHEN|WHILE|WIDENING|WITH|WITHEVENTS|WRITE|WRITEONLY|XOR)|\B(?:#CONST|#ELSE|#ELSEIF|#END|#IF))(?:\$|\b)/i,
		punctuation: /[,;:(){}]/
	});
}
var Schema$1 = class {
	constructor(property, normal, space$1) {
		this.property = property;
		this.normal = normal;
		if (space$1) this.space = space$1;
	}
};
Schema$1.prototype.property = {};
Schema$1.prototype.normal = {};
Schema$1.prototype.space = null;
function merge$1(definitions, space$1) {
	const property = {};
	const normal = {};
	let index$1 = -1;
	while (++index$1 < definitions.length) {
		Object.assign(property, definitions[index$1].property);
		Object.assign(normal, definitions[index$1].normal);
	}
	return new Schema$1(property, normal, space$1);
}
function normalize$1(value) {
	return value.toLowerCase();
}
var Info$1 = class {
	constructor(property, attribute$1) {
		this.property = property;
		this.attribute = attribute$1;
	}
};
Info$1.prototype.space = null;
Info$1.prototype.boolean = false;
Info$1.prototype.booleanish = false;
Info$1.prototype.overloadedBoolean = false;
Info$1.prototype.number = false;
Info$1.prototype.commaSeparated = false;
Info$1.prototype.spaceSeparated = false;
Info$1.prototype.commaOrSpaceSeparated = false;
Info$1.prototype.mustUseProperty = false;
Info$1.prototype.defined = false;
var types_exports$1 = {};
__export(types_exports$1, {
	boolean: () => boolean$1,
	booleanish: () => booleanish$1,
	commaOrSpaceSeparated: () => commaOrSpaceSeparated$1,
	commaSeparated: () => commaSeparated$1,
	number: () => number$1,
	overloadedBoolean: () => overloadedBoolean$1,
	spaceSeparated: () => spaceSeparated$1
});
let powers$1 = 0;
const boolean$1 = increment$1();
const booleanish$1 = increment$1();
const overloadedBoolean$1 = increment$1();
const number$1 = increment$1();
const spaceSeparated$1 = increment$1();
const commaSeparated$1 = increment$1();
const commaOrSpaceSeparated$1 = increment$1();
function increment$1() {
	return 2 ** ++powers$1;
}
const checks$1 = Object.keys(types_exports$1);
var DefinedInfo$1 = class extends Info$1 {
	constructor(property, attribute$1, mask, space$1) {
		let index$1 = -1;
		super(property, attribute$1);
		mark$1(this, "space", space$1);
		if (typeof mask === "number") while (++index$1 < checks$1.length) {
			const check = checks$1[index$1];
			mark$1(this, checks$1[index$1], (mask & types_exports$1[check]) === types_exports$1[check]);
		}
	}
};
DefinedInfo$1.prototype.defined = true;
function mark$1(values, key, value) {
	if (value) values[key] = value;
}
const own$12 = {}.hasOwnProperty;
function create$2(definition$2) {
	const property = {};
	const normal = {};
	let prop;
	for (prop in definition$2.properties) if (own$12.call(definition$2.properties, prop)) {
		const value = definition$2.properties[prop];
		const info = new DefinedInfo$1(prop, definition$2.transform(definition$2.attributes || {}, prop), value, definition$2.space);
		if (definition$2.mustUseProperty && definition$2.mustUseProperty.includes(prop)) info.mustUseProperty = true;
		property[prop] = info;
		normal[normalize$1(prop)] = prop;
		normal[normalize$1(info.attribute)] = prop;
	}
	return new Schema$1(property, normal, definition$2.space);
}
const xlink$1 = create$2({
	space: "xlink",
	transform(_$1, prop) {
		return "xlink:" + prop.slice(5).toLowerCase();
	},
	properties: {
		xLinkActuate: null,
		xLinkArcRole: null,
		xLinkHref: null,
		xLinkRole: null,
		xLinkShow: null,
		xLinkTitle: null,
		xLinkType: null
	}
});
const xml$1 = create$2({
	space: "xml",
	transform(_$1, prop) {
		return "xml:" + prop.slice(3).toLowerCase();
	},
	properties: {
		xmlLang: null,
		xmlBase: null,
		xmlSpace: null
	}
});
function caseSensitiveTransform$1(attributes$1, attribute$1) {
	return attribute$1 in attributes$1 ? attributes$1[attribute$1] : attribute$1;
}
function caseInsensitiveTransform$1(attributes$1, property) {
	return caseSensitiveTransform$1(attributes$1, property.toLowerCase());
}
const xmlns$1 = create$2({
	space: "xmlns",
	attributes: { xmlnsxlink: "xmlns:xlink" },
	transform: caseInsensitiveTransform$1,
	properties: {
		xmlns: null,
		xmlnsXLink: null
	}
});
const aria$1 = create$2({
	transform(_$1, prop) {
		return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
	},
	properties: {
		ariaActiveDescendant: null,
		ariaAtomic: booleanish$1,
		ariaAutoComplete: null,
		ariaBusy: booleanish$1,
		ariaChecked: booleanish$1,
		ariaColCount: number$1,
		ariaColIndex: number$1,
		ariaColSpan: number$1,
		ariaControls: spaceSeparated$1,
		ariaCurrent: null,
		ariaDescribedBy: spaceSeparated$1,
		ariaDetails: null,
		ariaDisabled: booleanish$1,
		ariaDropEffect: spaceSeparated$1,
		ariaErrorMessage: null,
		ariaExpanded: booleanish$1,
		ariaFlowTo: spaceSeparated$1,
		ariaGrabbed: booleanish$1,
		ariaHasPopup: null,
		ariaHidden: booleanish$1,
		ariaInvalid: null,
		ariaKeyShortcuts: null,
		ariaLabel: null,
		ariaLabelledBy: spaceSeparated$1,
		ariaLevel: number$1,
		ariaLive: null,
		ariaModal: booleanish$1,
		ariaMultiLine: booleanish$1,
		ariaMultiSelectable: booleanish$1,
		ariaOrientation: null,
		ariaOwns: spaceSeparated$1,
		ariaPlaceholder: null,
		ariaPosInSet: number$1,
		ariaPressed: booleanish$1,
		ariaReadOnly: booleanish$1,
		ariaRelevant: null,
		ariaRequired: booleanish$1,
		ariaRoleDescription: spaceSeparated$1,
		ariaRowCount: number$1,
		ariaRowIndex: number$1,
		ariaRowSpan: number$1,
		ariaSelected: booleanish$1,
		ariaSetSize: number$1,
		ariaSort: null,
		ariaValueMax: number$1,
		ariaValueMin: number$1,
		ariaValueNow: number$1,
		ariaValueText: null,
		role: null
	}
});
const html$5 = create$2({
	space: "html",
	attributes: {
		acceptcharset: "accept-charset",
		classname: "class",
		htmlfor: "for",
		httpequiv: "http-equiv"
	},
	transform: caseInsensitiveTransform$1,
	mustUseProperty: [
		"checked",
		"multiple",
		"muted",
		"selected"
	],
	properties: {
		abbr: null,
		accept: commaSeparated$1,
		acceptCharset: spaceSeparated$1,
		accessKey: spaceSeparated$1,
		action: null,
		allow: null,
		allowFullScreen: boolean$1,
		allowPaymentRequest: boolean$1,
		allowUserMedia: boolean$1,
		alt: null,
		as: null,
		async: boolean$1,
		autoCapitalize: null,
		autoComplete: spaceSeparated$1,
		autoFocus: boolean$1,
		autoPlay: boolean$1,
		blocking: spaceSeparated$1,
		capture: null,
		charSet: null,
		checked: boolean$1,
		cite: null,
		className: spaceSeparated$1,
		cols: number$1,
		colSpan: null,
		content: null,
		contentEditable: booleanish$1,
		controls: boolean$1,
		controlsList: spaceSeparated$1,
		coords: number$1 | commaSeparated$1,
		crossOrigin: null,
		data: null,
		dateTime: null,
		decoding: null,
		default: boolean$1,
		defer: boolean$1,
		dir: null,
		dirName: null,
		disabled: boolean$1,
		download: overloadedBoolean$1,
		draggable: booleanish$1,
		encType: null,
		enterKeyHint: null,
		fetchPriority: null,
		form: null,
		formAction: null,
		formEncType: null,
		formMethod: null,
		formNoValidate: boolean$1,
		formTarget: null,
		headers: spaceSeparated$1,
		height: number$1,
		hidden: boolean$1,
		high: number$1,
		href: null,
		hrefLang: null,
		htmlFor: spaceSeparated$1,
		httpEquiv: spaceSeparated$1,
		id: null,
		imageSizes: null,
		imageSrcSet: null,
		inert: boolean$1,
		inputMode: null,
		integrity: null,
		is: null,
		isMap: boolean$1,
		itemId: null,
		itemProp: spaceSeparated$1,
		itemRef: spaceSeparated$1,
		itemScope: boolean$1,
		itemType: spaceSeparated$1,
		kind: null,
		label: null,
		lang: null,
		language: null,
		list: null,
		loading: null,
		loop: boolean$1,
		low: number$1,
		manifest: null,
		max: null,
		maxLength: number$1,
		media: null,
		method: null,
		min: null,
		minLength: number$1,
		multiple: boolean$1,
		muted: boolean$1,
		name: null,
		nonce: null,
		noModule: boolean$1,
		noValidate: boolean$1,
		onAbort: null,
		onAfterPrint: null,
		onAuxClick: null,
		onBeforeMatch: null,
		onBeforePrint: null,
		onBeforeToggle: null,
		onBeforeUnload: null,
		onBlur: null,
		onCancel: null,
		onCanPlay: null,
		onCanPlayThrough: null,
		onChange: null,
		onClick: null,
		onClose: null,
		onContextLost: null,
		onContextMenu: null,
		onContextRestored: null,
		onCopy: null,
		onCueChange: null,
		onCut: null,
		onDblClick: null,
		onDrag: null,
		onDragEnd: null,
		onDragEnter: null,
		onDragExit: null,
		onDragLeave: null,
		onDragOver: null,
		onDragStart: null,
		onDrop: null,
		onDurationChange: null,
		onEmptied: null,
		onEnded: null,
		onError: null,
		onFocus: null,
		onFormData: null,
		onHashChange: null,
		onInput: null,
		onInvalid: null,
		onKeyDown: null,
		onKeyPress: null,
		onKeyUp: null,
		onLanguageChange: null,
		onLoad: null,
		onLoadedData: null,
		onLoadedMetadata: null,
		onLoadEnd: null,
		onLoadStart: null,
		onMessage: null,
		onMessageError: null,
		onMouseDown: null,
		onMouseEnter: null,
		onMouseLeave: null,
		onMouseMove: null,
		onMouseOut: null,
		onMouseOver: null,
		onMouseUp: null,
		onOffline: null,
		onOnline: null,
		onPageHide: null,
		onPageShow: null,
		onPaste: null,
		onPause: null,
		onPlay: null,
		onPlaying: null,
		onPopState: null,
		onProgress: null,
		onRateChange: null,
		onRejectionHandled: null,
		onReset: null,
		onResize: null,
		onScroll: null,
		onScrollEnd: null,
		onSecurityPolicyViolation: null,
		onSeeked: null,
		onSeeking: null,
		onSelect: null,
		onSlotChange: null,
		onStalled: null,
		onStorage: null,
		onSubmit: null,
		onSuspend: null,
		onTimeUpdate: null,
		onToggle: null,
		onUnhandledRejection: null,
		onUnload: null,
		onVolumeChange: null,
		onWaiting: null,
		onWheel: null,
		open: boolean$1,
		optimum: number$1,
		pattern: null,
		ping: spaceSeparated$1,
		placeholder: null,
		playsInline: boolean$1,
		popover: null,
		popoverTarget: null,
		popoverTargetAction: null,
		poster: null,
		preload: null,
		readOnly: boolean$1,
		referrerPolicy: null,
		rel: spaceSeparated$1,
		required: boolean$1,
		reversed: boolean$1,
		rows: number$1,
		rowSpan: number$1,
		sandbox: spaceSeparated$1,
		scope: null,
		scoped: boolean$1,
		seamless: boolean$1,
		selected: boolean$1,
		shadowRootClonable: boolean$1,
		shadowRootDelegatesFocus: boolean$1,
		shadowRootMode: null,
		shape: null,
		size: number$1,
		sizes: null,
		slot: null,
		span: number$1,
		spellCheck: booleanish$1,
		src: null,
		srcDoc: null,
		srcLang: null,
		srcSet: null,
		start: number$1,
		step: null,
		style: null,
		tabIndex: number$1,
		target: null,
		title: null,
		translate: null,
		type: null,
		typeMustMatch: boolean$1,
		useMap: null,
		value: booleanish$1,
		width: number$1,
		wrap: null,
		writingSuggestions: null,
		align: null,
		aLink: null,
		archive: spaceSeparated$1,
		axis: null,
		background: null,
		bgColor: null,
		border: number$1,
		borderColor: null,
		bottomMargin: number$1,
		cellPadding: null,
		cellSpacing: null,
		char: null,
		charOff: null,
		classId: null,
		clear: null,
		code: null,
		codeBase: null,
		codeType: null,
		color: null,
		compact: boolean$1,
		declare: boolean$1,
		event: null,
		face: null,
		frame: null,
		frameBorder: null,
		hSpace: number$1,
		leftMargin: number$1,
		link: null,
		longDesc: null,
		lowSrc: null,
		marginHeight: number$1,
		marginWidth: number$1,
		noResize: boolean$1,
		noHref: boolean$1,
		noShade: boolean$1,
		noWrap: boolean$1,
		object: null,
		profile: null,
		prompt: null,
		rev: null,
		rightMargin: number$1,
		rules: null,
		scheme: null,
		scrolling: booleanish$1,
		standby: null,
		summary: null,
		text: null,
		topMargin: number$1,
		valueType: null,
		version: null,
		vAlign: null,
		vLink: null,
		vSpace: number$1,
		allowTransparency: null,
		autoCorrect: null,
		autoSave: null,
		disablePictureInPicture: boolean$1,
		disableRemotePlayback: boolean$1,
		prefix: null,
		property: null,
		results: number$1,
		security: null,
		unselectable: null
	}
});
const svg$3 = create$2({
	space: "svg",
	attributes: {
		accentHeight: "accent-height",
		alignmentBaseline: "alignment-baseline",
		arabicForm: "arabic-form",
		baselineShift: "baseline-shift",
		capHeight: "cap-height",
		className: "class",
		clipPath: "clip-path",
		clipRule: "clip-rule",
		colorInterpolation: "color-interpolation",
		colorInterpolationFilters: "color-interpolation-filters",
		colorProfile: "color-profile",
		colorRendering: "color-rendering",
		crossOrigin: "crossorigin",
		dataType: "datatype",
		dominantBaseline: "dominant-baseline",
		enableBackground: "enable-background",
		fillOpacity: "fill-opacity",
		fillRule: "fill-rule",
		floodColor: "flood-color",
		floodOpacity: "flood-opacity",
		fontFamily: "font-family",
		fontSize: "font-size",
		fontSizeAdjust: "font-size-adjust",
		fontStretch: "font-stretch",
		fontStyle: "font-style",
		fontVariant: "font-variant",
		fontWeight: "font-weight",
		glyphName: "glyph-name",
		glyphOrientationHorizontal: "glyph-orientation-horizontal",
		glyphOrientationVertical: "glyph-orientation-vertical",
		hrefLang: "hreflang",
		horizAdvX: "horiz-adv-x",
		horizOriginX: "horiz-origin-x",
		horizOriginY: "horiz-origin-y",
		imageRendering: "image-rendering",
		letterSpacing: "letter-spacing",
		lightingColor: "lighting-color",
		markerEnd: "marker-end",
		markerMid: "marker-mid",
		markerStart: "marker-start",
		navDown: "nav-down",
		navDownLeft: "nav-down-left",
		navDownRight: "nav-down-right",
		navLeft: "nav-left",
		navNext: "nav-next",
		navPrev: "nav-prev",
		navRight: "nav-right",
		navUp: "nav-up",
		navUpLeft: "nav-up-left",
		navUpRight: "nav-up-right",
		onAbort: "onabort",
		onActivate: "onactivate",
		onAfterPrint: "onafterprint",
		onBeforePrint: "onbeforeprint",
		onBegin: "onbegin",
		onCancel: "oncancel",
		onCanPlay: "oncanplay",
		onCanPlayThrough: "oncanplaythrough",
		onChange: "onchange",
		onClick: "onclick",
		onClose: "onclose",
		onCopy: "oncopy",
		onCueChange: "oncuechange",
		onCut: "oncut",
		onDblClick: "ondblclick",
		onDrag: "ondrag",
		onDragEnd: "ondragend",
		onDragEnter: "ondragenter",
		onDragExit: "ondragexit",
		onDragLeave: "ondragleave",
		onDragOver: "ondragover",
		onDragStart: "ondragstart",
		onDrop: "ondrop",
		onDurationChange: "ondurationchange",
		onEmptied: "onemptied",
		onEnd: "onend",
		onEnded: "onended",
		onError: "onerror",
		onFocus: "onfocus",
		onFocusIn: "onfocusin",
		onFocusOut: "onfocusout",
		onHashChange: "onhashchange",
		onInput: "oninput",
		onInvalid: "oninvalid",
		onKeyDown: "onkeydown",
		onKeyPress: "onkeypress",
		onKeyUp: "onkeyup",
		onLoad: "onload",
		onLoadedData: "onloadeddata",
		onLoadedMetadata: "onloadedmetadata",
		onLoadStart: "onloadstart",
		onMessage: "onmessage",
		onMouseDown: "onmousedown",
		onMouseEnter: "onmouseenter",
		onMouseLeave: "onmouseleave",
		onMouseMove: "onmousemove",
		onMouseOut: "onmouseout",
		onMouseOver: "onmouseover",
		onMouseUp: "onmouseup",
		onMouseWheel: "onmousewheel",
		onOffline: "onoffline",
		onOnline: "ononline",
		onPageHide: "onpagehide",
		onPageShow: "onpageshow",
		onPaste: "onpaste",
		onPause: "onpause",
		onPlay: "onplay",
		onPlaying: "onplaying",
		onPopState: "onpopstate",
		onProgress: "onprogress",
		onRateChange: "onratechange",
		onRepeat: "onrepeat",
		onReset: "onreset",
		onResize: "onresize",
		onScroll: "onscroll",
		onSeeked: "onseeked",
		onSeeking: "onseeking",
		onSelect: "onselect",
		onShow: "onshow",
		onStalled: "onstalled",
		onStorage: "onstorage",
		onSubmit: "onsubmit",
		onSuspend: "onsuspend",
		onTimeUpdate: "ontimeupdate",
		onToggle: "ontoggle",
		onUnload: "onunload",
		onVolumeChange: "onvolumechange",
		onWaiting: "onwaiting",
		onZoom: "onzoom",
		overlinePosition: "overline-position",
		overlineThickness: "overline-thickness",
		paintOrder: "paint-order",
		panose1: "panose-1",
		pointerEvents: "pointer-events",
		referrerPolicy: "referrerpolicy",
		renderingIntent: "rendering-intent",
		shapeRendering: "shape-rendering",
		stopColor: "stop-color",
		stopOpacity: "stop-opacity",
		strikethroughPosition: "strikethrough-position",
		strikethroughThickness: "strikethrough-thickness",
		strokeDashArray: "stroke-dasharray",
		strokeDashOffset: "stroke-dashoffset",
		strokeLineCap: "stroke-linecap",
		strokeLineJoin: "stroke-linejoin",
		strokeMiterLimit: "stroke-miterlimit",
		strokeOpacity: "stroke-opacity",
		strokeWidth: "stroke-width",
		tabIndex: "tabindex",
		textAnchor: "text-anchor",
		textDecoration: "text-decoration",
		textRendering: "text-rendering",
		transformOrigin: "transform-origin",
		typeOf: "typeof",
		underlinePosition: "underline-position",
		underlineThickness: "underline-thickness",
		unicodeBidi: "unicode-bidi",
		unicodeRange: "unicode-range",
		unitsPerEm: "units-per-em",
		vAlphabetic: "v-alphabetic",
		vHanging: "v-hanging",
		vIdeographic: "v-ideographic",
		vMathematical: "v-mathematical",
		vectorEffect: "vector-effect",
		vertAdvY: "vert-adv-y",
		vertOriginX: "vert-origin-x",
		vertOriginY: "vert-origin-y",
		wordSpacing: "word-spacing",
		writingMode: "writing-mode",
		xHeight: "x-height",
		playbackOrder: "playbackorder",
		timelineBegin: "timelinebegin"
	},
	transform: caseSensitiveTransform$1,
	properties: {
		about: commaOrSpaceSeparated$1,
		accentHeight: number$1,
		accumulate: null,
		additive: null,
		alignmentBaseline: null,
		alphabetic: number$1,
		amplitude: number$1,
		arabicForm: null,
		ascent: number$1,
		attributeName: null,
		attributeType: null,
		azimuth: number$1,
		bandwidth: null,
		baselineShift: null,
		baseFrequency: null,
		baseProfile: null,
		bbox: null,
		begin: null,
		bias: number$1,
		by: null,
		calcMode: null,
		capHeight: number$1,
		className: spaceSeparated$1,
		clip: null,
		clipPath: null,
		clipPathUnits: null,
		clipRule: null,
		color: null,
		colorInterpolation: null,
		colorInterpolationFilters: null,
		colorProfile: null,
		colorRendering: null,
		content: null,
		contentScriptType: null,
		contentStyleType: null,
		crossOrigin: null,
		cursor: null,
		cx: null,
		cy: null,
		d: null,
		dataType: null,
		defaultAction: null,
		descent: number$1,
		diffuseConstant: number$1,
		direction: null,
		display: null,
		dur: null,
		divisor: number$1,
		dominantBaseline: null,
		download: boolean$1,
		dx: null,
		dy: null,
		edgeMode: null,
		editable: null,
		elevation: number$1,
		enableBackground: null,
		end: null,
		event: null,
		exponent: number$1,
		externalResourcesRequired: null,
		fill: null,
		fillOpacity: number$1,
		fillRule: null,
		filter: null,
		filterRes: null,
		filterUnits: null,
		floodColor: null,
		floodOpacity: null,
		focusable: null,
		focusHighlight: null,
		fontFamily: null,
		fontSize: null,
		fontSizeAdjust: null,
		fontStretch: null,
		fontStyle: null,
		fontVariant: null,
		fontWeight: null,
		format: null,
		fr: null,
		from: null,
		fx: null,
		fy: null,
		g1: commaSeparated$1,
		g2: commaSeparated$1,
		glyphName: commaSeparated$1,
		glyphOrientationHorizontal: null,
		glyphOrientationVertical: null,
		glyphRef: null,
		gradientTransform: null,
		gradientUnits: null,
		handler: null,
		hanging: number$1,
		hatchContentUnits: null,
		hatchUnits: null,
		height: null,
		href: null,
		hrefLang: null,
		horizAdvX: number$1,
		horizOriginX: number$1,
		horizOriginY: number$1,
		id: null,
		ideographic: number$1,
		imageRendering: null,
		initialVisibility: null,
		in: null,
		in2: null,
		intercept: number$1,
		k: number$1,
		k1: number$1,
		k2: number$1,
		k3: number$1,
		k4: number$1,
		kernelMatrix: commaOrSpaceSeparated$1,
		kernelUnitLength: null,
		keyPoints: null,
		keySplines: null,
		keyTimes: null,
		kerning: null,
		lang: null,
		lengthAdjust: null,
		letterSpacing: null,
		lightingColor: null,
		limitingConeAngle: number$1,
		local: null,
		markerEnd: null,
		markerMid: null,
		markerStart: null,
		markerHeight: null,
		markerUnits: null,
		markerWidth: null,
		mask: null,
		maskContentUnits: null,
		maskUnits: null,
		mathematical: null,
		max: null,
		media: null,
		mediaCharacterEncoding: null,
		mediaContentEncodings: null,
		mediaSize: number$1,
		mediaTime: null,
		method: null,
		min: null,
		mode: null,
		name: null,
		navDown: null,
		navDownLeft: null,
		navDownRight: null,
		navLeft: null,
		navNext: null,
		navPrev: null,
		navRight: null,
		navUp: null,
		navUpLeft: null,
		navUpRight: null,
		numOctaves: null,
		observer: null,
		offset: null,
		onAbort: null,
		onActivate: null,
		onAfterPrint: null,
		onBeforePrint: null,
		onBegin: null,
		onCancel: null,
		onCanPlay: null,
		onCanPlayThrough: null,
		onChange: null,
		onClick: null,
		onClose: null,
		onCopy: null,
		onCueChange: null,
		onCut: null,
		onDblClick: null,
		onDrag: null,
		onDragEnd: null,
		onDragEnter: null,
		onDragExit: null,
		onDragLeave: null,
		onDragOver: null,
		onDragStart: null,
		onDrop: null,
		onDurationChange: null,
		onEmptied: null,
		onEnd: null,
		onEnded: null,
		onError: null,
		onFocus: null,
		onFocusIn: null,
		onFocusOut: null,
		onHashChange: null,
		onInput: null,
		onInvalid: null,
		onKeyDown: null,
		onKeyPress: null,
		onKeyUp: null,
		onLoad: null,
		onLoadedData: null,
		onLoadedMetadata: null,
		onLoadStart: null,
		onMessage: null,
		onMouseDown: null,
		onMouseEnter: null,
		onMouseLeave: null,
		onMouseMove: null,
		onMouseOut: null,
		onMouseOver: null,
		onMouseUp: null,
		onMouseWheel: null,
		onOffline: null,
		onOnline: null,
		onPageHide: null,
		onPageShow: null,
		onPaste: null,
		onPause: null,
		onPlay: null,
		onPlaying: null,
		onPopState: null,
		onProgress: null,
		onRateChange: null,
		onRepeat: null,
		onReset: null,
		onResize: null,
		onScroll: null,
		onSeeked: null,
		onSeeking: null,
		onSelect: null,
		onShow: null,
		onStalled: null,
		onStorage: null,
		onSubmit: null,
		onSuspend: null,
		onTimeUpdate: null,
		onToggle: null,
		onUnload: null,
		onVolumeChange: null,
		onWaiting: null,
		onZoom: null,
		opacity: null,
		operator: null,
		order: null,
		orient: null,
		orientation: null,
		origin: null,
		overflow: null,
		overlay: null,
		overlinePosition: number$1,
		overlineThickness: number$1,
		paintOrder: null,
		panose1: null,
		path: null,
		pathLength: number$1,
		patternContentUnits: null,
		patternTransform: null,
		patternUnits: null,
		phase: null,
		ping: spaceSeparated$1,
		pitch: null,
		playbackOrder: null,
		pointerEvents: null,
		points: null,
		pointsAtX: number$1,
		pointsAtY: number$1,
		pointsAtZ: number$1,
		preserveAlpha: null,
		preserveAspectRatio: null,
		primitiveUnits: null,
		propagate: null,
		property: commaOrSpaceSeparated$1,
		r: null,
		radius: null,
		referrerPolicy: null,
		refX: null,
		refY: null,
		rel: commaOrSpaceSeparated$1,
		rev: commaOrSpaceSeparated$1,
		renderingIntent: null,
		repeatCount: null,
		repeatDur: null,
		requiredExtensions: commaOrSpaceSeparated$1,
		requiredFeatures: commaOrSpaceSeparated$1,
		requiredFonts: commaOrSpaceSeparated$1,
		requiredFormats: commaOrSpaceSeparated$1,
		resource: null,
		restart: null,
		result: null,
		rotate: null,
		rx: null,
		ry: null,
		scale: null,
		seed: null,
		shapeRendering: null,
		side: null,
		slope: null,
		snapshotTime: null,
		specularConstant: number$1,
		specularExponent: number$1,
		spreadMethod: null,
		spacing: null,
		startOffset: null,
		stdDeviation: null,
		stemh: null,
		stemv: null,
		stitchTiles: null,
		stopColor: null,
		stopOpacity: null,
		strikethroughPosition: number$1,
		strikethroughThickness: number$1,
		string: null,
		stroke: null,
		strokeDashArray: commaOrSpaceSeparated$1,
		strokeDashOffset: null,
		strokeLineCap: null,
		strokeLineJoin: null,
		strokeMiterLimit: number$1,
		strokeOpacity: number$1,
		strokeWidth: null,
		style: null,
		surfaceScale: number$1,
		syncBehavior: null,
		syncBehaviorDefault: null,
		syncMaster: null,
		syncTolerance: null,
		syncToleranceDefault: null,
		systemLanguage: commaOrSpaceSeparated$1,
		tabIndex: number$1,
		tableValues: null,
		target: null,
		targetX: number$1,
		targetY: number$1,
		textAnchor: null,
		textDecoration: null,
		textRendering: null,
		textLength: null,
		timelineBegin: null,
		title: null,
		transformBehavior: null,
		type: null,
		typeOf: commaOrSpaceSeparated$1,
		to: null,
		transform: null,
		transformOrigin: null,
		u1: null,
		u2: null,
		underlinePosition: number$1,
		underlineThickness: number$1,
		unicode: null,
		unicodeBidi: null,
		unicodeRange: null,
		unitsPerEm: number$1,
		values: null,
		vAlphabetic: number$1,
		vMathematical: number$1,
		vectorEffect: null,
		vHanging: number$1,
		vIdeographic: number$1,
		version: null,
		vertAdvY: number$1,
		vertOriginX: number$1,
		vertOriginY: number$1,
		viewBox: null,
		viewTarget: null,
		visibility: null,
		width: null,
		widths: null,
		wordSpacing: null,
		writingMode: null,
		x: null,
		x1: null,
		x2: null,
		xChannelSelector: null,
		xHeight: number$1,
		y: null,
		y1: null,
		y2: null,
		yChannelSelector: null,
		z: null,
		zoomAndPan: null
	}
});
const valid$1 = /^data[-\w.:]+$/i;
const dash$1 = /-[a-z]/g;
const cap$2 = /[A-Z]/g;
function find$1(schema, value) {
	const normal = normalize$1(value);
	let prop = value;
	let Type = Info$1;
	if (normal in schema.normal) return schema.property[schema.normal[normal]];
	if (normal.length > 4 && normal.slice(0, 4) === "data" && valid$1.test(value)) {
		if (value.charAt(4) === "-") {
			const rest$1 = value.slice(5).replace(dash$1, camelcase$1);
			prop = "data" + rest$1.charAt(0).toUpperCase() + rest$1.slice(1);
		} else {
			const rest$1 = value.slice(4);
			if (!dash$1.test(rest$1)) {
				let dashes = rest$1.replace(cap$2, kebab$1);
				if (dashes.charAt(0) !== "-") dashes = "-" + dashes;
				value = "data" + dashes;
			}
		}
		Type = DefinedInfo$1;
	}
	return new Type(prop, value);
}
function kebab$1($0) {
	return "-" + $0.toLowerCase();
}
function camelcase$1($0) {
	return $0.charAt(1).toUpperCase();
}
const html$3 = merge$1([
	xml$1,
	xlink$1,
	xmlns$1,
	aria$1,
	html$5
], "html");
const svg$1 = merge$1([
	xml$1,
	xlink$1,
	xmlns$1,
	aria$1,
	svg$3
], "svg");
const search$2 = /[#.]/g;
function parseSelector$1(selector, defaultTagName) {
	const value = selector || "";
	const props = {};
	let start = 0;
	let previous$2;
	let tagName;
	while (start < value.length) {
		search$2.lastIndex = start;
		const match = search$2.exec(value);
		const subvalue = value.slice(start, match ? match.index : value.length);
		if (subvalue) {
			if (!previous$2) tagName = subvalue;
			else if (previous$2 === "#") props.id = subvalue;
			else if (Array.isArray(props.className)) props.className.push(subvalue);
			else props.className = [subvalue];
			start += subvalue.length;
		}
		if (match) {
			previous$2 = match[0];
			start++;
		}
	}
	return {
		type: "element",
		tagName: tagName || defaultTagName || "div",
		properties: props,
		children: []
	};
}
function parse$2(value) {
	const input = String(value || "").trim();
	return input ? input.split(/[ \t\n\r\f]+/g) : [];
}
function stringify$1(values) {
	return values.join(" ").trim();
}
function parse$1(value) {
	const tokens = [];
	const input = String(value || "");
	let index$1 = input.indexOf(",");
	let start = 0;
	let end = false;
	while (!end) {
		if (index$1 === -1) {
			index$1 = input.length;
			end = true;
		}
		const token = input.slice(start, index$1).trim();
		if (token || !end) tokens.push(token);
		start = index$1 + 1;
		index$1 = input.indexOf(",", start);
	}
	return tokens;
}
function stringify(values, options) {
	const settings = options || {};
	const input = values[values.length - 1] === "" ? [...values, ""] : values;
	return input.join((settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")).trim();
}
const buttonTypes = new Set([
	"menu",
	"submit",
	"reset",
	"button"
]);
const own$11 = {}.hasOwnProperty;
function core(schema, defaultTagName, caseSensitive) {
	const adjust = caseSensitive && createAdjustMap$1(caseSensitive);
	const h$2 = function(selector, properties$1, ...children) {
		let index$1 = -1;
		let node$1;
		if (selector === void 0 || selector === null) {
			node$1 = {
				type: "root",
				children: []
			};
			children.unshift(properties$1);
		} else {
			node$1 = parseSelector$1(selector, defaultTagName);
			node$1.tagName = node$1.tagName.toLowerCase();
			if (adjust && own$11.call(adjust, node$1.tagName)) node$1.tagName = adjust[node$1.tagName];
			if (isProperties(properties$1, node$1.tagName)) {
				let key;
				for (key in properties$1) if (own$11.call(properties$1, key)) addProperty$1(schema, node$1.properties, key, properties$1[key]);
			} else children.unshift(properties$1);
		}
		while (++index$1 < children.length) addChild$1(node$1.children, children[index$1]);
		if (node$1.type === "element" && node$1.tagName === "template") {
			node$1.content = {
				type: "root",
				children: node$1.children
			};
			node$1.children = [];
		}
		return node$1;
	};
	return h$2;
}
function isProperties(value, name$2) {
	if (value === null || value === void 0 || typeof value !== "object" || Array.isArray(value)) return false;
	if (name$2 === "input" || !value.type || typeof value.type !== "string") return true;
	if ("children" in value && Array.isArray(value.children)) return false;
	if (name$2 === "button") return buttonTypes.has(value.type.toLowerCase());
	return !("value" in value);
}
function addProperty$1(schema, properties$1, key, value) {
	const info = find$1(schema, key);
	let index$1 = -1;
	let result;
	if (value === void 0 || value === null) return;
	if (typeof value === "number") {
		if (Number.isNaN(value)) return;
		result = value;
	} else if (typeof value === "boolean") result = value;
	else if (typeof value === "string") if (info.spaceSeparated) result = parse$2(value);
	else if (info.commaSeparated) result = parse$1(value);
	else if (info.commaOrSpaceSeparated) result = parse$2(parse$1(value).join(" "));
	else result = parsePrimitive$1(info, info.property, value);
	else if (Array.isArray(value)) result = value.concat();
	else result = info.property === "style" ? style$1(value) : String(value);
	if (Array.isArray(result)) {
		const finalResult = [];
		while (++index$1 < result.length) finalResult[index$1] = parsePrimitive$1(info, info.property, result[index$1]);
		result = finalResult;
	}
	if (info.property === "className" && Array.isArray(properties$1.className)) result = properties$1.className.concat(result);
	properties$1[info.property] = result;
}
function addChild$1(nodes, value) {
	let index$1 = -1;
	if (value === void 0 || value === null) {} else if (typeof value === "string" || typeof value === "number") nodes.push({
		type: "text",
		value: String(value)
	});
	else if (Array.isArray(value)) while (++index$1 < value.length) addChild$1(nodes, value[index$1]);
	else if (typeof value === "object" && "type" in value) if (value.type === "root") addChild$1(nodes, value.children);
	else nodes.push(value);
	else throw new Error("Expected node, nodes, or string, got `" + value + "`");
}
function parsePrimitive$1(info, name$2, value) {
	if (typeof value === "string") {
		if (info.number && value && !Number.isNaN(Number(value))) return Number(value);
		if ((info.boolean || info.overloadedBoolean) && (value === "" || normalize$1(value) === normalize$1(name$2))) return true;
	}
	return value;
}
function style$1(value) {
	const result = [];
	let key;
	for (key in value) if (own$11.call(value, key)) result.push([key, value[key]].join(": "));
	return result.join("; ");
}
function createAdjustMap$1(values) {
	const result = {};
	let index$1 = -1;
	while (++index$1 < values.length) result[values[index$1].toLowerCase()] = values[index$1];
	return result;
}
const h$1 = core(html$3, "div");
const characterEntitiesLegacy = [
	"AElig",
	"AMP",
	"Aacute",
	"Acirc",
	"Agrave",
	"Aring",
	"Atilde",
	"Auml",
	"COPY",
	"Ccedil",
	"ETH",
	"Eacute",
	"Ecirc",
	"Egrave",
	"Euml",
	"GT",
	"Iacute",
	"Icirc",
	"Igrave",
	"Iuml",
	"LT",
	"Ntilde",
	"Oacute",
	"Ocirc",
	"Ograve",
	"Oslash",
	"Otilde",
	"Ouml",
	"QUOT",
	"REG",
	"THORN",
	"Uacute",
	"Ucirc",
	"Ugrave",
	"Uuml",
	"Yacute",
	"aacute",
	"acirc",
	"acute",
	"aelig",
	"agrave",
	"amp",
	"aring",
	"atilde",
	"auml",
	"brvbar",
	"ccedil",
	"cedil",
	"cent",
	"copy",
	"curren",
	"deg",
	"divide",
	"eacute",
	"ecirc",
	"egrave",
	"eth",
	"euml",
	"frac12",
	"frac14",
	"frac34",
	"gt",
	"iacute",
	"icirc",
	"iexcl",
	"igrave",
	"iquest",
	"iuml",
	"laquo",
	"lt",
	"macr",
	"micro",
	"middot",
	"nbsp",
	"not",
	"ntilde",
	"oacute",
	"ocirc",
	"ograve",
	"ordf",
	"ordm",
	"oslash",
	"otilde",
	"ouml",
	"para",
	"plusmn",
	"pound",
	"quot",
	"raquo",
	"reg",
	"sect",
	"shy",
	"sup1",
	"sup2",
	"sup3",
	"szlig",
	"thorn",
	"times",
	"uacute",
	"ucirc",
	"ugrave",
	"uml",
	"uuml",
	"yacute",
	"yen",
	"yuml"
];
const characterReferenceInvalid = {
	0: "�",
	128: "€",
	130: "‚",
	131: "ƒ",
	132: "„",
	133: "…",
	134: "†",
	135: "‡",
	136: "ˆ",
	137: "‰",
	138: "Š",
	139: "‹",
	140: "Œ",
	142: "Ž",
	145: "‘",
	146: "’",
	147: "“",
	148: "”",
	149: "•",
	150: "–",
	151: "—",
	152: "˜",
	153: "™",
	154: "š",
	155: "›",
	156: "œ",
	158: "ž",
	159: "Ÿ"
};
function isDecimal(character) {
	const code$3 = typeof character === "string" ? character.charCodeAt(0) : character;
	return code$3 >= 48 && code$3 <= 57;
}
function isHexadecimal(character) {
	const code$3 = typeof character === "string" ? character.charCodeAt(0) : character;
	return code$3 >= 97 && code$3 <= 102 || code$3 >= 65 && code$3 <= 70 || code$3 >= 48 && code$3 <= 57;
}
function isAlphabetical(character) {
	const code$3 = typeof character === "string" ? character.charCodeAt(0) : character;
	return code$3 >= 97 && code$3 <= 122 || code$3 >= 65 && code$3 <= 90;
}
function isAlphanumerical(character) {
	return isAlphabetical(character) || isDecimal(character);
}
const characterEntities = {
	AElig: "Æ",
	AMP: "&",
	Aacute: "Á",
	Abreve: "Ă",
	Acirc: "Â",
	Acy: "А",
	Afr: "𝔄",
	Agrave: "À",
	Alpha: "Α",
	Amacr: "Ā",
	And: "⩓",
	Aogon: "Ą",
	Aopf: "𝔸",
	ApplyFunction: "⁡",
	Aring: "Å",
	Ascr: "𝒜",
	Assign: "≔",
	Atilde: "Ã",
	Auml: "Ä",
	Backslash: "∖",
	Barv: "⫧",
	Barwed: "⌆",
	Bcy: "Б",
	Because: "∵",
	Bernoullis: "ℬ",
	Beta: "Β",
	Bfr: "𝔅",
	Bopf: "𝔹",
	Breve: "˘",
	Bscr: "ℬ",
	Bumpeq: "≎",
	CHcy: "Ч",
	COPY: "©",
	Cacute: "Ć",
	Cap: "⋒",
	CapitalDifferentialD: "ⅅ",
	Cayleys: "ℭ",
	Ccaron: "Č",
	Ccedil: "Ç",
	Ccirc: "Ĉ",
	Cconint: "∰",
	Cdot: "Ċ",
	Cedilla: "¸",
	CenterDot: "·",
	Cfr: "ℭ",
	Chi: "Χ",
	CircleDot: "⊙",
	CircleMinus: "⊖",
	CirclePlus: "⊕",
	CircleTimes: "⊗",
	ClockwiseContourIntegral: "∲",
	CloseCurlyDoubleQuote: "”",
	CloseCurlyQuote: "’",
	Colon: "∷",
	Colone: "⩴",
	Congruent: "≡",
	Conint: "∯",
	ContourIntegral: "∮",
	Copf: "ℂ",
	Coproduct: "∐",
	CounterClockwiseContourIntegral: "∳",
	Cross: "⨯",
	Cscr: "𝒞",
	Cup: "⋓",
	CupCap: "≍",
	DD: "ⅅ",
	DDotrahd: "⤑",
	DJcy: "Ђ",
	DScy: "Ѕ",
	DZcy: "Џ",
	Dagger: "‡",
	Darr: "↡",
	Dashv: "⫤",
	Dcaron: "Ď",
	Dcy: "Д",
	Del: "∇",
	Delta: "Δ",
	Dfr: "𝔇",
	DiacriticalAcute: "´",
	DiacriticalDot: "˙",
	DiacriticalDoubleAcute: "˝",
	DiacriticalGrave: "`",
	DiacriticalTilde: "˜",
	Diamond: "⋄",
	DifferentialD: "ⅆ",
	Dopf: "𝔻",
	Dot: "¨",
	DotDot: "⃜",
	DotEqual: "≐",
	DoubleContourIntegral: "∯",
	DoubleDot: "¨",
	DoubleDownArrow: "⇓",
	DoubleLeftArrow: "⇐",
	DoubleLeftRightArrow: "⇔",
	DoubleLeftTee: "⫤",
	DoubleLongLeftArrow: "⟸",
	DoubleLongLeftRightArrow: "⟺",
	DoubleLongRightArrow: "⟹",
	DoubleRightArrow: "⇒",
	DoubleRightTee: "⊨",
	DoubleUpArrow: "⇑",
	DoubleUpDownArrow: "⇕",
	DoubleVerticalBar: "∥",
	DownArrow: "↓",
	DownArrowBar: "⤓",
	DownArrowUpArrow: "⇵",
	DownBreve: "̑",
	DownLeftRightVector: "⥐",
	DownLeftTeeVector: "⥞",
	DownLeftVector: "↽",
	DownLeftVectorBar: "⥖",
	DownRightTeeVector: "⥟",
	DownRightVector: "⇁",
	DownRightVectorBar: "⥗",
	DownTee: "⊤",
	DownTeeArrow: "↧",
	Downarrow: "⇓",
	Dscr: "𝒟",
	Dstrok: "Đ",
	ENG: "Ŋ",
	ETH: "Ð",
	Eacute: "É",
	Ecaron: "Ě",
	Ecirc: "Ê",
	Ecy: "Э",
	Edot: "Ė",
	Efr: "𝔈",
	Egrave: "È",
	Element: "∈",
	Emacr: "Ē",
	EmptySmallSquare: "◻",
	EmptyVerySmallSquare: "▫",
	Eogon: "Ę",
	Eopf: "𝔼",
	Epsilon: "Ε",
	Equal: "⩵",
	EqualTilde: "≂",
	Equilibrium: "⇌",
	Escr: "ℰ",
	Esim: "⩳",
	Eta: "Η",
	Euml: "Ë",
	Exists: "∃",
	ExponentialE: "ⅇ",
	Fcy: "Ф",
	Ffr: "𝔉",
	FilledSmallSquare: "◼",
	FilledVerySmallSquare: "▪",
	Fopf: "𝔽",
	ForAll: "∀",
	Fouriertrf: "ℱ",
	Fscr: "ℱ",
	GJcy: "Ѓ",
	GT: ">",
	Gamma: "Γ",
	Gammad: "Ϝ",
	Gbreve: "Ğ",
	Gcedil: "Ģ",
	Gcirc: "Ĝ",
	Gcy: "Г",
	Gdot: "Ġ",
	Gfr: "𝔊",
	Gg: "⋙",
	Gopf: "𝔾",
	GreaterEqual: "≥",
	GreaterEqualLess: "⋛",
	GreaterFullEqual: "≧",
	GreaterGreater: "⪢",
	GreaterLess: "≷",
	GreaterSlantEqual: "⩾",
	GreaterTilde: "≳",
	Gscr: "𝒢",
	Gt: "≫",
	HARDcy: "Ъ",
	Hacek: "ˇ",
	Hat: "^",
	Hcirc: "Ĥ",
	Hfr: "ℌ",
	HilbertSpace: "ℋ",
	Hopf: "ℍ",
	HorizontalLine: "─",
	Hscr: "ℋ",
	Hstrok: "Ħ",
	HumpDownHump: "≎",
	HumpEqual: "≏",
	IEcy: "Е",
	IJlig: "Ĳ",
	IOcy: "Ё",
	Iacute: "Í",
	Icirc: "Î",
	Icy: "И",
	Idot: "İ",
	Ifr: "ℑ",
	Igrave: "Ì",
	Im: "ℑ",
	Imacr: "Ī",
	ImaginaryI: "ⅈ",
	Implies: "⇒",
	Int: "∬",
	Integral: "∫",
	Intersection: "⋂",
	InvisibleComma: "⁣",
	InvisibleTimes: "⁢",
	Iogon: "Į",
	Iopf: "𝕀",
	Iota: "Ι",
	Iscr: "ℐ",
	Itilde: "Ĩ",
	Iukcy: "І",
	Iuml: "Ï",
	Jcirc: "Ĵ",
	Jcy: "Й",
	Jfr: "𝔍",
	Jopf: "𝕁",
	Jscr: "𝒥",
	Jsercy: "Ј",
	Jukcy: "Є",
	KHcy: "Х",
	KJcy: "Ќ",
	Kappa: "Κ",
	Kcedil: "Ķ",
	Kcy: "К",
	Kfr: "𝔎",
	Kopf: "𝕂",
	Kscr: "𝒦",
	LJcy: "Љ",
	LT: "<",
	Lacute: "Ĺ",
	Lambda: "Λ",
	Lang: "⟪",
	Laplacetrf: "ℒ",
	Larr: "↞",
	Lcaron: "Ľ",
	Lcedil: "Ļ",
	Lcy: "Л",
	LeftAngleBracket: "⟨",
	LeftArrow: "←",
	LeftArrowBar: "⇤",
	LeftArrowRightArrow: "⇆",
	LeftCeiling: "⌈",
	LeftDoubleBracket: "⟦",
	LeftDownTeeVector: "⥡",
	LeftDownVector: "⇃",
	LeftDownVectorBar: "⥙",
	LeftFloor: "⌊",
	LeftRightArrow: "↔",
	LeftRightVector: "⥎",
	LeftTee: "⊣",
	LeftTeeArrow: "↤",
	LeftTeeVector: "⥚",
	LeftTriangle: "⊲",
	LeftTriangleBar: "⧏",
	LeftTriangleEqual: "⊴",
	LeftUpDownVector: "⥑",
	LeftUpTeeVector: "⥠",
	LeftUpVector: "↿",
	LeftUpVectorBar: "⥘",
	LeftVector: "↼",
	LeftVectorBar: "⥒",
	Leftarrow: "⇐",
	Leftrightarrow: "⇔",
	LessEqualGreater: "⋚",
	LessFullEqual: "≦",
	LessGreater: "≶",
	LessLess: "⪡",
	LessSlantEqual: "⩽",
	LessTilde: "≲",
	Lfr: "𝔏",
	Ll: "⋘",
	Lleftarrow: "⇚",
	Lmidot: "Ŀ",
	LongLeftArrow: "⟵",
	LongLeftRightArrow: "⟷",
	LongRightArrow: "⟶",
	Longleftarrow: "⟸",
	Longleftrightarrow: "⟺",
	Longrightarrow: "⟹",
	Lopf: "𝕃",
	LowerLeftArrow: "↙",
	LowerRightArrow: "↘",
	Lscr: "ℒ",
	Lsh: "↰",
	Lstrok: "Ł",
	Lt: "≪",
	Map: "⤅",
	Mcy: "М",
	MediumSpace: " ",
	Mellintrf: "ℳ",
	Mfr: "𝔐",
	MinusPlus: "∓",
	Mopf: "𝕄",
	Mscr: "ℳ",
	Mu: "Μ",
	NJcy: "Њ",
	Nacute: "Ń",
	Ncaron: "Ň",
	Ncedil: "Ņ",
	Ncy: "Н",
	NegativeMediumSpace: "​",
	NegativeThickSpace: "​",
	NegativeThinSpace: "​",
	NegativeVeryThinSpace: "​",
	NestedGreaterGreater: "≫",
	NestedLessLess: "≪",
	NewLine: "\n",
	Nfr: "𝔑",
	NoBreak: "⁠",
	NonBreakingSpace: "\xA0",
	Nopf: "ℕ",
	Not: "⫬",
	NotCongruent: "≢",
	NotCupCap: "≭",
	NotDoubleVerticalBar: "∦",
	NotElement: "∉",
	NotEqual: "≠",
	NotEqualTilde: "≂̸",
	NotExists: "∄",
	NotGreater: "≯",
	NotGreaterEqual: "≱",
	NotGreaterFullEqual: "≧̸",
	NotGreaterGreater: "≫̸",
	NotGreaterLess: "≹",
	NotGreaterSlantEqual: "⩾̸",
	NotGreaterTilde: "≵",
	NotHumpDownHump: "≎̸",
	NotHumpEqual: "≏̸",
	NotLeftTriangle: "⋪",
	NotLeftTriangleBar: "⧏̸",
	NotLeftTriangleEqual: "⋬",
	NotLess: "≮",
	NotLessEqual: "≰",
	NotLessGreater: "≸",
	NotLessLess: "≪̸",
	NotLessSlantEqual: "⩽̸",
	NotLessTilde: "≴",
	NotNestedGreaterGreater: "⪢̸",
	NotNestedLessLess: "⪡̸",
	NotPrecedes: "⊀",
	NotPrecedesEqual: "⪯̸",
	NotPrecedesSlantEqual: "⋠",
	NotReverseElement: "∌",
	NotRightTriangle: "⋫",
	NotRightTriangleBar: "⧐̸",
	NotRightTriangleEqual: "⋭",
	NotSquareSubset: "⊏̸",
	NotSquareSubsetEqual: "⋢",
	NotSquareSuperset: "⊐̸",
	NotSquareSupersetEqual: "⋣",
	NotSubset: "⊂⃒",
	NotSubsetEqual: "⊈",
	NotSucceeds: "⊁",
	NotSucceedsEqual: "⪰̸",
	NotSucceedsSlantEqual: "⋡",
	NotSucceedsTilde: "≿̸",
	NotSuperset: "⊃⃒",
	NotSupersetEqual: "⊉",
	NotTilde: "≁",
	NotTildeEqual: "≄",
	NotTildeFullEqual: "≇",
	NotTildeTilde: "≉",
	NotVerticalBar: "∤",
	Nscr: "𝒩",
	Ntilde: "Ñ",
	Nu: "Ν",
	OElig: "Œ",
	Oacute: "Ó",
	Ocirc: "Ô",
	Ocy: "О",
	Odblac: "Ő",
	Ofr: "𝔒",
	Ograve: "Ò",
	Omacr: "Ō",
	Omega: "Ω",
	Omicron: "Ο",
	Oopf: "𝕆",
	OpenCurlyDoubleQuote: "“",
	OpenCurlyQuote: "‘",
	Or: "⩔",
	Oscr: "𝒪",
	Oslash: "Ø",
	Otilde: "Õ",
	Otimes: "⨷",
	Ouml: "Ö",
	OverBar: "‾",
	OverBrace: "⏞",
	OverBracket: "⎴",
	OverParenthesis: "⏜",
	PartialD: "∂",
	Pcy: "П",
	Pfr: "𝔓",
	Phi: "Φ",
	Pi: "Π",
	PlusMinus: "±",
	Poincareplane: "ℌ",
	Popf: "ℙ",
	Pr: "⪻",
	Precedes: "≺",
	PrecedesEqual: "⪯",
	PrecedesSlantEqual: "≼",
	PrecedesTilde: "≾",
	Prime: "″",
	Product: "∏",
	Proportion: "∷",
	Proportional: "∝",
	Pscr: "𝒫",
	Psi: "Ψ",
	QUOT: "\"",
	Qfr: "𝔔",
	Qopf: "ℚ",
	Qscr: "𝒬",
	RBarr: "⤐",
	REG: "®",
	Racute: "Ŕ",
	Rang: "⟫",
	Rarr: "↠",
	Rarrtl: "⤖",
	Rcaron: "Ř",
	Rcedil: "Ŗ",
	Rcy: "Р",
	Re: "ℜ",
	ReverseElement: "∋",
	ReverseEquilibrium: "⇋",
	ReverseUpEquilibrium: "⥯",
	Rfr: "ℜ",
	Rho: "Ρ",
	RightAngleBracket: "⟩",
	RightArrow: "→",
	RightArrowBar: "⇥",
	RightArrowLeftArrow: "⇄",
	RightCeiling: "⌉",
	RightDoubleBracket: "⟧",
	RightDownTeeVector: "⥝",
	RightDownVector: "⇂",
	RightDownVectorBar: "⥕",
	RightFloor: "⌋",
	RightTee: "⊢",
	RightTeeArrow: "↦",
	RightTeeVector: "⥛",
	RightTriangle: "⊳",
	RightTriangleBar: "⧐",
	RightTriangleEqual: "⊵",
	RightUpDownVector: "⥏",
	RightUpTeeVector: "⥜",
	RightUpVector: "↾",
	RightUpVectorBar: "⥔",
	RightVector: "⇀",
	RightVectorBar: "⥓",
	Rightarrow: "⇒",
	Ropf: "ℝ",
	RoundImplies: "⥰",
	Rrightarrow: "⇛",
	Rscr: "ℛ",
	Rsh: "↱",
	RuleDelayed: "⧴",
	SHCHcy: "Щ",
	SHcy: "Ш",
	SOFTcy: "Ь",
	Sacute: "Ś",
	Sc: "⪼",
	Scaron: "Š",
	Scedil: "Ş",
	Scirc: "Ŝ",
	Scy: "С",
	Sfr: "𝔖",
	ShortDownArrow: "↓",
	ShortLeftArrow: "←",
	ShortRightArrow: "→",
	ShortUpArrow: "↑",
	Sigma: "Σ",
	SmallCircle: "∘",
	Sopf: "𝕊",
	Sqrt: "√",
	Square: "□",
	SquareIntersection: "⊓",
	SquareSubset: "⊏",
	SquareSubsetEqual: "⊑",
	SquareSuperset: "⊐",
	SquareSupersetEqual: "⊒",
	SquareUnion: "⊔",
	Sscr: "𝒮",
	Star: "⋆",
	Sub: "⋐",
	Subset: "⋐",
	SubsetEqual: "⊆",
	Succeeds: "≻",
	SucceedsEqual: "⪰",
	SucceedsSlantEqual: "≽",
	SucceedsTilde: "≿",
	SuchThat: "∋",
	Sum: "∑",
	Sup: "⋑",
	Superset: "⊃",
	SupersetEqual: "⊇",
	Supset: "⋑",
	THORN: "Þ",
	TRADE: "™",
	TSHcy: "Ћ",
	TScy: "Ц",
	Tab: "	",
	Tau: "Τ",
	Tcaron: "Ť",
	Tcedil: "Ţ",
	Tcy: "Т",
	Tfr: "𝔗",
	Therefore: "∴",
	Theta: "Θ",
	ThickSpace: "  ",
	ThinSpace: " ",
	Tilde: "∼",
	TildeEqual: "≃",
	TildeFullEqual: "≅",
	TildeTilde: "≈",
	Topf: "𝕋",
	TripleDot: "⃛",
	Tscr: "𝒯",
	Tstrok: "Ŧ",
	Uacute: "Ú",
	Uarr: "↟",
	Uarrocir: "⥉",
	Ubrcy: "Ў",
	Ubreve: "Ŭ",
	Ucirc: "Û",
	Ucy: "У",
	Udblac: "Ű",
	Ufr: "𝔘",
	Ugrave: "Ù",
	Umacr: "Ū",
	UnderBar: "_",
	UnderBrace: "⏟",
	UnderBracket: "⎵",
	UnderParenthesis: "⏝",
	Union: "⋃",
	UnionPlus: "⊎",
	Uogon: "Ų",
	Uopf: "𝕌",
	UpArrow: "↑",
	UpArrowBar: "⤒",
	UpArrowDownArrow: "⇅",
	UpDownArrow: "↕",
	UpEquilibrium: "⥮",
	UpTee: "⊥",
	UpTeeArrow: "↥",
	Uparrow: "⇑",
	Updownarrow: "⇕",
	UpperLeftArrow: "↖",
	UpperRightArrow: "↗",
	Upsi: "ϒ",
	Upsilon: "Υ",
	Uring: "Ů",
	Uscr: "𝒰",
	Utilde: "Ũ",
	Uuml: "Ü",
	VDash: "⊫",
	Vbar: "⫫",
	Vcy: "В",
	Vdash: "⊩",
	Vdashl: "⫦",
	Vee: "⋁",
	Verbar: "‖",
	Vert: "‖",
	VerticalBar: "∣",
	VerticalLine: "|",
	VerticalSeparator: "❘",
	VerticalTilde: "≀",
	VeryThinSpace: " ",
	Vfr: "𝔙",
	Vopf: "𝕍",
	Vscr: "𝒱",
	Vvdash: "⊪",
	Wcirc: "Ŵ",
	Wedge: "⋀",
	Wfr: "𝔚",
	Wopf: "𝕎",
	Wscr: "𝒲",
	Xfr: "𝔛",
	Xi: "Ξ",
	Xopf: "𝕏",
	Xscr: "𝒳",
	YAcy: "Я",
	YIcy: "Ї",
	YUcy: "Ю",
	Yacute: "Ý",
	Ycirc: "Ŷ",
	Ycy: "Ы",
	Yfr: "𝔜",
	Yopf: "𝕐",
	Yscr: "𝒴",
	Yuml: "Ÿ",
	ZHcy: "Ж",
	Zacute: "Ź",
	Zcaron: "Ž",
	Zcy: "З",
	Zdot: "Ż",
	ZeroWidthSpace: "​",
	Zeta: "Ζ",
	Zfr: "ℨ",
	Zopf: "ℤ",
	Zscr: "𝒵",
	aacute: "á",
	abreve: "ă",
	ac: "∾",
	acE: "∾̳",
	acd: "∿",
	acirc: "â",
	acute: "´",
	acy: "а",
	aelig: "æ",
	af: "⁡",
	afr: "𝔞",
	agrave: "à",
	alefsym: "ℵ",
	aleph: "ℵ",
	alpha: "α",
	amacr: "ā",
	amalg: "⨿",
	amp: "&",
	and: "∧",
	andand: "⩕",
	andd: "⩜",
	andslope: "⩘",
	andv: "⩚",
	ang: "∠",
	ange: "⦤",
	angle: "∠",
	angmsd: "∡",
	angmsdaa: "⦨",
	angmsdab: "⦩",
	angmsdac: "⦪",
	angmsdad: "⦫",
	angmsdae: "⦬",
	angmsdaf: "⦭",
	angmsdag: "⦮",
	angmsdah: "⦯",
	angrt: "∟",
	angrtvb: "⊾",
	angrtvbd: "⦝",
	angsph: "∢",
	angst: "Å",
	angzarr: "⍼",
	aogon: "ą",
	aopf: "𝕒",
	ap: "≈",
	apE: "⩰",
	apacir: "⩯",
	ape: "≊",
	apid: "≋",
	apos: "'",
	approx: "≈",
	approxeq: "≊",
	aring: "å",
	ascr: "𝒶",
	ast: "*",
	asymp: "≈",
	asympeq: "≍",
	atilde: "ã",
	auml: "ä",
	awconint: "∳",
	awint: "⨑",
	bNot: "⫭",
	backcong: "≌",
	backepsilon: "϶",
	backprime: "‵",
	backsim: "∽",
	backsimeq: "⋍",
	barvee: "⊽",
	barwed: "⌅",
	barwedge: "⌅",
	bbrk: "⎵",
	bbrktbrk: "⎶",
	bcong: "≌",
	bcy: "б",
	bdquo: "„",
	becaus: "∵",
	because: "∵",
	bemptyv: "⦰",
	bepsi: "϶",
	bernou: "ℬ",
	beta: "β",
	beth: "ℶ",
	between: "≬",
	bfr: "𝔟",
	bigcap: "⋂",
	bigcirc: "◯",
	bigcup: "⋃",
	bigodot: "⨀",
	bigoplus: "⨁",
	bigotimes: "⨂",
	bigsqcup: "⨆",
	bigstar: "★",
	bigtriangledown: "▽",
	bigtriangleup: "△",
	biguplus: "⨄",
	bigvee: "⋁",
	bigwedge: "⋀",
	bkarow: "⤍",
	blacklozenge: "⧫",
	blacksquare: "▪",
	blacktriangle: "▴",
	blacktriangledown: "▾",
	blacktriangleleft: "◂",
	blacktriangleright: "▸",
	blank: "␣",
	blk12: "▒",
	blk14: "░",
	blk34: "▓",
	block: "█",
	bne: "=⃥",
	bnequiv: "≡⃥",
	bnot: "⌐",
	bopf: "𝕓",
	bot: "⊥",
	bottom: "⊥",
	bowtie: "⋈",
	boxDL: "╗",
	boxDR: "╔",
	boxDl: "╖",
	boxDr: "╓",
	boxH: "═",
	boxHD: "╦",
	boxHU: "╩",
	boxHd: "╤",
	boxHu: "╧",
	boxUL: "╝",
	boxUR: "╚",
	boxUl: "╜",
	boxUr: "╙",
	boxV: "║",
	boxVH: "╬",
	boxVL: "╣",
	boxVR: "╠",
	boxVh: "╫",
	boxVl: "╢",
	boxVr: "╟",
	boxbox: "⧉",
	boxdL: "╕",
	boxdR: "╒",
	boxdl: "┐",
	boxdr: "┌",
	boxh: "─",
	boxhD: "╥",
	boxhU: "╨",
	boxhd: "┬",
	boxhu: "┴",
	boxminus: "⊟",
	boxplus: "⊞",
	boxtimes: "⊠",
	boxuL: "╛",
	boxuR: "╘",
	boxul: "┘",
	boxur: "└",
	boxv: "│",
	boxvH: "╪",
	boxvL: "╡",
	boxvR: "╞",
	boxvh: "┼",
	boxvl: "┤",
	boxvr: "├",
	bprime: "‵",
	breve: "˘",
	brvbar: "¦",
	bscr: "𝒷",
	bsemi: "⁏",
	bsim: "∽",
	bsime: "⋍",
	bsol: "\\",
	bsolb: "⧅",
	bsolhsub: "⟈",
	bull: "•",
	bullet: "•",
	bump: "≎",
	bumpE: "⪮",
	bumpe: "≏",
	bumpeq: "≏",
	cacute: "ć",
	cap: "∩",
	capand: "⩄",
	capbrcup: "⩉",
	capcap: "⩋",
	capcup: "⩇",
	capdot: "⩀",
	caps: "∩︀",
	caret: "⁁",
	caron: "ˇ",
	ccaps: "⩍",
	ccaron: "č",
	ccedil: "ç",
	ccirc: "ĉ",
	ccups: "⩌",
	ccupssm: "⩐",
	cdot: "ċ",
	cedil: "¸",
	cemptyv: "⦲",
	cent: "¢",
	centerdot: "·",
	cfr: "𝔠",
	chcy: "ч",
	check: "✓",
	checkmark: "✓",
	chi: "χ",
	cir: "○",
	cirE: "⧃",
	circ: "ˆ",
	circeq: "≗",
	circlearrowleft: "↺",
	circlearrowright: "↻",
	circledR: "®",
	circledS: "Ⓢ",
	circledast: "⊛",
	circledcirc: "⊚",
	circleddash: "⊝",
	cire: "≗",
	cirfnint: "⨐",
	cirmid: "⫯",
	cirscir: "⧂",
	clubs: "♣",
	clubsuit: "♣",
	colon: ":",
	colone: "≔",
	coloneq: "≔",
	comma: ",",
	commat: "@",
	comp: "∁",
	compfn: "∘",
	complement: "∁",
	complexes: "ℂ",
	cong: "≅",
	congdot: "⩭",
	conint: "∮",
	copf: "𝕔",
	coprod: "∐",
	copy: "©",
	copysr: "℗",
	crarr: "↵",
	cross: "✗",
	cscr: "𝒸",
	csub: "⫏",
	csube: "⫑",
	csup: "⫐",
	csupe: "⫒",
	ctdot: "⋯",
	cudarrl: "⤸",
	cudarrr: "⤵",
	cuepr: "⋞",
	cuesc: "⋟",
	cularr: "↶",
	cularrp: "⤽",
	cup: "∪",
	cupbrcap: "⩈",
	cupcap: "⩆",
	cupcup: "⩊",
	cupdot: "⊍",
	cupor: "⩅",
	cups: "∪︀",
	curarr: "↷",
	curarrm: "⤼",
	curlyeqprec: "⋞",
	curlyeqsucc: "⋟",
	curlyvee: "⋎",
	curlywedge: "⋏",
	curren: "¤",
	curvearrowleft: "↶",
	curvearrowright: "↷",
	cuvee: "⋎",
	cuwed: "⋏",
	cwconint: "∲",
	cwint: "∱",
	cylcty: "⌭",
	dArr: "⇓",
	dHar: "⥥",
	dagger: "†",
	daleth: "ℸ",
	darr: "↓",
	dash: "‐",
	dashv: "⊣",
	dbkarow: "⤏",
	dblac: "˝",
	dcaron: "ď",
	dcy: "д",
	dd: "ⅆ",
	ddagger: "‡",
	ddarr: "⇊",
	ddotseq: "⩷",
	deg: "°",
	delta: "δ",
	demptyv: "⦱",
	dfisht: "⥿",
	dfr: "𝔡",
	dharl: "⇃",
	dharr: "⇂",
	diam: "⋄",
	diamond: "⋄",
	diamondsuit: "♦",
	diams: "♦",
	die: "¨",
	digamma: "ϝ",
	disin: "⋲",
	div: "÷",
	divide: "÷",
	divideontimes: "⋇",
	divonx: "⋇",
	djcy: "ђ",
	dlcorn: "⌞",
	dlcrop: "⌍",
	dollar: "$",
	dopf: "𝕕",
	dot: "˙",
	doteq: "≐",
	doteqdot: "≑",
	dotminus: "∸",
	dotplus: "∔",
	dotsquare: "⊡",
	doublebarwedge: "⌆",
	downarrow: "↓",
	downdownarrows: "⇊",
	downharpoonleft: "⇃",
	downharpoonright: "⇂",
	drbkarow: "⤐",
	drcorn: "⌟",
	drcrop: "⌌",
	dscr: "𝒹",
	dscy: "ѕ",
	dsol: "⧶",
	dstrok: "đ",
	dtdot: "⋱",
	dtri: "▿",
	dtrif: "▾",
	duarr: "⇵",
	duhar: "⥯",
	dwangle: "⦦",
	dzcy: "џ",
	dzigrarr: "⟿",
	eDDot: "⩷",
	eDot: "≑",
	eacute: "é",
	easter: "⩮",
	ecaron: "ě",
	ecir: "≖",
	ecirc: "ê",
	ecolon: "≕",
	ecy: "э",
	edot: "ė",
	ee: "ⅇ",
	efDot: "≒",
	efr: "𝔢",
	eg: "⪚",
	egrave: "è",
	egs: "⪖",
	egsdot: "⪘",
	el: "⪙",
	elinters: "⏧",
	ell: "ℓ",
	els: "⪕",
	elsdot: "⪗",
	emacr: "ē",
	empty: "∅",
	emptyset: "∅",
	emptyv: "∅",
	emsp13: " ",
	emsp14: " ",
	emsp: " ",
	eng: "ŋ",
	ensp: " ",
	eogon: "ę",
	eopf: "𝕖",
	epar: "⋕",
	eparsl: "⧣",
	eplus: "⩱",
	epsi: "ε",
	epsilon: "ε",
	epsiv: "ϵ",
	eqcirc: "≖",
	eqcolon: "≕",
	eqsim: "≂",
	eqslantgtr: "⪖",
	eqslantless: "⪕",
	equals: "=",
	equest: "≟",
	equiv: "≡",
	equivDD: "⩸",
	eqvparsl: "⧥",
	erDot: "≓",
	erarr: "⥱",
	escr: "ℯ",
	esdot: "≐",
	esim: "≂",
	eta: "η",
	eth: "ð",
	euml: "ë",
	euro: "€",
	excl: "!",
	exist: "∃",
	expectation: "ℰ",
	exponentiale: "ⅇ",
	fallingdotseq: "≒",
	fcy: "ф",
	female: "♀",
	ffilig: "ﬃ",
	fflig: "ﬀ",
	ffllig: "ﬄ",
	ffr: "𝔣",
	filig: "ﬁ",
	fjlig: "fj",
	flat: "♭",
	fllig: "ﬂ",
	fltns: "▱",
	fnof: "ƒ",
	fopf: "𝕗",
	forall: "∀",
	fork: "⋔",
	forkv: "⫙",
	fpartint: "⨍",
	frac12: "½",
	frac13: "⅓",
	frac14: "¼",
	frac15: "⅕",
	frac16: "⅙",
	frac18: "⅛",
	frac23: "⅔",
	frac25: "⅖",
	frac34: "¾",
	frac35: "⅗",
	frac38: "⅜",
	frac45: "⅘",
	frac56: "⅚",
	frac58: "⅝",
	frac78: "⅞",
	frasl: "⁄",
	frown: "⌢",
	fscr: "𝒻",
	gE: "≧",
	gEl: "⪌",
	gacute: "ǵ",
	gamma: "γ",
	gammad: "ϝ",
	gap: "⪆",
	gbreve: "ğ",
	gcirc: "ĝ",
	gcy: "г",
	gdot: "ġ",
	ge: "≥",
	gel: "⋛",
	geq: "≥",
	geqq: "≧",
	geqslant: "⩾",
	ges: "⩾",
	gescc: "⪩",
	gesdot: "⪀",
	gesdoto: "⪂",
	gesdotol: "⪄",
	gesl: "⋛︀",
	gesles: "⪔",
	gfr: "𝔤",
	gg: "≫",
	ggg: "⋙",
	gimel: "ℷ",
	gjcy: "ѓ",
	gl: "≷",
	glE: "⪒",
	gla: "⪥",
	glj: "⪤",
	gnE: "≩",
	gnap: "⪊",
	gnapprox: "⪊",
	gne: "⪈",
	gneq: "⪈",
	gneqq: "≩",
	gnsim: "⋧",
	gopf: "𝕘",
	grave: "`",
	gscr: "ℊ",
	gsim: "≳",
	gsime: "⪎",
	gsiml: "⪐",
	gt: ">",
	gtcc: "⪧",
	gtcir: "⩺",
	gtdot: "⋗",
	gtlPar: "⦕",
	gtquest: "⩼",
	gtrapprox: "⪆",
	gtrarr: "⥸",
	gtrdot: "⋗",
	gtreqless: "⋛",
	gtreqqless: "⪌",
	gtrless: "≷",
	gtrsim: "≳",
	gvertneqq: "≩︀",
	gvnE: "≩︀",
	hArr: "⇔",
	hairsp: " ",
	half: "½",
	hamilt: "ℋ",
	hardcy: "ъ",
	harr: "↔",
	harrcir: "⥈",
	harrw: "↭",
	hbar: "ℏ",
	hcirc: "ĥ",
	hearts: "♥",
	heartsuit: "♥",
	hellip: "…",
	hercon: "⊹",
	hfr: "𝔥",
	hksearow: "⤥",
	hkswarow: "⤦",
	hoarr: "⇿",
	homtht: "∻",
	hookleftarrow: "↩",
	hookrightarrow: "↪",
	hopf: "𝕙",
	horbar: "―",
	hscr: "𝒽",
	hslash: "ℏ",
	hstrok: "ħ",
	hybull: "⁃",
	hyphen: "‐",
	iacute: "í",
	ic: "⁣",
	icirc: "î",
	icy: "и",
	iecy: "е",
	iexcl: "¡",
	iff: "⇔",
	ifr: "𝔦",
	igrave: "ì",
	ii: "ⅈ",
	iiiint: "⨌",
	iiint: "∭",
	iinfin: "⧜",
	iiota: "℩",
	ijlig: "ĳ",
	imacr: "ī",
	image: "ℑ",
	imagline: "ℐ",
	imagpart: "ℑ",
	imath: "ı",
	imof: "⊷",
	imped: "Ƶ",
	in: "∈",
	incare: "℅",
	infin: "∞",
	infintie: "⧝",
	inodot: "ı",
	int: "∫",
	intcal: "⊺",
	integers: "ℤ",
	intercal: "⊺",
	intlarhk: "⨗",
	intprod: "⨼",
	iocy: "ё",
	iogon: "į",
	iopf: "𝕚",
	iota: "ι",
	iprod: "⨼",
	iquest: "¿",
	iscr: "𝒾",
	isin: "∈",
	isinE: "⋹",
	isindot: "⋵",
	isins: "⋴",
	isinsv: "⋳",
	isinv: "∈",
	it: "⁢",
	itilde: "ĩ",
	iukcy: "і",
	iuml: "ï",
	jcirc: "ĵ",
	jcy: "й",
	jfr: "𝔧",
	jmath: "ȷ",
	jopf: "𝕛",
	jscr: "𝒿",
	jsercy: "ј",
	jukcy: "є",
	kappa: "κ",
	kappav: "ϰ",
	kcedil: "ķ",
	kcy: "к",
	kfr: "𝔨",
	kgreen: "ĸ",
	khcy: "х",
	kjcy: "ќ",
	kopf: "𝕜",
	kscr: "𝓀",
	lAarr: "⇚",
	lArr: "⇐",
	lAtail: "⤛",
	lBarr: "⤎",
	lE: "≦",
	lEg: "⪋",
	lHar: "⥢",
	lacute: "ĺ",
	laemptyv: "⦴",
	lagran: "ℒ",
	lambda: "λ",
	lang: "⟨",
	langd: "⦑",
	langle: "⟨",
	lap: "⪅",
	laquo: "«",
	larr: "←",
	larrb: "⇤",
	larrbfs: "⤟",
	larrfs: "⤝",
	larrhk: "↩",
	larrlp: "↫",
	larrpl: "⤹",
	larrsim: "⥳",
	larrtl: "↢",
	lat: "⪫",
	latail: "⤙",
	late: "⪭",
	lates: "⪭︀",
	lbarr: "⤌",
	lbbrk: "❲",
	lbrace: "{",
	lbrack: "[",
	lbrke: "⦋",
	lbrksld: "⦏",
	lbrkslu: "⦍",
	lcaron: "ľ",
	lcedil: "ļ",
	lceil: "⌈",
	lcub: "{",
	lcy: "л",
	ldca: "⤶",
	ldquo: "“",
	ldquor: "„",
	ldrdhar: "⥧",
	ldrushar: "⥋",
	ldsh: "↲",
	le: "≤",
	leftarrow: "←",
	leftarrowtail: "↢",
	leftharpoondown: "↽",
	leftharpoonup: "↼",
	leftleftarrows: "⇇",
	leftrightarrow: "↔",
	leftrightarrows: "⇆",
	leftrightharpoons: "⇋",
	leftrightsquigarrow: "↭",
	leftthreetimes: "⋋",
	leg: "⋚",
	leq: "≤",
	leqq: "≦",
	leqslant: "⩽",
	les: "⩽",
	lescc: "⪨",
	lesdot: "⩿",
	lesdoto: "⪁",
	lesdotor: "⪃",
	lesg: "⋚︀",
	lesges: "⪓",
	lessapprox: "⪅",
	lessdot: "⋖",
	lesseqgtr: "⋚",
	lesseqqgtr: "⪋",
	lessgtr: "≶",
	lesssim: "≲",
	lfisht: "⥼",
	lfloor: "⌊",
	lfr: "𝔩",
	lg: "≶",
	lgE: "⪑",
	lhard: "↽",
	lharu: "↼",
	lharul: "⥪",
	lhblk: "▄",
	ljcy: "љ",
	ll: "≪",
	llarr: "⇇",
	llcorner: "⌞",
	llhard: "⥫",
	lltri: "◺",
	lmidot: "ŀ",
	lmoust: "⎰",
	lmoustache: "⎰",
	lnE: "≨",
	lnap: "⪉",
	lnapprox: "⪉",
	lne: "⪇",
	lneq: "⪇",
	lneqq: "≨",
	lnsim: "⋦",
	loang: "⟬",
	loarr: "⇽",
	lobrk: "⟦",
	longleftarrow: "⟵",
	longleftrightarrow: "⟷",
	longmapsto: "⟼",
	longrightarrow: "⟶",
	looparrowleft: "↫",
	looparrowright: "↬",
	lopar: "⦅",
	lopf: "𝕝",
	loplus: "⨭",
	lotimes: "⨴",
	lowast: "∗",
	lowbar: "_",
	loz: "◊",
	lozenge: "◊",
	lozf: "⧫",
	lpar: "(",
	lparlt: "⦓",
	lrarr: "⇆",
	lrcorner: "⌟",
	lrhar: "⇋",
	lrhard: "⥭",
	lrm: "‎",
	lrtri: "⊿",
	lsaquo: "‹",
	lscr: "𝓁",
	lsh: "↰",
	lsim: "≲",
	lsime: "⪍",
	lsimg: "⪏",
	lsqb: "[",
	lsquo: "‘",
	lsquor: "‚",
	lstrok: "ł",
	lt: "<",
	ltcc: "⪦",
	ltcir: "⩹",
	ltdot: "⋖",
	lthree: "⋋",
	ltimes: "⋉",
	ltlarr: "⥶",
	ltquest: "⩻",
	ltrPar: "⦖",
	ltri: "◃",
	ltrie: "⊴",
	ltrif: "◂",
	lurdshar: "⥊",
	luruhar: "⥦",
	lvertneqq: "≨︀",
	lvnE: "≨︀",
	mDDot: "∺",
	macr: "¯",
	male: "♂",
	malt: "✠",
	maltese: "✠",
	map: "↦",
	mapsto: "↦",
	mapstodown: "↧",
	mapstoleft: "↤",
	mapstoup: "↥",
	marker: "▮",
	mcomma: "⨩",
	mcy: "м",
	mdash: "—",
	measuredangle: "∡",
	mfr: "𝔪",
	mho: "℧",
	micro: "µ",
	mid: "∣",
	midast: "*",
	midcir: "⫰",
	middot: "·",
	minus: "−",
	minusb: "⊟",
	minusd: "∸",
	minusdu: "⨪",
	mlcp: "⫛",
	mldr: "…",
	mnplus: "∓",
	models: "⊧",
	mopf: "𝕞",
	mp: "∓",
	mscr: "𝓂",
	mstpos: "∾",
	mu: "μ",
	multimap: "⊸",
	mumap: "⊸",
	nGg: "⋙̸",
	nGt: "≫⃒",
	nGtv: "≫̸",
	nLeftarrow: "⇍",
	nLeftrightarrow: "⇎",
	nLl: "⋘̸",
	nLt: "≪⃒",
	nLtv: "≪̸",
	nRightarrow: "⇏",
	nVDash: "⊯",
	nVdash: "⊮",
	nabla: "∇",
	nacute: "ń",
	nang: "∠⃒",
	nap: "≉",
	napE: "⩰̸",
	napid: "≋̸",
	napos: "ŉ",
	napprox: "≉",
	natur: "♮",
	natural: "♮",
	naturals: "ℕ",
	nbsp: "\xA0",
	nbump: "≎̸",
	nbumpe: "≏̸",
	ncap: "⩃",
	ncaron: "ň",
	ncedil: "ņ",
	ncong: "≇",
	ncongdot: "⩭̸",
	ncup: "⩂",
	ncy: "н",
	ndash: "–",
	ne: "≠",
	neArr: "⇗",
	nearhk: "⤤",
	nearr: "↗",
	nearrow: "↗",
	nedot: "≐̸",
	nequiv: "≢",
	nesear: "⤨",
	nesim: "≂̸",
	nexist: "∄",
	nexists: "∄",
	nfr: "𝔫",
	ngE: "≧̸",
	nge: "≱",
	ngeq: "≱",
	ngeqq: "≧̸",
	ngeqslant: "⩾̸",
	nges: "⩾̸",
	ngsim: "≵",
	ngt: "≯",
	ngtr: "≯",
	nhArr: "⇎",
	nharr: "↮",
	nhpar: "⫲",
	ni: "∋",
	nis: "⋼",
	nisd: "⋺",
	niv: "∋",
	njcy: "њ",
	nlArr: "⇍",
	nlE: "≦̸",
	nlarr: "↚",
	nldr: "‥",
	nle: "≰",
	nleftarrow: "↚",
	nleftrightarrow: "↮",
	nleq: "≰",
	nleqq: "≦̸",
	nleqslant: "⩽̸",
	nles: "⩽̸",
	nless: "≮",
	nlsim: "≴",
	nlt: "≮",
	nltri: "⋪",
	nltrie: "⋬",
	nmid: "∤",
	nopf: "𝕟",
	not: "¬",
	notin: "∉",
	notinE: "⋹̸",
	notindot: "⋵̸",
	notinva: "∉",
	notinvb: "⋷",
	notinvc: "⋶",
	notni: "∌",
	notniva: "∌",
	notnivb: "⋾",
	notnivc: "⋽",
	npar: "∦",
	nparallel: "∦",
	nparsl: "⫽⃥",
	npart: "∂̸",
	npolint: "⨔",
	npr: "⊀",
	nprcue: "⋠",
	npre: "⪯̸",
	nprec: "⊀",
	npreceq: "⪯̸",
	nrArr: "⇏",
	nrarr: "↛",
	nrarrc: "⤳̸",
	nrarrw: "↝̸",
	nrightarrow: "↛",
	nrtri: "⋫",
	nrtrie: "⋭",
	nsc: "⊁",
	nsccue: "⋡",
	nsce: "⪰̸",
	nscr: "𝓃",
	nshortmid: "∤",
	nshortparallel: "∦",
	nsim: "≁",
	nsime: "≄",
	nsimeq: "≄",
	nsmid: "∤",
	nspar: "∦",
	nsqsube: "⋢",
	nsqsupe: "⋣",
	nsub: "⊄",
	nsubE: "⫅̸",
	nsube: "⊈",
	nsubset: "⊂⃒",
	nsubseteq: "⊈",
	nsubseteqq: "⫅̸",
	nsucc: "⊁",
	nsucceq: "⪰̸",
	nsup: "⊅",
	nsupE: "⫆̸",
	nsupe: "⊉",
	nsupset: "⊃⃒",
	nsupseteq: "⊉",
	nsupseteqq: "⫆̸",
	ntgl: "≹",
	ntilde: "ñ",
	ntlg: "≸",
	ntriangleleft: "⋪",
	ntrianglelefteq: "⋬",
	ntriangleright: "⋫",
	ntrianglerighteq: "⋭",
	nu: "ν",
	num: "#",
	numero: "№",
	numsp: " ",
	nvDash: "⊭",
	nvHarr: "⤄",
	nvap: "≍⃒",
	nvdash: "⊬",
	nvge: "≥⃒",
	nvgt: ">⃒",
	nvinfin: "⧞",
	nvlArr: "⤂",
	nvle: "≤⃒",
	nvlt: "<⃒",
	nvltrie: "⊴⃒",
	nvrArr: "⤃",
	nvrtrie: "⊵⃒",
	nvsim: "∼⃒",
	nwArr: "⇖",
	nwarhk: "⤣",
	nwarr: "↖",
	nwarrow: "↖",
	nwnear: "⤧",
	oS: "Ⓢ",
	oacute: "ó",
	oast: "⊛",
	ocir: "⊚",
	ocirc: "ô",
	ocy: "о",
	odash: "⊝",
	odblac: "ő",
	odiv: "⨸",
	odot: "⊙",
	odsold: "⦼",
	oelig: "œ",
	ofcir: "⦿",
	ofr: "𝔬",
	ogon: "˛",
	ograve: "ò",
	ogt: "⧁",
	ohbar: "⦵",
	ohm: "Ω",
	oint: "∮",
	olarr: "↺",
	olcir: "⦾",
	olcross: "⦻",
	oline: "‾",
	olt: "⧀",
	omacr: "ō",
	omega: "ω",
	omicron: "ο",
	omid: "⦶",
	ominus: "⊖",
	oopf: "𝕠",
	opar: "⦷",
	operp: "⦹",
	oplus: "⊕",
	or: "∨",
	orarr: "↻",
	ord: "⩝",
	order: "ℴ",
	orderof: "ℴ",
	ordf: "ª",
	ordm: "º",
	origof: "⊶",
	oror: "⩖",
	orslope: "⩗",
	orv: "⩛",
	oscr: "ℴ",
	oslash: "ø",
	osol: "⊘",
	otilde: "õ",
	otimes: "⊗",
	otimesas: "⨶",
	ouml: "ö",
	ovbar: "⌽",
	par: "∥",
	para: "¶",
	parallel: "∥",
	parsim: "⫳",
	parsl: "⫽",
	part: "∂",
	pcy: "п",
	percnt: "%",
	period: ".",
	permil: "‰",
	perp: "⊥",
	pertenk: "‱",
	pfr: "𝔭",
	phi: "φ",
	phiv: "ϕ",
	phmmat: "ℳ",
	phone: "☎",
	pi: "π",
	pitchfork: "⋔",
	piv: "ϖ",
	planck: "ℏ",
	planckh: "ℎ",
	plankv: "ℏ",
	plus: "+",
	plusacir: "⨣",
	plusb: "⊞",
	pluscir: "⨢",
	plusdo: "∔",
	plusdu: "⨥",
	pluse: "⩲",
	plusmn: "±",
	plussim: "⨦",
	plustwo: "⨧",
	pm: "±",
	pointint: "⨕",
	popf: "𝕡",
	pound: "£",
	pr: "≺",
	prE: "⪳",
	prap: "⪷",
	prcue: "≼",
	pre: "⪯",
	prec: "≺",
	precapprox: "⪷",
	preccurlyeq: "≼",
	preceq: "⪯",
	precnapprox: "⪹",
	precneqq: "⪵",
	precnsim: "⋨",
	precsim: "≾",
	prime: "′",
	primes: "ℙ",
	prnE: "⪵",
	prnap: "⪹",
	prnsim: "⋨",
	prod: "∏",
	profalar: "⌮",
	profline: "⌒",
	profsurf: "⌓",
	prop: "∝",
	propto: "∝",
	prsim: "≾",
	prurel: "⊰",
	pscr: "𝓅",
	psi: "ψ",
	puncsp: " ",
	qfr: "𝔮",
	qint: "⨌",
	qopf: "𝕢",
	qprime: "⁗",
	qscr: "𝓆",
	quaternions: "ℍ",
	quatint: "⨖",
	quest: "?",
	questeq: "≟",
	quot: "\"",
	rAarr: "⇛",
	rArr: "⇒",
	rAtail: "⤜",
	rBarr: "⤏",
	rHar: "⥤",
	race: "∽̱",
	racute: "ŕ",
	radic: "√",
	raemptyv: "⦳",
	rang: "⟩",
	rangd: "⦒",
	range: "⦥",
	rangle: "⟩",
	raquo: "»",
	rarr: "→",
	rarrap: "⥵",
	rarrb: "⇥",
	rarrbfs: "⤠",
	rarrc: "⤳",
	rarrfs: "⤞",
	rarrhk: "↪",
	rarrlp: "↬",
	rarrpl: "⥅",
	rarrsim: "⥴",
	rarrtl: "↣",
	rarrw: "↝",
	ratail: "⤚",
	ratio: "∶",
	rationals: "ℚ",
	rbarr: "⤍",
	rbbrk: "❳",
	rbrace: "}",
	rbrack: "]",
	rbrke: "⦌",
	rbrksld: "⦎",
	rbrkslu: "⦐",
	rcaron: "ř",
	rcedil: "ŗ",
	rceil: "⌉",
	rcub: "}",
	rcy: "р",
	rdca: "⤷",
	rdldhar: "⥩",
	rdquo: "”",
	rdquor: "”",
	rdsh: "↳",
	real: "ℜ",
	realine: "ℛ",
	realpart: "ℜ",
	reals: "ℝ",
	rect: "▭",
	reg: "®",
	rfisht: "⥽",
	rfloor: "⌋",
	rfr: "𝔯",
	rhard: "⇁",
	rharu: "⇀",
	rharul: "⥬",
	rho: "ρ",
	rhov: "ϱ",
	rightarrow: "→",
	rightarrowtail: "↣",
	rightharpoondown: "⇁",
	rightharpoonup: "⇀",
	rightleftarrows: "⇄",
	rightleftharpoons: "⇌",
	rightrightarrows: "⇉",
	rightsquigarrow: "↝",
	rightthreetimes: "⋌",
	ring: "˚",
	risingdotseq: "≓",
	rlarr: "⇄",
	rlhar: "⇌",
	rlm: "‏",
	rmoust: "⎱",
	rmoustache: "⎱",
	rnmid: "⫮",
	roang: "⟭",
	roarr: "⇾",
	robrk: "⟧",
	ropar: "⦆",
	ropf: "𝕣",
	roplus: "⨮",
	rotimes: "⨵",
	rpar: ")",
	rpargt: "⦔",
	rppolint: "⨒",
	rrarr: "⇉",
	rsaquo: "›",
	rscr: "𝓇",
	rsh: "↱",
	rsqb: "]",
	rsquo: "’",
	rsquor: "’",
	rthree: "⋌",
	rtimes: "⋊",
	rtri: "▹",
	rtrie: "⊵",
	rtrif: "▸",
	rtriltri: "⧎",
	ruluhar: "⥨",
	rx: "℞",
	sacute: "ś",
	sbquo: "‚",
	sc: "≻",
	scE: "⪴",
	scap: "⪸",
	scaron: "š",
	sccue: "≽",
	sce: "⪰",
	scedil: "ş",
	scirc: "ŝ",
	scnE: "⪶",
	scnap: "⪺",
	scnsim: "⋩",
	scpolint: "⨓",
	scsim: "≿",
	scy: "с",
	sdot: "⋅",
	sdotb: "⊡",
	sdote: "⩦",
	seArr: "⇘",
	searhk: "⤥",
	searr: "↘",
	searrow: "↘",
	sect: "§",
	semi: ";",
	seswar: "⤩",
	setminus: "∖",
	setmn: "∖",
	sext: "✶",
	sfr: "𝔰",
	sfrown: "⌢",
	sharp: "♯",
	shchcy: "щ",
	shcy: "ш",
	shortmid: "∣",
	shortparallel: "∥",
	shy: "­",
	sigma: "σ",
	sigmaf: "ς",
	sigmav: "ς",
	sim: "∼",
	simdot: "⩪",
	sime: "≃",
	simeq: "≃",
	simg: "⪞",
	simgE: "⪠",
	siml: "⪝",
	simlE: "⪟",
	simne: "≆",
	simplus: "⨤",
	simrarr: "⥲",
	slarr: "←",
	smallsetminus: "∖",
	smashp: "⨳",
	smeparsl: "⧤",
	smid: "∣",
	smile: "⌣",
	smt: "⪪",
	smte: "⪬",
	smtes: "⪬︀",
	softcy: "ь",
	sol: "/",
	solb: "⧄",
	solbar: "⌿",
	sopf: "𝕤",
	spades: "♠",
	spadesuit: "♠",
	spar: "∥",
	sqcap: "⊓",
	sqcaps: "⊓︀",
	sqcup: "⊔",
	sqcups: "⊔︀",
	sqsub: "⊏",
	sqsube: "⊑",
	sqsubset: "⊏",
	sqsubseteq: "⊑",
	sqsup: "⊐",
	sqsupe: "⊒",
	sqsupset: "⊐",
	sqsupseteq: "⊒",
	squ: "□",
	square: "□",
	squarf: "▪",
	squf: "▪",
	srarr: "→",
	sscr: "𝓈",
	ssetmn: "∖",
	ssmile: "⌣",
	sstarf: "⋆",
	star: "☆",
	starf: "★",
	straightepsilon: "ϵ",
	straightphi: "ϕ",
	strns: "¯",
	sub: "⊂",
	subE: "⫅",
	subdot: "⪽",
	sube: "⊆",
	subedot: "⫃",
	submult: "⫁",
	subnE: "⫋",
	subne: "⊊",
	subplus: "⪿",
	subrarr: "⥹",
	subset: "⊂",
	subseteq: "⊆",
	subseteqq: "⫅",
	subsetneq: "⊊",
	subsetneqq: "⫋",
	subsim: "⫇",
	subsub: "⫕",
	subsup: "⫓",
	succ: "≻",
	succapprox: "⪸",
	succcurlyeq: "≽",
	succeq: "⪰",
	succnapprox: "⪺",
	succneqq: "⪶",
	succnsim: "⋩",
	succsim: "≿",
	sum: "∑",
	sung: "♪",
	sup1: "¹",
	sup2: "²",
	sup3: "³",
	sup: "⊃",
	supE: "⫆",
	supdot: "⪾",
	supdsub: "⫘",
	supe: "⊇",
	supedot: "⫄",
	suphsol: "⟉",
	suphsub: "⫗",
	suplarr: "⥻",
	supmult: "⫂",
	supnE: "⫌",
	supne: "⊋",
	supplus: "⫀",
	supset: "⊃",
	supseteq: "⊇",
	supseteqq: "⫆",
	supsetneq: "⊋",
	supsetneqq: "⫌",
	supsim: "⫈",
	supsub: "⫔",
	supsup: "⫖",
	swArr: "⇙",
	swarhk: "⤦",
	swarr: "↙",
	swarrow: "↙",
	swnwar: "⤪",
	szlig: "ß",
	target: "⌖",
	tau: "τ",
	tbrk: "⎴",
	tcaron: "ť",
	tcedil: "ţ",
	tcy: "т",
	tdot: "⃛",
	telrec: "⌕",
	tfr: "𝔱",
	there4: "∴",
	therefore: "∴",
	theta: "θ",
	thetasym: "ϑ",
	thetav: "ϑ",
	thickapprox: "≈",
	thicksim: "∼",
	thinsp: " ",
	thkap: "≈",
	thksim: "∼",
	thorn: "þ",
	tilde: "˜",
	times: "×",
	timesb: "⊠",
	timesbar: "⨱",
	timesd: "⨰",
	tint: "∭",
	toea: "⤨",
	top: "⊤",
	topbot: "⌶",
	topcir: "⫱",
	topf: "𝕥",
	topfork: "⫚",
	tosa: "⤩",
	tprime: "‴",
	trade: "™",
	triangle: "▵",
	triangledown: "▿",
	triangleleft: "◃",
	trianglelefteq: "⊴",
	triangleq: "≜",
	triangleright: "▹",
	trianglerighteq: "⊵",
	tridot: "◬",
	trie: "≜",
	triminus: "⨺",
	triplus: "⨹",
	trisb: "⧍",
	tritime: "⨻",
	trpezium: "⏢",
	tscr: "𝓉",
	tscy: "ц",
	tshcy: "ћ",
	tstrok: "ŧ",
	twixt: "≬",
	twoheadleftarrow: "↞",
	twoheadrightarrow: "↠",
	uArr: "⇑",
	uHar: "⥣",
	uacute: "ú",
	uarr: "↑",
	ubrcy: "ў",
	ubreve: "ŭ",
	ucirc: "û",
	ucy: "у",
	udarr: "⇅",
	udblac: "ű",
	udhar: "⥮",
	ufisht: "⥾",
	ufr: "𝔲",
	ugrave: "ù",
	uharl: "↿",
	uharr: "↾",
	uhblk: "▀",
	ulcorn: "⌜",
	ulcorner: "⌜",
	ulcrop: "⌏",
	ultri: "◸",
	umacr: "ū",
	uml: "¨",
	uogon: "ų",
	uopf: "𝕦",
	uparrow: "↑",
	updownarrow: "↕",
	upharpoonleft: "↿",
	upharpoonright: "↾",
	uplus: "⊎",
	upsi: "υ",
	upsih: "ϒ",
	upsilon: "υ",
	upuparrows: "⇈",
	urcorn: "⌝",
	urcorner: "⌝",
	urcrop: "⌎",
	uring: "ů",
	urtri: "◹",
	uscr: "𝓊",
	utdot: "⋰",
	utilde: "ũ",
	utri: "▵",
	utrif: "▴",
	uuarr: "⇈",
	uuml: "ü",
	uwangle: "⦧",
	vArr: "⇕",
	vBar: "⫨",
	vBarv: "⫩",
	vDash: "⊨",
	vangrt: "⦜",
	varepsilon: "ϵ",
	varkappa: "ϰ",
	varnothing: "∅",
	varphi: "ϕ",
	varpi: "ϖ",
	varpropto: "∝",
	varr: "↕",
	varrho: "ϱ",
	varsigma: "ς",
	varsubsetneq: "⊊︀",
	varsubsetneqq: "⫋︀",
	varsupsetneq: "⊋︀",
	varsupsetneqq: "⫌︀",
	vartheta: "ϑ",
	vartriangleleft: "⊲",
	vartriangleright: "⊳",
	vcy: "в",
	vdash: "⊢",
	vee: "∨",
	veebar: "⊻",
	veeeq: "≚",
	vellip: "⋮",
	verbar: "|",
	vert: "|",
	vfr: "𝔳",
	vltri: "⊲",
	vnsub: "⊂⃒",
	vnsup: "⊃⃒",
	vopf: "𝕧",
	vprop: "∝",
	vrtri: "⊳",
	vscr: "𝓋",
	vsubnE: "⫋︀",
	vsubne: "⊊︀",
	vsupnE: "⫌︀",
	vsupne: "⊋︀",
	vzigzag: "⦚",
	wcirc: "ŵ",
	wedbar: "⩟",
	wedge: "∧",
	wedgeq: "≙",
	weierp: "℘",
	wfr: "𝔴",
	wopf: "𝕨",
	wp: "℘",
	wr: "≀",
	wreath: "≀",
	wscr: "𝓌",
	xcap: "⋂",
	xcirc: "◯",
	xcup: "⋃",
	xdtri: "▽",
	xfr: "𝔵",
	xhArr: "⟺",
	xharr: "⟷",
	xi: "ξ",
	xlArr: "⟸",
	xlarr: "⟵",
	xmap: "⟼",
	xnis: "⋻",
	xodot: "⨀",
	xopf: "𝕩",
	xoplus: "⨁",
	xotime: "⨂",
	xrArr: "⟹",
	xrarr: "⟶",
	xscr: "𝓍",
	xsqcup: "⨆",
	xuplus: "⨄",
	xutri: "△",
	xvee: "⋁",
	xwedge: "⋀",
	yacute: "ý",
	yacy: "я",
	ycirc: "ŷ",
	ycy: "ы",
	yen: "¥",
	yfr: "𝔶",
	yicy: "ї",
	yopf: "𝕪",
	yscr: "𝓎",
	yucy: "ю",
	yuml: "ÿ",
	zacute: "ź",
	zcaron: "ž",
	zcy: "з",
	zdot: "ż",
	zeetrf: "ℨ",
	zeta: "ζ",
	zfr: "𝔷",
	zhcy: "ж",
	zigrarr: "⇝",
	zopf: "𝕫",
	zscr: "𝓏",
	zwj: "‍",
	zwnj: "‌"
};
const own$10 = {}.hasOwnProperty;
function decodeNamedCharacterReference(value) {
	return own$10.call(characterEntities, value) ? characterEntities[value] : false;
}
const messages = [
	"",
	"Named character references must be terminated by a semicolon",
	"Numeric character references must be terminated by a semicolon",
	"Named character references cannot be empty",
	"Numeric character references cannot be empty",
	"Named character references must be known",
	"Numeric character references cannot be disallowed",
	"Numeric character references cannot be outside the permissible Unicode range"
];
function parseEntities(value, options) {
	const settings = options || {};
	const additional = typeof settings.additional === "string" ? settings.additional.charCodeAt(0) : settings.additional;
	const result = [];
	let index$1 = 0;
	let lines = -1;
	let queue = "";
	let point$4;
	let indent$1;
	if (settings.position) if ("start" in settings.position || "indent" in settings.position) {
		indent$1 = settings.position.indent;
		point$4 = settings.position.start;
	} else point$4 = settings.position;
	let line = (point$4 ? point$4.line : 0) || 1;
	let column = (point$4 ? point$4.column : 0) || 1;
	let previous$2 = now();
	let character;
	index$1--;
	while (++index$1 <= value.length) {
		if (character === 10) column = (indent$1 ? indent$1[lines] : 0) || 1;
		character = value.charCodeAt(index$1);
		if (character === 38) {
			const following = value.charCodeAt(index$1 + 1);
			if (following === 9 || following === 10 || following === 12 || following === 32 || following === 38 || following === 60 || Number.isNaN(following) || additional && following === additional) {
				queue += String.fromCharCode(character);
				column++;
				continue;
			}
			const start = index$1 + 1;
			let begin = start;
			let end = start;
			let type;
			if (following === 35) {
				end = ++begin;
				const following$1 = value.charCodeAt(end);
				if (following$1 === 88 || following$1 === 120) {
					type = "hexadecimal";
					end = ++begin;
				} else type = "decimal";
			} else type = "named";
			let characterReferenceCharacters = "";
			let characterReference$1 = "";
			let characters = "";
			const test$1 = type === "named" ? isAlphanumerical : type === "decimal" ? isDecimal : isHexadecimal;
			end--;
			while (++end <= value.length) {
				const following$1 = value.charCodeAt(end);
				if (!test$1(following$1)) break;
				characters += String.fromCharCode(following$1);
				if (type === "named" && characterEntitiesLegacy.includes(characters)) {
					characterReferenceCharacters = characters;
					characterReference$1 = decodeNamedCharacterReference(characters);
				}
			}
			let terminated = value.charCodeAt(end) === 59;
			if (terminated) {
				end++;
				const namedReference = type === "named" ? decodeNamedCharacterReference(characters) : false;
				if (namedReference) {
					characterReferenceCharacters = characters;
					characterReference$1 = namedReference;
				}
			}
			let diff$1 = 1 + end - start;
			let reference = "";
			if (!terminated && settings.nonTerminated === false) {} else if (!characters) {
				if (type !== "named") warning(4, diff$1);
			} else if (type === "named") {
				if (terminated && !characterReference$1) warning(5, 1);
				else {
					if (characterReferenceCharacters !== characters) {
						end = begin + characterReferenceCharacters.length;
						diff$1 = 1 + end - begin;
						terminated = false;
					}
					if (!terminated) {
						const reason$1 = characterReferenceCharacters ? 1 : 3;
						if (settings.attribute) {
							const following$1 = value.charCodeAt(end);
							if (following$1 === 61) {
								warning(reason$1, diff$1);
								characterReference$1 = "";
							} else if (isAlphanumerical(following$1)) characterReference$1 = "";
							else warning(reason$1, diff$1);
						} else warning(reason$1, diff$1);
					}
				}
				reference = characterReference$1;
			} else {
				if (!terminated) warning(2, diff$1);
				let referenceCode = Number.parseInt(characters, type === "hexadecimal" ? 16 : 10);
				if (prohibited(referenceCode)) {
					warning(7, diff$1);
					reference = String.fromCharCode(65533);
				} else if (referenceCode in characterReferenceInvalid) {
					warning(6, diff$1);
					reference = characterReferenceInvalid[referenceCode];
				} else {
					let output = "";
					if (disallowed(referenceCode)) warning(6, diff$1);
					if (referenceCode > 65535) {
						referenceCode -= 65536;
						output += String.fromCharCode(referenceCode >>> 10 | 55296);
						referenceCode = 56320 | referenceCode & 1023;
					}
					reference = output + String.fromCharCode(referenceCode);
				}
			}
			if (reference) {
				flush();
				previous$2 = now();
				index$1 = end - 1;
				column += end - start + 1;
				result.push(reference);
				const next$1 = now();
				next$1.offset++;
				if (settings.reference) settings.reference.call(settings.referenceContext || void 0, reference, {
					start: previous$2,
					end: next$1
				}, value.slice(start - 1, end));
				previous$2 = next$1;
			} else {
				characters = value.slice(start - 1, end);
				queue += characters;
				column += characters.length;
				index$1 = end - 1;
			}
		} else {
			if (character === 10) {
				line++;
				lines++;
				column = 0;
			}
			if (Number.isNaN(character)) flush();
			else {
				queue += String.fromCharCode(character);
				column++;
			}
		}
	}
	return result.join("");
	function now() {
		return {
			line,
			column,
			offset: index$1 + ((point$4 ? point$4.offset : 0) || 0)
		};
	}
	function warning(code$3, offset) {
		let position$3;
		if (settings.warning) {
			position$3 = now();
			position$3.column += offset;
			position$3.offset += offset;
			settings.warning.call(settings.warningContext || void 0, messages[code$3], position$3, code$3);
		}
	}
	function flush() {
		if (queue) {
			result.push(queue);
			if (settings.text) settings.text.call(settings.textContext || void 0, queue, {
				start: previous$2,
				end: now()
			});
			queue = "";
		}
	}
}
function prohibited(code$3) {
	return code$3 >= 55296 && code$3 <= 57343 || code$3 > 1114111;
}
function disallowed(code$3) {
	return code$3 >= 1 && code$3 <= 8 || code$3 === 11 || code$3 >= 13 && code$3 <= 31 || code$3 >= 127 && code$3 <= 159 || code$3 >= 64976 && code$3 <= 65007 || (code$3 & 65535) === 65535 || (code$3 & 65535) === 65534;
}
var uniqueId = 0;
var plainTextGrammar = {};
var _ = {
	util: {
		type: function(o) {
			return Object.prototype.toString.call(o).slice(8, -1);
		},
		objId: function(obj) {
			if (!obj["__id"]) Object.defineProperty(obj, "__id", { value: ++uniqueId });
			return obj["__id"];
		},
		clone: function deepClone(o, visited) {
			visited = visited || {};
			var clone$1;
			var id$1;
			switch (_.util.type(o)) {
				case "Object":
					id$1 = _.util.objId(o);
					if (visited[id$1]) return visited[id$1];
					clone$1 = {};
					visited[id$1] = clone$1;
					for (var key in o) if (o.hasOwnProperty(key)) clone$1[key] = deepClone(o[key], visited);
					return clone$1;
				case "Array":
					id$1 = _.util.objId(o);
					if (visited[id$1]) return visited[id$1];
					clone$1 = [];
					visited[id$1] = clone$1;
					o.forEach(function(v$1, i) {
						clone$1[i] = deepClone(v$1, visited);
					});
					return clone$1;
				default: return o;
			}
		}
	},
	languages: {
		plain: plainTextGrammar,
		plaintext: plainTextGrammar,
		text: plainTextGrammar,
		txt: plainTextGrammar,
		extend: function(id$1, redef) {
			var lang$1 = _.util.clone(_.languages[id$1]);
			for (var key in redef) lang$1[key] = redef[key];
			return lang$1;
		},
		insertBefore: function(inside, before, insert, root$6) {
			root$6 = root$6 || _.languages;
			var grammar = root$6[inside];
			var ret = {};
			for (var token in grammar) if (grammar.hasOwnProperty(token)) {
				if (token == before) {
					for (var newToken in insert) if (insert.hasOwnProperty(newToken)) ret[newToken] = insert[newToken];
				}
				if (!insert.hasOwnProperty(token)) ret[token] = grammar[token];
			}
			var old = root$6[inside];
			root$6[inside] = ret;
			_.languages.DFS(_.languages, function(key, value) {
				if (value === old && key != inside) this[key] = ret;
			});
			return ret;
		},
		DFS: function DFS(o, callback, type, visited) {
			visited = visited || {};
			var objId = _.util.objId;
			for (var i in o) if (o.hasOwnProperty(i)) {
				callback.call(o, i, o[i], type || i);
				var property = o[i];
				var propertyType = _.util.type(property);
				if (propertyType === "Object" && !visited[objId(property)]) {
					visited[objId(property)] = true;
					DFS(property, callback, null, visited);
				} else if (propertyType === "Array" && !visited[objId(property)]) {
					visited[objId(property)] = true;
					DFS(property, callback, i, visited);
				}
			}
		}
	},
	plugins: {},
	highlight: function(text$8, grammar, language) {
		var env$1 = {
			code: text$8,
			grammar,
			language
		};
		_.hooks.run("before-tokenize", env$1);
		if (!env$1.grammar) throw new Error("The language \"" + env$1.language + "\" has no grammar.");
		env$1.tokens = _.tokenize(env$1.code, env$1.grammar);
		_.hooks.run("after-tokenize", env$1);
		return Token.stringify(_.util.encode(env$1.tokens), env$1.language);
	},
	tokenize: function(text$8, grammar) {
		var rest$1 = grammar.rest;
		if (rest$1) {
			for (var token in rest$1) grammar[token] = rest$1[token];
			delete grammar.rest;
		}
		var tokenList = new LinkedList();
		addAfter(tokenList, tokenList.head, text$8);
		matchGrammar(text$8, tokenList, grammar, tokenList.head, 0);
		return toArray(tokenList);
	},
	hooks: {
		all: {},
		add: function(name$2, callback) {
			var hooks = _.hooks.all;
			hooks[name$2] = hooks[name$2] || [];
			hooks[name$2].push(callback);
		},
		run: function(name$2, env$1) {
			var callbacks = _.hooks.all[name$2];
			if (!callbacks || !callbacks.length) return;
			for (var i = 0, callback; callback = callbacks[i++];) callback(env$1);
		}
	},
	Token
};
function Token(type, content$2, alias$1, matchedStr) {
	this.type = type;
	this.content = content$2;
	this.alias = alias$1;
	this.length = (matchedStr || "").length | 0;
}
function matchPattern(pattern, pos, text$8, lookbehind) {
	pattern.lastIndex = pos;
	var match = pattern.exec(text$8);
	if (match && lookbehind && match[1]) {
		var lookbehindLength = match[1].length;
		match.index += lookbehindLength;
		match[0] = match[0].slice(lookbehindLength);
	}
	return match;
}
function matchGrammar(text$8, tokenList, grammar, startNode, startPos, rematch) {
	for (var token in grammar) {
		if (!grammar.hasOwnProperty(token) || !grammar[token]) continue;
		var patterns = grammar[token];
		patterns = Array.isArray(patterns) ? patterns : [patterns];
		for (var j$1 = 0; j$1 < patterns.length; ++j$1) {
			if (rematch && rematch.cause == token + "," + j$1) return;
			var patternObj = patterns[j$1];
			var inside = patternObj.inside;
			var lookbehind = !!patternObj.lookbehind;
			var greedy = !!patternObj.greedy;
			var alias$1 = patternObj.alias;
			if (greedy && !patternObj.pattern.global) {
				var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
				patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
			}
			var pattern = patternObj.pattern || patternObj;
			for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
				if (rematch && pos >= rematch.reach) break;
				var str = currentNode.value;
				if (tokenList.length > text$8.length) return;
				if (str instanceof Token) continue;
				var removeCount = 1;
				var match;
				if (greedy) {
					match = matchPattern(pattern, pos, text$8, lookbehind);
					if (!match || match.index >= text$8.length) break;
					var from = match.index;
					var to = match.index + match[0].length;
					var p$1 = pos;
					p$1 += currentNode.value.length;
					while (from >= p$1) {
						currentNode = currentNode.next;
						p$1 += currentNode.value.length;
					}
					p$1 -= currentNode.value.length;
					pos = p$1;
					if (currentNode.value instanceof Token) continue;
					for (var k = currentNode; k !== tokenList.tail && (p$1 < to || typeof k.value === "string"); k = k.next) {
						removeCount++;
						p$1 += k.value.length;
					}
					removeCount--;
					str = text$8.slice(pos, p$1);
					match.index -= pos;
				} else {
					match = matchPattern(pattern, 0, str, lookbehind);
					if (!match) continue;
				}
				var from = match.index;
				var matchStr = match[0];
				var before = str.slice(0, from);
				var after = str.slice(from + matchStr.length);
				var reach = pos + str.length;
				if (rematch && reach > rematch.reach) rematch.reach = reach;
				var removeFrom = currentNode.prev;
				if (before) {
					removeFrom = addAfter(tokenList, removeFrom, before);
					pos += before.length;
				}
				removeRange(tokenList, removeFrom, removeCount);
				var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias$1, matchStr);
				currentNode = addAfter(tokenList, removeFrom, wrapped);
				if (after) addAfter(tokenList, currentNode, after);
				if (removeCount > 1) {
					var nestedRematch = {
						cause: token + "," + j$1,
						reach
					};
					matchGrammar(text$8, tokenList, grammar, currentNode.prev, pos, nestedRematch);
					if (rematch && nestedRematch.reach > rematch.reach) rematch.reach = nestedRematch.reach;
				}
			}
		}
	}
}
function LinkedList() {
	var head = {
		value: null,
		prev: null,
		next: null
	};
	var tail = {
		value: null,
		prev: head,
		next: null
	};
	head.next = tail;
	this.head = head;
	this.tail = tail;
	this.length = 0;
}
function addAfter(list$3, node$1, value) {
	var next$1 = node$1.next;
	var newNode = {
		value,
		prev: node$1,
		next: next$1
	};
	node$1.next = newNode;
	next$1.prev = newNode;
	list$3.length++;
	return newNode;
}
function removeRange(list$3, node$1, count$1) {
	var next$1 = node$1.next;
	for (var i = 0; i < count$1 && next$1 !== list$3.tail; i++) next$1 = next$1.next;
	node$1.next = next$1;
	next$1.prev = node$1;
	list$3.length -= i;
}
function toArray(list$3) {
	var array = [];
	var node$1 = list$3.head.next;
	while (node$1 !== list$3.tail) {
		array.push(node$1.value);
		node$1 = node$1.next;
	}
	return array;
}
const Prism = _;
const own$9 = {}.hasOwnProperty;
function Refractor() {}
Refractor.prototype = Prism;
const refractor = new Refractor();
refractor.highlight = highlight;
refractor.register = register;
refractor.alias = alias;
refractor.registered = registered;
refractor.listLanguages = listLanguages;
refractor.util.encode = encode;
refractor.Token.stringify = stringify$2;
function highlight(value, language) {
	if (typeof value !== "string") throw new TypeError("Expected `string` for `value`, got `" + value + "`");
	let grammar;
	let name$2;
	if (language && typeof language === "object") grammar = language;
	else {
		name$2 = language;
		if (typeof name$2 !== "string") throw new TypeError("Expected `string` for `name`, got `" + name$2 + "`");
		if (own$9.call(refractor.languages, name$2)) grammar = refractor.languages[name$2];
		else throw new Error("Unknown language: `" + name$2 + "` is not registered");
	}
	return {
		type: "root",
		children: Prism.highlight.call(refractor, value, grammar, name$2)
	};
}
function register(syntax) {
	if (typeof syntax !== "function" || !syntax.displayName) throw new Error("Expected `function` for `syntax`, got `" + syntax + "`");
	if (!own$9.call(refractor.languages, syntax.displayName)) syntax(refractor);
}
function alias(language, alias$1) {
	const languages = refractor.languages;
	let map$2 = {};
	if (typeof language === "string") {
		if (alias$1) map$2[language] = alias$1;
	} else map$2 = language;
	let key;
	for (key in map$2) if (own$9.call(map$2, key)) {
		const value = map$2[key];
		const list$3 = typeof value === "string" ? [value] : value;
		let index$1 = -1;
		while (++index$1 < list$3.length) languages[list$3[index$1]] = languages[key];
	}
}
function registered(aliasOrLanguage) {
	if (typeof aliasOrLanguage !== "string") throw new TypeError("Expected `string` for `aliasOrLanguage`, got `" + aliasOrLanguage + "`");
	return own$9.call(refractor.languages, aliasOrLanguage);
}
function listLanguages() {
	const languages = refractor.languages;
	const list$3 = [];
	let language;
	for (language in languages) if (own$9.call(languages, language) && typeof languages[language] === "object") list$3.push(language);
	return list$3;
}
function stringify$2(value, language) {
	if (typeof value === "string") return {
		type: "text",
		value
	};
	if (Array.isArray(value)) {
		const result = [];
		let index$1 = -1;
		while (++index$1 < value.length) if (value[index$1] !== null && value[index$1] !== void 0 && value[index$1] !== "") result.push(stringify$2(value[index$1], language));
		return result;
	}
	const env$1 = {
		attributes: {},
		classes: ["token", value.type],
		content: stringify$2(value.content, language),
		language,
		tag: "span",
		type: value.type
	};
	if (value.alias) env$1.classes.push(...typeof value.alias === "string" ? [value.alias] : value.alias);
	refractor.hooks.run("wrap", env$1);
	return h$1(env$1.tag + "." + env$1.classes.join("."), attributes(env$1.attributes), env$1.content);
}
function encode(tokens) {
	return tokens;
}
function attributes(record) {
	let key;
	for (key in record) if (own$9.call(record, key)) record[key] = parseEntities(record[key]);
	return record;
}
refractor.register(clike);
refractor.register(c$1);
refractor.register(cpp);
refractor.register(arduino);
refractor.register(bash);
refractor.register(csharp);
refractor.register(markup);
refractor.register(css);
refractor.register(diff);
refractor.register(go);
refractor.register(ini);
refractor.register(java);
refractor.register(regex$1);
refractor.register(javascript);
refractor.register(json);
refractor.register(kotlin);
refractor.register(less);
refractor.register(lua);
refractor.register(makefile);
refractor.register(yaml);
refractor.register(markdown);
refractor.register(objectivec);
refractor.register(perl);
refractor.register(markupTemplating);
refractor.register(php);
refractor.register(python);
refractor.register(r);
refractor.register(ruby);
refractor.register(rust);
refractor.register(sass);
refractor.register(scss);
refractor.register(sql);
refractor.register(swift);
refractor.register(typescript);
refractor.register(basic);
refractor.register(vbnet);
abap.displayName = "abap";
abap.aliases = [];
function abap(Prism$1) {
	Prism$1.languages.abap = {
		comment: /^\*.*/m,
		string: /(`|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
		"string-template": {
			pattern: /([|}])(?:\\.|[^\\|{\r\n])*(?=[|{])/,
			lookbehind: true,
			alias: "string"
		},
		"eol-comment": {
			pattern: /(^|\s)".*/m,
			lookbehind: true,
			alias: "comment"
		},
		keyword: {
			pattern: /(\s|\.|^)(?:\*-INPUT|\?TO|ABAP-SOURCE|ABBREVIATED|ABS|ABSTRACT|ACCEPT|ACCEPTING|ACCESSPOLICY|ACCORDING|ACOS|ACTIVATION|ACTUAL|ADD|ADD-CORRESPONDING|ADJACENT|AFTER|ALIAS|ALIASES|ALIGN|ALL|ALLOCATE|ALPHA|ANALYSIS|ANALYZER|AND|ANY|APPEND|APPENDAGE|APPENDING|APPLICATION|ARCHIVE|AREA|ARITHMETIC|AS|ASCENDING|ASIN|ASPECT|ASSERT|ASSIGN|ASSIGNED|ASSIGNING|ASSOCIATION|ASYNCHRONOUS|AT|ATAN|ATTRIBUTES|AUTHORITY|AUTHORITY-CHECK|AVG|BACK|BACKGROUND|BACKUP|BACKWARD|BADI|BASE|BEFORE|BEGIN|BETWEEN|BIG|BINARY|BINDING|BIT|BIT-AND|BIT-NOT|BIT-OR|BIT-XOR|BLACK|BLANK|BLANKS|BLOB|BLOCK|BLOCKS|BLUE|BOUND|BOUNDARIES|BOUNDS|BOXED|BREAK-POINT|BT|BUFFER|BY|BYPASSING|BYTE|BYTE-CA|BYTE-CN|BYTE-CO|BYTE-CS|BYTE-NA|BYTE-NS|BYTE-ORDER|C|CA|CALL|CALLING|CASE|CAST|CASTING|CATCH|CEIL|CENTER|CENTERED|CHAIN|CHAIN-INPUT|CHAIN-REQUEST|CHANGE|CHANGING|CHANNELS|CHAR-TO-HEX|CHARACTER|CHARLEN|CHECK|CHECKBOX|CIRCULAR|CI_|CLASS|CLASS-CODING|CLASS-DATA|CLASS-EVENTS|CLASS-METHODS|CLASS-POOL|CLEANUP|CLEAR|CLIENT|CLOB|CLOCK|CLOSE|CN|CNT|CO|COALESCE|CODE|CODING|COLLECT|COLOR|COLUMN|COLUMNS|COL_BACKGROUND|COL_GROUP|COL_HEADING|COL_KEY|COL_NEGATIVE|COL_NORMAL|COL_POSITIVE|COL_TOTAL|COMMENT|COMMENTS|COMMIT|COMMON|COMMUNICATION|COMPARING|COMPONENT|COMPONENTS|COMPRESSION|COMPUTE|CONCAT|CONCATENATE|COND|CONDENSE|CONDITION|CONNECT|CONNECTION|CONSTANTS|CONTEXT|CONTEXTS|CONTINUE|CONTROL|CONTROLS|CONV|CONVERSION|CONVERT|COPIES|COPY|CORRESPONDING|COS|COSH|COUNT|COUNTRY|COVER|CP|CPI|CREATE|CREATING|CRITICAL|CS|CURRENCY|CURRENCY_CONVERSION|CURRENT|CURSOR|CURSOR-SELECTION|CUSTOMER|CUSTOMER-FUNCTION|DANGEROUS|DATA|DATABASE|DATAINFO|DATASET|DATE|DAYLIGHT|DBMAXLEN|DD\/MM\/YY|DD\/MM\/YYYY|DDMMYY|DEALLOCATE|DECIMALS|DECIMAL_SHIFT|DECLARATIONS|DEEP|DEFAULT|DEFERRED|DEFINE|DEFINING|DEFINITION|DELETE|DELETING|DEMAND|DEPARTMENT|DESCENDING|DESCRIBE|DESTINATION|DETAIL|DIALOG|DIRECTORY|DISCONNECT|DISPLAY|DISPLAY-MODE|DISTANCE|DISTINCT|DIV|DIVIDE|DIVIDE-CORRESPONDING|DIVISION|DO|DUMMY|DUPLICATE|DUPLICATES|DURATION|DURING|DYNAMIC|DYNPRO|E|EACH|EDIT|EDITOR-CALL|ELSE|ELSEIF|EMPTY|ENABLED|ENABLING|ENCODING|END|END-ENHANCEMENT-SECTION|END-LINES|END-OF-DEFINITION|END-OF-FILE|END-OF-PAGE|END-OF-SELECTION|ENDAT|ENDCASE|ENDCATCH|ENDCHAIN|ENDCLASS|ENDDO|ENDENHANCEMENT|ENDEXEC|ENDFOR|ENDFORM|ENDFUNCTION|ENDIAN|ENDIF|ENDING|ENDINTERFACE|ENDLOOP|ENDMETHOD|ENDMODULE|ENDON|ENDPROVIDE|ENDSELECT|ENDTRY|ENDWHILE|ENGINEERING|ENHANCEMENT|ENHANCEMENT-POINT|ENHANCEMENT-SECTION|ENHANCEMENTS|ENTRIES|ENTRY|ENVIRONMENT|EQ|EQUAL|EQUIV|ERRORMESSAGE|ERRORS|ESCAPE|ESCAPING|EVENT|EVENTS|EXACT|EXCEPT|EXCEPTION|EXCEPTION-TABLE|EXCEPTIONS|EXCLUDE|EXCLUDING|EXEC|EXECUTE|EXISTS|EXIT|EXIT-COMMAND|EXP|EXPAND|EXPANDING|EXPIRATION|EXPLICIT|EXPONENT|EXPORT|EXPORTING|EXTEND|EXTENDED|EXTENSION|EXTRACT|FAIL|FETCH|FIELD|FIELD-GROUPS|FIELD-SYMBOL|FIELD-SYMBOLS|FIELDS|FILE|FILTER|FILTER-TABLE|FILTERS|FINAL|FIND|FIRST|FIRST-LINE|FIXED-POINT|FKEQ|FKGE|FLOOR|FLUSH|FONT|FOR|FORM|FORMAT|FORWARD|FOUND|FRAC|FRAME|FRAMES|FREE|FRIENDS|FROM|FUNCTION|FUNCTION-POOL|FUNCTIONALITY|FURTHER|GAPS|GE|GENERATE|GET|GIVING|GKEQ|GKGE|GLOBAL|GRANT|GREATER|GREEN|GROUP|GROUPS|GT|HANDLE|HANDLER|HARMLESS|HASHED|HAVING|HDB|HEAD-LINES|HEADER|HEADERS|HEADING|HELP-ID|HELP-REQUEST|HIDE|HIGH|HINT|HOLD|HOTSPOT|I|ICON|ID|IDENTIFICATION|IDENTIFIER|IDS|IF|IGNORE|IGNORING|IMMEDIATELY|IMPLEMENTATION|IMPLEMENTATIONS|IMPLEMENTED|IMPLICIT|IMPORT|IMPORTING|IN|INACTIVE|INCL|INCLUDE|INCLUDES|INCLUDING|INCREMENT|INDEX|INDEX-LINE|INFOTYPES|INHERITING|INIT|INITIAL|INITIALIZATION|INNER|INOUT|INPUT|INSERT|INSTANCES|INTENSIFIED|INTERFACE|INTERFACE-POOL|INTERFACES|INTERNAL|INTERVALS|INTO|INVERSE|INVERTED-DATE|IS|ISO|ITERATOR|ITNO|JOB|JOIN|KEEP|KEEPING|KERNEL|KEY|KEYS|KEYWORDS|KIND|LANGUAGE|LAST|LATE|LAYOUT|LE|LEADING|LEAVE|LEFT|LEFT-JUSTIFIED|LEFTPLUS|LEFTSPACE|LEGACY|LENGTH|LESS|LET|LEVEL|LEVELS|LIKE|LINE|LINE-COUNT|LINE-SELECTION|LINE-SIZE|LINEFEED|LINES|LIST|LIST-PROCESSING|LISTBOX|LITTLE|LLANG|LOAD|LOAD-OF-PROGRAM|LOB|LOCAL|LOCALE|LOCATOR|LOG|LOG-POINT|LOG10|LOGFILE|LOGICAL|LONG|LOOP|LOW|LOWER|LPAD|LPI|LT|M|MAIL|MAIN|MAJOR-ID|MAPPING|MARGIN|MARK|MASK|MATCH|MATCHCODE|MAX|MAXIMUM|MEDIUM|MEMBERS|MEMORY|MESH|MESSAGE|MESSAGE-ID|MESSAGES|MESSAGING|METHOD|METHODS|MIN|MINIMUM|MINOR-ID|MM\/DD\/YY|MM\/DD\/YYYY|MMDDYY|MOD|MODE|MODIF|MODIFIER|MODIFY|MODULE|MOVE|MOVE-CORRESPONDING|MULTIPLY|MULTIPLY-CORRESPONDING|NA|NAME|NAMETAB|NATIVE|NB|NE|NESTED|NESTING|NEW|NEW-LINE|NEW-PAGE|NEW-SECTION|NEXT|NO|NO-DISPLAY|NO-EXTENSION|NO-GAP|NO-GAPS|NO-GROUPING|NO-HEADING|NO-SCROLLING|NO-SIGN|NO-TITLE|NO-TOPOFPAGE|NO-ZERO|NODE|NODES|NON-UNICODE|NON-UNIQUE|NOT|NP|NS|NULL|NUMBER|NUMOFCHAR|O|OBJECT|OBJECTS|OBLIGATORY|OCCURRENCE|OCCURRENCES|OCCURS|OF|OFF|OFFSET|OLE|ON|ONLY|OPEN|OPTION|OPTIONAL|OPTIONS|OR|ORDER|OTHER|OTHERS|OUT|OUTER|OUTPUT|OUTPUT-LENGTH|OVERFLOW|OVERLAY|PACK|PACKAGE|PAD|PADDING|PAGE|PAGES|PARAMETER|PARAMETER-TABLE|PARAMETERS|PART|PARTIALLY|PATTERN|PERCENTAGE|PERFORM|PERFORMING|PERSON|PF|PF-STATUS|PINK|PLACES|POOL|POSITION|POS_HIGH|POS_LOW|PRAGMAS|PRECOMPILED|PREFERRED|PRESERVING|PRIMARY|PRINT|PRINT-CONTROL|PRIORITY|PRIVATE|PROCEDURE|PROCESS|PROGRAM|PROPERTY|PROTECTED|PROVIDE|PUBLIC|PUSHBUTTON|PUT|QUEUE-ONLY|QUICKINFO|RADIOBUTTON|RAISE|RAISING|RANGE|RANGES|RAW|READ|READ-ONLY|READER|RECEIVE|RECEIVED|RECEIVER|RECEIVING|RED|REDEFINITION|REDUCE|REDUCED|REF|REFERENCE|REFRESH|REGEX|REJECT|REMOTE|RENAMING|REPLACE|REPLACEMENT|REPLACING|REPORT|REQUEST|REQUESTED|RESERVE|RESET|RESOLUTION|RESPECTING|RESPONSIBLE|RESULT|RESULTS|RESUMABLE|RESUME|RETRY|RETURN|RETURNCODE|RETURNING|RIGHT|RIGHT-JUSTIFIED|RIGHTPLUS|RIGHTSPACE|RISK|RMC_COMMUNICATION_FAILURE|RMC_INVALID_STATUS|RMC_SYSTEM_FAILURE|ROLE|ROLLBACK|ROUND|ROWS|RTTI|RUN|SAP|SAP-SPOOL|SAVING|SCALE_PRESERVING|SCALE_PRESERVING_SCIENTIFIC|SCAN|SCIENTIFIC|SCIENTIFIC_WITH_LEADING_ZERO|SCREEN|SCROLL|SCROLL-BOUNDARY|SCROLLING|SEARCH|SECONDARY|SECONDS|SECTION|SELECT|SELECT-OPTIONS|SELECTION|SELECTION-SCREEN|SELECTION-SET|SELECTION-SETS|SELECTION-TABLE|SELECTIONS|SELECTOR|SEND|SEPARATE|SEPARATED|SET|SHARED|SHIFT|SHORT|SHORTDUMP-ID|SIGN|SIGN_AS_POSTFIX|SIMPLE|SIN|SINGLE|SINH|SIZE|SKIP|SKIPPING|SMART|SOME|SORT|SORTABLE|SORTED|SOURCE|SPACE|SPECIFIED|SPLIT|SPOOL|SPOTS|SQL|SQLSCRIPT|SQRT|STABLE|STAMP|STANDARD|START-OF-SELECTION|STARTING|STATE|STATEMENT|STATEMENTS|STATIC|STATICS|STATUSINFO|STEP-LOOP|STOP|STRLEN|STRUCTURE|STRUCTURES|STYLE|SUBKEY|SUBMATCHES|SUBMIT|SUBROUTINE|SUBSCREEN|SUBSTRING|SUBTRACT|SUBTRACT-CORRESPONDING|SUFFIX|SUM|SUMMARY|SUMMING|SUPPLIED|SUPPLY|SUPPRESS|SWITCH|SWITCHSTATES|SYMBOL|SYNCPOINTS|SYNTAX|SYNTAX-CHECK|SYNTAX-TRACE|SYSTEM-CALL|SYSTEM-EXCEPTIONS|SYSTEM-EXIT|TAB|TABBED|TABLE|TABLES|TABLEVIEW|TABSTRIP|TAN|TANH|TARGET|TASK|TASKS|TEST|TESTING|TEXT|TEXTPOOL|THEN|THROW|TIME|TIMES|TIMESTAMP|TIMEZONE|TITLE|TITLE-LINES|TITLEBAR|TO|TOKENIZATION|TOKENS|TOP-LINES|TOP-OF-PAGE|TRACE-FILE|TRACE-TABLE|TRAILING|TRANSACTION|TRANSFER|TRANSFORMATION|TRANSLATE|TRANSPORTING|TRMAC|TRUNC|TRUNCATE|TRUNCATION|TRY|TYPE|TYPE-POOL|TYPE-POOLS|TYPES|ULINE|UNASSIGN|UNDER|UNICODE|UNION|UNIQUE|UNIT|UNIT_CONVERSION|UNIX|UNPACK|UNTIL|UNWIND|UP|UPDATE|UPPER|USER|USER-COMMAND|USING|UTF-8|VALID|VALUE|VALUE-REQUEST|VALUES|VARY|VARYING|VERIFICATION-MESSAGE|VERSION|VIA|VIEW|VISIBLE|WAIT|WARNING|WHEN|WHENEVER|WHERE|WHILE|WIDTH|WINDOW|WINDOWS|WITH|WITH-HEADING|WITH-TITLE|WITHOUT|WORD|WORK|WRITE|WRITER|X|XML|XOR|XSD|XSTRLEN|YELLOW|YES|YYMMDD|Z|ZERO|ZONE)(?![\w-])/i,
			lookbehind: true
		},
		number: /\b\d+\b/,
		operator: {
			pattern: /(\s)(?:\*\*?|<[=>]?|>=?|\?=|[-+\/=])(?=\s)/,
			lookbehind: true
		},
		"string-operator": {
			pattern: /(\s)&&?(?=\s)/,
			lookbehind: true,
			alias: "keyword"
		},
		"token-operator": [{
			pattern: /(\w)(?:->?|=>|[~|{}])(?=\w)/,
			lookbehind: true,
			alias: "punctuation"
		}, {
			pattern: /[|{}]/,
			alias: "punctuation"
		}],
		punctuation: /[,.:()]/
	};
}
abnf.displayName = "abnf";
abnf.aliases = [];
function abnf(Prism$1) {
	(function(Prism$2) {
		var coreRules = "(?:ALPHA|BIT|CHAR|CR|CRLF|CTL|DIGIT|DQUOTE|HEXDIG|HTAB|LF|LWSP|OCTET|SP|VCHAR|WSP)";
		Prism$2.languages.abnf = {
			comment: /;.*/,
			string: {
				pattern: /(?:%[is])?"[^"\n\r]*"/,
				greedy: true,
				inside: { punctuation: /^%[is]/ }
			},
			range: {
				pattern: /%(?:b[01]+-[01]+|d\d+-\d+|x[A-F\d]+-[A-F\d]+)/i,
				alias: "number"
			},
			terminal: {
				pattern: /%(?:b[01]+(?:\.[01]+)*|d\d+(?:\.\d+)*|x[A-F\d]+(?:\.[A-F\d]+)*)/i,
				alias: "number"
			},
			repetition: {
				pattern: /(^|[^\w-])(?:\d*\*\d*|\d+)/,
				lookbehind: true,
				alias: "operator"
			},
			definition: {
				pattern: /(^[ \t]*)(?:[a-z][\w-]*|<[^<>\r\n]*>)(?=\s*=)/m,
				lookbehind: true,
				alias: "keyword",
				inside: { punctuation: /<|>/ }
			},
			"core-rule": {
				pattern: RegExp("(?:(^|[^<\\w-])" + coreRules + "|<" + coreRules + ">)(?![\\w-])", "i"),
				lookbehind: true,
				alias: ["rule", "constant"],
				inside: { punctuation: /<|>/ }
			},
			rule: {
				pattern: /(^|[^<\w-])[a-z][\w-]*|<[^<>\r\n]*>/i,
				lookbehind: true,
				inside: { punctuation: /<|>/ }
			},
			operator: /=\/?|\//,
			punctuation: /[()\[\]]/
		};
	})(Prism$1);
}
actionscript.displayName = "actionscript";
actionscript.aliases = [];
function actionscript(Prism$1) {
	Prism$1.register(javascript);
	Prism$1.languages.actionscript = Prism$1.languages.extend("javascript", {
		keyword: /\b(?:as|break|case|catch|class|const|default|delete|do|dynamic|each|else|extends|final|finally|for|function|get|if|implements|import|in|include|instanceof|interface|internal|is|namespace|native|new|null|override|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|use|var|void|while|with)\b/,
		operator: /\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/
	});
	Prism$1.languages.actionscript["class-name"].alias = "function";
	delete Prism$1.languages.actionscript["parameter"];
	delete Prism$1.languages.actionscript["literal-property"];
	if (Prism$1.languages.markup) Prism$1.languages.insertBefore("actionscript", "string", { xml: {
		pattern: /(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/,
		lookbehind: true,
		inside: Prism$1.languages.markup
	} });
}
ada.displayName = "ada";
ada.aliases = [];
function ada(Prism$1) {
	Prism$1.languages.ada = {
		comment: /--.*/,
		string: /"(?:""|[^"\r\f\n])*"/,
		number: [{ pattern: /\b\d(?:_?\d)*#[\dA-F](?:_?[\dA-F])*(?:\.[\dA-F](?:_?[\dA-F])*)?#(?:E[+-]?\d(?:_?\d)*)?/i }, { pattern: /\b\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:E[+-]?\d(?:_?\d)*)?\b/i }],
		attribute: {
			pattern: /\b'\w+/,
			alias: "attr-name"
		},
		keyword: /\b(?:abort|abs|abstract|accept|access|aliased|all|and|array|at|begin|body|case|constant|declare|delay|delta|digits|do|else|elsif|end|entry|exception|exit|for|function|generic|goto|if|in|interface|is|limited|loop|mod|new|not|null|of|or|others|out|overriding|package|pragma|private|procedure|protected|raise|range|record|rem|renames|requeue|return|reverse|select|separate|some|subtype|synchronized|tagged|task|terminate|then|type|until|use|when|while|with|xor)\b/i,
		boolean: /\b(?:false|true)\b/i,
		operator: /<[=>]?|>=?|=>?|:=|\/=?|\*\*?|[&+-]/,
		punctuation: /\.\.?|[,;():]/,
		char: /'.'/,
		variable: /\b[a-z](?:\w)*\b/i
	};
}
agda.displayName = "agda";
agda.aliases = [];
function agda(Prism$1) {
	(function(Prism$2) {
		Prism$2.languages.agda = {
			comment: /\{-[\s\S]*?(?:-\}|$)|--.*/,
			string: {
				pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
				greedy: true
			},
			punctuation: /[(){}⦃⦄.;@]/,
			"class-name": {
				pattern: /((?:data|record) +)\S+/,
				lookbehind: true
			},
			function: {
				pattern: /(^[ \t]*)(?!\s)[^:\r\n]+(?=:)/m,
				lookbehind: true
			},
			operator: {
				pattern: /(^\s*|\s)(?:[=|:∀→λ\\?_]|->)(?=\s)/,
				lookbehind: true
			},
			keyword: /\b(?:Set|abstract|constructor|data|eta-equality|field|forall|hiding|import|in|inductive|infix|infixl|infixr|instance|let|macro|module|mutual|no-eta-equality|open|overlap|pattern|postulate|primitive|private|public|quote|quoteContext|quoteGoal|quoteTerm|record|renaming|rewrite|syntax|tactic|unquote|unquoteDecl|unquoteDef|using|variable|where|with)\b/
		};
	})(Prism$1);
}
al.displayName = "al";
al.aliases = [];
function al(Prism$1) {
	Prism$1.languages.al = {
		comment: /\/\/.*|\/\*[\s\S]*?\*\//,
		string: {
			pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
			greedy: true
		},
		function: {
			pattern: /(\b(?:event|procedure|trigger)\s+|(?:^|[^.])\.\s*)[a-z_]\w*(?=\s*\()/i,
			lookbehind: true
		},
		keyword: [/\b(?:array|asserterror|begin|break|case|do|downto|else|end|event|exit|for|foreach|function|if|implements|in|indataset|interface|internal|local|of|procedure|program|protected|repeat|runonclient|securityfiltering|suppressdispose|temporary|then|to|trigger|until|var|while|with|withevents)\b/i, /\b(?:action|actions|addafter|addbefore|addfirst|addlast|area|assembly|chartpart|codeunit|column|controladdin|cuegroup|customizes|dataitem|dataset|dotnet|elements|enum|enumextension|extends|field|fieldattribute|fieldelement|fieldgroup|fieldgroups|fields|filter|fixed|grid|group|key|keys|label|labels|layout|modify|moveafter|movebefore|movefirst|movelast|page|pagecustomization|pageextension|part|profile|query|repeater|report|requestpage|schema|separator|systempart|table|tableelement|tableextension|textattribute|textelement|type|usercontrol|value|xmlport)\b/i],
		number: /\b(?:0x[\da-f]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)(?:F|LL?|U(?:LL?)?)?\b/i,
		boolean: /\b(?:false|true)\b/i,
		variable: /\b(?:Curr(?:FieldNo|Page|Report)|x?Rec|RequestOptionsPage)\b/,
		"class-name": /\b(?:automation|biginteger|bigtext|blob|boolean|byte|char|clienttype|code|completiontriggererrorlevel|connectiontype|database|dataclassification|datascope|date|dateformula|datetime|decimal|defaultlayout|dialog|dictionary|dotnetassembly|dotnettypedeclaration|duration|errorinfo|errortype|executioncontext|executionmode|fieldclass|fieldref|fieldtype|file|filterpagebuilder|guid|httpclient|httpcontent|httpheaders|httprequestmessage|httpresponsemessage|instream|integer|joker|jsonarray|jsonobject|jsontoken|jsonvalue|keyref|list|moduledependencyinfo|moduleinfo|none|notification|notificationscope|objecttype|option|outstream|pageresult|record|recordid|recordref|reportformat|securityfilter|sessionsettings|tableconnectiontype|tablefilter|testaction|testfield|testfilterfield|testpage|testpermissions|testrequestpage|text|textbuilder|textconst|textencoding|time|transactionmodel|transactiontype|variant|verbosity|version|view|views|webserviceactioncontext|webserviceactionresultcode|xmlattribute|xmlattributecollection|xmlcdata|xmlcomment|xmldeclaration|xmldocument|xmldocumenttype|xmlelement|xmlnamespacemanager|xmlnametable|xmlnode|xmlnodelist|xmlprocessinginstruction|xmlreadoptions|xmltext|xmlwriteoptions)\b/i,
		operator: /\.\.|:[=:]|[-+*/]=?|<>|[<>]=?|=|\b(?:and|div|mod|not|or|xor)\b/i,
		punctuation: /[()\[\]{}:.;,]/
	};
}
antlr4.displayName = "antlr4";
antlr4.aliases = ["g4"];
function antlr4(Prism$1) {
	Prism$1.languages.antlr4 = {
		comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
		string: {
			pattern: /'(?:\\.|[^\\'\r\n])*'/,
			greedy: true
		},
		"character-class": {
			pattern: /\[(?:\\.|[^\\\]\r\n])*\]/,
			greedy: true,
			alias: "regex",
			inside: {
				range: {
					pattern: /([^[]|(?:^|[^\\])(?:\\\\)*\\\[)-(?!\])/,
					lookbehind: true,
					alias: "punctuation"
				},
				escape: /\\(?:u(?:[a-fA-F\d]{4}|\{[a-fA-F\d]+\})|[pP]\{[=\w-]+\}|[^\r\nupP])/,
				punctuation: /[\[\]]/
			}
		},
		action: {
			pattern: /\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\}/,
			greedy: true,
			inside: {
				content: {
					pattern: /(\{)[\s\S]+(?=\})/,
					lookbehind: true
				},
				punctuation: /[{}]/
			}
		},
		command: {
			pattern: /(->\s*(?!\s))(?:\s*(?:,\s*)?\b[a-z]\w*(?:\s*\([^()\r\n]*\))?)+(?=\s*;)/i,
			lookbehind: true,
			inside: {
				function: /\b\w+(?=\s*(?:[,(]|$))/,
				punctuation: /[,()]/
			}
		},
		annotation: {
			pattern: /@\w+(?:::\w+)*/,
			alias: "keyword"
		},
		label: {
			pattern: /#[ \t]*\w+/,
			alias: "punctuation"
		},
		keyword: /\b(?:catch|channels|finally|fragment|grammar|import|lexer|locals|mode|options|parser|returns|throws|tokens)\b/,
		definition: [{
			pattern: /\b[a-z]\w*(?=\s*:)/,
			alias: ["rule", "class-name"]
		}, {
			pattern: /\b[A-Z]\w*(?=\s*:)/,
			alias: ["token", "constant"]
		}],
		constant: /\b[A-Z][A-Z_]*\b/,
		operator: /\.\.|->|[|~]|[*+?]\??/,
		punctuation: /[;:()=]/
	};
	Prism$1.languages.g4 = Prism$1.languages.antlr4;
}
apacheconf.displayName = "apacheconf";
apacheconf.aliases = [];
function apacheconf(Prism$1) {
	Prism$1.languages.apacheconf = {
		comment: /#.*/,
		"directive-inline": {
			pattern: /(^[\t ]*)\b(?:AcceptFilter|AcceptPathInfo|AccessFileName|Action|Add(?:Alt|AltByEncoding|AltByType|Charset|DefaultCharset|Description|Encoding|Handler|Icon|IconByEncoding|IconByType|InputFilter|Language|ModuleInfo|OutputFilter|OutputFilterByType|Type)|Alias|AliasMatch|Allow(?:CONNECT|EncodedSlashes|Methods|Override|OverrideList)?|Anonymous(?:_LogEmail|_MustGiveEmail|_NoUserID|_VerifyEmail)?|AsyncRequestWorkerFactor|Auth(?:BasicAuthoritative|BasicFake|BasicProvider|BasicUseDigestAlgorithm|DBDUserPWQuery|DBDUserRealmQuery|DBMGroupFile|DBMType|DBMUserFile|Digest(?:Algorithm|Domain|NonceLifetime|Provider|Qop|ShmemSize)|Form(?:Authoritative|Body|DisableNoStore|FakeBasicAuth|Location|LoginRequiredLocation|LoginSuccessLocation|LogoutLocation|Method|Mimetype|Password|Provider|SitePassphrase|Size|Username)|GroupFile|LDAP(?:AuthorizePrefix|BindAuthoritative|BindDN|BindPassword|CharsetConfig|CompareAsUser|CompareDNOnServer|DereferenceAliases|GroupAttribute|GroupAttributeIsDN|InitialBindAsUser|InitialBindPattern|MaxSubGroupDepth|RemoteUserAttribute|RemoteUserIsDN|SearchAsUser|SubGroupAttribute|SubGroupClass|Url)|Merging|Name|nCache(?:Context|Enable|ProvideFor|SOCache|Timeout)|nzFcgiCheckAuthnProvider|nzFcgiDefineProvider|Type|UserFile|zDBDLoginToReferer|zDBDQuery|zDBDRedirectQuery|zDBMType|zSendForbiddenOnFailure)|BalancerGrowth|BalancerInherit|BalancerMember|BalancerPersist|BrowserMatch|BrowserMatchNoCase|BufferedLogs|BufferSize|Cache(?:DefaultExpire|DetailHeader|DirLength|DirLevels|Disable|Enable|File|Header|IgnoreCacheControl|IgnoreHeaders|IgnoreNoLastMod|IgnoreQueryString|IgnoreURLSessionIdentifiers|KeyBaseURL|LastModifiedFactor|Lock|LockMaxAge|LockPath|MaxExpire|MaxFileSize|MinExpire|MinFileSize|NegotiatedDocs|QuickHandler|ReadSize|ReadTime|Root|Socache(?:MaxSize|MaxTime|MinTime|ReadSize|ReadTime)?|StaleOnError|StoreExpired|StoreNoStore|StorePrivate)|CGIDScriptTimeout|CGIMapExtension|CharsetDefault|CharsetOptions|CharsetSourceEnc|CheckCaseOnly|CheckSpelling|ChrootDir|ContentDigest|CookieDomain|CookieExpires|CookieName|CookieStyle|CookieTracking|CoreDumpDirectory|CustomLog|Dav|DavDepthInfinity|DavGenericLockDB|DavLockDB|DavMinTimeout|DBDExptime|DBDInitSQL|DBDKeep|DBDMax|DBDMin|DBDParams|DBDPersist|DBDPrepareSQL|DBDriver|DefaultIcon|DefaultLanguage|DefaultRuntimeDir|DefaultType|Define|Deflate(?:BufferSize|CompressionLevel|FilterNote|InflateLimitRequestBody|InflateRatio(?:Burst|Limit)|MemLevel|WindowSize)|Deny|DirectoryCheckHandler|DirectoryIndex|DirectoryIndexRedirect|DirectorySlash|DocumentRoot|DTracePrivileges|DumpIOInput|DumpIOOutput|EnableExceptionHook|EnableMMAP|EnableSendfile|Error|ErrorDocument|ErrorLog|ErrorLogFormat|Example|ExpiresActive|ExpiresByType|ExpiresDefault|ExtendedStatus|ExtFilterDefine|ExtFilterOptions|FallbackResource|FileETag|FilterChain|FilterDeclare|FilterProtocol|FilterProvider|FilterTrace|ForceLanguagePriority|ForceType|ForensicLog|GprofDir|GracefulShutdownTimeout|Group|Header|HeaderName|Heartbeat(?:Address|Listen|MaxServers|Storage)|HostnameLookups|IdentityCheck|IdentityCheckTimeout|ImapBase|ImapDefault|ImapMenu|Include|IncludeOptional|Index(?:HeadInsert|Ignore|IgnoreReset|Options|OrderDefault|StyleSheet)|InputSed|ISAPI(?:AppendLogToErrors|AppendLogToQuery|CacheFile|FakeAsync|LogNotSupported|ReadAheadBuffer)|KeepAlive|KeepAliveTimeout|KeptBodySize|LanguagePriority|LDAP(?:CacheEntries|CacheTTL|ConnectionPoolTTL|ConnectionTimeout|LibraryDebug|OpCacheEntries|OpCacheTTL|ReferralHopLimit|Referrals|Retries|RetryDelay|SharedCacheFile|SharedCacheSize|Timeout|TrustedClientCert|TrustedGlobalCert|TrustedMode|VerifyServerCert)|Limit(?:InternalRecursion|Request(?:Body|Fields|FieldSize|Line)|XMLRequestBody)|Listen|ListenBackLog|LoadFile|LoadModule|LogFormat|LogLevel|LogMessage|LuaAuthzProvider|LuaCodeCache|Lua(?:Hook(?:AccessChecker|AuthChecker|CheckUserID|Fixups|InsertFilter|Log|MapToStorage|TranslateName|TypeChecker)|Inherit|InputFilter|MapHandler|OutputFilter|PackageCPath|PackagePath|QuickHandler|Root|Scope)|Max(?:ConnectionsPerChild|KeepAliveRequests|MemFree|RangeOverlaps|RangeReversals|Ranges|RequestWorkers|SpareServers|SpareThreads|Threads)|MergeTrailers|MetaDir|MetaFiles|MetaSuffix|MimeMagicFile|MinSpareServers|MinSpareThreads|MMapFile|ModemStandard|ModMimeUsePathInfo|MultiviewsMatch|Mutex|NameVirtualHost|NoProxy|NWSSLTrustedCerts|NWSSLUpgradeable|Options|Order|OutputSed|PassEnv|PidFile|PrivilegesMode|Protocol|ProtocolEcho|Proxy(?:AddHeaders|BadHeader|Block|Domain|ErrorOverride|ExpressDBMFile|ExpressDBMType|ExpressEnable|FtpDirCharset|FtpEscapeWildcards|FtpListOnWildcard|HTML(?:BufSize|CharsetOut|DocType|Enable|Events|Extended|Fixups|Interp|Links|Meta|StripComments|URLMap)|IOBufferSize|MaxForwards|Pass(?:Inherit|InterpolateEnv|Match|Reverse|ReverseCookieDomain|ReverseCookiePath)?|PreserveHost|ReceiveBufferSize|Remote|RemoteMatch|Requests|SCGIInternalRedirect|SCGISendfile|Set|SourceAddress|Status|Timeout|Via)|ReadmeName|ReceiveBufferSize|Redirect|RedirectMatch|RedirectPermanent|RedirectTemp|ReflectorHeader|RemoteIP(?:Header|InternalProxy|InternalProxyList|ProxiesHeader|TrustedProxy|TrustedProxyList)|RemoveCharset|RemoveEncoding|RemoveHandler|RemoveInputFilter|RemoveLanguage|RemoveOutputFilter|RemoveType|RequestHeader|RequestReadTimeout|Require|Rewrite(?:Base|Cond|Engine|Map|Options|Rule)|RLimitCPU|RLimitMEM|RLimitNPROC|Satisfy|ScoreBoardFile|Script(?:Alias|AliasMatch|InterpreterSource|Log|LogBuffer|LogLength|Sock)?|SecureListen|SeeRequestTail|SendBufferSize|Server(?:Admin|Alias|Limit|Name|Path|Root|Signature|Tokens)|Session(?:Cookie(?:Name|Name2|Remove)|Crypto(?:Cipher|Driver|Passphrase|PassphraseFile)|DBD(?:CookieName|CookieName2|CookieRemove|DeleteLabel|InsertLabel|PerUser|SelectLabel|UpdateLabel)|Env|Exclude|Header|Include|MaxAge)?|SetEnv|SetEnvIf|SetEnvIfExpr|SetEnvIfNoCase|SetHandler|SetInputFilter|SetOutputFilter|SSIEndTag|SSIErrorMsg|SSIETag|SSILastModified|SSILegacyExprParser|SSIStartTag|SSITimeFormat|SSIUndefinedEcho|SSL(?:CACertificateFile|CACertificatePath|CADNRequestFile|CADNRequestPath|CARevocationCheck|CARevocationFile|CARevocationPath|CertificateChainFile|CertificateFile|CertificateKeyFile|CipherSuite|Compression|CryptoDevice|Engine|FIPS|HonorCipherOrder|InsecureRenegotiation|OCSP(?:DefaultResponder|Enable|OverrideResponder|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|UseRequestNonce)|OpenSSLConfCmd|Options|PassPhraseDialog|Protocol|Proxy(?:CACertificateFile|CACertificatePath|CARevocation(?:Check|File|Path)|CheckPeer(?:CN|Expire|Name)|CipherSuite|Engine|MachineCertificate(?:ChainFile|File|Path)|Protocol|Verify|VerifyDepth)|RandomSeed|RenegBufferSize|Require|RequireSSL|Session(?:Cache|CacheTimeout|TicketKeyFile|Tickets)|SRPUnknownUserSeed|SRPVerifierFile|Stapling(?:Cache|ErrorCacheTimeout|FakeTryLater|ForceURL|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|ReturnResponderErrors|StandardCacheTimeout)|StrictSNIVHostCheck|UserName|UseStapling|VerifyClient|VerifyDepth)|StartServers|StartThreads|Substitute|Suexec|SuexecUserGroup|ThreadLimit|ThreadsPerChild|ThreadStackSize|TimeOut|TraceEnable|TransferLog|TypesConfig|UnDefine|UndefMacro|UnsetEnv|Use|UseCanonicalName|UseCanonicalPhysicalPort|User|UserDir|VHostCGIMode|VHostCGIPrivs|VHostGroup|VHostPrivs|VHostSecure|VHostUser|Virtual(?:DocumentRoot|ScriptAlias)(?:IP)?|WatchdogInterval|XBitHack|xml2EncAlias|xml2EncDefault|xml2StartParse)\b/im,
			lookbehind: true,
			alias: "property"
		},
		"directive-block": {
			pattern: /<\/?\b(?:Auth[nz]ProviderAlias|Directory|DirectoryMatch|Else|ElseIf|Files|FilesMatch|If|IfDefine|IfModule|IfVersion|Limit|LimitExcept|Location|LocationMatch|Macro|Proxy|Require(?:All|Any|None)|VirtualHost)\b.*>/i,
			inside: {
				"directive-block": {
					pattern: /^<\/?\w+/,
					inside: { punctuation: /^<\/?/ },
					alias: "tag"
				},
				"directive-block-parameter": {
					pattern: /.*[^>]/,
					inside: {
						punctuation: /:/,
						string: {
							pattern: /("|').*\1/,
							inside: { variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/ }
						}
					},
					alias: "attr-value"
				},
				punctuation: />/
			},
			alias: "tag"
		},
		"directive-flags": {
			pattern: /\[(?:[\w=],?)+\]/,
			alias: "keyword"
		},
		string: {
			pattern: /("|').*\1/,
			inside: { variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/ }
		},
		variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/,
		regex: /\^?.*\$|\^.*\$?/
	};
}
apex.displayName = "apex";
apex.aliases = [];
function apex(Prism$1) {
	Prism$1.register(clike);
	Prism$1.register(sql);
	(function(Prism$2) {
		var keywords = /\b(?:(?:after|before)(?=\s+[a-z])|abstract|activate|and|any|array|as|asc|autonomous|begin|bigdecimal|blob|boolean|break|bulk|by|byte|case|cast|catch|char|class|collect|commit|const|continue|currency|date|datetime|decimal|default|delete|desc|do|double|else|end|enum|exception|exit|export|extends|final|finally|float|for|from|get(?=\s*[{};])|global|goto|group|having|hint|if|implements|import|in|inner|insert|instanceof|int|integer|interface|into|join|like|limit|list|long|loop|map|merge|new|not|null|nulls|number|object|of|on|or|outer|override|package|parallel|pragma|private|protected|public|retrieve|return|rollback|select|set|short|sObject|sort|static|string|super|switch|synchronized|system|testmethod|then|this|throw|time|transaction|transient|trigger|try|undelete|update|upsert|using|virtual|void|webservice|when|where|while|(?:inherited|with|without)\s+sharing)\b/i;
		var className$1 = /\b(?:(?=[a-z_]\w*\s*[<\[])|(?!<keyword>))[A-Z_]\w*(?:\s*\.\s*[A-Z_]\w*)*\b(?:\s*(?:\[\s*\]|<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>))*/.source.replace(/<keyword>/g, function() {
			return keywords.source;
		});
		function insertClassName(pattern) {
			return RegExp(pattern.replace(/<CLASS-NAME>/g, function() {
				return className$1;
			}), "i");
		}
		var classNameInside = {
			keyword: keywords,
			punctuation: /[()\[\]{};,:.<>]/
		};
		Prism$2.languages.apex = {
			comment: Prism$2.languages.clike.comment,
			string: Prism$2.languages.clike.string,
			sql: {
				pattern: /((?:[=,({:]|\breturn)\s*)\[[^\[\]]*\]/i,
				lookbehind: true,
				greedy: true,
				alias: "language-sql",
				inside: Prism$2.languages.sql
			},
			annotation: {
				pattern: /@\w+\b/,
				alias: "punctuation"
			},
			"class-name": [
				{
					pattern: insertClassName(/(\b(?:class|enum|extends|implements|instanceof|interface|new|trigger\s+\w+\s+on)\s+)<CLASS-NAME>/.source),
					lookbehind: true,
					inside: classNameInside
				},
				{
					pattern: insertClassName(/(\(\s*)<CLASS-NAME>(?=\s*\)\s*[\w(])/.source),
					lookbehind: true,
					inside: classNameInside
				},
				{
					pattern: insertClassName(/<CLASS-NAME>(?=\s*\w+\s*[;=,(){:])/.source),
					inside: classNameInside
				}
			],
			trigger: {
				pattern: /(\btrigger\s+)\w+\b/i,
				lookbehind: true,
				alias: "class-name"
			},
			keyword: keywords,
			function: /\b[a-z_]\w*(?=\s*\()/i,
			boolean: /\b(?:false|true)\b/i,
			number: /(?:\B\.\d+|\b\d+(?:\.\d+|L)?)\b/i,
			operator: /[!=](?:==?)?|\?\.?|&&|\|\||--|\+\+|[-+*/^&|]=?|:|<<?=?|>{1,3}=?/,
			punctuation: /[()\[\]{};,.]/
		};
	})(Prism$1);
}
apl.displayName = "apl";
apl.aliases = [];
function apl(Prism$1) {
	Prism$1.languages.apl = {
		comment: /(?:⍝|#[! ]).*$/m,
		string: {
			pattern: /'(?:[^'\r\n]|'')*'/,
			greedy: true
		},
		number: /¯?(?:\d*\.?\b\d+(?:e[+¯]?\d+)?|¯|∞)(?:j¯?(?:(?:\d+(?:\.\d+)?|\.\d+)(?:e[+¯]?\d+)?|¯|∞))?/i,
		statement: /:[A-Z][a-z][A-Za-z]*\b/,
		"system-function": {
			pattern: /⎕[A-Z]+/i,
			alias: "function"
		},
		constant: /[⍬⌾#⎕⍞]/,
		function: /[-+×÷⌈⌊∣|⍳⍸?*⍟○!⌹<≤=>≥≠≡≢∊⍷∪∩~∨∧⍱⍲⍴,⍪⌽⊖⍉↑↓⊂⊃⊆⊇⌷⍋⍒⊤⊥⍕⍎⊣⊢⍁⍂≈⍯↗¤→]/,
		"monadic-operator": {
			pattern: /[\\\/⌿⍀¨⍨⌶&∥]/,
			alias: "operator"
		},
		"dyadic-operator": {
			pattern: /[.⍣⍠⍤∘⌸@⌺⍥]/,
			alias: "operator"
		},
		assignment: {
			pattern: /←/,
			alias: "keyword"
		},
		punctuation: /[\[;\]()◇⋄]/,
		dfn: {
			pattern: /[{}⍺⍵⍶⍹∇⍫:]/,
			alias: "builtin"
		}
	};
}
applescript.displayName = "applescript";
applescript.aliases = [];
function applescript(Prism$1) {
	Prism$1.languages.applescript = {
		comment: [
			/\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/,
			/--.+/,
			/#.+/
		],
		string: /"(?:\\.|[^"\\\r\n])*"/,
		number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e-?\d+)?\b/i,
		operator: [/[&=≠≤≥*+\-\/÷^]|[<>]=?/, /\b(?:(?:begin|end|start)s? with|(?:contains?|(?:does not|doesn't) contain)|(?:is|isn't|is not) (?:contained by|in)|(?:(?:is|isn't|is not) )?(?:greater|less) than(?: or equal)?(?: to)?|(?:comes|(?:does not|doesn't) come) (?:after|before)|(?:is|isn't|is not) equal(?: to)?|(?:(?:does not|doesn't) equal|equal to|equals|is not|isn't)|(?:a )?(?:ref(?: to)?|reference to)|(?:and|as|div|mod|not|or))\b/],
		keyword: /\b(?:about|above|after|against|apart from|around|aside from|at|back|before|beginning|behind|below|beneath|beside|between|but|by|considering|continue|copy|does|eighth|else|end|equal|error|every|exit|false|fifth|first|for|fourth|from|front|get|given|global|if|ignoring|in|instead of|into|is|it|its|last|local|me|middle|my|ninth|of|on|onto|out of|over|prop|property|put|repeat|return|returning|second|set|seventh|since|sixth|some|tell|tenth|that|the|then|third|through|thru|timeout|times|to|transaction|true|try|until|where|while|whose|with|without)\b/,
		"class-name": /\b(?:POSIX file|RGB color|alias|application|boolean|centimeters|centimetres|class|constant|cubic centimeters|cubic centimetres|cubic feet|cubic inches|cubic meters|cubic metres|cubic yards|date|degrees Celsius|degrees Fahrenheit|degrees Kelvin|feet|file|gallons|grams|inches|integer|kilograms|kilometers|kilometres|list|liters|litres|meters|metres|miles|number|ounces|pounds|quarts|real|record|reference|script|square feet|square kilometers|square kilometres|square meters|square metres|square miles|square yards|text|yards)\b/,
		punctuation: /[{}():,¬«»《》]/
	};
}
aql.displayName = "aql";
aql.aliases = [];
function aql(Prism$1) {
	Prism$1.languages.aql = {
		comment: /\/\/.*|\/\*[\s\S]*?\*\//,
		property: {
			pattern: /([{,]\s*)(?:(?!\d)\w+|(["'´`])(?:(?!\2)[^\\\r\n]|\\.)*\2)(?=\s*:)/,
			lookbehind: true,
			greedy: true
		},
		string: {
			pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\.)*\1/,
			greedy: true
		},
		identifier: {
			pattern: /([´`])(?:(?!\1)[^\\\r\n]|\\.)*\1/,
			greedy: true
		},
		variable: /@@?\w+/,
		keyword: [
			{
				pattern: /(\bWITH\s+)COUNT(?=\s+INTO\b)/i,
				lookbehind: true
			},
			/\b(?:AGGREGATE|ALL|AND|ANY|ASC|COLLECT|DESC|DISTINCT|FILTER|FOR|GRAPH|IN|INBOUND|INSERT|INTO|K_PATHS|K_SHORTEST_PATHS|LET|LIKE|LIMIT|NONE|NOT|NULL|OR|OUTBOUND|REMOVE|REPLACE|RETURN|SHORTEST_PATH|SORT|UPDATE|UPSERT|WINDOW|WITH)\b/i,
			{
				pattern: /(^|[^\w.[])(?:KEEP|PRUNE|SEARCH|TO)\b/i,
				lookbehind: true
			},
			{
				pattern: /(^|[^\w.[])(?:CURRENT|NEW|OLD)\b/,
				lookbehind: true
			},
			{ pattern: /\bOPTIONS(?=\s*\{)/i }
		],
		function: /\b(?!\d)\w+(?=\s*\()/,
		boolean: /\b(?:false|true)\b/i,
		range: {
			pattern: /\.\./,
			alias: "operator"
		},
		number: [
			/\b0b[01]+/i,
			/\b0x[0-9a-f]+/i,
			/(?:\B\.\d+|\b(?:0|[1-9]\d*)(?:\.\d+)?)(?:e[+-]?\d+)?/i
		],
		operator: /\*{2,}|[=!]~|[!=<>]=?|&&|\|\||[-+*/%]/,
		punctuation: /::|[?.:,;()[\]{}]/
	};
}
arff.displayName = "arff";
arff.aliases = [];
function arff(Prism$1) {
	Prism$1.languages.arff = {
		comment: /%.*/,
		string: {
			pattern: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
			greedy: true
		},
		keyword: /@(?:attribute|data|end|relation)\b/i,
		number: /\b\d+(?:\.\d+)?\b/,
		punctuation: /[{},]/
	};
}
armasm.displayName = "armasm";
armasm.aliases = ["arm-asm"];
function armasm(Prism$1) {
	Prism$1.languages.armasm = {
		comment: {
			pattern: /;.*/,
			greedy: true
		},
		string: {
			pattern: /"(?:[^"\r\n]|"")*"/,
			greedy: true,
			inside: { variable: {
				pattern: /((?:^|[^$])(?:\${2})*)\$\w+/,
				lookbehind: true
			} }
		},
		char: {
			pattern: /'(?:[^'\r\n]{0,4}|'')'/,
			greedy: true
		},
		"version-symbol": {
			pattern: /\|[\w@]+\|/,
			greedy: true,
			alias: "property"
		},
		boolean: /\b(?:FALSE|TRUE)\b/,
		directive: {
			pattern: /\b(?:ALIAS|ALIGN|AREA|ARM|ASSERT|ATTR|CN|CODE|CODE16|CODE32|COMMON|CP|DATA|DCB|DCD|DCDO|DCDU|DCFD|DCFDU|DCI|DCQ|DCQU|DCW|DCWU|DN|ELIF|ELSE|END|ENDFUNC|ENDIF|ENDP|ENTRY|EQU|EXPORT|EXPORTAS|EXTERN|FIELD|FILL|FN|FUNCTION|GBLA|GBLL|GBLS|GET|GLOBAL|IF|IMPORT|INCBIN|INCLUDE|INFO|KEEP|LCLA|LCLL|LCLS|LTORG|MACRO|MAP|MEND|MEXIT|NOFP|OPT|PRESERVE8|PROC|QN|READONLY|RELOC|REQUIRE|REQUIRE8|RLIST|ROUT|SETA|SETL|SETS|SN|SPACE|SUBT|THUMB|THUMBX|TTL|WEND|WHILE)\b/,
			alias: "property"
		},
		instruction: {
			pattern: /((?:^|(?:^|[^\\])(?:\r\n?|\n))[ \t]*(?:(?:[A-Z][A-Z0-9_]*[a-z]\w*|[a-z]\w*|\d+)[ \t]+)?)\b[A-Z.]+\b/,
			lookbehind: true,
			alias: "keyword"
		},
		variable: /\$\w+/,
		number: /(?:\b[2-9]_\d+|(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e-?\d+)?|\b0(?:[fd]_|x)[0-9a-f]+|&[0-9a-f]+)\b/i,
		register: {
			pattern: /\b(?:r\d|lr)\b/,
			alias: "symbol"
		},
		operator: /<>|<<|>>|&&|\|\||[=!<>/]=?|[+\-*%#?&|^]|:[A-Z]+:/,
		punctuation: /[()[\],]/
	};
	Prism$1.languages["arm-asm"] = Prism$1.languages.armasm;
}
arturo.displayName = "arturo";
arturo.aliases = ["art"];
function arturo(Prism$1) {
	(function(Prism$2) {
		var createLanguageString = function(lang$1, pattern) {
			return {
				pattern: RegExp(/\{!/.source + "(?:" + (pattern || lang$1) + ")" + /$[\s\S]*\}/.source, "m"),
				greedy: true,
				inside: {
					embedded: {
						pattern: /(^\{!\w+\b)[\s\S]+(?=\}$)/,
						lookbehind: true,
						alias: "language-" + lang$1,
						inside: Prism$2.languages[lang$1]
					},
					string: /[\s\S]+/
				}
			};
		};
		Prism$2.languages.arturo = {
			comment: {
				pattern: /;.*/,
				greedy: true
			},
			character: {
				pattern: /`.`/,
				alias: "char",
				greedy: true
			},
			number: { pattern: /\b\d+(?:\.\d+(?:\.\d+(?:-[\w+-]+)?)?)?\b/ },
			string: {
				pattern: /"(?:[^"\\\r\n]|\\.)*"/,
				greedy: true
			},
			regex: {
				pattern: /\{\/.*?\/\}/,
				greedy: true
			},
			"html-string": createLanguageString("html"),
			"css-string": createLanguageString("css"),
			"js-string": createLanguageString("js"),
			"md-string": createLanguageString("md"),
			"sql-string": createLanguageString("sql"),
			"sh-string": createLanguageString("shell", "sh"),
			multistring: {
				pattern: /».*|\{:[\s\S]*?:\}|\{[\s\S]*?\}|^-{6}$[\s\S]*/m,
				alias: "string",
				greedy: true
			},
			label: {
				pattern: /\w+\b\??:/,
				alias: "property"
			},
			literal: {
				pattern: /'(?:\w+\b\??:?)/,
				alias: "constant"
			},
			type: {
				pattern: /:(?:\w+\b\??:?)/,
				alias: "class-name"
			},
			color: /#\w+/,
			predicate: {
				pattern: /\b(?:all|and|any|ascii|attr|attribute|attributeLabel|binary|block|char|contains|database|date|dictionary|empty|equal|even|every|exists|false|floating|function|greater|greaterOrEqual|if|in|inline|integer|is|key|label|leap|less|lessOrEqual|literal|logical|lower|nand|negative|nor|not|notEqual|null|numeric|odd|or|path|pathLabel|positive|prefix|prime|regex|same|set|some|sorted|standalone|string|subset|suffix|superset|symbol|symbolLiteral|true|try|type|unless|upper|when|whitespace|word|xnor|xor|zero)\?/,
				alias: "keyword"
			},
			"builtin-function": {
				pattern: /\b(?:abs|acos|acosh|acsec|acsech|actan|actanh|add|after|alert|alias|and|angle|append|arg|args|arity|array|as|asec|asech|asin|asinh|atan|atan2|atanh|attr|attrs|average|before|benchmark|blend|break|call|capitalize|case|ceil|chop|clear|clip|close|color|combine|conj|continue|copy|cos|cosh|crc|csec|csech|ctan|ctanh|cursor|darken|dec|decode|define|delete|desaturate|deviation|dialog|dictionary|difference|digest|digits|div|do|download|drop|dup|e|else|empty|encode|ensure|env|escape|execute|exit|exp|extend|extract|factors|fdiv|filter|first|flatten|floor|fold|from|function|gamma|gcd|get|goto|hash|hypot|if|inc|indent|index|infinity|info|input|insert|inspect|intersection|invert|jaro|join|keys|kurtosis|last|let|levenshtein|lighten|list|ln|log|loop|lower|mail|map|match|max|median|min|mod|module|mul|nand|neg|new|nor|normalize|not|now|null|open|or|outdent|pad|palette|panic|path|pause|permissions|permutate|pi|pop|popup|pow|powerset|powmod|prefix|print|prints|process|product|query|random|range|read|relative|remove|rename|render|repeat|replace|request|return|reverse|round|sample|saturate|script|sec|sech|select|serve|set|shl|shr|shuffle|sin|sinh|size|skewness|slice|sort|spin|split|sqrt|squeeze|stack|strip|sub|suffix|sum|switch|symbols|symlink|sys|take|tan|tanh|terminal|terminate|to|truncate|try|type|unclip|union|unique|unless|until|unzip|upper|values|var|variance|volume|webview|while|with|wordwrap|write|xnor|xor|zip)\b/,
				alias: "keyword"
			},
			sugar: {
				pattern: /->|=>|\||::/,
				alias: "operator"
			},
			punctuation: /[()[\],]/,
			symbol: { pattern: /<:|-:|ø|@|#|\+|\||\*|\$|---|-|%|\/|\.\.|\^|~|=|<|>|\\/ },
			boolean: { pattern: /\b(?:false|maybe|true)\b/ }
		};
		Prism$2.languages.art = Prism$2.languages["arturo"];
	})(Prism$1);
}
asciidoc.displayName = "asciidoc";
asciidoc.aliases = ["adoc"];
function asciidoc(Prism$1) {
	(function(Prism$2) {
		var attributes$1 = {
			pattern: /(^[ \t]*)\[(?!\[)(?:(["'$`])(?:(?!\2)[^\\]|\\.)*\2|\[(?:[^\[\]\\]|\\.)*\]|[^\[\]\\"'$`]|\\.)*\]/m,
			lookbehind: true,
			inside: {
				quoted: {
					pattern: /([$`])(?:(?!\1)[^\\]|\\.)*\1/,
					inside: { punctuation: /^[$`]|[$`]$/ }
				},
				interpreted: {
					pattern: /'(?:[^'\\]|\\.)*'/,
					inside: { punctuation: /^'|'$/ }
				},
				string: /"(?:[^"\\]|\\.)*"/,
				variable: /\w+(?==)/,
				punctuation: /^\[|\]$|,/,
				operator: /=/,
				"attr-value": /(?!^\s+$).+/
			}
		};
		var asciidoc$1 = Prism$2.languages.asciidoc = {
			"comment-block": {
				pattern: /^(\/{4,})$[\s\S]*?^\1/m,
				alias: "comment"
			},
			table: {
				pattern: /^\|={3,}(?:(?:\r?\n|\r(?!\n)).*)*?(?:\r?\n|\r)\|={3,}$/m,
				inside: {
					specifiers: {
						pattern: /(?:(?:(?:\d+(?:\.\d+)?|\.\d+)[+*](?:[<^>](?:\.[<^>])?|\.[<^>])?|[<^>](?:\.[<^>])?|\.[<^>])[a-z]*|[a-z]+)(?=\|)/,
						alias: "attr-value"
					},
					punctuation: {
						pattern: /(^|[^\\])[|!]=*/,
						lookbehind: true
					}
				}
			},
			"passthrough-block": {
				pattern: /^(\+{4,})$[\s\S]*?^\1$/m,
				inside: { punctuation: /^\++|\++$/ }
			},
			"literal-block": {
				pattern: /^(-{4,}|\.{4,})$[\s\S]*?^\1$/m,
				inside: { punctuation: /^(?:-+|\.+)|(?:-+|\.+)$/ }
			},
			"other-block": {
				pattern: /^(--|\*{4,}|_{4,}|={4,})$[\s\S]*?^\1$/m,
				inside: { punctuation: /^(?:-+|\*+|_+|=+)|(?:-+|\*+|_+|=+)$/ }
			},
			"list-punctuation": {
				pattern: /(^[ \t]*)(?:-|\*{1,5}|\.{1,5}|(?:[a-z]|\d+)\.|[xvi]+\))(?= )/im,
				lookbehind: true,
				alias: "punctuation"
			},
			"list-label": {
				pattern: /(^[ \t]*)[a-z\d].+(?::{2,4}|;;)(?=\s)/im,
				lookbehind: true,
				alias: "symbol"
			},
			"indented-block": {
				pattern: /((\r?\n|\r)\2)([ \t]+)\S.*(?:(?:\r?\n|\r)\3.+)*(?=\2{2}|$)/,
				lookbehind: true
			},
			comment: /^\/\/.*/m,
			title: {
				pattern: /^.+(?:\r?\n|\r)(?:={3,}|-{3,}|~{3,}|\^{3,}|\+{3,})$|^={1,5} .+|^\.(?![\s.]).*/m,
				alias: "important",
				inside: { punctuation: /^(?:\.|=+)|(?:=+|-+|~+|\^+|\++)$/ }
			},
			"attribute-entry": {
				pattern: /^:[^:\r\n]+:(?: .*?(?: \+(?:\r?\n|\r).*?)*)?$/m,
				alias: "tag"
			},
			attributes: attributes$1,
			hr: {
				pattern: /^'{3,}$/m,
				alias: "punctuation"
			},
			"page-break": {
				pattern: /^<{3,}$/m,
				alias: "punctuation"
			},
			admonition: {
				pattern: /^(?:CAUTION|IMPORTANT|NOTE|TIP|WARNING):/m,
				alias: "keyword"
			},
			callout: [{
				pattern: /(^[ \t]*)<?\d*>/m,
				lookbehind: true,
				alias: "symbol"
			}, {
				pattern: /<\d+>/,
				alias: "symbol"
			}],
			macro: {
				pattern: /\b[a-z\d][a-z\d-]*::?(?:[^\s\[\]]*\[(?:[^\]\\"']|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
				inside: {
					function: /^[a-z\d-]+(?=:)/,
					punctuation: /^::?/,
					attributes: {
						pattern: /(?:\[(?:[^\]\\"']|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
						inside: attributes$1.inside
					}
				}
			},
			inline: {
				pattern: /(^|[^\\])(?:(?:\B\[(?:[^\]\\"']|(["'])(?:(?!\2)[^\\]|\\.)*\2|\\.)*\])?(?:\b_(?!\s)(?: _|[^_\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: _|[^_\\\r\n]|\\.)+)*_\b|\B``(?!\s).+?(?:(?:\r?\n|\r).+?)*''\B|\B`(?!\s)(?:[^`'\s]|\s+\S)+['`]\B|\B(['*+#])(?!\s)(?: \3|(?!\3)[^\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: \3|(?!\3)[^\\\r\n]|\\.)+)*\3\B)|(?:\[(?:[^\]\\"']|(["'])(?:(?!\4)[^\\]|\\.)*\4|\\.)*\])?(?:(__|\*\*|\+\+\+?|##|\$\$|[~^]).+?(?:(?:\r?\n|\r).+?)*\5|\{[^}\r\n]+\}|\[\[\[?.+?(?:(?:\r?\n|\r).+?)*\]?\]\]|<<.+?(?:(?:\r?\n|\r).+?)*>>|\(\(\(?.+?(?:(?:\r?\n|\r).+?)*\)?\)\)))/m,
				lookbehind: true,
				inside: {
					attributes: attributes$1,
					url: {
						pattern: /^(?:\[\[\[?.+?\]?\]\]|<<.+?>>)$/,
						inside: { punctuation: /^(?:\[\[\[?|<<)|(?:\]\]\]?|>>)$/ }
					},
					"attribute-ref": {
						pattern: /^\{.+\}$/,
						inside: {
							variable: {
								pattern: /(^\{)[a-z\d,+_-]+/,
								lookbehind: true
							},
							operator: /^[=?!#%@$]|!(?=[:}])/,
							punctuation: /^\{|\}$|::?/
						}
					},
					italic: {
						pattern: /^(['_])[\s\S]+\1$/,
						inside: { punctuation: /^(?:''?|__?)|(?:''?|__?)$/ }
					},
					bold: {
						pattern: /^\*[\s\S]+\*$/,
						inside: { punctuation: /^\*\*?|\*\*?$/ }
					},
					punctuation: /^(?:``?|\+{1,3}|##?|\$\$|[~^]|\(\(\(?)|(?:''?|\+{1,3}|##?|\$\$|[~^`]|\)?\)\))$/
				}
			},
			replacement: {
				pattern: /\((?:C|R|TM)\)/,
				alias: "builtin"
			},
			entity: /&#?[\da-z]{1,8};/i,
			"line-continuation": {
				pattern: /(^| )\+$/m,
				lookbehind: true,
				alias: "punctuation"
			}
		};
		function copyFromAsciiDoc(keys$1) {
			keys$1 = keys$1.split(" ");
			var o = {};
			for (var i = 0, l$1 = keys$1.length; i < l$1; i++) o[keys$1[i]] = asciidoc$1[keys$1[i]];
			return o;
		}
		attributes$1.inside["interpreted"].inside.rest = copyFromAsciiDoc("macro inline replacement entity");
		asciidoc$1["passthrough-block"].inside.rest = copyFromAsciiDoc("macro");
		asciidoc$1["literal-block"].inside.rest = copyFromAsciiDoc("callout");
		asciidoc$1["table"].inside.rest = copyFromAsciiDoc("comment-block passthrough-block literal-block other-block list-punctuation indented-block comment title attribute-entry attributes hr page-break admonition list-label callout macro inline replacement entity line-continuation");
		asciidoc$1["other-block"].inside.rest = copyFromAsciiDoc("table list-punctuation indented-block comment attribute-entry attributes hr page-break admonition list-label macro inline replacement entity line-continuation");
		asciidoc$1["title"].inside.rest = copyFromAsciiDoc("macro inline replacement entity");
		Prism$2.hooks.add("wrap", function(env$1) {
			if (env$1.type === "entity") env$1.attributes["title"] = env$1.content.value.replace(/&amp;/, "&");
		});
		Prism$2.languages.adoc = Prism$2.languages.asciidoc;
	})(Prism$1);
}
aspnet.displayName = "aspnet";
aspnet.aliases = [];
function aspnet(Prism$1) {
	Prism$1.register(csharp);
	Prism$1.register(markup);
	Prism$1.languages.aspnet = Prism$1.languages.extend("markup", {
		"page-directive": {
			pattern: /<%\s*@.*%>/,
			alias: "tag",
			inside: {
				"page-directive": {
					pattern: /<%\s*@\s*(?:Assembly|Control|Implements|Import|Master(?:Type)?|OutputCache|Page|PreviousPageType|Reference|Register)?|%>/i,
					alias: "tag"
				},
				rest: Prism$1.languages.markup.tag.inside
			}
		},
		directive: {
			pattern: /<%.*%>/,
			alias: "tag",
			inside: {
				directive: {
					pattern: /<%\s*?[$=%#:]{0,2}|%>/,
					alias: "tag"
				},
				rest: Prism$1.languages.csharp
			}
		}
	});
	Prism$1.languages.aspnet.tag.pattern = /<(?!%)\/?[^\s>\/]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/;
	Prism$1.languages.insertBefore("inside", "punctuation", { directive: Prism$1.languages.aspnet["directive"] }, Prism$1.languages.aspnet.tag.inside["attr-value"]);
	Prism$1.languages.insertBefore("aspnet", "comment", { "asp-comment": {
		pattern: /<%--[\s\S]*?--%>/,
		alias: ["asp", "comment"]
	} });
	Prism$1.languages.insertBefore("aspnet", Prism$1.languages.javascript ? "script" : "tag", { "asp-script": {
		pattern: /(<script(?=.*runat=['"]?server\b)[^>]*>)[\s\S]*?(?=<\/script>)/i,
		lookbehind: true,
		alias: ["asp", "script"],
		inside: Prism$1.languages.csharp || {}
	} });
}
asm6502.displayName = "asm6502";
asm6502.aliases = [];
function asm6502(Prism$1) {
	Prism$1.languages.asm6502 = {
		comment: /;.*/,
		directive: {
			pattern: /\.\w+(?= )/,
			alias: "property"
		},
		string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
		"op-code": {
			pattern: /\b(?:ADC|AND|ASL|BCC|BCS|BEQ|BIT|BMI|BNE|BPL|BRK|BVC|BVS|CLC|CLD|CLI|CLV|CMP|CPX|CPY|DEC|DEX|DEY|EOR|INC|INX|INY|JMP|JSR|LDA|LDX|LDY|LSR|NOP|ORA|PHA|PHP|PLA|PLP|ROL|ROR|RTI|RTS|SBC|SEC|SED|SEI|STA|STX|STY|TAX|TAY|TSX|TXA|TXS|TYA|adc|and|asl|bcc|bcs|beq|bit|bmi|bne|bpl|brk|bvc|bvs|clc|cld|cli|clv|cmp|cpx|cpy|dec|dex|dey|eor|inc|inx|iny|jmp|jsr|lda|ldx|ldy|lsr|nop|ora|pha|php|pla|plp|rol|ror|rti|rts|sbc|sec|sed|sei|sta|stx|sty|tax|tay|tsx|txa|txs|tya)\b/,
			alias: "keyword"
		},
		"hex-number": {
			pattern: /#?\$[\da-f]{1,4}\b/i,
			alias: "number"
		},
		"binary-number": {
			pattern: /#?%[01]+\b/,
			alias: "number"
		},
		"decimal-number": {
			pattern: /#?\b\d+\b/,
			alias: "number"
		},
		register: {
			pattern: /\b[xya]\b/i,
			alias: "variable"
		},
		punctuation: /[(),:]/
	};
}
asmatmel.displayName = "asmatmel";
asmatmel.aliases = [];
function asmatmel(Prism$1) {
	Prism$1.languages.asmatmel = {
		comment: {
			pattern: /;.*/,
			greedy: true
		},
		string: {
			pattern: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
			greedy: true
		},
		constant: /\b(?:PORT[A-Z]|DDR[A-Z]|(?:DD|P)[A-Z](?:\d|[0-2]\d|3[01]))\b/,
		directive: {
			pattern: /\.\w+(?= )/,
			alias: "property"
		},
		"r-register": {
			pattern: /\br(?:\d|[12]\d|3[01])\b/,
			alias: "variable"
		},
		"op-code": {
			pattern: /\b(?:ADC|ADD|ADIW|AND|ANDI|ASR|BCLR|BLD|BRBC|BRBS|BRCC|BRCS|BREAK|BREQ|BRGE|BRHC|BRHS|BRID|BRIE|BRLO|BRLT|BRMI|BRNE|BRPL|BRSH|BRTC|BRTS|BRVC|BRVS|BSET|BST|CALL|CBI|CBR|CLC|CLH|CLI|CLN|CLR|CLS|CLT|CLV|CLZ|COM|CP|CPC|CPI|CPSE|DEC|DES|EICALL|EIJMP|ELPM|EOR|FMUL|FMULS|FMULSU|ICALL|IJMP|IN|INC|JMP|LAC|LAS|LAT|LD|LD[A-Za-z0-9]|LPM|LSL|LSR|MOV|MOVW|MUL|MULS|MULSU|NEG|NOP|OR|ORI|OUT|POP|PUSH|RCALL|RET|RETI|RJMP|ROL|ROR|SBC|SBCI|SBI|SBIC|SBIS|SBIW|SBR|SBRC|SBRS|SEC|SEH|SEI|SEN|SER|SES|SET|SEV|SEZ|SLEEP|SPM|ST|ST[A-Z0-9]|SUB|SUBI|SWAP|TST|WDR|XCH|adc|add|adiw|and|andi|asr|bclr|bld|brbc|brbs|brcc|brcs|break|breq|brge|brhc|brhs|brid|brie|brlo|brlt|brmi|brne|brpl|brsh|brtc|brts|brvc|brvs|bset|bst|call|cbi|cbr|clc|clh|cli|cln|clr|cls|clt|clv|clz|com|cp|cpc|cpi|cpse|dec|des|eicall|eijmp|elpm|eor|fmul|fmuls|fmulsu|icall|ijmp|in|inc|jmp|lac|las|lat|ld|ld[a-z0-9]|lpm|lsl|lsr|mov|movw|mul|muls|mulsu|neg|nop|or|ori|out|pop|push|rcall|ret|reti|rjmp|rol|ror|sbc|sbci|sbi|sbic|sbis|sbiw|sbr|sbrc|sbrs|sec|seh|sei|sen|ser|ses|set|sev|sez|sleep|spm|st|st[a-zA-Z0-9]|sub|subi|swap|tst|wdr|xch)\b/,
			alias: "keyword"
		},
		"hex-number": {
			pattern: /#?\$[\da-f]{2,4}\b/i,
			alias: "number"
		},
		"binary-number": {
			pattern: /#?%[01]+\b/,
			alias: "number"
		},
		"decimal-number": {
			pattern: /#?\b\d+\b/,
			alias: "number"
		},
		register: {
			pattern: /\b[acznvshtixy]\b/i,
			alias: "variable"
		},
		operator: />>=?|<<=?|&[&=]?|\|[\|=]?|[-+*/%^!=<>?]=?/,
		punctuation: /[(),:]/
	};
}
autohotkey.displayName = "autohotkey";
autohotkey.aliases = [];
function autohotkey(Prism$1) {
	Prism$1.languages.autohotkey = {
		comment: [{
			pattern: /(^|\s);.*/,
			lookbehind: true
		}, {
			pattern: /(^[\t ]*)\/\*(?:[\r\n](?![ \t]*\*\/)|[^\r\n])*(?:[\r\n][ \t]*\*\/)?/m,
			lookbehind: true,
			greedy: true
		}],
		tag: {
			pattern: /^([ \t]*)[^\s,`":]+(?=:[ \t]*$)/m,
			lookbehind: true
		},
		string: /"(?:[^"\n\r]|"")*"/,
		variable: /%\w+%/,
		number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
		operator: /\?|\/\/?=?|:=|\|[=|]?|&[=&]?|\+[=+]?|-[=-]?|\*[=*]?|<(?:<=?|>|=)?|>>?=?|[.^!=~]=?|\b(?:AND|NOT|OR)\b/,
		boolean: /\b(?:false|true)\b/,
		command: {
			pattern: /\b(?:AutoTrim|BlockInput|Break|Click|ClipWait|Continue|Control|ControlClick|ControlFocus|ControlGet|ControlGetFocus|ControlGetPos|ControlGetText|ControlMove|ControlSend|ControlSendRaw|ControlSetText|CoordMode|Critical|DetectHiddenText|DetectHiddenWindows|Drive|DriveGet|DriveSpaceFree|EnvAdd|EnvDiv|EnvGet|EnvMult|EnvSet|EnvSub|EnvUpdate|Exit|ExitApp|FileAppend|FileCopy|FileCopyDir|FileCreateDir|FileCreateShortcut|FileDelete|FileEncoding|FileGetAttrib|FileGetShortcut|FileGetSize|FileGetTime|FileGetVersion|FileInstall|FileMove|FileMoveDir|FileRead|FileReadLine|FileRecycle|FileRecycleEmpty|FileRemoveDir|FileSelectFile|FileSelectFolder|FileSetAttrib|FileSetTime|FormatTime|GetKeyState|Gosub|Goto|GroupActivate|GroupAdd|GroupClose|GroupDeactivate|Gui|GuiControl|GuiControlGet|Hotkey|ImageSearch|IniDelete|IniRead|IniWrite|Input|InputBox|KeyWait|ListHotkeys|ListLines|ListVars|Loop|Menu|MouseClick|MouseClickDrag|MouseGetPos|MouseMove|MsgBox|OnExit|OutputDebug|Pause|PixelGetColor|PixelSearch|PostMessage|Process|Progress|Random|RegDelete|RegRead|RegWrite|Reload|Repeat|Return|Run|RunAs|RunWait|Send|SendEvent|SendInput|SendMessage|SendMode|SendPlay|SendRaw|SetBatchLines|SetCapslockState|SetControlDelay|SetDefaultMouseSpeed|SetEnv|SetFormat|SetKeyDelay|SetMouseDelay|SetNumlockState|SetRegView|SetScrollLockState|SetStoreCapslockMode|SetTimer|SetTitleMatchMode|SetWinDelay|SetWorkingDir|Shutdown|Sleep|Sort|SoundBeep|SoundGet|SoundGetWaveVolume|SoundPlay|SoundSet|SoundSetWaveVolume|SplashImage|SplashTextOff|SplashTextOn|SplitPath|StatusBarGetText|StatusBarWait|StringCaseSense|StringGetPos|StringLeft|StringLen|StringLower|StringMid|StringReplace|StringRight|StringSplit|StringTrimLeft|StringTrimRight|StringUpper|Suspend|SysGet|Thread|ToolTip|Transform|TrayTip|URLDownloadToFile|WinActivate|WinActivateBottom|WinClose|WinGet|WinGetActiveStats|WinGetActiveTitle|WinGetClass|WinGetPos|WinGetText|WinGetTitle|WinHide|WinKill|WinMaximize|WinMenuSelectItem|WinMinimize|WinMinimizeAll|WinMinimizeAllUndo|WinMove|WinRestore|WinSet|WinSetTitle|WinShow|WinWait|WinWaitActive|WinWaitClose|WinWaitNotActive)\b/i,
			alias: "selector"
		},
		constant: /\b(?:a_ahkpath|a_ahkversion|a_appdata|a_appdatacommon|a_autotrim|a_batchlines|a_caretx|a_carety|a_computername|a_controldelay|a_cursor|a_dd|a_ddd|a_dddd|a_defaultmousespeed|a_desktop|a_desktopcommon|a_detecthiddentext|a_detecthiddenwindows|a_endchar|a_eventinfo|a_exitreason|a_fileencoding|a_formatfloat|a_formatinteger|a_gui|a_guicontrol|a_guicontrolevent|a_guievent|a_guiheight|a_guiwidth|a_guix|a_guiy|a_hour|a_iconfile|a_iconhidden|a_iconnumber|a_icontip|a_index|a_ipaddress1|a_ipaddress2|a_ipaddress3|a_ipaddress4|a_is64bitos|a_isadmin|a_iscompiled|a_iscritical|a_ispaused|a_issuspended|a_isunicode|a_keydelay|a_language|a_lasterror|a_linefile|a_linenumber|a_loopfield|a_loopfileattrib|a_loopfiledir|a_loopfileext|a_loopfilefullpath|a_loopfilelongpath|a_loopfilename|a_loopfileshortname|a_loopfileshortpath|a_loopfilesize|a_loopfilesizekb|a_loopfilesizemb|a_loopfiletimeaccessed|a_loopfiletimecreated|a_loopfiletimemodified|a_loopreadline|a_loopregkey|a_loopregname|a_loopregsubkey|a_loopregtimemodified|a_loopregtype|a_mday|a_min|a_mm|a_mmm|a_mmmm|a_mon|a_mousedelay|a_msec|a_mydocuments|a_now|a_nowutc|a_numbatchlines|a_ostype|a_osversion|a_priorhotkey|a_priorkey|a_programfiles|a_programs|a_programscommon|a_ptrsize|a_regview|a_screendpi|a_screenheight|a_screenwidth|a_scriptdir|a_scriptfullpath|a_scripthwnd|a_scriptname|a_sec|a_space|a_startmenu|a_startmenucommon|a_startup|a_startupcommon|a_stringcasesense|a_tab|a_temp|a_thisfunc|a_thishotkey|a_thislabel|a_thismenu|a_thismenuitem|a_thismenuitempos|a_tickcount|a_timeidle|a_timeidlephysical|a_timesincepriorhotkey|a_timesincethishotkey|a_titlematchmode|a_titlematchmodespeed|a_username|a_wday|a_windelay|a_windir|a_workingdir|a_yday|a_year|a_yweek|a_yyyy|clipboard|clipboardall|comspec|errorlevel|programfiles)\b/i,
		builtin: /\b(?:abs|acos|asc|asin|atan|ceil|chr|class|comobjactive|comobjarray|comobjconnect|comobjcreate|comobjerror|comobjflags|comobjget|comobjquery|comobjtype|comobjvalue|cos|dllcall|exp|fileexist|Fileopen|floor|format|il_add|il_create|il_destroy|instr|isfunc|islabel|IsObject|ln|log|ltrim|lv_add|lv_delete|lv_deletecol|lv_getcount|lv_getnext|lv_gettext|lv_insert|lv_insertcol|lv_modify|lv_modifycol|lv_setimagelist|mod|numget|numput|onmessage|regexmatch|regexreplace|registercallback|round|rtrim|sb_seticon|sb_setparts|sb_settext|sin|sqrt|strlen|strreplace|strsplit|substr|tan|tv_add|tv_delete|tv_get|tv_getchild|tv_getcount|tv_getnext|tv_getparent|tv_getprev|tv_getselection|tv_gettext|tv_modify|varsetcapacity|winactive|winexist|__Call|__Get|__New|__Set)\b/i,
		symbol: /\b(?:alt|altdown|altup|appskey|backspace|browser_back|browser_favorites|browser_forward|browser_home|browser_refresh|browser_search|browser_stop|bs|capslock|ctrl|ctrlbreak|ctrldown|ctrlup|del|delete|down|end|enter|esc|escape|f1|f10|f11|f12|f13|f14|f15|f16|f17|f18|f19|f2|f20|f21|f22|f23|f24|f3|f4|f5|f6|f7|f8|f9|home|ins|insert|joy1|joy10|joy11|joy12|joy13|joy14|joy15|joy16|joy17|joy18|joy19|joy2|joy20|joy21|joy22|joy23|joy24|joy25|joy26|joy27|joy28|joy29|joy3|joy30|joy31|joy32|joy4|joy5|joy6|joy7|joy8|joy9|joyaxes|joybuttons|joyinfo|joyname|joypov|joyr|joyu|joyv|joyx|joyy|joyz|lalt|launch_app1|launch_app2|launch_mail|launch_media|lbutton|lcontrol|lctrl|left|lshift|lwin|lwindown|lwinup|mbutton|media_next|media_play_pause|media_prev|media_stop|numlock|numpad0|numpad1|numpad2|numpad3|numpad4|numpad5|numpad6|numpad7|numpad8|numpad9|numpadadd|numpadclear|numpaddel|numpaddiv|numpaddot|numpaddown|numpadend|numpadenter|numpadhome|numpadins|numpadleft|numpadmult|numpadpgdn|numpadpgup|numpadright|numpadsub|numpadup|pgdn|pgup|printscreen|ralt|rbutton|rcontrol|rctrl|right|rshift|rwin|rwindown|rwinup|scrolllock|shift|shiftdown|shiftup|space|tab|up|volume_down|volume_mute|volume_up|wheeldown|wheelleft|wheelright|wheelup|xbutton1|xbutton2)\b/i,
		directive: {
			pattern: /#[a-z]+\b/i,
			alias: "important"
		},
		keyword: /\b(?:Abort|AboveNormal|Add|ahk_class|ahk_exe|ahk_group|ahk_id|ahk_pid|All|Alnum|Alpha|AltSubmit|AltTab|AltTabAndMenu|AltTabMenu|AltTabMenuDismiss|AlwaysOnTop|AutoSize|Background|BackgroundTrans|BelowNormal|between|BitAnd|BitNot|BitOr|BitShiftLeft|BitShiftRight|BitXOr|Bold|Border|Button|ByRef|Catch|Checkbox|Checked|CheckedGray|Choose|ChooseString|Close|Color|ComboBox|Contains|ControlList|Count|Date|DateTime|Days|DDL|Default|DeleteAll|Delimiter|Deref|Destroy|Digit|Disable|Disabled|DropDownList|Edit|Eject|Else|Enable|Enabled|Error|Exist|Expand|ExStyle|FileSystem|Finally|First|Flash|Float|FloatFast|Focus|Font|for|global|Grid|Group|GroupBox|GuiClose|GuiContextMenu|GuiDropFiles|GuiEscape|GuiSize|Hdr|Hidden|Hide|High|HKCC|HKCR|HKCU|HKEY_CLASSES_ROOT|HKEY_CURRENT_CONFIG|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS|HKLM|HKU|Hours|HScroll|Icon|IconSmall|ID|IDLast|If|IfEqual|IfExist|IfGreater|IfGreaterOrEqual|IfInString|IfLess|IfLessOrEqual|IfMsgBox|IfNotEqual|IfNotExist|IfNotInString|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Ignore|ImageList|in|Integer|IntegerFast|Interrupt|is|italic|Join|Label|LastFound|LastFoundExist|Limit|Lines|List|ListBox|ListView|local|Lock|Logoff|Low|Lower|Lowercase|MainWindow|Margin|Maximize|MaximizeBox|MaxSize|Minimize|MinimizeBox|MinMax|MinSize|Minutes|MonthCal|Mouse|Move|Multi|NA|No|NoActivate|NoDefault|NoHide|NoIcon|NoMainWindow|norm|Normal|NoSort|NoSortHdr|NoStandard|Not|NoTab|NoTimers|Number|Off|Ok|On|OwnDialogs|Owner|Parse|Password|Picture|Pixel|Pos|Pow|Priority|ProcessName|Radio|Range|Read|ReadOnly|Realtime|Redraw|Region|REG_BINARY|REG_DWORD|REG_EXPAND_SZ|REG_MULTI_SZ|REG_SZ|Relative|Rename|Report|Resize|Restore|Retry|RGB|Screen|Seconds|Section|Serial|SetLabel|ShiftAltTab|Show|Single|Slider|SortDesc|Standard|static|Status|StatusBar|StatusCD|strike|Style|Submit|SysMenu|Tab2|TabStop|Text|Theme|Throw|Tile|ToggleCheck|ToggleEnable|ToolWindow|Top|Topmost|TransColor|Transparent|Tray|TreeView|Try|TryAgain|Type|UnCheck|underline|Unicode|Unlock|Until|UpDown|Upper|Uppercase|UseErrorLevel|Vis|VisFirst|Visible|VScroll|Wait|WaitClose|WantCtrlA|WantF2|WantReturn|While|Wrap|Xdigit|xm|xp|xs|Yes|ym|yp|ys)\b/i,
		function: /[^(); \t,\n+*\-=?>:\\\/<&%\[\]]+(?=\()/,
		punctuation: /[{}[\]():,]/
	};
}
autoit.displayName = "autoit";
autoit.aliases = [];
function autoit(Prism$1) {
	Prism$1.languages.autoit = {
		comment: [/;.*/, {
			pattern: /(^[\t ]*)#(?:comments-start|cs)[\s\S]*?^[ \t]*#(?:ce|comments-end)/m,
			lookbehind: true
		}],
		url: {
			pattern: /(^[\t ]*#include\s+)(?:<[^\r\n>]+>|"[^\r\n"]+")/m,
			lookbehind: true
		},
		string: {
			pattern: /(["'])(?:\1\1|(?!\1)[^\r\n])*\1/,
			greedy: true,
			inside: { variable: /([%$@])\w+\1/ }
		},
		directive: {
			pattern: /(^[\t ]*)#[\w-]+/m,
			lookbehind: true,
			alias: "keyword"
		},
		function: /\b\w+(?=\()/,
		variable: /[$@]\w+/,
		keyword: /\b(?:Case|Const|Continue(?:Case|Loop)|Default|Dim|Do|Else(?:If)?|End(?:Func|If|Select|Switch|With)|Enum|Exit(?:Loop)?|For|Func|Global|If|In|Local|Next|Null|ReDim|Select|Static|Step|Switch|Then|To|Until|Volatile|WEnd|While|With)\b/i,
		number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
		boolean: /\b(?:False|True)\b/i,
		operator: /<[=>]?|[-+*\/=&>]=?|[?^]|\b(?:And|Not|Or)\b/i,
		punctuation: /[\[\]().,:]/
	};
}
avisynth.displayName = "avisynth";
avisynth.aliases = ["avs"];
function avisynth(Prism$1) {
	(function(Prism$2) {
		function replace$1(pattern, replacements) {
			return pattern.replace(/<<(\d+)>>/g, function(m, index$1) {
				return replacements[+index$1];
			});
		}
		function re$1(pattern, replacements, flags) {
			return RegExp(replace$1(pattern, replacements), flags || "");
		}
		var types = /bool|clip|float|int|string|val/.source;
		var internals = [
			/is(?:bool|clip|float|int|string)|defined|(?:(?:internal)?function|var)?exists?/.source,
			/apply|assert|default|eval|import|nop|select|undefined/.source,
			/opt_(?:allowfloataudio|avipadscanlines|dwchannelmask|enable_(?:b64a|planartopackedrgb|v210|y3_10_10|y3_10_16)|usewaveextensible|vdubplanarhack)|set(?:cachemode|maxcpu|memorymax|planarlegacyalignment|workingdir)/.source,
			/hex(?:value)?|value/.source,
			/abs|ceil|continued(?:denominator|numerator)?|exp|floor|fmod|frac|log(?:10)?|max|min|muldiv|pi|pow|rand|round|sign|spline|sqrt/.source,
			/a?sinh?|a?cosh?|a?tan[2h]?/.source,
			/(?:bit(?:and|not|x?or|[lr]?shift[aslu]?|sh[lr]|sa[lr]|[lr]rotatel?|ro[rl]|te?st|set(?:count)?|cl(?:ea)?r|ch(?:an)?ge?))/.source,
			/average(?:[bgr]|chroma[uv]|luma)|(?:[rgb]|chroma[uv]|luma|rgb|[yuv](?=difference(?:fromprevious|tonext)))difference(?:fromprevious|tonext)?|[yuvrgb]plane(?:median|min|max|minmaxdifference)/.source,
			/getprocessinfo|logmsg|script(?:dir(?:utf8)?|file(?:utf8)?|name(?:utf8)?)|setlogparams/.source,
			/chr|(?:fill|find|left|mid|replace|rev|right)str|format|[lu]case|ord|str(?:cmpi?|fromutf8|len|toutf8)|time|trim(?:all|left|right)/.source,
			/isversionorgreater|version(?:number|string)/.source,
			/buildpixeltype|colorspacenametopixeltype/.source,
			/addautoloaddir|on(?:cpu|cuda)|prefetch|setfiltermtmode/.source
		].join("|");
		var properties$1 = [
			/has(?:audio|video)/.source,
			/height|width/.source,
			/frame(?:count|rate)|framerate(?:denominator|numerator)/.source,
			/getparity|is(?:field|frame)based/.source,
			/bitspercomponent|componentsize|hasalpha|is(?:planar(?:rgba?)?|interleaved|rgb(?:24|32|48|64)?|y(?:8|u(?:va?|y2))?|yv(?:12|16|24|411)|420|422|444|packedrgb)|numcomponents|pixeltype/.source,
			/audio(?:bits|channels|duration|length(?:[fs]|hi|lo)?|rate)|isaudio(?:float|int)/.source
		].join("|");
		var filters = [
			/avi(?:file)?source|directshowsource|image(?:reader|source|sourceanim)|opendmlsource|segmented(?:avisource|directshowsource)|wavsource/.source,
			/coloryuv|convertbacktoyuy2|convertto(?:RGB(?:24|32|48|64)|(?:planar)?RGBA?|Y8?|YV(?:12|16|24|411)|YUVA?(?:411|420|422|444)|YUY2)|fixluminance|gr[ae]yscale|invert|levels|limiter|mergea?rgb|merge(?:chroma|luma)|rgbadjust|show(?:alpha|blue|green|red)|swapuv|tweak|[uv]toy8?|ytouv/.source,
			/(?:colorkey|reset)mask|layer|mask(?:hs)?|merge|overlay|subtract/.source,
			/addborders|(?:bicubic|bilinear|blackman|gauss|lanczos4|lanczos|point|sinc|spline(?:16|36|64))resize|crop(?:bottom)?|flip(?:horizontal|vertical)|(?:horizontal|vertical)?reduceby2|letterbox|skewrows|turn(?:180|left|right)/.source,
			/blur|fixbrokenchromaupsampling|generalconvolution|(?:spatial|temporal)soften|sharpen/.source,
			/trim|(?:un)?alignedsplice|(?:assume|assumescaled|change|convert)FPS|(?:delete|duplicate)frame|dissolve|fade(?:in|io|out)[02]?|freezeframe|interleave|loop|reverse|select(?:even|odd|(?:range)?every)/.source,
			/assume[bt]ff|assume(?:field|frame)based|bob|complementparity|doubleweave|peculiarblend|pulldown|separate(?:columns|fields|rows)|swapfields|weave(?:columns|rows)?/.source,
			/amplify(?:db)?|assumesamplerate|audiodub(?:ex)?|audiotrim|convertaudioto(?:(?:8|16|24|32)bit|float)|converttomono|delayaudio|ensurevbrmp3sync|get(?:left|right)?channel|kill(?:audio|video)|mergechannels|mixaudio|monotostereo|normalize|resampleaudio|ssrc|supereq|timestretch/.source,
			/animate|applyrange|conditional(?:filter|reader|select)|frameevaluate|scriptclip|tcp(?:server|source)|writefile(?:end|if|start)?/.source,
			/imagewriter/.source,
			/blackness|blankclip|colorbars(?:hd)?|compare|dumpfiltergraph|echo|histogram|info|messageclip|preroll|setgraphanalysis|show(?:framenumber|smpte|time)|showfiveversions|stack(?:horizontal|vertical)|subtitle|tone|version/.source
		].join("|");
		var allinternals = [
			internals,
			properties$1,
			filters
		].join("|");
		Prism$2.languages.avisynth = {
			comment: [
				{
					pattern: /(^|[^\\])\[\*(?:[^\[*]|\[(?!\*)|\*(?!\])|\[\*(?:[^\[*]|\[(?!\*)|\*(?!\]))*\*\])*\*\]/,
					lookbehind: true,
					greedy: true
				},
				{
					pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
					lookbehind: true,
					greedy: true
				},
				{
					pattern: /(^|[^\\$])#.*/,
					lookbehind: true,
					greedy: true
				}
			],
			argument: {
				pattern: re$1(/\b(?:<<0>>)\s+("?)\w+\1/.source, [types], "i"),
				inside: { keyword: /^\w+/ }
			},
			"argument-label": {
				pattern: /([,(][\s\\]*)\w+\s*=(?!=)/,
				lookbehind: true,
				inside: {
					"argument-name": {
						pattern: /^\w+/,
						alias: "punctuation"
					},
					punctuation: /=$/
				}
			},
			string: [{
				pattern: /"""[\s\S]*?"""/,
				greedy: true
			}, {
				pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
				greedy: true,
				inside: { constant: { pattern: /\b(?:DEFAULT_MT_MODE|(?:MAINSCRIPT|PROGRAM|SCRIPT)DIR|(?:MACHINE|USER)_(?:CLASSIC|PLUS)_PLUGINS)\b/ } }
			}],
			variable: /\b(?:last)\b/i,
			boolean: /\b(?:false|no|true|yes)\b/i,
			keyword: /\b(?:catch|else|for|function|global|if|return|try|while|__END__)\b/i,
			constant: /\bMT_(?:MULTI_INSTANCE|NICE_FILTER|SERIALIZED|SPECIAL_MT)\b/,
			"builtin-function": {
				pattern: re$1(/\b(?:<<0>>)\b/.source, [allinternals], "i"),
				alias: "function"
			},
			"type-cast": {
				pattern: re$1(/\b(?:<<0>>)(?=\s*\()/.source, [types], "i"),
				alias: "keyword"
			},
			function: {
				pattern: /\b[a-z_]\w*(?=\s*\()|(\.)[a-z_]\w*\b/i,
				lookbehind: true
			},
			"line-continuation": {
				pattern: /(^[ \t]*)\\|\\(?=[ \t]*$)/m,
				lookbehind: true,
				alias: "punctuation"
			},
			number: /\B\$(?:[\da-f]{6}|[\da-f]{8})\b|(?:(?:\b|\B-)\d+(?:\.\d*)?\b|\B\.\d+\b)/i,
			operator: /\+\+?|[!=<>]=?|&&|\|\||[?:*/%-]/,
			punctuation: /[{}\[\]();,.]/
		};
		Prism$2.languages.avs = Prism$2.languages.avisynth;
	})(Prism$1);
}
avroIdl.displayName = "avro-idl";
avroIdl.aliases = ["avdl"];
function avroIdl(Prism$1) {
	Prism$1.languages["avro-idl"] = {
		comment: {
			pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
			greedy: true
		},
		string: {
			pattern: /(^|[^\\])"(?:[^\r\n"\\]|\\.)*"/,
			lookbehind: true,
			greedy: true
		},
		annotation: {
			pattern: /@(?:[$\w.-]|`[^\r\n`]+`)+/,
			greedy: true,
			alias: "function"
		},
		"function-identifier": {
			pattern: /`[^\r\n`]+`(?=\s*\()/,
			greedy: true,
			alias: "function"
		},
		identifier: {
			pattern: /`[^\r\n`]+`/,
			greedy: true
		},
		"class-name": {
			pattern: /(\b(?:enum|error|protocol|record|throws)\b\s+)[$\w]+/,
			lookbehind: true,
			greedy: true
		},
		keyword: /\b(?:array|boolean|bytes|date|decimal|double|enum|error|false|fixed|float|idl|import|int|local_timestamp_ms|long|map|null|oneway|protocol|record|schema|string|throws|time_ms|timestamp_ms|true|union|uuid|void)\b/,
		function: /\b[a-z_]\w*(?=\s*\()/i,
		number: [{
			pattern: /(^|[^\w.])-?(?:(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|0x(?:[a-f0-9]+(?:\.[a-f0-9]*)?|\.[a-f0-9]+)(?:p[+-]?\d+)?)[dfl]?(?![\w.])/i,
			lookbehind: true
		}, /-?\b(?:Infinity|NaN)\b/],
		operator: /=/,
		punctuation: /[()\[\]{}<>.:,;-]/
	};
	Prism$1.languages.avdl = Prism$1.languages["avro-idl"];
}
awk.displayName = "awk";
awk.aliases = ["gawk"];
function awk(Prism$1) {
	Prism$1.languages.awk = {
		hashbang: {
			pattern: /^#!.*/,
			greedy: true,
			alias: "comment"
		},
		comment: {
			pattern: /#.*/,
			greedy: true
		},
		string: {
			pattern: /(^|[^\\])"(?:[^\\"\r\n]|\\.)*"/,
			lookbehind: true,
			greedy: true
		},
		regex: {
			pattern: /((?:^|[^\w\s)])\s*)\/(?:[^\/\\\r\n]|\\.)*\//,
			lookbehind: true,
			greedy: true
		},
		variable: /\$\w+/,
		keyword: /\b(?:BEGIN|BEGINFILE|END|ENDFILE|break|case|continue|default|delete|do|else|exit|for|function|getline|if|in|next|nextfile|printf?|return|switch|while)\b|@(?:include|load)\b/,
		function: /\b[a-z_]\w*(?=\s*\()/i,
		number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0x[a-fA-F0-9]+)\b/,
		operator: /--|\+\+|!?~|>&|>>|<<|(?:\*\*|[<>!=+\-*/%^])=?|&&|\|[|&]|[?:]/,
		punctuation: /[()[\]{},;]/
	};
	Prism$1.languages.gawk = Prism$1.languages.awk;
}
batch.displayName = "batch";
batch.aliases = [];
function batch(Prism$1) {
	(function(Prism$2) {
		var variable = /%%?[~:\w]+%?|!\S+!/;
		var parameter = {
			pattern: /\/[a-z?]+(?=[ :]|$):?|-[a-z]\b|--[a-z-]+\b/im,
			alias: "attr-name",
			inside: { punctuation: /:/ }
		};
		var string$2 = /"(?:[\\"]"|[^"])*"(?!")/;
		var number$2 = /(?:\b|-)\d+\b/;
		Prism$2.languages.batch = {
			comment: [/^::.*/m, {
				pattern: /((?:^|[&(])[ \t]*)rem\b(?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
				lookbehind: true
			}],
			label: {
				pattern: /^:.*/m,
				alias: "property"
			},
			command: [
				{
					pattern: /((?:^|[&(])[ \t]*)for(?: \/[a-z?](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* \S+ in \([^)]+\) do/im,
					lookbehind: true,
					inside: {
						keyword: /\b(?:do|in)\b|^for\b/i,
						string: string$2,
						parameter,
						variable,
						number: number$2,
						punctuation: /[()',]/
					}
				},
				{
					pattern: /((?:^|[&(])[ \t]*)if(?: \/[a-z?](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* (?:not )?(?:cmdextversion \d+|defined \w+|errorlevel \d+|exist \S+|(?:"[^"]*"|(?!")(?:(?!==)\S)+)?(?:==| (?:equ|geq|gtr|leq|lss|neq) )(?:"[^"]*"|[^\s"]\S*))/im,
					lookbehind: true,
					inside: {
						keyword: /\b(?:cmdextversion|defined|errorlevel|exist|not)\b|^if\b/i,
						string: string$2,
						parameter,
						variable,
						number: number$2,
						operator: /\^|==|\b(?:equ|geq|gtr|leq|lss|neq)\b/i
					}
				},
				{
					pattern: /((?:^|[&()])[ \t]*)else\b/im,
					lookbehind: true,
					inside: { keyword: /^else\b/i }
				},
				{
					pattern: /((?:^|[&(])[ \t]*)set(?: \/[a-z](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* (?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
					lookbehind: true,
					inside: {
						keyword: /^set\b/i,
						string: string$2,
						parameter,
						variable: [variable, /\w+(?=(?:[*\/%+\-&^|]|<<|>>)?=)/],
						number: number$2,
						operator: /[*\/%+\-&^|]=?|<<=?|>>=?|[!~_=]/,
						punctuation: /[()',]/
					}
				},
				{
					pattern: /((?:^|[&(])[ \t]*@?)\w+\b(?:"(?:[\\"]"|[^"])*"(?!")|[^"^&)\r\n]|\^(?:\r\n|[\s\S]))*/m,
					lookbehind: true,
					inside: {
						keyword: /^\w+\b/,
						string: string$2,
						parameter,
						label: {
							pattern: /(^\s*):\S+/m,
							lookbehind: true,
							alias: "property"
						},
						variable,
						number: number$2,
						operator: /\^/
					}
				}
			],
			operator: /[&@]/,
			punctuation: /[()']/
		};
	})(Prism$1);
}
bbcode.displayName = "bbcode";
bbcode.aliases = ["shortcode"];
function bbcode(Prism$1) {
	Prism$1.languages.bbcode = { tag: {
		pattern: /\[\/?[^\s=\]]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+))?(?:\s+[^\s=\]]+\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+))*\s*\]/,
		inside: {
			tag: {
				pattern: /^\[\/?[^\s=\]]+/,
				inside: { punctuation: /^\[\/?/ }
			},
			"attr-value": {
				pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+)/,
				inside: { punctuation: [/^=/, {
					pattern: /^(\s*)["']|["']$/,
					lookbehind: true
				}] }
			},
			punctuation: /\]/,
			"attr-name": /[^\s=\]]+/
		}
	} };
	Prism$1.languages.shortcode = Prism$1.languages.bbcode;
}
bbj.displayName = "bbj";
bbj.aliases = [];
function bbj(Prism$1) {
	(function(Prism$2) {
		Prism$2.languages.bbj = {
			comment: {
				pattern: /(^|[^\\:])rem\s+.*/i,
				lookbehind: true,
				greedy: true
			},
			string: {
				pattern: /(['"])(?:(?!\1|\\).|\\.)*\1/,
				greedy: true
			},
			number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
			keyword: /\b(?:abstract|all|argc|begin|bye|callback|case|chn|class|classend|ctl|day|declare|delete|dim|dom|dread|dsz|else|end|endif|err|exitto|extends|fi|field|for|from|gosub|goto|if|implements|interface|interfaceend|iol|iolist|let|list|load|method|methodend|methodret|on|opts|pfx|print|private|process_events|protected|psz|public|read|read_resource|release|remove_callback|repeat|restore|return|rev|seterr|setesc|sqlchn|sqlunt|ssn|start|static|swend|switch|sys|then|tim|unt|until|use|void|wend|where|while)\b/i,
			function: /\b\w+(?=\()/,
			boolean: /\b(?:BBjAPI\.TRUE|BBjAPI\.FALSE)\b/i,
			operator: /<[=>]?|>=?|[+\-*\/^=&]|\b(?:and|not|or|xor)\b/i,
			punctuation: /[.,;:()]/
		};
	})(Prism$1);
}
bicep.displayName = "bicep";
bicep.aliases = [];
function bicep(Prism$1) {
	Prism$1.languages.bicep = {
		comment: [{
			pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
			lookbehind: true,
			greedy: true
		}, {
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true,
			greedy: true
		}],
		property: [{
			pattern: /([\r\n][ \t]*)[a-z_]\w*(?=[ \t]*:)/i,
			lookbehind: true
		}, {
			pattern: /([\r\n][ \t]*)'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'(?=[ \t]*:)/,
			lookbehind: true,
			greedy: true
		}],
		string: [{
			pattern: /'''[^'][\s\S]*?'''/,
			greedy: true
		}, {
			pattern: /(^|[^\\'])'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'/,
			lookbehind: true,
			greedy: true
		}],
		"interpolated-string": {
			pattern: /(^|[^\\'])'(?:\\.|\$(?:(?!\{)|\{[^{}\r\n]*\})|[^'\\\r\n$])*'/,
			lookbehind: true,
			greedy: true,
			inside: {
				interpolation: {
					pattern: /\$\{[^{}\r\n]*\}/,
					inside: {
						expression: {
							pattern: /(^\$\{)[\s\S]+(?=\}$)/,
							lookbehind: true
						},
						punctuation: /^\$\{|\}$/
					}
				},
				string: /[\s\S]+/
			}
		},
		datatype: {
			pattern: /(\b(?:output|param)\b[ \t]+\w+[ \t]+)\w+\b/,
			lookbehind: true,
			alias: "class-name"
		},
		boolean: /\b(?:false|true)\b/,
		keyword: /\b(?:existing|for|if|in|module|null|output|param|resource|targetScope|var)\b/,
		decorator: /@\w+\b/,
		function: /\b[a-z_]\w*(?=[ \t]*\()/i,
		number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
		operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/,
		punctuation: /[{}[\];(),.:]/
	};
	Prism$1.languages.bicep["interpolated-string"].inside["interpolation"].inside["expression"].inside = Prism$1.languages.bicep;
}
birb.displayName = "birb";
birb.aliases = [];
function birb(Prism$1) {
	Prism$1.register(clike);
	Prism$1.languages.birb = Prism$1.languages.extend("clike", {
		string: {
			pattern: /r?("|')(?:\\.|(?!\1)[^\\])*\1/,
			greedy: true
		},
		"class-name": [/\b[A-Z](?:[\d_]*[a-zA-Z]\w*)?\b/, /\b(?:[A-Z]\w*|(?!(?:var|void)\b)[a-z]\w*)(?=\s+\w+\s*[;,=()])/],
		keyword: /\b(?:assert|break|case|class|const|default|else|enum|final|follows|for|grab|if|nest|new|next|noSeeb|return|static|switch|throw|var|void|while)\b/,
		operator: /\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?|:/,
		variable: /\b[a-z_]\w*\b/
	});
	Prism$1.languages.insertBefore("birb", "function", { metadata: {
		pattern: /<\w+>/,
		greedy: true,
		alias: "symbol"
	} });
}
bison.displayName = "bison";
bison.aliases = [];
function bison(Prism$1) {
	Prism$1.register(c$1);
	Prism$1.languages.bison = Prism$1.languages.extend("c", {});
	Prism$1.languages.insertBefore("bison", "comment", { bison: {
		pattern: /^(?:[^%]|%(?!%))*%%[\s\S]*?%%/,
		inside: {
			c: {
				pattern: /%\{[\s\S]*?%\}|\{(?:\{[^}]*\}|[^{}])*\}/,
				inside: {
					delimiter: {
						pattern: /^%?\{|%?\}$/,
						alias: "punctuation"
					},
					"bison-variable": {
						pattern: /[$@](?:<[^\s>]+>)?[\w$]+/,
						alias: "variable",
						inside: { punctuation: /<|>/ }
					},
					rest: Prism$1.languages.c
				}
			},
			comment: Prism$1.languages.c.comment,
			string: Prism$1.languages.c.string,
			property: /\S+(?=:)/,
			keyword: /%\w+/,
			number: {
				pattern: /(^|[^@])\b(?:0x[\da-f]+|\d+)/i,
				lookbehind: true
			},
			punctuation: /%[%?]|[|:;\[\]<>]/
		}
	} });
}
bnf.displayName = "bnf";
bnf.aliases = ["rbnf"];
function bnf(Prism$1) {
	Prism$1.languages.bnf = {
		string: { pattern: /"[^\r\n"]*"|'[^\r\n']*'/ },
		definition: {
			pattern: /<[^<>\r\n\t]+>(?=\s*::=)/,
			alias: ["rule", "keyword"],
			inside: { punctuation: /^<|>$/ }
		},
		rule: {
			pattern: /<[^<>\r\n\t]+>/,
			inside: { punctuation: /^<|>$/ }
		},
		operator: /::=|[|()[\]{}*+?]|\.{3}/
	};
	Prism$1.languages.rbnf = Prism$1.languages.bnf;
}
bqn.displayName = "bqn";
bqn.aliases = [];
function bqn(Prism$1) {
	Prism$1.languages.bqn = {
		shebang: {
			pattern: /^#![ \t]*\/.*/,
			alias: "important",
			greedy: true
		},
		comment: {
			pattern: /#.*/,
			greedy: true
		},
		"string-literal": {
			pattern: /"(?:[^"]|"")*"/,
			greedy: true,
			alias: "string"
		},
		"character-literal": {
			pattern: /'(?:[\s\S]|[\uD800-\uDBFF][\uDC00-\uDFFF])'/,
			greedy: true,
			alias: "char"
		},
		function: /•[\w¯.∞π]+[\w¯.∞π]*/,
		"dot-notation-on-brackets": {
			pattern: /\{(?=.*\}\.)|\}\./,
			alias: "namespace"
		},
		"special-name": {
			pattern: /(?:𝕨|𝕩|𝕗|𝕘|𝕤|𝕣|𝕎|𝕏|𝔽|𝔾|𝕊|_𝕣_|_𝕣)/,
			alias: "keyword"
		},
		"dot-notation-on-name": {
			pattern: /[A-Za-z_][\w¯∞π]*\./,
			alias: "namespace"
		},
		"word-number-scientific": {
			pattern: /\d+(?:\.\d+)?[eE]¯?\d+/,
			alias: "number"
		},
		"word-name": {
			pattern: /[A-Za-z_][\w¯∞π]*/,
			alias: "symbol"
		},
		"word-number": {
			pattern: /[¯∞π]?(?:\d*\.?\b\d+(?:e[+¯]?\d+|E[+¯]?\d+)?|¯|∞|π)(?:j¯?(?:(?:\d+(?:\.\d+)?|\.\d+)(?:e[+¯]?\d+|E[+¯]?\d+)?|¯|∞|π))?/,
			alias: "number"
		},
		"null-literal": {
			pattern: /@/,
			alias: "char"
		},
		"primitive-functions": {
			pattern: /[-+×÷⋆√⌊⌈|¬∧∨<>≠=≤≥≡≢⊣⊢⥊∾≍⋈↑↓↕«»⌽⍉/⍋⍒⊏⊑⊐⊒∊⍷⊔!]/,
			alias: "operator"
		},
		"primitive-1-operators": {
			pattern: /[`˜˘¨⁼⌜´˝˙]/,
			alias: "operator"
		},
		"primitive-2-operators": {
			pattern: /[∘⊸⟜○⌾⎉⚇⍟⊘◶⎊]/,
			alias: "operator"
		},
		punctuation: /[←⇐↩(){}⟨⟩[\]‿·⋄,.;:?]/
	};
}
brainfuck.displayName = "brainfuck";
brainfuck.aliases = [];
function brainfuck(Prism$1) {
	Prism$1.languages.brainfuck = {
		pointer: {
			pattern: /<|>/,
			alias: "keyword"
		},
		increment: {
			pattern: /\+/,
			alias: "inserted"
		},
		decrement: {
			pattern: /-/,
			alias: "deleted"
		},
		branching: {
			pattern: /\[|\]/,
			alias: "important"
		},
		operator: /[.,]/,
		comment: /\S+/
	};
}
brightscript.displayName = "brightscript";
brightscript.aliases = [];
function brightscript(Prism$1) {
	Prism$1.languages.brightscript = {
		comment: /(?:\brem|').*/i,
		"directive-statement": {
			pattern: /(^[\t ]*)#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if).*/im,
			lookbehind: true,
			alias: "property",
			inside: {
				"error-message": {
					pattern: /(^#error).+/,
					lookbehind: true
				},
				directive: {
					pattern: /^#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if)/,
					alias: "keyword"
				},
				expression: {
					pattern: /[\s\S]+/,
					inside: null
				}
			}
		},
		property: {
			pattern: /([\r\n{,][\t ]*)(?:(?!\d)\w+|"(?:[^"\r\n]|"")*"(?!"))(?=[ \t]*:)/,
			lookbehind: true,
			greedy: true
		},
		string: {
			pattern: /"(?:[^"\r\n]|"")*"(?!")/,
			greedy: true
		},
		"class-name": {
			pattern: /(\bAs[\t ]+)\w+/i,
			lookbehind: true
		},
		keyword: /\b(?:As|Dim|Each|Else|Elseif|End|Exit|For|Function|Goto|If|In|Print|Return|Step|Stop|Sub|Then|To|While)\b/i,
		boolean: /\b(?:false|true)\b/i,
		function: /\b(?!\d)\w+(?=[\t ]*\()/,
		number: /(?:\b\d+(?:\.\d+)?(?:[ed][+-]\d+)?|&h[a-f\d]+)\b[%&!#]?/i,
		operator: /--|\+\+|>>=?|<<=?|<>|[-+*/\\<>]=?|[:^=?]|\b(?:and|mod|not|or)\b/i,
		punctuation: /[.,;()[\]{}]/,
		constant: /\b(?:LINE_NUM)\b/i
	};
	Prism$1.languages.brightscript["directive-statement"].inside.expression.inside = Prism$1.languages.brightscript;
}
bro.displayName = "bro";
bro.aliases = [];
function bro(Prism$1) {
	Prism$1.languages.bro = {
		comment: {
			pattern: /(^|[^\\$])#.*/,
			lookbehind: true,
			inside: { italic: /\b(?:FIXME|TODO|XXX)\b/ }
		},
		string: {
			pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
			greedy: true
		},
		boolean: /\b[TF]\b/,
		function: {
			pattern: /(\b(?:event|function|hook)[ \t]+)\w+(?:::\w+)?/,
			lookbehind: true
		},
		builtin: /(?:@(?:load(?:-(?:plugin|sigs))?|unload|prefixes|ifn?def|else|(?:end)?if|DIR|FILENAME))|(?:&?(?:add_func|create_expire|default|delete_func|encrypt|error_handler|expire_func|group|log|mergeable|optional|persistent|priority|raw_output|read_expire|redef|rotate_interval|rotate_size|synchronized|type_column|write_expire))/,
		constant: {
			pattern: /(\bconst[ \t]+)\w+/i,
			lookbehind: true
		},
		keyword: /\b(?:add|addr|alarm|any|bool|break|const|continue|count|delete|double|else|enum|event|export|file|for|function|global|hook|if|in|int|interval|local|module|next|of|opaque|pattern|port|print|record|return|schedule|set|string|subnet|table|time|timeout|using|vector|when)\b/,
		operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&|\|\|?|\?|\*|\/|~|\^|%/,
		number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
		punctuation: /[{}[\];(),.:]/
	};
}
bsl.displayName = "bsl";
bsl.aliases = ["oscript"];
function bsl(Prism$1) {
	Prism$1.languages.bsl = {
		comment: /\/\/.*/,
		string: [{
			pattern: /"(?:[^"]|"")*"(?!")/,
			greedy: true
		}, { pattern: /'(?:[^'\r\n\\]|\\.)*'/ }],
		keyword: [{
			pattern: /(^|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:пока|для|новый|прервать|попытка|исключение|вызватьисключение|иначе|конецпопытки|неопределено|функция|перем|возврат|конецфункции|если|иначеесли|процедура|конецпроцедуры|тогда|знач|экспорт|конецесли|из|каждого|истина|ложь|по|цикл|конеццикла|выполнить)(?![\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])/i,
			lookbehind: true
		}, { pattern: /\b(?:break|do|each|else|elseif|enddo|endfunction|endif|endprocedure|endtry|except|execute|export|false|for|function|if|in|new|null|procedure|raise|return|then|to|true|try|undefined|val|var|while)\b/i }],
		number: {
			pattern: /(^(?=\d)|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:\d+(?:\.\d*)?|\.\d+)(?:E[+-]?\d+)?/i,
			lookbehind: true
		},
		operator: [
			/[<>+\-*/]=?|[%=]/,
			{
				pattern: /(^|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:и|или|не)(?![\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])/i,
				lookbehind: true
			},
			{ pattern: /\b(?:and|not|or)\b/i }
		],
		punctuation: /\(\.|\.\)|[()\[\]:;,.]/,
		directive: [{
			pattern: /^([ \t]*)&.*/m,
			lookbehind: true,
			greedy: true,
			alias: "important"
		}, {
			pattern: /^([ \t]*)#.*/gm,
			lookbehind: true,
			greedy: true,
			alias: "important"
		}]
	};
	Prism$1.languages.oscript = Prism$1.languages["bsl"];
}
cfscript.displayName = "cfscript";
cfscript.aliases = ["cfc"];
function cfscript(Prism$1) {
	Prism$1.register(clike);
	Prism$1.languages.cfscript = Prism$1.languages.extend("clike", {
		comment: [{
			pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
			lookbehind: true,
			inside: { annotation: {
				pattern: /(?:^|[^.])@[\w\.]+/,
				alias: "punctuation"
			} }
		}, {
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true,
			greedy: true
		}],
		keyword: /\b(?:abstract|break|catch|component|continue|default|do|else|extends|final|finally|for|function|if|in|include|package|private|property|public|remote|required|rethrow|return|static|switch|throw|try|var|while|xml)\b(?!\s*=)/,
		operator: [/\+\+|--|&&|\|\||::|=>|[!=]==|[-+*/%&|^!=<>]=?|\?(?:\.|:)?|:/, /\b(?:and|contains|eq|equal|eqv|gt|gte|imp|is|lt|lte|mod|not|or|xor)\b/],
		scope: {
			pattern: /\b(?:application|arguments|cgi|client|cookie|local|session|super|this|variables)\b/,
			alias: "global"
		},
		type: {
			pattern: /\b(?:any|array|binary|boolean|date|guid|numeric|query|string|struct|uuid|void|xml)\b/,
			alias: "builtin"
		}
	});
	Prism$1.languages.insertBefore("cfscript", "keyword", { "function-variable": {
		pattern: /[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
		alias: "function"
	} });
	delete Prism$1.languages.cfscript["class-name"];
	Prism$1.languages.cfc = Prism$1.languages["cfscript"];
}
chaiscript.displayName = "chaiscript";
chaiscript.aliases = [];
function chaiscript(Prism$1) {
	Prism$1.register(clike);
	Prism$1.register(cpp);
	Prism$1.languages.chaiscript = Prism$1.languages.extend("clike", {
		string: {
			pattern: /(^|[^\\])'(?:[^'\\]|\\[\s\S])*'/,
			lookbehind: true,
			greedy: true
		},
		"class-name": [{
			pattern: /(\bclass\s+)\w+/,
			lookbehind: true
		}, {
			pattern: /(\b(?:attr|def)\s+)\w+(?=\s*::)/,
			lookbehind: true
		}],
		keyword: /\b(?:attr|auto|break|case|catch|class|continue|def|default|else|finally|for|fun|global|if|return|switch|this|try|var|while)\b/,
		number: [Prism$1.languages.cpp.number, /\b(?:Infinity|NaN)\b/],
		operator: />>=?|<<=?|\|\||&&|:[:=]?|--|\+\+|[=!<>+\-*/%|&^]=?|[?~]|`[^`\r\n]{1,4}`/
	});
	Prism$1.languages.insertBefore("chaiscript", "operator", { "parameter-type": {
		pattern: /([,(]\s*)\w+(?=\s+\w)/,
		lookbehind: true,
		alias: "class-name"
	} });
	Prism$1.languages.insertBefore("chaiscript", "string", { "string-interpolation": {
		pattern: /(^|[^\\])"(?:[^"$\\]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*"/,
		lookbehind: true,
		greedy: true,
		inside: {
			interpolation: {
				pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\}/,
				lookbehind: true,
				inside: {
					"interpolation-expression": {
						pattern: /(^\$\{)[\s\S]+(?=\}$)/,
						lookbehind: true,
						inside: Prism$1.languages.chaiscript
					},
					"interpolation-punctuation": {
						pattern: /^\$\{|\}$/,
						alias: "punctuation"
					}
				}
			},
			string: /[\s\S]+/
		}
	} });
}
cil.displayName = "cil";
cil.aliases = [];
function cil(Prism$1) {
	Prism$1.languages.cil = {
		comment: /\/\/.*/,
		string: {
			pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
			greedy: true
		},
		directive: {
			pattern: /(^|\W)\.[a-z]+(?=\s)/,
			lookbehind: true,
			alias: "class-name"
		},
		variable: /\[[\w\.]+\]/,
		keyword: /\b(?:abstract|ansi|assembly|auto|autochar|beforefieldinit|bool|bstr|byvalstr|catch|char|cil|class|currency|date|decimal|default|enum|error|explicit|extends|extern|famandassem|family|famorassem|final(?:ly)?|float32|float64|hidebysig|u?int(?:8|16|32|64)?|iant|idispatch|implements|import|initonly|instance|interface|iunknown|literal|lpstr|lpstruct|lptstr|lpwstr|managed|method|native(?:Type)?|nested|newslot|object(?:ref)?|pinvokeimpl|private|privatescope|public|reqsecobj|rtspecialname|runtime|sealed|sequential|serializable|specialname|static|string|struct|syschar|tbstr|unicode|unmanagedexp|unsigned|value(?:type)?|variant|virtual|void)\b/,
		function: /\b(?:(?:constrained|no|readonly|tail|unaligned|volatile)\.)?(?:conv\.(?:[iu][1248]?|ovf\.[iu][1248]?(?:\.un)?|r\.un|r4|r8)|ldc\.(?:i4(?:\.\d+|\.[mM]1|\.s)?|i8|r4|r8)|ldelem(?:\.[iu][1248]?|\.r[48]|\.ref|a)?|ldind\.(?:[iu][1248]?|r[48]|ref)|stelem\.?(?:i[1248]?|r[48]|ref)?|stind\.(?:i[1248]?|r[48]|ref)?|end(?:fault|filter|finally)|ldarg(?:\.[0-3s]|a(?:\.s)?)?|ldloc(?:\.\d+|\.s)?|sub(?:\.ovf(?:\.un)?)?|mul(?:\.ovf(?:\.un)?)?|add(?:\.ovf(?:\.un)?)?|stloc(?:\.[0-3s])?|refany(?:type|val)|blt(?:\.un)?(?:\.s)?|ble(?:\.un)?(?:\.s)?|bgt(?:\.un)?(?:\.s)?|bge(?:\.un)?(?:\.s)?|unbox(?:\.any)?|init(?:blk|obj)|call(?:i|virt)?|brfalse(?:\.s)?|bne\.un(?:\.s)?|ldloca(?:\.s)?|brzero(?:\.s)?|brtrue(?:\.s)?|brnull(?:\.s)?|brinst(?:\.s)?|starg(?:\.s)?|leave(?:\.s)?|shr(?:\.un)?|rem(?:\.un)?|div(?:\.un)?|clt(?:\.un)?|alignment|castclass|ldvirtftn|beq(?:\.s)?|ckfinite|ldsflda|ldtoken|localloc|mkrefany|rethrow|cgt\.un|arglist|switch|stsfld|sizeof|newobj|newarr|ldsfld|ldnull|ldflda|isinst|throw|stobj|stfld|ldstr|ldobj|ldlen|ldftn|ldfld|cpobj|cpblk|break|br\.s|xor|shl|ret|pop|not|nop|neg|jmp|dup|cgt|ceq|box|and|or|br)\b/,
		boolean: /\b(?:false|true)\b/,
		number: /\b-?(?:0x[0-9a-f]+|\d+)(?:\.[0-9a-f]+)?\b/i,
		punctuation: /[{}[\];(),:=]|IL_[0-9A-Za-z]+/
	};
}
cilkc.displayName = "cilkc";
cilkc.aliases = ["cilk-c"];
function cilkc(Prism$1) {
	Prism$1.register(c$1);
	Prism$1.languages.cilkc = Prism$1.languages.insertBefore("c", "function", { "parallel-keyword": {
		pattern: /\bcilk_(?:for|reducer|s(?:cope|pawn|ync))\b/,
		alias: "keyword"
	} });
	Prism$1.languages["cilk-c"] = Prism$1.languages["cilkc"];
}
cilkcpp.displayName = "cilkcpp";
cilkcpp.aliases = ["cilk", "cilk-cpp"];
function cilkcpp(Prism$1) {
	Prism$1.register(cpp);
	Prism$1.languages.cilkcpp = Prism$1.languages.insertBefore("cpp", "function", { "parallel-keyword": {
		pattern: /\bcilk_(?:for|reducer|s(?:cope|pawn|ync))\b/,
		alias: "keyword"
	} });
	Prism$1.languages["cilk-cpp"] = Prism$1.languages["cilkcpp"];
	Prism$1.languages["cilk"] = Prism$1.languages["cilkcpp"];
}
clojure.displayName = "clojure";
clojure.aliases = [];
function clojure(Prism$1) {
	Prism$1.languages.clojure = {
		comment: {
			pattern: /;.*/,
			greedy: true
		},
		string: {
			pattern: /"(?:[^"\\]|\\.)*"/,
			greedy: true
		},
		char: /\\\w+/,
		symbol: {
			pattern: /(^|[\s()\[\]{},])::?[\w*+!?'<>=/.-]+/,
			lookbehind: true
		},
		keyword: {
			pattern: /(\()(?:-|->|->>|\.|\.\.|\*|\/|\+|<|<=|=|==|>|>=|accessor|agent|agent-errors|aget|alength|all-ns|alter|and|append-child|apply|array-map|aset|aset-boolean|aset-byte|aset-char|aset-double|aset-float|aset-int|aset-long|aset-short|assert|assoc|await|await-for|bean|binding|bit-and|bit-not|bit-or|bit-shift-left|bit-shift-right|bit-xor|boolean|branch\?|butlast|byte|cast|char|children|class|clear-agent-errors|comment|commute|comp|comparator|complement|concat|cond|conj|cons|constantly|construct-proxy|contains\?|count|create-ns|create-struct|cycle|dec|declare|def|def-|definline|definterface|defmacro|defmethod|defmulti|defn|defn-|defonce|defproject|defprotocol|defrecord|defstruct|deftype|deref|difference|disj|dissoc|distinct|do|doall|doc|dorun|doseq|dosync|dotimes|doto|double|down|drop|drop-while|edit|end\?|ensure|eval|every\?|false\?|ffirst|file-seq|filter|find|find-doc|find-ns|find-var|first|float|flush|fn|fnseq|for|frest|gensym|get|get-proxy-class|hash-map|hash-set|identical\?|identity|if|if-let|if-not|import|in-ns|inc|index|insert-child|insert-left|insert-right|inspect-table|inspect-tree|instance\?|int|interleave|intersection|into|into-array|iterate|join|key|keys|keyword|keyword\?|last|lazy-cat|lazy-cons|left|lefts|let|line-seq|list|list\*|load|load-file|locking|long|loop|macroexpand|macroexpand-1|make-array|make-node|map|map-invert|map\?|mapcat|max|max-key|memfn|merge|merge-with|meta|min|min-key|monitor-enter|name|namespace|neg\?|new|newline|next|nil\?|node|not|not-any\?|not-every\?|not=|ns|ns-imports|ns-interns|ns-map|ns-name|ns-publics|ns-refers|ns-resolve|ns-unmap|nth|nthrest|or|parse|partial|path|peek|pop|pos\?|pr|pr-str|print|print-str|println|println-str|prn|prn-str|project|proxy|proxy-mappings|quot|quote|rand|rand-int|range|re-find|re-groups|re-matcher|re-matches|re-pattern|re-seq|read|read-line|recur|reduce|ref|ref-set|refer|rem|remove|remove-method|remove-ns|rename|rename-keys|repeat|replace|replicate|resolve|rest|resultset-seq|reverse|rfirst|right|rights|root|rrest|rseq|second|select|select-keys|send|send-off|seq|seq-zip|seq\?|set|set!|short|slurp|some|sort|sort-by|sorted-map|sorted-map-by|sorted-set|special-symbol\?|split-at|split-with|str|string\?|struct|struct-map|subs|subvec|symbol|symbol\?|sync|take|take-nth|take-while|test|throw|time|to-array|to-array-2d|tree-seq|true\?|try|union|up|update-proxy|val|vals|var|var-get|var-set|var\?|vector|vector-zip|vector\?|when|when-first|when-let|when-not|with-local-vars|with-meta|with-open|with-out-str|xml-seq|xml-zip|zero\?|zipmap|zipper)(?=[\s)]|$)/,
			lookbehind: true
		},
		boolean: /\b(?:false|nil|true)\b/,
		number: {
			pattern: /(^|[^\w$@])(?:\d+(?:[/.]\d+)?(?:e[+-]?\d+)?|0x[a-f0-9]+|[1-9]\d?r[a-z0-9]+)[lmn]?(?![\w$@])/i,
			lookbehind: true
		},
		function: {
			pattern: /((?:^|[^'])\()[\w*+!?'<>=/.-]+(?=[\s)]|$)/,
			lookbehind: true
		},
		operator: /[#@^`~]/,
		punctuation: /[{}\[\](),]/
	};
}
cmake.displayName = "cmake";
cmake.aliases = [];
function cmake(Prism$1) {
	Prism$1.languages.cmake = {
		comment: /#.*/,
		string: {
			pattern: /"(?:[^\\"]|\\.)*"/,
			greedy: true,
			inside: { interpolation: {
				pattern: /\$\{(?:[^{}$]|\$\{[^{}$]*\})*\}/,
				inside: {
					punctuation: /\$\{|\}/,
					variable: /\w+/
				}
			} }
		},
		variable: /\b(?:CMAKE_\w+|\w+_(?:(?:BINARY|SOURCE)_DIR|DESCRIPTION|HOMEPAGE_URL|ROOT|VERSION(?:_MAJOR|_MINOR|_PATCH|_TWEAK)?)|(?:ANDROID|APPLE|BORLAND|BUILD_SHARED_LIBS|CACHE|CPACK_(?:ABSOLUTE_DESTINATION_FILES|COMPONENT_INCLUDE_TOPLEVEL_DIRECTORY|ERROR_ON_ABSOLUTE_INSTALL_DESTINATION|INCLUDE_TOPLEVEL_DIRECTORY|INSTALL_DEFAULT_DIRECTORY_PERMISSIONS|INSTALL_SCRIPT|PACKAGING_INSTALL_PREFIX|SET_DESTDIR|WARN_ON_ABSOLUTE_INSTALL_DESTINATION)|CTEST_(?:BINARY_DIRECTORY|BUILD_COMMAND|BUILD_NAME|BZR_COMMAND|BZR_UPDATE_OPTIONS|CHANGE_ID|CHECKOUT_COMMAND|CONFIGURATION_TYPE|CONFIGURE_COMMAND|COVERAGE_COMMAND|COVERAGE_EXTRA_FLAGS|CURL_OPTIONS|CUSTOM_(?:COVERAGE_EXCLUDE|ERROR_EXCEPTION|ERROR_MATCH|ERROR_POST_CONTEXT|ERROR_PRE_CONTEXT|MAXIMUM_FAILED_TEST_OUTPUT_SIZE|MAXIMUM_NUMBER_OF_(?:ERRORS|WARNINGS)|MAXIMUM_PASSED_TEST_OUTPUT_SIZE|MEMCHECK_IGNORE|POST_MEMCHECK|POST_TEST|PRE_MEMCHECK|PRE_TEST|TESTS_IGNORE|WARNING_EXCEPTION|WARNING_MATCH)|CVS_CHECKOUT|CVS_COMMAND|CVS_UPDATE_OPTIONS|DROP_LOCATION|DROP_METHOD|DROP_SITE|DROP_SITE_CDASH|DROP_SITE_PASSWORD|DROP_SITE_USER|EXTRA_COVERAGE_GLOB|GIT_COMMAND|GIT_INIT_SUBMODULES|GIT_UPDATE_CUSTOM|GIT_UPDATE_OPTIONS|HG_COMMAND|HG_UPDATE_OPTIONS|LABELS_FOR_SUBPROJECTS|MEMORYCHECK_(?:COMMAND|COMMAND_OPTIONS|SANITIZER_OPTIONS|SUPPRESSIONS_FILE|TYPE)|NIGHTLY_START_TIME|P4_CLIENT|P4_COMMAND|P4_OPTIONS|P4_UPDATE_OPTIONS|RUN_CURRENT_SCRIPT|SCP_COMMAND|SITE|SOURCE_DIRECTORY|SUBMIT_URL|SVN_COMMAND|SVN_OPTIONS|SVN_UPDATE_OPTIONS|TEST_LOAD|TEST_TIMEOUT|TRIGGER_SITE|UPDATE_COMMAND|UPDATE_OPTIONS|UPDATE_VERSION_ONLY|USE_LAUNCHERS)|CYGWIN|ENV|EXECUTABLE_OUTPUT_PATH|GHS-MULTI|IOS|LIBRARY_OUTPUT_PATH|MINGW|MSVC(?:10|11|12|14|60|70|71|80|90|_IDE|_TOOLSET_VERSION|_VERSION)?|MSYS|PROJECT_NAME|UNIX|WIN32|WINCE|WINDOWS_PHONE|WINDOWS_STORE|XCODE))\b/,
		property: /\b(?:cxx_\w+|(?:ARCHIVE_OUTPUT_(?:DIRECTORY|NAME)|COMPILE_DEFINITIONS|COMPILE_PDB_NAME|COMPILE_PDB_OUTPUT_DIRECTORY|EXCLUDE_FROM_DEFAULT_BUILD|IMPORTED_(?:IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_LANGUAGES|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|NO_SONAME|OBJECTS|SONAME)|INTERPROCEDURAL_OPTIMIZATION|LIBRARY_OUTPUT_DIRECTORY|LIBRARY_OUTPUT_NAME|LINK_FLAGS|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|MAP_IMPORTED_CONFIG|OSX_ARCHITECTURES|OUTPUT_NAME|PDB_NAME|PDB_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_NAME|STATIC_LIBRARY_FLAGS|VS_CSHARP|VS_DOTNET_REFERENCEPROP|VS_DOTNET_REFERENCE|VS_GLOBAL_SECTION_POST|VS_GLOBAL_SECTION_PRE|VS_GLOBAL|XCODE_ATTRIBUTE)_\w+|\w+_(?:CLANG_TIDY|COMPILER_LAUNCHER|CPPCHECK|CPPLINT|INCLUDE_WHAT_YOU_USE|OUTPUT_NAME|POSTFIX|VISIBILITY_PRESET)|ABSTRACT|ADDITIONAL_MAKE_CLEAN_FILES|ADVANCED|ALIASED_TARGET|ALLOW_DUPLICATE_CUSTOM_TARGETS|ANDROID_(?:ANT_ADDITIONAL_OPTIONS|API|API_MIN|ARCH|ASSETS_DIRECTORIES|GUI|JAR_DEPENDENCIES|NATIVE_LIB_DEPENDENCIES|NATIVE_LIB_DIRECTORIES|PROCESS_MAX|PROGUARD|PROGUARD_CONFIG_PATH|SECURE_PROPS_PATH|SKIP_ANT_STEP|STL_TYPE)|ARCHIVE_OUTPUT_DIRECTORY|ATTACHED_FILES|ATTACHED_FILES_ON_FAIL|AUTOGEN_(?:BUILD_DIR|ORIGIN_DEPENDS|PARALLEL|SOURCE_GROUP|TARGETS_FOLDER|TARGET_DEPENDS)|AUTOMOC|AUTOMOC_(?:COMPILER_PREDEFINES|DEPEND_FILTERS|EXECUTABLE|MACRO_NAMES|MOC_OPTIONS|SOURCE_GROUP|TARGETS_FOLDER)|AUTORCC|AUTORCC_EXECUTABLE|AUTORCC_OPTIONS|AUTORCC_SOURCE_GROUP|AUTOUIC|AUTOUIC_EXECUTABLE|AUTOUIC_OPTIONS|AUTOUIC_SEARCH_PATHS|BINARY_DIR|BUILDSYSTEM_TARGETS|BUILD_RPATH|BUILD_RPATH_USE_ORIGIN|BUILD_WITH_INSTALL_NAME_DIR|BUILD_WITH_INSTALL_RPATH|BUNDLE|BUNDLE_EXTENSION|CACHE_VARIABLES|CLEAN_NO_CUSTOM|COMMON_LANGUAGE_RUNTIME|COMPATIBLE_INTERFACE_(?:BOOL|NUMBER_MAX|NUMBER_MIN|STRING)|COMPILE_(?:DEFINITIONS|FEATURES|FLAGS|OPTIONS|PDB_NAME|PDB_OUTPUT_DIRECTORY)|COST|CPACK_DESKTOP_SHORTCUTS|CPACK_NEVER_OVERWRITE|CPACK_PERMANENT|CPACK_STARTUP_SHORTCUTS|CPACK_START_MENU_SHORTCUTS|CPACK_WIX_ACL|CROSSCOMPILING_EMULATOR|CUDA_EXTENSIONS|CUDA_PTX_COMPILATION|CUDA_RESOLVE_DEVICE_SYMBOLS|CUDA_SEPARABLE_COMPILATION|CUDA_STANDARD|CUDA_STANDARD_REQUIRED|CXX_EXTENSIONS|CXX_STANDARD|CXX_STANDARD_REQUIRED|C_EXTENSIONS|C_STANDARD|C_STANDARD_REQUIRED|DEBUG_CONFIGURATIONS|DEFINE_SYMBOL|DEFINITIONS|DEPENDS|DEPLOYMENT_ADDITIONAL_FILES|DEPLOYMENT_REMOTE_DIRECTORY|DISABLED|DISABLED_FEATURES|ECLIPSE_EXTRA_CPROJECT_CONTENTS|ECLIPSE_EXTRA_NATURES|ENABLED_FEATURES|ENABLED_LANGUAGES|ENABLE_EXPORTS|ENVIRONMENT|EXCLUDE_FROM_ALL|EXCLUDE_FROM_DEFAULT_BUILD|EXPORT_NAME|EXPORT_PROPERTIES|EXTERNAL_OBJECT|EchoString|FAIL_REGULAR_EXPRESSION|FIND_LIBRARY_USE_LIB32_PATHS|FIND_LIBRARY_USE_LIB64_PATHS|FIND_LIBRARY_USE_LIBX32_PATHS|FIND_LIBRARY_USE_OPENBSD_VERSIONING|FIXTURES_CLEANUP|FIXTURES_REQUIRED|FIXTURES_SETUP|FOLDER|FRAMEWORK|Fortran_FORMAT|Fortran_MODULE_DIRECTORY|GENERATED|GENERATOR_FILE_NAME|GENERATOR_IS_MULTI_CONFIG|GHS_INTEGRITY_APP|GHS_NO_SOURCE_GROUP_FILE|GLOBAL_DEPENDS_DEBUG_MODE|GLOBAL_DEPENDS_NO_CYCLES|GNUtoMS|HAS_CXX|HEADER_FILE_ONLY|HELPSTRING|IMPLICIT_DEPENDS_INCLUDE_TRANSFORM|IMPORTED|IMPORTED_(?:COMMON_LANGUAGE_RUNTIME|CONFIGURATIONS|GLOBAL|IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_(?:LANGUAGES|LIBRARIES|MULTIPLICITY)|LOCATION|NO_SONAME|OBJECTS|SONAME)|IMPORT_PREFIX|IMPORT_SUFFIX|INCLUDE_DIRECTORIES|INCLUDE_REGULAR_EXPRESSION|INSTALL_NAME_DIR|INSTALL_RPATH|INSTALL_RPATH_USE_LINK_PATH|INTERFACE_(?:AUTOUIC_OPTIONS|COMPILE_DEFINITIONS|COMPILE_FEATURES|COMPILE_OPTIONS|INCLUDE_DIRECTORIES|LINK_DEPENDS|LINK_DIRECTORIES|LINK_LIBRARIES|LINK_OPTIONS|POSITION_INDEPENDENT_CODE|SOURCES|SYSTEM_INCLUDE_DIRECTORIES)|INTERPROCEDURAL_OPTIMIZATION|IN_TRY_COMPILE|IOS_INSTALL_COMBINED|JOB_POOLS|JOB_POOL_COMPILE|JOB_POOL_LINK|KEEP_EXTENSION|LABELS|LANGUAGE|LIBRARY_OUTPUT_DIRECTORY|LINKER_LANGUAGE|LINK_(?:DEPENDS|DEPENDS_NO_SHARED|DIRECTORIES|FLAGS|INTERFACE_LIBRARIES|INTERFACE_MULTIPLICITY|LIBRARIES|OPTIONS|SEARCH_END_STATIC|SEARCH_START_STATIC|WHAT_YOU_USE)|LISTFILE_STACK|LOCATION|MACOSX_BUNDLE|MACOSX_BUNDLE_INFO_PLIST|MACOSX_FRAMEWORK_INFO_PLIST|MACOSX_PACKAGE_LOCATION|MACOSX_RPATH|MACROS|MANUALLY_ADDED_DEPENDENCIES|MEASUREMENT|MODIFIED|NAME|NO_SONAME|NO_SYSTEM_FROM_IMPORTED|OBJECT_DEPENDS|OBJECT_OUTPUTS|OSX_ARCHITECTURES|OUTPUT_NAME|PACKAGES_FOUND|PACKAGES_NOT_FOUND|PARENT_DIRECTORY|PASS_REGULAR_EXPRESSION|PDB_NAME|PDB_OUTPUT_DIRECTORY|POSITION_INDEPENDENT_CODE|POST_INSTALL_SCRIPT|PREDEFINED_TARGETS_FOLDER|PREFIX|PRE_INSTALL_SCRIPT|PRIVATE_HEADER|PROCESSORS|PROCESSOR_AFFINITY|PROJECT_LABEL|PUBLIC_HEADER|REPORT_UNDEFINED_PROPERTIES|REQUIRED_FILES|RESOURCE|RESOURCE_LOCK|RULE_LAUNCH_COMPILE|RULE_LAUNCH_CUSTOM|RULE_LAUNCH_LINK|RULE_MESSAGES|RUNTIME_OUTPUT_DIRECTORY|RUN_SERIAL|SKIP_AUTOGEN|SKIP_AUTOMOC|SKIP_AUTORCC|SKIP_AUTOUIC|SKIP_BUILD_RPATH|SKIP_RETURN_CODE|SOURCES|SOURCE_DIR|SOVERSION|STATIC_LIBRARY_FLAGS|STATIC_LIBRARY_OPTIONS|STRINGS|SUBDIRECTORIES|SUFFIX|SYMBOLIC|TARGET_ARCHIVES_MAY_BE_SHARED_LIBS|TARGET_MESSAGES|TARGET_SUPPORTS_SHARED_LIBS|TESTS|TEST_INCLUDE_FILE|TEST_INCLUDE_FILES|TIMEOUT|TIMEOUT_AFTER_MATCH|TYPE|USE_FOLDERS|VALUE|VARIABLES|VERSION|VISIBILITY_INLINES_HIDDEN|VS_(?:CONFIGURATION_TYPE|COPY_TO_OUT_DIR|DEBUGGER_(?:COMMAND|COMMAND_ARGUMENTS|ENVIRONMENT|WORKING_DIRECTORY)|DEPLOYMENT_CONTENT|DEPLOYMENT_LOCATION|DOTNET_REFERENCES|DOTNET_REFERENCES_COPY_LOCAL|INCLUDE_IN_VSIX|IOT_STARTUP_TASK|KEYWORD|RESOURCE_GENERATOR|SCC_AUXPATH|SCC_LOCALPATH|SCC_PROJECTNAME|SCC_PROVIDER|SDK_REFERENCES|SHADER_(?:DISABLE_OPTIMIZATIONS|ENABLE_DEBUG|ENTRYPOINT|FLAGS|MODEL|OBJECT_FILE_NAME|OUTPUT_HEADER_FILE|TYPE|VARIABLE_NAME)|STARTUP_PROJECT|TOOL_OVERRIDE|USER_PROPS|WINRT_COMPONENT|WINRT_EXTENSIONS|WINRT_REFERENCES|XAML_TYPE)|WILL_FAIL|WIN32_EXECUTABLE|WINDOWS_EXPORT_ALL_SYMBOLS|WORKING_DIRECTORY|WRAP_EXCLUDE|XCODE_(?:EMIT_EFFECTIVE_PLATFORM_NAME|EXPLICIT_FILE_TYPE|FILE_ATTRIBUTES|LAST_KNOWN_FILE_TYPE|PRODUCT_TYPE|SCHEME_(?:ADDRESS_SANITIZER|ADDRESS_SANITIZER_USE_AFTER_RETURN|ARGUMENTS|DISABLE_MAIN_THREAD_CHECKER|DYNAMIC_LIBRARY_LOADS|DYNAMIC_LINKER_API_USAGE|ENVIRONMENT|EXECUTABLE|GUARD_MALLOC|MAIN_THREAD_CHECKER_STOP|MALLOC_GUARD_EDGES|MALLOC_SCRIBBLE|MALLOC_STACK|THREAD_SANITIZER(?:_STOP)?|UNDEFINED_BEHAVIOUR_SANITIZER(?:_STOP)?|ZOMBIE_OBJECTS))|XCTEST)\b/,
		keyword: /\b(?:add_compile_definitions|add_compile_options|add_custom_command|add_custom_target|add_definitions|add_dependencies|add_executable|add_library|add_link_options|add_subdirectory|add_test|aux_source_directory|break|build_command|build_name|cmake_host_system_information|cmake_minimum_required|cmake_parse_arguments|cmake_policy|configure_file|continue|create_test_sourcelist|ctest_build|ctest_configure|ctest_coverage|ctest_empty_binary_directory|ctest_memcheck|ctest_read_custom_files|ctest_run_script|ctest_sleep|ctest_start|ctest_submit|ctest_test|ctest_update|ctest_upload|define_property|else|elseif|enable_language|enable_testing|endforeach|endfunction|endif|endmacro|endwhile|exec_program|execute_process|export|export_library_dependencies|file|find_file|find_library|find_package|find_path|find_program|fltk_wrap_ui|foreach|function|get_cmake_property|get_directory_property|get_filename_component|get_property|get_source_file_property|get_target_property|get_test_property|if|include|include_directories|include_external_msproject|include_guard|include_regular_expression|install|install_files|install_programs|install_targets|link_directories|link_libraries|list|load_cache|load_command|macro|make_directory|mark_as_advanced|math|message|option|output_required_files|project|qt_wrap_cpp|qt_wrap_ui|remove|remove_definitions|return|separate_arguments|set|set_directory_properties|set_property|set_source_files_properties|set_target_properties|set_tests_properties|site_name|source_group|string|subdir_depends|subdirs|target_compile_definitions|target_compile_features|target_compile_options|target_include_directories|target_link_directories|target_link_libraries|target_link_options|target_sources|try_compile|try_run|unset|use_mangled_mesa|utility_source|variable_requires|variable_watch|while|write_file)(?=\s*\()\b/,
		boolean: /\b(?:FALSE|OFF|ON|TRUE)\b/,
		namespace: /\b(?:INTERFACE|PRIVATE|PROPERTIES|PUBLIC|SHARED|STATIC|TARGET_OBJECTS)\b/,
		operator: /\b(?:AND|DEFINED|EQUAL|GREATER|LESS|MATCHES|NOT|OR|STREQUAL|STRGREATER|STRLESS|VERSION_EQUAL|VERSION_GREATER|VERSION_LESS)\b/,
		inserted: {
			pattern: /\b\w+::\w+\b/,
			alias: "class-name"
		},
		number: /\b\d+(?:\.\d+)*\b/,
		function: /\b[a-z_]\w*(?=\s*\()\b/i,
		punctuation: /[()>}]|\$[<{]/
	};
}
cobol.displayName = "cobol";
cobol.aliases = [];
function cobol(Prism$1) {
	Prism$1.languages.cobol = {
		comment: {
			pattern: /\*>.*|(^[ \t]*)\*.*/m,
			lookbehind: true,
			greedy: true
		},
		string: {
			pattern: /[xzgn]?(?:"(?:[^\r\n"]|"")*"(?!")|'(?:[^\r\n']|'')*'(?!'))/i,
			greedy: true
		},
		level: {
			pattern: /(^[ \t]*)\d+\b/m,
			lookbehind: true,
			greedy: true,
			alias: "number"
		},
		"class-name": {
			pattern: /(\bpic(?:ture)?\s+)(?:(?:[-\w$/,:*+<>]|\.(?!\s|$))(?:\(\d+\))?)+/i,
			lookbehind: true,
			inside: {
				number: {
					pattern: /(\()\d+/,
					lookbehind: true
				},
				punctuation: /[()]/
			}
		},
		keyword: {
			pattern: /(^|[^\w-])(?:ABORT|ACCEPT|ACCESS|ADD|ADDRESS|ADVANCING|AFTER|ALIGNED|ALL|ALPHABET|ALPHABETIC|ALPHABETIC-LOWER|ALPHABETIC-UPPER|ALPHANUMERIC|ALPHANUMERIC-EDITED|ALSO|ALTER|ALTERNATE|ANY|ARE|AREA|AREAS|AS|ASCENDING|ASCII|ASSIGN|ASSOCIATED-DATA|ASSOCIATED-DATA-LENGTH|AT|ATTRIBUTE|AUTHOR|AUTO|AUTO-SKIP|BACKGROUND-COLOR|BACKGROUND-COLOUR|BASIS|BEEP|BEFORE|BEGINNING|BELL|BINARY|BIT|BLANK|BLINK|BLOCK|BOTTOM|BOUNDS|BY|BYFUNCTION|BYTITLE|CALL|CANCEL|CAPABLE|CCSVERSION|CD|CF|CH|CHAINING|CHANGED|CHANNEL|CHARACTER|CHARACTERS|CLASS|CLASS-ID|CLOCK-UNITS|CLOSE|CLOSE-DISPOSITION|COBOL|CODE|CODE-SET|COL|COLLATING|COLUMN|COM-REG|COMMA|COMMITMENT|COMMON|COMMUNICATION|COMP|COMP-1|COMP-2|COMP-3|COMP-4|COMP-5|COMPUTATIONAL|COMPUTATIONAL-1|COMPUTATIONAL-2|COMPUTATIONAL-3|COMPUTATIONAL-4|COMPUTATIONAL-5|COMPUTE|CONFIGURATION|CONTAINS|CONTENT|CONTINUE|CONTROL|CONTROL-POINT|CONTROLS|CONVENTION|CONVERTING|COPY|CORR|CORRESPONDING|COUNT|CRUNCH|CURRENCY|CURSOR|DATA|DATA-BASE|DATE|DATE-COMPILED|DATE-WRITTEN|DAY|DAY-OF-WEEK|DBCS|DE|DEBUG-CONTENTS|DEBUG-ITEM|DEBUG-LINE|DEBUG-NAME|DEBUG-SUB-1|DEBUG-SUB-2|DEBUG-SUB-3|DEBUGGING|DECIMAL-POINT|DECLARATIVES|DEFAULT|DEFAULT-DISPLAY|DEFINITION|DELETE|DELIMITED|DELIMITER|DEPENDING|DESCENDING|DESTINATION|DETAIL|DFHRESP|DFHVALUE|DISABLE|DISK|DISPLAY|DISPLAY-1|DIVIDE|DIVISION|DONTCARE|DOUBLE|DOWN|DUPLICATES|DYNAMIC|EBCDIC|EGCS|EGI|ELSE|EMI|EMPTY-CHECK|ENABLE|END|END-ACCEPT|END-ADD|END-CALL|END-COMPUTE|END-DELETE|END-DIVIDE|END-EVALUATE|END-IF|END-MULTIPLY|END-OF-PAGE|END-PERFORM|END-READ|END-RECEIVE|END-RETURN|END-REWRITE|END-SEARCH|END-START|END-STRING|END-SUBTRACT|END-UNSTRING|END-WRITE|ENDING|ENTER|ENTRY|ENTRY-PROCEDURE|ENVIRONMENT|EOL|EOP|EOS|ERASE|ERROR|ESCAPE|ESI|EVALUATE|EVENT|EVERY|EXCEPTION|EXCLUSIVE|EXHIBIT|EXIT|EXPORT|EXTEND|EXTENDED|EXTERNAL|FD|FILE|FILE-CONTROL|FILLER|FINAL|FIRST|FOOTING|FOR|FOREGROUND-COLOR|FOREGROUND-COLOUR|FROM|FULL|FUNCTION|FUNCTION-POINTER|FUNCTIONNAME|GENERATE|GIVING|GLOBAL|GO|GOBACK|GRID|GROUP|HEADING|HIGH-VALUE|HIGH-VALUES|HIGHLIGHT|I-O|I-O-CONTROL|ID|IDENTIFICATION|IF|IMPLICIT|IMPORT|IN|INDEX|INDEXED|INDICATE|INITIAL|INITIALIZE|INITIATE|INPUT|INPUT-OUTPUT|INSPECT|INSTALLATION|INTEGER|INTO|INVALID|INVOKE|IS|JUST|JUSTIFIED|KANJI|KEPT|KEY|KEYBOARD|LABEL|LANGUAGE|LAST|LB|LD|LEADING|LEFT|LEFTLINE|LENGTH|LENGTH-CHECK|LIBACCESS|LIBPARAMETER|LIBRARY|LIMIT|LIMITS|LINAGE|LINAGE-COUNTER|LINE|LINE-COUNTER|LINES|LINKAGE|LIST|LOCAL|LOCAL-STORAGE|LOCK|LONG-DATE|LONG-TIME|LOW-VALUE|LOW-VALUES|LOWER|LOWLIGHT|MEMORY|MERGE|MESSAGE|MMDDYYYY|MODE|MODULES|MORE-LABELS|MOVE|MULTIPLE|MULTIPLY|NAMED|NATIONAL|NATIONAL-EDITED|NATIVE|NEGATIVE|NETWORK|NEXT|NO|NO-ECHO|NULL|NULLS|NUMBER|NUMERIC|NUMERIC-DATE|NUMERIC-EDITED|NUMERIC-TIME|OBJECT-COMPUTER|OCCURS|ODT|OF|OFF|OMITTED|ON|OPEN|OPTIONAL|ORDER|ORDERLY|ORGANIZATION|OTHER|OUTPUT|OVERFLOW|OVERLINE|OWN|PACKED-DECIMAL|PADDING|PAGE|PAGE-COUNTER|PASSWORD|PERFORM|PF|PH|PIC|PICTURE|PLUS|POINTER|PORT|POSITION|POSITIVE|PRINTER|PRINTING|PRIVATE|PROCEDURE|PROCEDURE-POINTER|PROCEDURES|PROCEED|PROCESS|PROGRAM|PROGRAM-ID|PROGRAM-LIBRARY|PROMPT|PURGE|QUEUE|QUOTE|QUOTES|RANDOM|RD|READ|READER|REAL|RECEIVE|RECEIVED|RECORD|RECORDING|RECORDS|RECURSIVE|REDEFINES|REEL|REF|REFERENCE|REFERENCES|RELATIVE|RELEASE|REMAINDER|REMARKS|REMOTE|REMOVAL|REMOVE|RENAMES|REPLACE|REPLACING|REPORT|REPORTING|REPORTS|REQUIRED|RERUN|RESERVE|RESET|RETURN|RETURN-CODE|RETURNING|REVERSE-VIDEO|REVERSED|REWIND|REWRITE|RF|RH|RIGHT|ROUNDED|RUN|SAME|SAVE|SCREEN|SD|SEARCH|SECTION|SECURE|SECURITY|SEGMENT|SEGMENT-LIMIT|SELECT|SEND|SENTENCE|SEPARATE|SEQUENCE|SEQUENTIAL|SET|SHARED|SHAREDBYALL|SHAREDBYRUNUNIT|SHARING|SHIFT-IN|SHIFT-OUT|SHORT-DATE|SIGN|SIZE|SORT|SORT-CONTROL|SORT-CORE-SIZE|SORT-FILE-SIZE|SORT-MERGE|SORT-MESSAGE|SORT-MODE-SIZE|SORT-RETURN|SOURCE|SOURCE-COMPUTER|SPACE|SPACES|SPECIAL-NAMES|STANDARD|STANDARD-1|STANDARD-2|START|STATUS|STOP|STRING|SUB-QUEUE-1|SUB-QUEUE-2|SUB-QUEUE-3|SUBTRACT|SUM|SUPPRESS|SYMBOL|SYMBOLIC|SYNC|SYNCHRONIZED|TABLE|TALLY|TALLYING|TAPE|TASK|TERMINAL|TERMINATE|TEST|TEXT|THEN|THREAD|THREAD-LOCAL|THROUGH|THRU|TIME|TIMER|TIMES|TITLE|TO|TODAYS-DATE|TODAYS-NAME|TOP|TRAILING|TRUNCATED|TYPE|TYPEDEF|UNDERLINE|UNIT|UNSTRING|UNTIL|UP|UPON|USAGE|USE|USING|VALUE|VALUES|VARYING|VIRTUAL|WAIT|WHEN|WHEN-COMPILED|WITH|WORDS|WORKING-STORAGE|WRITE|YEAR|YYYYDDD|YYYYMMDD|ZERO-FILL|ZEROES|ZEROS)(?![\w-])/i,
			lookbehind: true
		},
		boolean: {
			pattern: /(^|[^\w-])(?:false|true)(?![\w-])/i,
			lookbehind: true
		},
		number: {
			pattern: /(^|[^\w-])(?:[+-]?(?:(?:\d+(?:[.,]\d+)?|[.,]\d+)(?:e[+-]?\d+)?|zero))(?![\w-])/i,
			lookbehind: true
		},
		operator: [/<>|[<>]=?|[=+*/&]/, {
			pattern: /(^|[^\w-])(?:-|and|equal|greater|less|not|or|than)(?![\w-])/i,
			lookbehind: true
		}],
		punctuation: /[.:,()]/
	};
}
coffeescript.displayName = "coffeescript";
coffeescript.aliases = ["coffee"];
function coffeescript(Prism$1) {
	Prism$1.register(javascript);
	(function(Prism$2) {
		var comment$2 = /#(?!\{).+/;
		var interpolation = {
			pattern: /#\{[^}]+\}/,
			alias: "variable"
		};
		Prism$2.languages.coffeescript = Prism$2.languages.extend("javascript", {
			comment: comment$2,
			string: [{
				pattern: /'(?:\\[\s\S]|[^\\'])*'/,
				greedy: true
			}, {
				pattern: /"(?:\\[\s\S]|[^\\"])*"/,
				greedy: true,
				inside: { interpolation }
			}],
			keyword: /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
			"class-member": {
				pattern: /@(?!\d)\w+/,
				alias: "variable"
			}
		});
		Prism$2.languages.insertBefore("coffeescript", "comment", {
			"multiline-comment": {
				pattern: /###[\s\S]+?###/,
				alias: "comment"
			},
			"block-regex": {
				pattern: /\/{3}[\s\S]*?\/{3}/,
				alias: "regex",
				inside: {
					comment: comment$2,
					interpolation
				}
			}
		});
		Prism$2.languages.insertBefore("coffeescript", "string", {
			"inline-javascript": {
				pattern: /`(?:\\[\s\S]|[^\\`])*`/,
				inside: {
					delimiter: {
						pattern: /^`|`$/,
						alias: "punctuation"
					},
					script: {
						pattern: /[\s\S]+/,
						alias: "language-javascript",
						inside: Prism$2.languages.javascript
					}
				}
			},
			"multiline-string": [{
				pattern: /'''[\s\S]*?'''/,
				greedy: true,
				alias: "string"
			}, {
				pattern: /"""[\s\S]*?"""/,
				greedy: true,
				alias: "string",
				inside: { interpolation }
			}]
		});
		Prism$2.languages.insertBefore("coffeescript", "keyword", { property: /(?!\d)\w+(?=\s*:(?!:))/ });
		delete Prism$2.languages.coffeescript["template-string"];
		Prism$2.languages.coffee = Prism$2.languages.coffeescript;
	})(Prism$1);
}
concurnas.displayName = "concurnas";
concurnas.aliases = ["conc"];
function concurnas(Prism$1) {
	Prism$1.languages.concurnas = {
		comment: {
			pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*)/,
			lookbehind: true,
			greedy: true
		},
		langext: {
			pattern: /\b\w+\s*\|\|[\s\S]+?\|\|/,
			greedy: true,
			inside: {
				"class-name": /^\w+/,
				string: {
					pattern: /(^\s*\|\|)[\s\S]+(?=\|\|$)/,
					lookbehind: true
				},
				punctuation: /\|\|/
			}
		},
		function: {
			pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/,
			lookbehind: true
		},
		keyword: /\b(?:abstract|actor|also|annotation|assert|async|await|bool|boolean|break|byte|case|catch|changed|char|class|closed|constant|continue|def|default|del|double|elif|else|enum|every|extends|false|finally|float|for|from|global|gpudef|gpukernel|if|import|in|init|inject|int|lambda|local|long|loop|match|new|nodefault|null|of|onchange|open|out|override|package|parfor|parforsync|post|pre|private|protected|provide|provider|public|return|shared|short|single|size_t|sizeof|super|sync|this|throw|trait|trans|transient|true|try|typedef|unchecked|using|val|var|void|while|with)\b/,
		boolean: /\b(?:false|true)\b/,
		number: /\b0b[01][01_]*L?\b|\b0x(?:[\da-f_]*\.)?[\da-f_p+-]+\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfls]?/i,
		punctuation: /[{}[\];(),.:]/,
		operator: /<==|>==|=>|->|<-|<>|&==|&<>|\?:?|\.\?|\+\+|--|[-+*/=<>]=?|[!^~]|\b(?:and|as|band|bor|bxor|comp|is|isnot|mod|or)\b=?/,
		annotation: {
			pattern: /@(?:\w+:)?(?:\w+|\[[^\]]+\])?/,
			alias: "builtin"
		}
	};
	Prism$1.languages.insertBefore("concurnas", "langext", {
		"regex-literal": {
			pattern: /\br("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
			greedy: true,
			inside: {
				interpolation: {
					pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
					lookbehind: true,
					inside: Prism$1.languages.concurnas
				},
				regex: /[\s\S]+/
			}
		},
		"string-literal": {
			pattern: /(?:\B|\bs)("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
			greedy: true,
			inside: {
				interpolation: {
					pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
					lookbehind: true,
					inside: Prism$1.languages.concurnas
				},
				string: /[\s\S]+/
			}
		}
	});
	Prism$1.languages.conc = Prism$1.languages.concurnas;
}
csp.displayName = "csp";
csp.aliases = [];
function csp(Prism$1) {
	(function(Prism$2) {
		function value(source) {
			return RegExp(/([ \t])/.source + "(?:" + source + ")" + /(?=[\s;]|$)/.source, "i");
		}
		Prism$2.languages.csp = {
			directive: {
				pattern: /(^|[\s;])(?:base-uri|block-all-mixed-content|(?:child|connect|default|font|frame|img|manifest|media|object|prefetch|script|style|worker)-src|disown-opener|form-action|frame-(?:ancestors|options)|input-protection(?:-(?:clip|selectors))?|navigate-to|plugin-types|policy-uri|referrer|reflected-xss|report-(?:to|uri)|require-sri-for|sandbox|(?:script|style)-src-(?:attr|elem)|upgrade-insecure-requests)(?=[\s;]|$)/i,
				lookbehind: true,
				alias: "property"
			},
			scheme: {
				pattern: value(/[a-z][a-z0-9.+-]*:/.source),
				lookbehind: true
			},
			none: {
				pattern: value(/'none'/.source),
				lookbehind: true,
				alias: "keyword"
			},
			nonce: {
				pattern: value(/'nonce-[-+/\w=]+'/.source),
				lookbehind: true,
				alias: "number"
			},
			hash: {
				pattern: value(/'sha(?:256|384|512)-[-+/\w=]+'/.source),
				lookbehind: true,
				alias: "number"
			},
			host: {
				pattern: value(/[a-z][a-z0-9.+-]*:\/\/[^\s;,']*/.source + "|" + /\*[^\s;,']*/.source + "|" + /[a-z0-9-]+(?:\.[a-z0-9-]+)+(?::[\d*]+)?(?:\/[^\s;,']*)?/.source),
				lookbehind: true,
				alias: "url",
				inside: { important: /\*/ }
			},
			keyword: [{
				pattern: value(/'unsafe-[a-z-]+'/.source),
				lookbehind: true,
				alias: "unsafe"
			}, {
				pattern: value(/'[a-z-]+'/.source),
				lookbehind: true,
				alias: "safe"
			}],
			punctuation: /;/
		};
	})(Prism$1);
}
cooklang.displayName = "cooklang";
cooklang.aliases = [];
function cooklang(Prism$1) {
	(function(Prism$2) {
		var single_token_suffix = /(?:(?!\s)[\d$+<=a-zA-Z\x80-\uFFFF])+/.source;
		var multi_token_infix = /[^{}@#]+/.source;
		var multi_token_suffix = /\{[^}#@]*\}/.source;
		var multi_token = multi_token_infix + multi_token_suffix;
		var timer_units = /(?:h|hours|hrs|m|min|minutes)/.source;
		var amount_group_impl = {
			pattern: /\{[^{}]*\}/,
			inside: {
				amount: {
					pattern: /([\{|])[^{}|*%]+/,
					lookbehind: true,
					alias: "number"
				},
				unit: {
					pattern: /(%)[^}]+/,
					lookbehind: true,
					alias: "symbol"
				},
				"servings-scaler": {
					pattern: /\*/,
					alias: "operator"
				},
				"servings-alternative-separator": {
					pattern: /\|/,
					alias: "operator"
				},
				"unit-separator": {
					pattern: /(?:%|(\*)%)/,
					lookbehind: true,
					alias: "operator"
				},
				punctuation: /[{}]/
			}
		};
		Prism$2.languages.cooklang = {
			comment: {
				pattern: /\[-[\s\S]*?-\]|--.*/,
				greedy: true
			},
			meta: {
				pattern: />>.*:.*/,
				inside: { property: {
					pattern: /(>>\s*)[^\s:](?:[^:]*[^\s:])?/,
					lookbehind: true
				} }
			},
			"cookware-group": {
				pattern: new RegExp("#(?:" + multi_token + "|" + single_token_suffix + ")"),
				inside: {
					cookware: {
						pattern: new RegExp("(^#)(?:" + multi_token_infix + ")"),
						lookbehind: true,
						alias: "variable"
					},
					"cookware-keyword": {
						pattern: /^#/,
						alias: "keyword"
					},
					"quantity-group": {
						pattern: new RegExp(/\{[^{}@#]*\}/),
						inside: {
							quantity: {
								pattern: new RegExp(/(^\{)/.source + multi_token_infix),
								lookbehind: true,
								alias: "number"
							},
							punctuation: /[{}]/
						}
					}
				}
			},
			"ingredient-group": {
				pattern: new RegExp("@(?:" + multi_token + "|" + single_token_suffix + ")"),
				inside: {
					ingredient: {
						pattern: new RegExp("(^@)(?:" + multi_token_infix + ")"),
						lookbehind: true,
						alias: "variable"
					},
					"ingredient-keyword": {
						pattern: /^@/,
						alias: "keyword"
					},
					"amount-group": amount_group_impl
				}
			},
			"timer-group": {
				pattern: /~(?!\s)[^@#~{}]*\{[^{}]*\}/,
				inside: {
					timer: {
						pattern: /(^~)[^{]+/,
						lookbehind: true,
						alias: "variable"
					},
					"duration-group": {
						pattern: /\{[^{}]*\}/,
						inside: {
							punctuation: /[{}]/,
							unit: {
								pattern: new RegExp(/(%\s*)/.source + timer_units + /\b/.source),
								lookbehind: true,
								alias: "symbol"
							},
							operator: /%/,
							duration: {
								pattern: /\d+/,
								alias: "number"
							}
						}
					},
					"timer-keyword": {
						pattern: /^~/,
						alias: "keyword"
					}
				}
			}
		};
	})(Prism$1);
}
coq.displayName = "coq";
coq.aliases = [];
function coq(Prism$1) {
	(function(Prism$2) {
		var commentSource = /\(\*(?:[^(*]|\((?!\*)|\*(?!\))|<self>)*\*\)/.source;
		for (var i = 0; i < 2; i++) commentSource = commentSource.replace(/<self>/g, function() {
			return commentSource;
		});
		commentSource = commentSource.replace(/<self>/g, "[]");
		Prism$2.languages.coq = {
			comment: RegExp(commentSource),
			string: {
				pattern: /"(?:[^"]|"")*"(?!")/,
				greedy: true
			},
			attribute: [{
				pattern: RegExp(/#\[(?:[^\[\]("]|"(?:[^"]|"")*"(?!")|\((?!\*)|<comment>)*\]/.source.replace(/<comment>/g, function() {
					return commentSource;
				})),
				greedy: true,
				alias: "attr-name",
				inside: {
					comment: RegExp(commentSource),
					string: {
						pattern: /"(?:[^"]|"")*"(?!")/,
						greedy: true
					},
					operator: /=/,
					punctuation: /^#\[|\]$|[,()]/
				}
			}, {
				pattern: /\b(?:Cumulative|Global|Local|Monomorphic|NonCumulative|Polymorphic|Private|Program)\b/,
				alias: "attr-name"
			}],
			keyword: /\b(?:Abort|About|Add|Admit|Admitted|All|Arguments|As|Assumptions|Axiom|Axioms|Back|BackTo|Backtrace|BinOp|BinOpSpec|BinRel|Bind|Blacklist|Canonical|Case|Cd|Check|Class|Classes|Close|CoFixpoint|CoInductive|Coercion|Coercions|Collection|Combined|Compute|Conjecture|Conjectures|Constant|Constants|Constraint|Constructors|Context|Corollary|Create|CstOp|Custom|Cut|Debug|Declare|Defined|Definition|Delimit|Dependencies|Dependent|Derive|Diffs|Drop|Elimination|End|Entry|Equality|Eval|Example|Existential|Existentials|Existing|Export|Extern|Extraction|Fact|Fail|Field|File|Firstorder|Fixpoint|Flags|Focus|From|Funclass|Function|Functional|GC|Generalizable|Goal|Grab|Grammar|Graph|Guarded|Haskell|Heap|Hide|Hint|HintDb|Hints|Hypotheses|Hypothesis|IF|Identity|Immediate|Implicit|Implicits|Import|Include|Induction|Inductive|Infix|Info|Initial|InjTyp|Inline|Inspect|Instance|Instances|Intro|Intros|Inversion|Inversion_clear|JSON|Language|Left|Lemma|Let|Lia|Libraries|Library|Load|LoadPath|Locate|Ltac|Ltac2|ML|Match|Method|Minimality|Module|Modules|Morphism|Next|NoInline|Notation|Number|OCaml|Obligation|Obligations|Opaque|Open|Optimize|Parameter|Parameters|Parametric|Path|Paths|Prenex|Preterm|Primitive|Print|Profile|Projections|Proof|Prop|PropBinOp|PropOp|PropUOp|Property|Proposition|Pwd|Qed|Quit|Rec|Record|Recursive|Redirect|Reduction|Register|Relation|Remark|Remove|Require|Reserved|Reset|Resolve|Restart|Rewrite|Right|Ring|Rings|SProp|Saturate|Save|Scheme|Scope|Scopes|Search|SearchHead|SearchPattern|SearchRewrite|Section|Separate|Set|Setoid|Show|Signatures|Solve|Solver|Sort|Sortclass|Sorted|Spec|Step|Strategies|Strategy|String|Structure|SubClass|Subgraph|SuchThat|Tactic|Term|TestCompile|Theorem|Time|Timeout|To|Transparent|Type|Typeclasses|Types|Typing|UnOp|UnOpSpec|Undelimit|Undo|Unfocus|Unfocused|Unfold|Universe|Universes|Unshelve|Variable|Variables|Variant|Verbose|View|Visibility|Zify|_|apply|as|at|by|cofix|else|end|exists|exists2|fix|for|forall|fun|if|in|let|match|measure|move|removed|return|struct|then|using|wf|where|with)\b/,
			number: /\b(?:0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]+)?(?:p[+-]?\d[\d_]*)?|\d[\d_]*(?:\.[\d_]+)?(?:e[+-]?\d[\d_]*)?)\b/i,
			punct: {
				pattern: /@\{|\{\||\[=|:>/,
				alias: "punctuation"
			},
			operator: /\/\\|\\\/|\.{2,3}|:{1,2}=|\*\*|[-=]>|<(?:->?|[+:=>]|<:)|>(?:=|->)|\|[-|]?|[-!%&*+/<=>?@^~']/,
			punctuation: /\.\(|`\(|@\{|`\{|\{\||\[=|:>|[:.,;(){}\[\]]/
		};
	})(Prism$1);
}
crystal.displayName = "crystal";
crystal.aliases = [];
function crystal(Prism$1) {
	Prism$1.register(ruby);
	(function(Prism$2) {
		Prism$2.languages.crystal = Prism$2.languages.extend("ruby", {
			keyword: [/\b(?:__DIR__|__END_LINE__|__FILE__|__LINE__|abstract|alias|annotation|as|asm|begin|break|case|class|def|do|else|elsif|end|ensure|enum|extend|for|fun|if|ifdef|include|instance_sizeof|lib|macro|module|next|of|out|pointerof|private|protected|ptr|require|rescue|return|select|self|sizeof|struct|super|then|type|typeof|undef|uninitialized|union|unless|until|when|while|with|yield)\b/, {
				pattern: /(\.\s*)(?:is_a|responds_to)\?/,
				lookbehind: true
			}],
			number: /\b(?:0b[01_]*[01]|0o[0-7_]*[0-7]|0x[\da-fA-F_]*[\da-fA-F]|(?:\d(?:[\d_]*\d)?)(?:\.[\d_]*\d)?(?:[eE][+-]?[\d_]*\d)?)(?:_(?:[uif](?:8|16|32|64))?)?\b/,
			operator: [/->/, Prism$2.languages.ruby.operator],
			punctuation: /[(){}[\].,;\\]/
		});
		Prism$2.languages.insertBefore("crystal", "string-literal", {
			attribute: {
				pattern: /@\[.*?\]/,
				inside: {
					delimiter: {
						pattern: /^@\[|\]$/,
						alias: "punctuation"
					},
					attribute: {
						pattern: /^(\s*)\w+/,
						lookbehind: true,
						alias: "class-name"
					},
					args: {
						pattern: /\S(?:[\s\S]*\S)?/,
						inside: Prism$2.languages.crystal
					}
				}
			},
			expansion: {
				pattern: /\{(?:\{.*?\}|%.*?%)\}/,
				inside: {
					content: {
						pattern: /^(\{.)[\s\S]+(?=.\}$)/,
						lookbehind: true,
						inside: Prism$2.languages.crystal
					},
					delimiter: {
						pattern: /^\{[\{%]|[\}%]\}$/,
						alias: "operator"
					}
				}
			},
			char: {
				pattern: /'(?:[^\\\r\n]{1,2}|\\(?:.|u(?:[A-Fa-f0-9]{1,4}|\{[A-Fa-f0-9]{1,6}\})))'/,
				greedy: true
			}
		});
	})(Prism$1);
}
cssExtras.displayName = "css-extras";
cssExtras.aliases = [];
function cssExtras(Prism$1) {
	Prism$1.register(css);
	(function(Prism$2) {
		var string$2 = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
		var selectorInside;
		Prism$2.languages.css.selector = {
			pattern: Prism$2.languages.css.selector.pattern,
			lookbehind: true,
			inside: selectorInside = {
				"pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,
				"pseudo-class": /:[-\w]+/,
				class: /\.[-\w]+/,
				id: /#[-\w]+/,
				attribute: {
					pattern: RegExp("\\[(?:[^[\\]\"']|" + string$2.source + ")*\\]"),
					greedy: true,
					inside: {
						punctuation: /^\[|\]$/,
						"case-sensitivity": {
							pattern: /(\s)[si]$/i,
							lookbehind: true,
							alias: "keyword"
						},
						namespace: {
							pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/,
							lookbehind: true,
							inside: { punctuation: /\|$/ }
						},
						"attr-name": {
							pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/,
							lookbehind: true
						},
						"attr-value": [string$2, {
							pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/,
							lookbehind: true
						}],
						operator: /[|~*^$]?=/
					}
				},
				"n-th": [{
					pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/,
					lookbehind: true,
					inside: {
						number: /[\dn]+/,
						operator: /[+-]/
					}
				}, {
					pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i,
					lookbehind: true
				}],
				combinator: />|\+|~|\|\|/,
				punctuation: /[(),]/
			}
		};
		Prism$2.languages.css["atrule"].inside["selector-function-argument"].inside = selectorInside;
		Prism$2.languages.insertBefore("css", "property", { variable: {
			pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i,
			lookbehind: true
		} });
		var unit = {
			pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/,
			lookbehind: true
		};
		var number$2 = {
			pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
			lookbehind: true
		};
		Prism$2.languages.insertBefore("css", "function", {
			operator: {
				pattern: /(\s)[+\-*\/](?=\s)/,
				lookbehind: true
			},
			hexcode: {
				pattern: /\B#[\da-f]{3,8}\b/i,
				alias: "color"
			},
			color: [{
				pattern: /(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|RebeccaPurple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i,
				lookbehind: true
			}, {
				pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
				inside: {
					unit,
					number: number$2,
					function: /[\w-]+(?=\()/,
					punctuation: /[(),]/
				}
			}],
			entity: /\\[\da-f]{1,8}/i,
			unit,
			number: number$2
		});
	})(Prism$1);
}
csv.displayName = "csv";
csv.aliases = [];
function csv(Prism$1) {
	Prism$1.languages.csv = {
		value: /[^\r\n,"]+|"(?:[^"]|"")*"(?!")/,
		punctuation: /,/
	};
}
cue.displayName = "cue";
cue.aliases = [];
function cue(Prism$1) {
	(function(Prism$2) {
		var stringEscape = /\\(?:(?!\2)|\2(?:[^()\r\n]|\([^()]*\)))/.source;
		var stringTypes = /"""(?:[^\\"]|"(?!""\2)|<esc>)*"""/.source + "|" + /'''(?:[^\\']|'(?!''\2)|<esc>)*'''/.source + "|" + /"(?:[^\\\r\n"]|"(?!\2)|<esc>)*"/.source + "|" + /'(?:[^\\\r\n']|'(?!\2)|<esc>)*'/.source;
		var stringLiteral = "(?:" + stringTypes.replace(/<esc>/g, stringEscape) + ")";
		Prism$2.languages.cue = {
			comment: {
				pattern: /\/\/.*/,
				greedy: true
			},
			"string-literal": {
				pattern: RegExp(/(^|[^#"'\\])(#*)/.source + stringLiteral + /(?!["'])\2/.source),
				lookbehind: true,
				greedy: true,
				inside: {
					escape: {
						pattern: /(?=[\s\S]*["'](#*)$)\\\1(?:U[a-fA-F0-9]{1,8}|u[a-fA-F0-9]{1,4}|x[a-fA-F0-9]{1,2}|\d{2,3}|[^(])/,
						greedy: true,
						alias: "string"
					},
					interpolation: {
						pattern: /(?=[\s\S]*["'](#*)$)\\\1\([^()]*\)/,
						greedy: true,
						inside: {
							punctuation: /^\\#*\(|\)$/,
							expression: {
								pattern: /[\s\S]+/,
								inside: null
							}
						}
					},
					string: /[\s\S]+/
				}
			},
			keyword: {
				pattern: /(^|[^\w$])(?:for|if|import|in|let|null|package)(?![\w$])/,
				lookbehind: true
			},
			boolean: {
				pattern: /(^|[^\w$])(?:false|true)(?![\w$])/,
				lookbehind: true
			},
			builtin: {
				pattern: /(^|[^\w$])(?:bool|bytes|float|float(?:32|64)|u?int(?:8|16|32|64|128)?|number|rune|string)(?![\w$])/,
				lookbehind: true
			},
			attribute: {
				pattern: /@[\w$]+(?=\s*\()/,
				alias: "function"
			},
			function: {
				pattern: /(^|[^\w$])[a-z_$][\w$]*(?=\s*\()/i,
				lookbehind: true
			},
			number: {
				pattern: /(^|[^\w$.])(?:0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|0[xX][0-9A-Fa-f]+(?:_[0-9A-Fa-f]+)*|(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[eE][+-]?\d+(?:_\d+)*)?(?:[KMGTP]i?)?)(?![\w$])/,
				lookbehind: true
			},
			operator: /\.{3}|_\|_|&&?|\|\|?|[=!]~|[<>=!]=?|[+\-*/?]/,
			punctuation: /[()[\]{},.:]/
		};
		Prism$2.languages.cue["string-literal"].inside.interpolation.inside.expression.inside = Prism$2.languages.cue;
	})(Prism$1);
}
cypher.displayName = "cypher";
cypher.aliases = [];
function cypher(Prism$1) {
	Prism$1.languages.cypher = {
		comment: /\/\/.*/,
		string: {
			pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/,
			greedy: true
		},
		"class-name": {
			pattern: /(:\s*)(?:\w+|`(?:[^`\\\r\n])*`)(?=\s*[{):])/,
			lookbehind: true,
			greedy: true
		},
		relationship: {
			pattern: /(-\[\s*(?:\w+\s*|`(?:[^`\\\r\n])*`\s*)?:\s*|\|\s*:\s*)(?:\w+|`(?:[^`\\\r\n])*`)/,
			lookbehind: true,
			greedy: true,
			alias: "property"
		},
		identifier: {
			pattern: /`(?:[^`\\\r\n])*`/,
			greedy: true
		},
		variable: /\$\w+/,
		keyword: /\b(?:ADD|ALL|AND|AS|ASC|ASCENDING|ASSERT|BY|CALL|CASE|COMMIT|CONSTRAINT|CONTAINS|CREATE|CSV|DELETE|DESC|DESCENDING|DETACH|DISTINCT|DO|DROP|ELSE|END|ENDS|EXISTS|FOR|FOREACH|IN|INDEX|IS|JOIN|KEY|LIMIT|LOAD|MANDATORY|MATCH|MERGE|NODE|NOT|OF|ON|OPTIONAL|OR|ORDER(?=\s+BY)|PERIODIC|REMOVE|REQUIRE|RETURN|SCALAR|SCAN|SET|SKIP|START|STARTS|THEN|UNION|UNIQUE|UNWIND|USING|WHEN|WHERE|WITH|XOR|YIELD)\b/i,
		function: /\b\w+\b(?=\s*\()/,
		boolean: /\b(?:false|null|true)\b/i,
		number: /\b(?:0x[\da-fA-F]+|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)\b/,
		operator: /:|<--?|--?>?|<>|=~?|[<>]=?|[+*/%^|]|\.\.\.?/,
		punctuation: /[()[\]{},;.]/
	};
}
d.displayName = "d";
d.aliases = [];
function d(Prism$1) {
	Prism$1.register(clike);
	Prism$1.languages.d = Prism$1.languages.extend("clike", {
		comment: [{
			pattern: /^\s*#!.+/,
			greedy: true
		}, {
			pattern: RegExp(/(^|[^\\])/.source + "(?:" + [
				/\/\+(?:\/\+(?:[^+]|\+(?!\/))*\+\/|(?!\/\+)[\s\S])*?\+\//.source,
				/\/\/.*/.source,
				/\/\*[\s\S]*?\*\//.source
			].join("|") + ")"),
			lookbehind: true,
			greedy: true
		}],
		string: [{
			pattern: RegExp([
				/\b[rx]"(?:\\[\s\S]|[^\\"])*"[cwd]?/.source,
				/\bq"(?:\[[\s\S]*?\]|\([\s\S]*?\)|<[\s\S]*?>|\{[\s\S]*?\})"/.source,
				/\bq"((?!\d)\w+)$[\s\S]*?^\1"/.source,
				/\bq"(.)[\s\S]*?\2"/.source,
				/(["`])(?:\\[\s\S]|(?!\3)[^\\])*\3[cwd]?/.source
			].join("|"), "m"),
			greedy: true
		}, {
			pattern: /\bq\{(?:\{[^{}]*\}|[^{}])*\}/,
			greedy: true,
			alias: "token-string"
		}],
		keyword: /\$|\b(?:__(?:(?:DATE|EOF|FILE|FUNCTION|LINE|MODULE|PRETTY_FUNCTION|TIMESTAMP|TIME|VENDOR|VERSION)__|gshared|parameters|traits|vector)|abstract|alias|align|asm|assert|auto|body|bool|break|byte|case|cast|catch|cdouble|cent|cfloat|char|class|const|continue|creal|dchar|debug|default|delegate|delete|deprecated|do|double|dstring|else|enum|export|extern|false|final|finally|float|for|foreach|foreach_reverse|function|goto|idouble|if|ifloat|immutable|import|inout|int|interface|invariant|ireal|lazy|long|macro|mixin|module|new|nothrow|null|out|override|package|pragma|private|protected|ptrdiff_t|public|pure|real|ref|return|scope|shared|short|size_t|static|string|struct|super|switch|synchronized|template|this|throw|true|try|typedef|typeid|typeof|ubyte|ucent|uint|ulong|union|unittest|ushort|version|void|volatile|wchar|while|with|wstring)\b/,
		number: [/\b0x\.?[a-f\d_]+(?:(?!\.\.)\.[a-f\d_]*)?(?:p[+-]?[a-f\d_]+)?[ulfi]{0,4}/i, {
			pattern: /((?:\.\.)?)(?:\b0b\.?|\b|\.)\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:e[+-]?\d[\d_]*)?[ulfi]{0,4}/i,
			lookbehind: true
		}],
		operator: /\|[|=]?|&[&=]?|\+[+=]?|-[-=]?|\.?\.\.|=[>=]?|!(?:i[ns]\b|<>?=?|>=?|=)?|\bi[ns]\b|(?:<[<>]?|>>?>?|\^\^|[*\/%^~])=?/
	});
	Prism$1.languages.insertBefore("d", "string", { char: /'(?:\\(?:\W|\w+)|[^\\])'/ });
	Prism$1.languages.insertBefore("d", "keyword", { property: /\B@\w*/ });
	Prism$1.languages.insertBefore("d", "function", { register: {
		pattern: /\b(?:[ABCD][LHX]|E?(?:BP|DI|SI|SP)|[BS]PL|[ECSDGF]S|CR[0234]|[DS]IL|DR[012367]|E[ABCD]X|X?MM[0-7]|R(?:1[0-5]|[89])[BWD]?|R[ABCD]X|R[BS]P|R[DS]I|TR[3-7]|XMM(?:1[0-5]|[89])|YMM(?:1[0-5]|\d))\b|\bST(?:\([0-7]\)|\b)/,
		alias: "variable"
	} });
}
dart.displayName = "dart";
dart.aliases = [];
function dart(Prism$1) {
	Prism$1.register(clike);
	(function(Prism$2) {
		var keywords = [/\b(?:async|sync|yield)\*/, /\b(?:abstract|assert|async|await|break|case|catch|class|const|continue|covariant|default|deferred|do|dynamic|else|enum|export|extends|extension|external|factory|final|finally|for|get|hide|if|implements|import|in|interface|library|mixin|new|null|on|operator|part|rethrow|return|set|show|static|super|switch|sync|this|throw|try|typedef|var|void|while|with|yield)\b/];
		var packagePrefix = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
		var className$1 = {
			pattern: RegExp(packagePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
			lookbehind: true,
			inside: { namespace: {
				pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
				inside: { punctuation: /\./ }
			} }
		};
		Prism$2.languages.dart = Prism$2.languages.extend("clike", {
			"class-name": [className$1, {
				pattern: RegExp(packagePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source),
				lookbehind: true,
				inside: className$1.inside
			}],
			keyword: keywords,
			operator: /\bis!|\b(?:as|is)\b|\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?/
		});
		Prism$2.languages.insertBefore("dart", "string", {
			"string-literal": {
				pattern: /r?(?:("""|''')[\s\S]*?\1|(["'])(?:\\.|(?!\2)[^\\\r\n])*\2(?!\2))/,
				greedy: true,
				inside: {
					interpolation: {
						pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
						lookbehind: true,
						inside: {
							punctuation: /^\$\{?|\}$/,
							expression: {
								pattern: /[\s\S]+/,
								inside: Prism$2.languages.dart
							}
						}
					},
					string: /[\s\S]+/
				}
			},
			string: void 0
		});
		Prism$2.languages.insertBefore("dart", "class-name", { metadata: {
			pattern: /@\w+/,
			alias: "function"
		} });
		Prism$2.languages.insertBefore("dart", "class-name", { generics: {
			pattern: /<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<[\w\s,.&?]*>)*>)*>)*>/,
			inside: {
				"class-name": className$1,
				keyword: keywords,
				punctuation: /[<>(),.:]/,
				operator: /[?&|]/
			}
		} });
	})(Prism$1);
}
dataweave.displayName = "dataweave";
dataweave.aliases = [];
function dataweave(Prism$1) {
	(function(Prism$2) {
		Prism$2.languages.dataweave = {
			url: /\b[A-Za-z]+:\/\/[\w/:.?=&-]+|\burn:[\w:.?=&-]+/,
			property: {
				pattern: /(?:\b\w+#)?(?:"(?:\\.|[^\\"\r\n])*"|\b\w+)(?=\s*[:@])/,
				greedy: true
			},
			string: {
				pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
				greedy: true
			},
			"mime-type": /\b(?:application|audio|image|multipart|text|video)\/[\w+-]+/,
			date: {
				pattern: /\|[\w:+-]+\|/,
				greedy: true
			},
			comment: [{
				pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
				lookbehind: true,
				greedy: true
			}, {
				pattern: /(^|[^\\:])\/\/.*/,
				lookbehind: true,
				greedy: true
			}],
			regex: {
				pattern: /\/(?:[^\\\/\r\n]|\\[^\r\n])+\//,
				greedy: true
			},
			keyword: /\b(?:and|as|at|case|do|else|fun|if|input|is|match|not|ns|null|or|output|type|unless|update|using|var)\b/,
			function: /\b[A-Z_]\w*(?=\s*\()/i,
			number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
			punctuation: /[{}[\];(),.:@]/,
			operator: /<<|>>|->|[<>~=]=?|!=|--?-?|\+\+?|!|\?/,
			boolean: /\b(?:false|true)\b/
		};
	})(Prism$1);
}
dax.displayName = "dax";
dax.aliases = [];
function dax(Prism$1) {
	Prism$1.languages.dax = {
		comment: {
			pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/).*)/,
			lookbehind: true
		},
		"data-field": {
			pattern: /'(?:[^']|'')*'(?!')(?:\[[ \w\xA0-\uFFFF]+\])?|\w+\[[ \w\xA0-\uFFFF]+\]/,
			alias: "symbol"
		},
		measure: {
			pattern: /\[[ \w\xA0-\uFFFF]+\]/,
			alias: "constant"
		},
		string: {
			pattern: /"(?:[^"]|"")*"(?!")/,
			greedy: true
		},
		function: /\b(?:ABS|ACOS|ACOSH|ACOT|ACOTH|ADDCOLUMNS|ADDMISSINGITEMS|ALL|ALLCROSSFILTERED|ALLEXCEPT|ALLNOBLANKROW|ALLSELECTED|AND|APPROXIMATEDISTINCTCOUNT|ASIN|ASINH|ATAN|ATANH|AVERAGE|AVERAGEA|AVERAGEX|BETA\.DIST|BETA\.INV|BLANK|CALCULATE|CALCULATETABLE|CALENDAR|CALENDARAUTO|CEILING|CHISQ\.DIST|CHISQ\.DIST\.RT|CHISQ\.INV|CHISQ\.INV\.RT|CLOSINGBALANCEMONTH|CLOSINGBALANCEQUARTER|CLOSINGBALANCEYEAR|COALESCE|COMBIN|COMBINA|COMBINEVALUES|CONCATENATE|CONCATENATEX|CONFIDENCE\.NORM|CONFIDENCE\.T|CONTAINS|CONTAINSROW|CONTAINSSTRING|CONTAINSSTRINGEXACT|CONVERT|COS|COSH|COT|COTH|COUNT|COUNTA|COUNTAX|COUNTBLANK|COUNTROWS|COUNTX|CROSSFILTER|CROSSJOIN|CURRENCY|CURRENTGROUP|CUSTOMDATA|DATATABLE|DATE|DATEADD|DATEDIFF|DATESBETWEEN|DATESINPERIOD|DATESMTD|DATESQTD|DATESYTD|DATEVALUE|DAY|DEGREES|DETAILROWS|DISTINCT|DISTINCTCOUNT|DISTINCTCOUNTNOBLANK|DIVIDE|EARLIER|EARLIEST|EDATE|ENDOFMONTH|ENDOFQUARTER|ENDOFYEAR|EOMONTH|ERROR|EVEN|EXACT|EXCEPT|EXP|EXPON\.DIST|FACT|FALSE|FILTER|FILTERS|FIND|FIRSTDATE|FIRSTNONBLANK|FIRSTNONBLANKVALUE|FIXED|FLOOR|FORMAT|GCD|GENERATE|GENERATEALL|GENERATESERIES|GEOMEAN|GEOMEANX|GROUPBY|HASONEFILTER|HASONEVALUE|HOUR|IF|IF\.EAGER|IFERROR|IGNORE|INT|INTERSECT|ISBLANK|ISCROSSFILTERED|ISEMPTY|ISERROR|ISEVEN|ISFILTERED|ISINSCOPE|ISLOGICAL|ISNONTEXT|ISNUMBER|ISO\.CEILING|ISODD|ISONORAFTER|ISSELECTEDMEASURE|ISSUBTOTAL|ISTEXT|KEEPFILTERS|KEYWORDMATCH|LASTDATE|LASTNONBLANK|LASTNONBLANKVALUE|LCM|LEFT|LEN|LN|LOG|LOG10|LOOKUPVALUE|LOWER|MAX|MAXA|MAXX|MEDIAN|MEDIANX|MID|MIN|MINA|MINUTE|MINX|MOD|MONTH|MROUND|NATURALINNERJOIN|NATURALLEFTOUTERJOIN|NEXTDAY|NEXTMONTH|NEXTQUARTER|NEXTYEAR|NONVISUAL|NORM\.DIST|NORM\.INV|NORM\.S\.DIST|NORM\.S\.INV|NOT|NOW|ODD|OPENINGBALANCEMONTH|OPENINGBALANCEQUARTER|OPENINGBALANCEYEAR|OR|PARALLELPERIOD|PATH|PATHCONTAINS|PATHITEM|PATHITEMREVERSE|PATHLENGTH|PERCENTILE\.EXC|PERCENTILE\.INC|PERCENTILEX\.EXC|PERCENTILEX\.INC|PERMUT|PI|POISSON\.DIST|POWER|PREVIOUSDAY|PREVIOUSMONTH|PREVIOUSQUARTER|PREVIOUSYEAR|PRODUCT|PRODUCTX|QUARTER|QUOTIENT|RADIANS|RAND|RANDBETWEEN|RANK\.EQ|RANKX|RELATED|RELATEDTABLE|REMOVEFILTERS|REPLACE|REPT|RIGHT|ROLLUP|ROLLUPADDISSUBTOTAL|ROLLUPGROUP|ROLLUPISSUBTOTAL|ROUND|ROUNDDOWN|ROUNDUP|ROW|SAMEPERIODLASTYEAR|SAMPLE|SEARCH|SECOND|SELECTCOLUMNS|SELECTEDMEASURE|SELECTEDMEASUREFORMATSTRING|SELECTEDMEASURENAME|SELECTEDVALUE|SIGN|SIN|SINH|SQRT|SQRTPI|STARTOFMONTH|STARTOFQUARTER|STARTOFYEAR|STDEV\.P|STDEV\.S|STDEVX\.P|STDEVX\.S|SUBSTITUTE|SUBSTITUTEWITHINDEX|SUM|SUMMARIZE|SUMMARIZECOLUMNS|SUMX|SWITCH|T\.DIST|T\.DIST\.2T|T\.DIST\.RT|T\.INV|T\.INV\.2T|TAN|TANH|TIME|TIMEVALUE|TODAY|TOPN|TOPNPERLEVEL|TOPNSKIP|TOTALMTD|TOTALQTD|TOTALYTD|TREATAS|TRIM|TRUE|TRUNC|UNICHAR|UNICODE|UNION|UPPER|USERELATIONSHIP|USERNAME|USEROBJECTID|USERPRINCIPALNAME|UTCNOW|UTCTODAY|VALUE|VALUES|VAR\.P|VAR\.S|VARX\.P|VARX\.S|WEEKDAY|WEEKNUM|XIRR|XNPV|YEAR|YEARFRAC)(?=\s*\()/i,
		keyword: /\b(?:DEFINE|EVALUATE|MEASURE|ORDER\s+BY|RETURN|VAR|START\s+AT|ASC|DESC)\b/i,
		boolean: {
			pattern: /\b(?:FALSE|NULL|TRUE)\b/i,
			alias: "constant"
		},
		number: /\b\d+(?:\.\d*)?|\B\.\d+\b/,
		operator: /:=|[-+*\/=^]|&&?|\|\||<(?:=>?|<|>)?|>[>=]?|\b(?:IN|NOT)\b/i,
		punctuation: /[;\[\](){}`,.]/
	};
}
dhall.displayName = "dhall";
dhall.aliases = [];
function dhall(Prism$1) {
	Prism$1.languages.dhall = {
		comment: /--.*|\{-(?:[^-{]|-(?!\})|\{(?!-)|\{-(?:[^-{]|-(?!\})|\{(?!-))*-\})*-\}/,
		string: {
			pattern: /"(?:[^"\\]|\\.)*"|''(?:[^']|'(?!')|'''|''\$\{)*''(?!'|\$)/,
			greedy: true,
			inside: { interpolation: {
				pattern: /\$\{[^{}]*\}/,
				inside: {
					expression: {
						pattern: /(^\$\{)[\s\S]+(?=\}$)/,
						lookbehind: true,
						alias: "language-dhall",
						inside: null
					},
					punctuation: /\$\{|\}/
				}
			} }
		},
		label: {
			pattern: /`[^`]*`/,
			greedy: true
		},
		url: {
			pattern: /\bhttps?:\/\/[\w.:%!$&'*+;=@~-]+(?:\/[\w.:%!$&'*+;=@~-]*)*(?:\?[/?\w.:%!$&'*+;=@~-]*)?/,
			greedy: true
		},
		env: {
			pattern: /\benv:(?:(?!\d)\w+|"(?:[^"\\=]|\\.)*")/,
			greedy: true,
			inside: {
				function: /^env/,
				operator: /^:/,
				variable: /[\s\S]+/
			}
		},
		hash: {
			pattern: /\bsha256:[\da-fA-F]{64}\b/,
			inside: {
				function: /sha256/,
				operator: /:/,
				number: /[\da-fA-F]{64}/
			}
		},
		keyword: /\b(?:as|assert|else|forall|if|in|let|merge|missing|then|toMap|using|with)\b|\u2200/,
		builtin: /\b(?:None|Some)\b/,
		boolean: /\b(?:False|True)\b/,
		number: /\bNaN\b|-?\bInfinity\b|[+-]?\b(?:0x[\da-fA-F]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/,
		operator: /\/\\|\/\/\\\\|&&|\|\||===|[!=]=|\/\/|->|\+\+|::|[+*#@=:?<>|\\\u2227\u2a53\u2261\u2afd\u03bb\u2192]/,
		punctuation: /\.\.|[{}\[\](),./]/,
		"class-name": /\b[A-Z]\w*\b/
	};
	Prism$1.languages.dhall.string.inside.interpolation.inside.expression.inside = Prism$1.languages.dhall;
}
django.displayName = "django";
django.aliases = ["jinja2"];
function django(Prism$1) {
	Prism$1.register(markupTemplating);
	(function(Prism$2) {
		Prism$2.languages.django = {
			comment: /^\{#[\s\S]*?#\}$/,
			tag: {
				pattern: /(^\{%[+-]?\s*)\w+/,
				lookbehind: true,
				alias: "keyword"
			},
			delimiter: {
				pattern: /^\{[{%][+-]?|[+-]?[}%]\}$/,
				alias: "punctuation"
			},
			string: {
				pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
				greedy: true
			},
			filter: {
				pattern: /(\|)\w+/,
				lookbehind: true,
				alias: "function"
			},
			test: {
				pattern: /(\bis\s+(?:not\s+)?)(?!not\b)\w+/,
				lookbehind: true,
				alias: "function"
			},
			function: /\b[a-z_]\w+(?=\s*\()/i,
			keyword: /\b(?:and|as|by|else|for|if|import|in|is|loop|not|or|recursive|with|without)\b/,
			operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
			number: /\b\d+(?:\.\d+)?\b/,
			boolean: /[Ff]alse|[Nn]one|[Tt]rue/,
			variable: /\b\w+\b/,
			punctuation: /[{}[\](),.:;]/
		};
		var pattern = /\{\{[\s\S]*?\}\}|\{%[\s\S]*?%\}|\{#[\s\S]*?#\}/g;
		var markupTemplating$1 = Prism$2.languages["markup-templating"];
		Prism$2.hooks.add("before-tokenize", function(env$1) {
			markupTemplating$1.buildPlaceholders(env$1, "django", pattern);
		});
		Prism$2.hooks.add("after-tokenize", function(env$1) {
			markupTemplating$1.tokenizePlaceholders(env$1, "django");
		});
		Prism$2.languages.jinja2 = Prism$2.languages.django;
		Prism$2.hooks.add("before-tokenize", function(env$1) {
			markupTemplating$1.buildPlaceholders(env$1, "jinja2", pattern);
		});
		Prism$2.hooks.add("after-tokenize", function(env$1) {
			markupTemplating$1.tokenizePlaceholders(env$1, "jinja2");
		});
	})(Prism$1);
}
dnsZoneFile.displayName = "dns-zone-file";
dnsZoneFile.aliases = ["dns-zone"];
function dnsZoneFile(Prism$1) {
	Prism$1.languages["dns-zone-file"] = {
		comment: /;.*/,
		string: {
			pattern: /"(?:\\.|[^"\\\r\n])*"/,
			greedy: true
		},
		variable: [{
			pattern: /(^\$ORIGIN[ \t]+)\S+/m,
			lookbehind: true
		}, {
			pattern: /(^|\s)@(?=\s|$)/,
			lookbehind: true
		}],
		keyword: /^\$(?:INCLUDE|ORIGIN|TTL)(?=\s|$)/m,
		class: {
			pattern: /(^|\s)(?:CH|CS|HS|IN)(?=\s|$)/,
			lookbehind: true,
			alias: "keyword"
		},
		type: {
			pattern: /(^|\s)(?:A|A6|AAAA|AFSDB|APL|ATMA|CAA|CDNSKEY|CDS|CERT|CNAME|DHCID|DLV|DNAME|DNSKEY|DS|EID|GID|GPOS|HINFO|HIP|IPSECKEY|ISDN|KEY|KX|LOC|MAILA|MAILB|MB|MD|MF|MG|MINFO|MR|MX|NAPTR|NB|NBSTAT|NIMLOC|NINFO|NS|NSAP|NSAP-PTR|NSEC|NSEC3|NSEC3PARAM|NULL|NXT|OPENPGPKEY|PTR|PX|RKEY|RP|RRSIG|RT|SIG|SINK|SMIMEA|SOA|SPF|SRV|SSHFP|TA|TKEY|TLSA|TSIG|TXT|UID|UINFO|UNSPEC|URI|WKS|X25)(?=\s|$)/,
			lookbehind: true,
			alias: "keyword"
		},
		punctuation: /[()]/
	};
	Prism$1.languages["dns-zone"] = Prism$1.languages["dns-zone-file"];
}
docker.displayName = "docker";
docker.aliases = ["dockerfile"];
function docker(Prism$1) {
	(function(Prism$2) {
		var spaceAfterBackSlash = /\\[\r\n](?:\s|\\[\r\n]|#.*(?!.))*(?![\s#]|\\[\r\n])/.source;
		var space$1 = /(?:[ \t]+(?![ \t])(?:<SP_BS>)?|<SP_BS>)/.source.replace(/<SP_BS>/g, function() {
			return spaceAfterBackSlash;
		});
		var string$2 = /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"|'(?:[^'\\\r\n]|\\(?:\r\n|[\s\S]))*'/.source;
		var option = /--[\w-]+=(?:<STR>|(?!["'])(?:[^\s\\]|\\.)+)/.source.replace(/<STR>/g, function() {
			return string$2;
		});
		var stringRule = {
			pattern: RegExp(string$2),
			greedy: true
		};
		var commentRule = {
			pattern: /(^[ \t]*)#.*/m,
			lookbehind: true,
			greedy: true
		};
		function re$1(source, flags) {
			source = source.replace(/<OPT>/g, function() {
				return option;
			}).replace(/<SP>/g, function() {
				return space$1;
			});
			return RegExp(source, flags);
		}
		Prism$2.languages.docker = {
			instruction: {
				pattern: /(^[ \t]*)(?:ADD|ARG|CMD|COPY|ENTRYPOINT|ENV|EXPOSE|FROM|HEALTHCHECK|LABEL|MAINTAINER|ONBUILD|RUN|SHELL|STOPSIGNAL|USER|VOLUME|WORKDIR)(?=\s)(?:\\.|[^\r\n\\])*(?:\\$(?:\s|#.*$)*(?![\s#])(?:\\.|[^\r\n\\])*)*/im,
				lookbehind: true,
				greedy: true,
				inside: {
					options: {
						pattern: re$1(/(^(?:ONBUILD<SP>)?\w+<SP>)<OPT>(?:<SP><OPT>)*/.source, "i"),
						lookbehind: true,
						greedy: true,
						inside: {
							property: {
								pattern: /(^|\s)--[\w-]+/,
								lookbehind: true
							},
							string: [stringRule, {
								pattern: /(=)(?!["'])(?:[^\s\\]|\\.)+/,
								lookbehind: true
							}],
							operator: /\\$/m,
							punctuation: /=/
						}
					},
					keyword: [
						{
							pattern: re$1(/(^(?:ONBUILD<SP>)?HEALTHCHECK<SP>(?:<OPT><SP>)*)(?:CMD|NONE)\b/.source, "i"),
							lookbehind: true,
							greedy: true
						},
						{
							pattern: re$1(/(^(?:ONBUILD<SP>)?FROM<SP>(?:<OPT><SP>)*(?!--)[^ \t\\]+<SP>)AS/.source, "i"),
							lookbehind: true,
							greedy: true
						},
						{
							pattern: re$1(/(^ONBUILD<SP>)\w+/.source, "i"),
							lookbehind: true,
							greedy: true
						},
						{
							pattern: /^\w+/,
							greedy: true
						}
					],
					comment: commentRule,
					string: stringRule,
					variable: /\$(?:\w+|\{[^{}"'\\]*\})/,
					operator: /\\$/m
				}
			},
			comment: commentRule
		};
		Prism$2.languages.dockerfile = Prism$2.languages.docker;
	})(Prism$1);
}
dot.displayName = "dot";
dot.aliases = ["gv"];
function dot(Prism$1) {
	(function(Prism$2) {
		var ID = "(?:" + [
			/[a-zA-Z_\x80-\uFFFF][\w\x80-\uFFFF]*/.source,
			/-?(?:\.\d+|\d+(?:\.\d*)?)/.source,
			/"[^"\\]*(?:\\[\s\S][^"\\]*)*"/.source,
			/<(?:[^<>]|(?!<!--)<(?:[^<>"']|"[^"]*"|'[^']*')+>|<!--(?:[^-]|-(?!->))*-->)*>/.source
		].join("|") + ")";
		var IDInside = { markup: {
			pattern: /(^<)[\s\S]+(?=>$)/,
			lookbehind: true,
			alias: [
				"language-markup",
				"language-html",
				"language-xml"
			],
			inside: Prism$2.languages.markup
		} };
		function withID(source, flags) {
			return RegExp(source.replace(/<ID>/g, function() {
				return ID;
			}), flags);
		}
		Prism$2.languages.dot = {
			comment: {
				pattern: /\/\/.*|\/\*[\s\S]*?\*\/|^#.*/m,
				greedy: true
			},
			"graph-name": {
				pattern: withID(/(\b(?:digraph|graph|subgraph)[ \t\r\n]+)<ID>/.source, "i"),
				lookbehind: true,
				greedy: true,
				alias: "class-name",
				inside: IDInside
			},
			"attr-value": {
				pattern: withID(/(=[ \t\r\n]*)<ID>/.source),
				lookbehind: true,
				greedy: true,
				inside: IDInside
			},
			"attr-name": {
				pattern: withID(/([\[;, \t\r\n])<ID>(?=[ \t\r\n]*=)/.source),
				lookbehind: true,
				greedy: true,
				inside: IDInside
			},
			keyword: /\b(?:digraph|edge|graph|node|strict|subgraph)\b/i,
			"compass-point": {
				pattern: /(:[ \t\r\n]*)(?:[ewc_]|[ns][ew]?)(?![\w\x80-\uFFFF])/,
				lookbehind: true,
				alias: "builtin"
			},
			node: {
				pattern: withID(/(^|[^-.\w\x80-\uFFFF\\])<ID>/.source),
				lookbehind: true,
				greedy: true,
				inside: IDInside
			},
			operator: /[=:]|-[->]/,
			punctuation: /[\[\]{};,]/
		};
		Prism$2.languages.gv = Prism$2.languages.dot;
	})(Prism$1);
}
ebnf.displayName = "ebnf";
ebnf.aliases = [];
function ebnf(Prism$1) {
	Prism$1.languages.ebnf = {
		comment: /\(\*[\s\S]*?\*\)/,
		string: {
			pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
			greedy: true
		},
		special: {
			pattern: /\?[^?\r\n]*\?/,
			greedy: true,
			alias: "class-name"
		},
		definition: {
			pattern: /^([\t ]*)[a-z]\w*(?:[ \t]+[a-z]\w*)*(?=\s*=)/im,
			lookbehind: true,
			alias: ["rule", "keyword"]
		},
		rule: /\b[a-z]\w*(?:[ \t]+[a-z]\w*)*\b/i,
		punctuation: /\([:/]|[:/]\)|[.,;()[\]{}]/,
		operator: /[-=|*/!]/
	};
}
editorconfig.displayName = "editorconfig";
editorconfig.aliases = [];
function editorconfig(Prism$1) {
	Prism$1.languages.editorconfig = {
		comment: /[;#].*/,
		section: {
			pattern: /(^[ \t]*)\[.+\]/m,
			lookbehind: true,
			alias: "selector",
			inside: {
				regex: /\\\\[\[\]{},!?.*]/,
				operator: /[!?]|\.\.|\*{1,2}/,
				punctuation: /[\[\]{},]/
			}
		},
		key: {
			pattern: /(^[ \t]*)[^\s=]+(?=[ \t]*=)/m,
			lookbehind: true,
			alias: "attr-name"
		},
		value: {
			pattern: /=.*/,
			alias: "attr-value",
			inside: { punctuation: /^=/ }
		}
	};
}
eiffel.displayName = "eiffel";
eiffel.aliases = [];
function eiffel(Prism$1) {
	Prism$1.languages.eiffel = {
		comment: /--.*/,
		string: [
			{
				pattern: /"([^[]*)\[[\s\S]*?\]\1"/,
				greedy: true
			},
			{
				pattern: /"([^{]*)\{[\s\S]*?\}\1"/,
				greedy: true
			},
			{
				pattern: /"(?:%(?:(?!\n)\s)*\n\s*%|%\S|[^%"\r\n])*"/,
				greedy: true
			}
		],
		char: /'(?:%.|[^%'\r\n])+'/,
		keyword: /\b(?:across|agent|alias|all|and|as|assign|attached|attribute|check|class|convert|create|Current|debug|deferred|detachable|do|else|elseif|end|ensure|expanded|export|external|feature|from|frozen|if|implies|inherit|inspect|invariant|like|local|loop|not|note|obsolete|old|once|or|Precursor|redefine|rename|require|rescue|Result|retry|select|separate|some|then|undefine|until|variant|Void|when|xor)\b/i,
		boolean: /\b(?:False|True)\b/i,
		"class-name": /\b[A-Z][\dA-Z_]*\b/,
		number: [/\b0[xcb][\da-f](?:_*[\da-f])*\b/i, /(?:\b\d(?:_*\d)*)?\.(?:(?:\d(?:_*\d)*)?e[+-]?)?\d(?:_*\d)*\b|\b\d(?:_*\d)*\b\.?/i],
		punctuation: /:=|<<|>>|\(\||\|\)|->|\.(?=\w)|[{}[\];(),:?]/,
		operator: /\\\\|\|\.\.\||\.\.|\/[~\/=]?|[><]=?|[-+*^=~]/
	};
}
ejs.displayName = "ejs";
ejs.aliases = ["eta"];
function ejs(Prism$1) {
	Prism$1.register(javascript);
	Prism$1.register(markupTemplating);
	(function(Prism$2) {
		Prism$2.languages.ejs = {
			delimiter: {
				pattern: /^<%[-_=]?|[-_]?%>$/,
				alias: "punctuation"
			},
			comment: /^#[\s\S]*/,
			"language-javascript": {
				pattern: /[\s\S]+/,
				inside: Prism$2.languages.javascript
			}
		};
		Prism$2.hooks.add("before-tokenize", function(env$1) {
			var ejsPattern = /<%(?!%)[\s\S]+?%>/g;
			Prism$2.languages["markup-templating"].buildPlaceholders(env$1, "ejs", ejsPattern);
		});
		Prism$2.hooks.add("after-tokenize", function(env$1) {
			Prism$2.languages["markup-templating"].tokenizePlaceholders(env$1, "ejs");
		});
		Prism$2.languages.eta = Prism$2.languages.ejs;
	})(Prism$1);
}
elixir.displayName = "elixir";
elixir.aliases = [];
function elixir(Prism$1) {
	Prism$1.languages.elixir = {
		doc: {
			pattern: /@(?:doc|moduledoc)\s+(?:("""|''')[\s\S]*?\1|("|')(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2)/,
			inside: {
				attribute: /^@\w+/,
				string: /['"][\s\S]+/
			}
		},
		comment: {
			pattern: /#.*/,
			greedy: true
		},
		regex: {
			pattern: /~[rR](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|[^\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[uismxfr]*/,
			greedy: true
		},
		string: [
			{
				pattern: /~[cCsSwW](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|#\{[^}]+\}|#(?!\{)|[^#\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[csa]?/,
				greedy: true,
				inside: {}
			},
			{
				pattern: /("""|''')[\s\S]*?\1/,
				greedy: true,
				inside: {}
			},
			{
				pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
				greedy: true,
				inside: {}
			}
		],
		atom: {
			pattern: /(^|[^:]):\w+/,
			lookbehind: true,
			alias: "symbol"
		},
		module: {
			pattern: /\b[A-Z]\w*\b/,
			alias: "class-name"
		},
		"attr-name": /\b\w+\??:(?!:)/,
		argument: {
			pattern: /(^|[^&])&\d+/,
			lookbehind: true,
			alias: "variable"
		},
		attribute: {
			pattern: /@\w+/,
			alias: "variable"
		},
		function: /\b[_a-zA-Z]\w*[?!]?(?:(?=\s*(?:\.\s*)?\()|(?=\/\d))/,
		number: /\b(?:0[box][a-f\d_]+|\d[\d_]*)(?:\.[\d_]+)?(?:e[+-]?[\d_]+)?\b/i,
		keyword: /\b(?:after|alias|and|case|catch|cond|def(?:callback|delegate|exception|impl|macro|module|n|np|p|protocol|struct)?|do|else|end|fn|for|if|import|not|or|quote|raise|require|rescue|try|unless|unquote|use|when)\b/,
		boolean: /\b(?:false|nil|true)\b/,
		operator: [
			/\bin\b|&&?|\|[|>]?|\\\\|::|\.\.\.?|\+\+?|-[->]?|<[-=>]|>=|!==?|\B!|=(?:==?|[>~])?|[*\/^]/,
			{
				pattern: /([^<])<(?!<)/,
				lookbehind: true
			},
			{
				pattern: /([^>])>(?!>)/,
				lookbehind: true
			}
		],
		punctuation: /<<|>>|[.,%\[\]{}()]/
	};
	Prism$1.languages.elixir.string.forEach(function(o) {
		o.inside = { interpolation: {
			pattern: /#\{[^}]+\}/,
			inside: {
				delimiter: {
					pattern: /^#\{|\}$/,
					alias: "punctuation"
				},
				rest: Prism$1.languages.elixir
			}
		} };
	});
}
elm.displayName = "elm";
elm.aliases = [];
function elm(Prism$1) {
	Prism$1.languages.elm = {
		comment: /--.*|\{-[\s\S]*?-\}/,
		char: {
			pattern: /'(?:[^\\'\r\n]|\\(?:[abfnrtv\\']|\d+|x[0-9a-fA-F]+|u\{[0-9a-fA-F]+\}))'/,
			greedy: true
		},
		string: [{
			pattern: /"""[\s\S]*?"""/,
			greedy: true
		}, {
			pattern: /"(?:[^\\"\r\n]|\\.)*"/,
			greedy: true
		}],
		"import-statement": {
			pattern: /(^[\t ]*)import\s+[A-Z]\w*(?:\.[A-Z]\w*)*(?:\s+as\s+(?:[A-Z]\w*)(?:\.[A-Z]\w*)*)?(?:\s+exposing\s+)?/m,
			lookbehind: true,
			inside: { keyword: /\b(?:as|exposing|import)\b/ }
		},
		keyword: /\b(?:alias|as|case|else|exposing|if|in|infixl|infixr|let|module|of|then|type)\b/,
		builtin: /\b(?:abs|acos|always|asin|atan|atan2|ceiling|clamp|compare|cos|curry|degrees|e|flip|floor|fromPolar|identity|isInfinite|isNaN|logBase|max|min|negate|never|not|pi|radians|rem|round|sin|sqrt|tan|toFloat|toPolar|toString|truncate|turns|uncurry|xor)\b/,
		number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0x[0-9a-f]+)\b/i,
		operator: /\s\.\s|[+\-/*=.$<>:&|^?%#@~!]{2,}|[+\-/*=$<>:&|^?%#@~!]/,
		hvariable: /\b(?:[A-Z]\w*\.)*[a-z]\w*\b/,
		constant: /\b(?:[A-Z]\w*\.)*[A-Z]\w*\b/,
		punctuation: /[{}[\]|(),.:]/
	};
}
etlua.displayName = "etlua";
etlua.aliases = [];
function etlua(Prism$1) {
	Prism$1.register(lua);
	Prism$1.register(markupTemplating);
	(function(Prism$2) {
		Prism$2.languages.etlua = {
			delimiter: {
				pattern: /^<%[-=]?|-?%>$/,
				alias: "punctuation"
			},
			"language-lua": {
				pattern: /[\s\S]+/,
				inside: Prism$2.languages.lua
			}
		};
		Prism$2.hooks.add("before-tokenize", function(env$1) {
			var pattern = /<%[\s\S]+?%>/g;
			Prism$2.languages["markup-templating"].buildPlaceholders(env$1, "etlua", pattern);
		});
		Prism$2.hooks.add("after-tokenize", function(env$1) {
			Prism$2.languages["markup-templating"].tokenizePlaceholders(env$1, "etlua");
		});
	})(Prism$1);
}
erb.displayName = "erb";
erb.aliases = [];
function erb(Prism$1) {
	Prism$1.register(markupTemplating);
	Prism$1.register(ruby);
	(function(Prism$2) {
		Prism$2.languages.erb = {
			delimiter: {
				pattern: /^(\s*)<%=?|%>(?=\s*$)/,
				lookbehind: true,
				alias: "punctuation"
			},
			ruby: {
				pattern: /\s*\S[\s\S]*/,
				alias: "language-ruby",
				inside: Prism$2.languages.ruby
			}
		};
		Prism$2.hooks.add("before-tokenize", function(env$1) {
			var erbPattern = /<%=?(?:[^\r\n]|[\r\n](?!=begin)|[\r\n]=begin\s(?:[^\r\n]|[\r\n](?!=end))*[\r\n]=end)+?%>/g;
			Prism$2.languages["markup-templating"].buildPlaceholders(env$1, "erb", erbPattern);
		});
		Prism$2.hooks.add("after-tokenize", function(env$1) {
			Prism$2.languages["markup-templating"].tokenizePlaceholders(env$1, "erb");
		});
	})(Prism$1);
}
erlang.displayName = "erlang";
erlang.aliases = [];
function erlang(Prism$1) {
	Prism$1.languages.erlang = {
		comment: /%.+/,
		string: {
			pattern: /"(?:\\.|[^\\"\r\n])*"/,
			greedy: true
		},
		"quoted-function": {
			pattern: /'(?:\\.|[^\\'\r\n])+'(?=\()/,
			alias: "function"
		},
		"quoted-atom": {
			pattern: /'(?:\\.|[^\\'\r\n])+'/,
			alias: "atom"
		},
		boolean: /\b(?:false|true)\b/,
		keyword: /\b(?:after|begin|case|catch|end|fun|if|of|receive|try|when)\b/,
		number: [
			/\$\\?./,
			/\b\d+#[a-z0-9]+/i,
			/(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i
		],
		function: /\b[a-z][\w@]*(?=\()/,
		variable: {
			pattern: /(^|[^@])(?:\b|\?)[A-Z_][\w@]*/,
			lookbehind: true
		},
		operator: [
			/[=\/<>:]=|=[:\/]=|\+\+?|--?|[=*\/!]|\b(?:and|andalso|band|bnot|bor|bsl|bsr|bxor|div|not|or|orelse|rem|xor)\b/,
			{
				pattern: /(^|[^<])<(?!<)/,
				lookbehind: true
			},
			{
				pattern: /(^|[^>])>(?!>)/,
				lookbehind: true
			}
		],
		atom: /\b[a-z][\w@]*/,
		punctuation: /[()[\]{}:;,.#|]|<<|>>/
	};
}
excelFormula.displayName = "excel-formula";
excelFormula.aliases = ["xls", "xlsx"];
function excelFormula(Prism$1) {
	Prism$1.languages["excel-formula"] = {
		comment: {
			pattern: /(\bN\(\s*)"(?:[^"]|"")*"(?=\s*\))/i,
			lookbehind: true,
			greedy: true
		},
		string: {
			pattern: /"(?:[^"]|"")*"(?!")/,
			greedy: true
		},
		reference: {
			pattern: /(?:'[^']*'|(?:[^\s()[\]{}<>*?"';,$&]*\[[^^\s()[\]{}<>*?"']+\])?\w+)!/,
			greedy: true,
			alias: "string",
			inside: {
				operator: /!$/,
				punctuation: /'/,
				sheet: {
					pattern: /[^[\]]+$/,
					alias: "function"
				},
				file: {
					pattern: /\[[^[\]]+\]$/,
					inside: { punctuation: /[[\]]/ }
				},
				path: /[\s\S]+/
			}
		},
		"function-name": {
			pattern: /\b[A-Z]\w*(?=\()/i,
			alias: "builtin"
		},
		range: {
			pattern: /\$?\b(?:[A-Z]+\$?\d+:\$?[A-Z]+\$?\d+|[A-Z]+:\$?[A-Z]+|\d+:\$?\d+)\b/i,
			alias: "selector",
			inside: {
				operator: /:/,
				cell: /\$?[A-Z]+\$?\d+/i,
				column: /\$?[A-Z]+/i,
				row: /\$?\d+/
			}
		},
		cell: {
			pattern: /\b[A-Z]+\d+\b|\$[A-Za-z]+\$?\d+\b|\b[A-Za-z]+\$\d+\b/,
			alias: "selector"
		},
		number: /(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[+-]?\d+)?\b/i,
		boolean: /\b(?:FALSE|TRUE)\b/i,
		operator: /[-+*/^%=&,]|<[=>]?|>=?/,
		punctuation: /[[\]();{}|]/
	};
	Prism$1.languages["xlsx"] = Prism$1.languages["xls"] = Prism$1.languages["excel-formula"];
}
fsharp.displayName = "fsharp";
fsharp.aliases = [];
function fsharp(Prism$1) {
	Prism$1.register(clike);
	Prism$1.languages.fsharp = Prism$1.languages.extend("clike", {
		comment: [{
			pattern: /(^|[^\\])\(\*(?!\))[\s\S]*?\*\)/,
			lookbehind: true,
			greedy: true
		}, {
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true,
			greedy: true
		}],
		string: {
			pattern: /(?:"""[\s\S]*?"""|@"(?:""|[^"])*"|"(?:\\[\s\S]|[^\\"])*")B?/,
			greedy: true
		},
		"class-name": {
			pattern: /(\b(?:exception|inherit|interface|new|of|type)\s+|\w\s*:\s*|\s:\??>\s*)[.\w]+\b(?:\s*(?:->|\*)\s*[.\w]+\b)*(?!\s*[:.])/,
			lookbehind: true,
			inside: {
				operator: /->|\*/,
				punctuation: /\./
			}
		},
		keyword: /\b(?:let|return|use|yield)(?:!\B|\b)|\b(?:abstract|and|as|asr|assert|atomic|base|begin|break|checked|class|component|const|constraint|constructor|continue|default|delegate|do|done|downcast|downto|eager|elif|else|end|event|exception|extern|external|false|finally|fixed|for|fun|function|functor|global|if|in|include|inherit|inline|interface|internal|land|lazy|lor|lsl|lsr|lxor|match|member|method|mixin|mod|module|mutable|namespace|new|not|null|object|of|open|or|override|parallel|private|process|protected|public|pure|rec|sealed|select|sig|static|struct|tailcall|then|to|trait|true|try|type|upcast|val|virtual|void|volatile|when|while|with)\b/,
		number: [
			/\b0x[\da-fA-F]+(?:LF|lf|un)?\b/,
			/\b0b[01]+(?:uy|y)?\b/,
			/(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[fm]|e[+-]?\d+)?\b/i,
			/\b\d+(?:[IlLsy]|UL|u[lsy]?)?\b/
		],
		operator: /([<>~&^])\1\1|([*.:<>&])\2|<-|->|[!=:]=|<?\|{1,3}>?|\??(?:<=|>=|<>|[-+*/%=<>])\??|[!?^&]|~[+~-]|:>|:\?>?/
	});
	Prism$1.languages.insertBefore("fsharp", "keyword", { preprocessor: {
		pattern: /(^[\t ]*)#.*/m,
		lookbehind: true,
		alias: "property",
		inside: { directive: {
			pattern: /(^#)\b(?:else|endif|if|light|line|nowarn)\b/,
			lookbehind: true,
			alias: "keyword"
		} }
	} });
	Prism$1.languages.insertBefore("fsharp", "punctuation", { "computation-expression": {
		pattern: /\b[_a-z]\w*(?=\s*\{)/i,
		alias: "keyword"
	} });
	Prism$1.languages.insertBefore("fsharp", "string", {
		annotation: {
			pattern: /\[<.+?>\]/,
			greedy: true,
			inside: {
				punctuation: /^\[<|>\]$/,
				"class-name": {
					pattern: /^\w+$|(^|;\s*)[A-Z]\w*(?=\()/,
					lookbehind: true
				},
				"annotation-content": {
					pattern: /[\s\S]+/,
					inside: Prism$1.languages.fsharp
				}
			}
		},
		char: {
			pattern: /'(?:[^\\']|\\(?:.|\d{3}|x[a-fA-F\d]{2}|u[a-fA-F\d]{4}|U[a-fA-F\d]{8}))'B?/,
			greedy: true
		}
	});
}
factor.displayName = "factor";
factor.aliases = [];
function factor(Prism$1) {
	(function(Prism$2) {
		var comment_inside = { function: /\b(?:BUGS?|FIX(?:MES?)?|NOTES?|TODOS?|XX+|HACKS?|WARN(?:ING)?|\?{2,}|!{2,})\b/ };
		var string_inside = { number: /\\[^\s']|%\w/ };
		var factor$1 = {
			comment: [
				{
					pattern: /(^|\s)(?:! .*|!$)/,
					lookbehind: true,
					inside: comment_inside
				},
				{
					pattern: /(^|\s)\/\*\s[\s\S]*?\*\/(?=\s|$)/,
					lookbehind: true,
					greedy: true,
					inside: comment_inside
				},
				{
					pattern: /(^|\s)!\[(={0,6})\[\s[\s\S]*?\]\2\](?=\s|$)/,
					lookbehind: true,
					greedy: true,
					inside: comment_inside
				}
			],
			number: [
				{
					pattern: /(^|\s)[+-]?\d+(?=\s|$)/,
					lookbehind: true
				},
				{
					pattern: /(^|\s)[+-]?0(?:b[01]+|o[0-7]+|d\d+|x[\dA-F]+)(?=\s|$)/i,
					lookbehind: true
				},
				{
					pattern: /(^|\s)[+-]?\d+\/\d+\.?(?=\s|$)/,
					lookbehind: true
				},
				{
					pattern: /(^|\s)\+?\d+\+\d+\/\d+(?=\s|$)/,
					lookbehind: true
				},
				{
					pattern: /(^|\s)-\d+-\d+\/\d+(?=\s|$)/,
					lookbehind: true
				},
				{
					pattern: /(^|\s)[+-]?(?:\d*\.\d+|\d+\.\d*|\d+)(?:e[+-]?\d+)?(?=\s|$)/i,
					lookbehind: true
				},
				{
					pattern: /(^|\s)NAN:\s+[\da-fA-F]+(?=\s|$)/,
					lookbehind: true
				},
				{
					pattern: /(^|\s)[+-]?0(?:b1\.[01]*|o1\.[0-7]*|d1\.\d*|x1\.[\dA-F]*)p\d+(?=\s|$)/i,
					lookbehind: true
				}
			],
			regexp: {
				pattern: /(^|\s)R\/\s(?:\\\S|[^\\/])*\/(?:[idmsr]*|[idmsr]+-[idmsr]+)(?=\s|$)/,
				lookbehind: true,
				alias: "number",
				inside: {
					variable: /\\\S/,
					keyword: /[+?*\[\]^$(){}.|]/,
					operator: {
						pattern: /(\/)[idmsr]+(?:-[idmsr]+)?/,
						lookbehind: true
					}
				}
			},
			boolean: {
				pattern: /(^|\s)[tf](?=\s|$)/,
				lookbehind: true
			},
			"custom-string": {
				pattern: /(^|\s)[A-Z0-9\-]+"\s(?:\\\S|[^"\\])*"/,
				lookbehind: true,
				greedy: true,
				alias: "string",
				inside: { number: /\\\S|%\w|\// }
			},
			"multiline-string": [
				{
					pattern: /(^|\s)STRING:\s+\S+(?:\n|\r\n).*(?:\n|\r\n)\s*;(?=\s|$)/,
					lookbehind: true,
					greedy: true,
					alias: "string",
					inside: {
						number: string_inside.number,
						"semicolon-or-setlocal": {
							pattern: /([\r\n][ \t]*);(?=\s|$)/,
							lookbehind: true,
							alias: "function"
						}
					}
				},
				{
					pattern: /(^|\s)HEREDOC:\s+\S+(?:\n|\r\n).*(?:\n|\r\n)\s*\S+(?=\s|$)/,
					lookbehind: true,
					greedy: true,
					alias: "string",
					inside: string_inside
				},
				{
					pattern: /(^|\s)\[(={0,6})\[\s[\s\S]*?\]\2\](?=\s|$)/,
					lookbehind: true,
					greedy: true,
					alias: "string",
					inside: string_inside
				}
			],
			"special-using": {
				pattern: /(^|\s)USING:(?:\s\S+)*(?=\s+;(?:\s|$))/,
				lookbehind: true,
				alias: "function",
				inside: { string: {
					pattern: /(\s)[^:\s]+/,
					lookbehind: true
				} }
			},
			"stack-effect-delimiter": [
				{
					pattern: /(^|\s)(?:call|eval|execute)?\((?=\s)/,
					lookbehind: true,
					alias: "operator"
				},
				{
					pattern: /(\s)--(?=\s)/,
					lookbehind: true,
					alias: "operator"
				},
				{
					pattern: /(\s)\)(?=\s|$)/,
					lookbehind: true,
					alias: "operator"
				}
			],
			combinators: {
				pattern: null,
				lookbehind: true,
				alias: "keyword"
			},
			"kernel-builtin": {
				pattern: null,
				lookbehind: true,
				alias: "variable"
			},
			"sequences-builtin": {
				pattern: null,
				lookbehind: true,
				alias: "variable"
			},
			"math-builtin": {
				pattern: null,
				lookbehind: true,
				alias: "variable"
			},
			"constructor-word": {
				pattern: /(^|\s)<(?!=+>|-+>)\S+>(?=\s|$)/,
				lookbehind: true,
				alias: "keyword"
			},
			"other-builtin-syntax": {
				pattern: null,
				lookbehind: true,
				alias: "operator"
			},
			"conventionally-named-word": {
				pattern: /(^|\s)(?!")(?:(?:change|new|set|with)-\S+|\$\S+|>[^>\s]+|[^:>\s]+>|[^>\s]+>[^>\s]+|\+[^+\s]+\+|[^?\s]+\?|\?[^?\s]+|[^>\s]+>>|>>[^>\s]+|[^<\s]+<<|\([^()\s]+\)|[^!\s]+!|[^*\s]\S*\*|[^.\s]\S*\.)(?=\s|$)/,
				lookbehind: true,
				alias: "keyword"
			},
			"colon-syntax": {
				pattern: /(^|\s)(?:[A-Z0-9\-]+#?)?:{1,2}\s+(?:;\S+|(?!;)\S+)(?=\s|$)/,
				lookbehind: true,
				greedy: true,
				alias: "function"
			},
			"semicolon-or-setlocal": {
				pattern: /(\s)(?:;|:>)(?=\s|$)/,
				lookbehind: true,
				alias: "function"
			},
			"curly-brace-literal-delimiter": [{
				pattern: /(^|\s)[a-z]*\{(?=\s)/i,
				lookbehind: true,
				alias: "operator"
			}, {
				pattern: /(\s)\}(?=\s|$)/,
				lookbehind: true,
				alias: "operator"
			}],
			"quotation-delimiter": [{
				pattern: /(^|\s)\[(?=\s)/,
				lookbehind: true,
				alias: "operator"
			}, {
				pattern: /(\s)\](?=\s|$)/,
				lookbehind: true,
				alias: "operator"
			}],
			"normal-word": {
				pattern: /(^|\s)[^"\s]\S*(?=\s|$)/,
				lookbehind: true
			},
			string: {
				pattern: /"(?:\\\S|[^"\\])*"/,
				greedy: true,
				inside: string_inside
			}
		};
		var escape$1 = function(str) {
			return (str + "").replace(/([.?*+\^$\[\]\\(){}|\-])/g, "\\$1");
		};
		var arrToWordsRegExp = function(arr) {
			return new RegExp("(^|\\s)(?:" + arr.map(escape$1).join("|") + ")(?=\\s|$)");
		};
		var builtins = {
			"kernel-builtin": [
				"or",
				"2nipd",
				"4drop",
				"tuck",
				"wrapper",
				"nip",
				"wrapper?",
				"callstack>array",
				"die",
				"dupd",
				"callstack",
				"callstack?",
				"3dup",
				"hashcode",
				"pick",
				"4nip",
				"build",
				">boolean",
				"nipd",
				"clone",
				"5nip",
				"eq?",
				"?",
				"=",
				"swapd",
				"2over",
				"clear",
				"2dup",
				"get-retainstack",
				"not",
				"tuple?",
				"dup",
				"3nipd",
				"call",
				"-rotd",
				"object",
				"drop",
				"assert=",
				"assert?",
				"-rot",
				"execute",
				"boa",
				"get-callstack",
				"curried?",
				"3drop",
				"pickd",
				"overd",
				"over",
				"roll",
				"3nip",
				"swap",
				"and",
				"2nip",
				"rotd",
				"throw",
				"(clone)",
				"hashcode*",
				"spin",
				"reach",
				"4dup",
				"equal?",
				"get-datastack",
				"assert",
				"2drop",
				"<wrapper>",
				"boolean?",
				"identity-hashcode",
				"identity-tuple?",
				"null",
				"composed?",
				"new",
				"5drop",
				"rot",
				"-roll",
				"xor",
				"identity-tuple",
				"boolean"
			],
			"other-builtin-syntax": [
				"=======",
				"recursive",
				"flushable",
				">>",
				"<<<<<<",
				"M\\",
				"B",
				"PRIVATE>",
				"\\",
				"======",
				"final",
				"inline",
				"delimiter",
				"deprecated",
				"<PRIVATE",
				">>>>>>",
				"<<<<<<<",
				"parse-complex",
				"malformed-complex",
				"read-only",
				">>>>>>>",
				"call-next-method",
				"<<",
				"foldable",
				"$",
				"$[",
				"${"
			],
			"sequences-builtin": [
				"member-eq?",
				"mismatch",
				"append",
				"assert-sequence=",
				"longer",
				"repetition",
				"clone-like",
				"3sequence",
				"assert-sequence?",
				"last-index-from",
				"reversed",
				"index-from",
				"cut*",
				"pad-tail",
				"join-as",
				"remove-eq!",
				"concat-as",
				"but-last",
				"snip",
				"nths",
				"nth",
				"sequence",
				"longest",
				"slice?",
				"<slice>",
				"remove-nth",
				"tail-slice",
				"empty?",
				"tail*",
				"member?",
				"virtual-sequence?",
				"set-length",
				"drop-prefix",
				"iota",
				"unclip",
				"bounds-error?",
				"unclip-last-slice",
				"non-negative-integer-expected",
				"non-negative-integer-expected?",
				"midpoint@",
				"longer?",
				"?set-nth",
				"?first",
				"rest-slice",
				"prepend-as",
				"prepend",
				"fourth",
				"sift",
				"subseq-start",
				"new-sequence",
				"?last",
				"like",
				"first4",
				"1sequence",
				"reverse",
				"slice",
				"virtual@",
				"repetition?",
				"set-last",
				"index",
				"4sequence",
				"max-length",
				"set-second",
				"immutable-sequence",
				"first2",
				"first3",
				"supremum",
				"unclip-slice",
				"suffix!",
				"insert-nth",
				"tail",
				"3append",
				"short",
				"suffix",
				"concat",
				"flip",
				"immutable?",
				"reverse!",
				"2sequence",
				"sum",
				"delete-all",
				"indices",
				"snip-slice",
				"<iota>",
				"check-slice",
				"sequence?",
				"head",
				"append-as",
				"halves",
				"sequence=",
				"collapse-slice",
				"?second",
				"slice-error?",
				"product",
				"bounds-check?",
				"bounds-check",
				"immutable",
				"virtual-exemplar",
				"harvest",
				"remove",
				"pad-head",
				"last",
				"set-fourth",
				"cartesian-product",
				"remove-eq",
				"shorten",
				"shorter",
				"reversed?",
				"shorter?",
				"shortest",
				"head-slice",
				"pop*",
				"tail-slice*",
				"but-last-slice",
				"iota?",
				"append!",
				"cut-slice",
				"new-resizable",
				"head-slice*",
				"sequence-hashcode",
				"pop",
				"set-nth",
				"?nth",
				"second",
				"join",
				"immutable-sequence?",
				"<reversed>",
				"3append-as",
				"virtual-sequence",
				"subseq?",
				"remove-nth!",
				"length",
				"last-index",
				"lengthen",
				"assert-sequence",
				"copy",
				"move",
				"third",
				"first",
				"tail?",
				"set-first",
				"prefix",
				"bounds-error",
				"<repetition>",
				"exchange",
				"surround",
				"cut",
				"min-length",
				"set-third",
				"push-all",
				"head?",
				"subseq-start-from",
				"delete-slice",
				"rest",
				"sum-lengths",
				"head*",
				"infimum",
				"remove!",
				"glue",
				"slice-error",
				"subseq",
				"push",
				"replace-slice",
				"subseq-as",
				"unclip-last"
			],
			"math-builtin": [
				"number=",
				"next-power-of-2",
				"?1+",
				"fp-special?",
				"imaginary-part",
				"float>bits",
				"number?",
				"fp-infinity?",
				"bignum?",
				"fp-snan?",
				"denominator",
				"gcd",
				"*",
				"+",
				"fp-bitwise=",
				"-",
				"u>=",
				"/",
				">=",
				"bitand",
				"power-of-2?",
				"log2-expects-positive",
				"neg?",
				"<",
				"log2",
				">",
				"integer?",
				"number",
				"bits>double",
				"2/",
				"zero?",
				"bits>float",
				"float?",
				"shift",
				"ratio?",
				"rect>",
				"even?",
				"ratio",
				"fp-sign",
				"bitnot",
				">fixnum",
				"complex?",
				"/i",
				"integer>fixnum",
				"/f",
				"sgn",
				">bignum",
				"next-float",
				"u<",
				"u>",
				"mod",
				"recip",
				"rational",
				">float",
				"2^",
				"integer",
				"fixnum?",
				"neg",
				"fixnum",
				"sq",
				"bignum",
				">rect",
				"bit?",
				"fp-qnan?",
				"simple-gcd",
				"complex",
				"<fp-nan>",
				"real",
				">fraction",
				"double>bits",
				"bitor",
				"rem",
				"fp-nan-payload",
				"real-part",
				"log2-expects-positive?",
				"prev-float",
				"align",
				"unordered?",
				"float",
				"fp-nan?",
				"abs",
				"bitxor",
				"integer>fixnum-strict",
				"u<=",
				"odd?",
				"<=",
				"/mod",
				">integer",
				"real?",
				"rational?",
				"numerator"
			]
		};
		Object.keys(builtins).forEach(function(k) {
			factor$1[k].pattern = arrToWordsRegExp(builtins[k]);
		});
		var combinators = [
			"2bi",
			"while",
			"2tri",
			"bi*",
			"4dip",
			"both?",
			"same?",
			"tri@",
			"curry",
			"prepose",
			"3bi",
			"?if",
			"tri*",
			"2keep",
			"3keep",
			"curried",
			"2keepd",
			"when",
			"2bi*",
			"2tri*",
			"4keep",
			"bi@",
			"keepdd",
			"do",
			"unless*",
			"tri-curry",
			"if*",
			"loop",
			"bi-curry*",
			"when*",
			"2bi@",
			"2tri@",
			"with",
			"2with",
			"either?",
			"bi",
			"until",
			"3dip",
			"3curry",
			"tri-curry*",
			"tri-curry@",
			"bi-curry",
			"keepd",
			"compose",
			"2dip",
			"if",
			"3tri",
			"unless",
			"tuple",
			"keep",
			"2curry",
			"tri",
			"most",
			"while*",
			"dip",
			"composed",
			"bi-curry@",
			"find-last-from",
			"trim-head-slice",
			"map-as",
			"each-from",
			"none?",
			"trim-tail",
			"partition",
			"if-empty",
			"accumulate*",
			"reject!",
			"find-from",
			"accumulate-as",
			"collector-for-as",
			"reject",
			"map",
			"map-sum",
			"accumulate!",
			"2each-from",
			"follow",
			"supremum-by",
			"map!",
			"unless-empty",
			"collector",
			"padding",
			"reduce-index",
			"replicate-as",
			"infimum-by",
			"trim-tail-slice",
			"count",
			"find-index",
			"filter",
			"accumulate*!",
			"reject-as",
			"map-integers",
			"map-find",
			"reduce",
			"selector",
			"interleave",
			"2map",
			"filter-as",
			"binary-reduce",
			"map-index-as",
			"find",
			"produce",
			"filter!",
			"replicate",
			"cartesian-map",
			"cartesian-each",
			"find-index-from",
			"map-find-last",
			"3map-as",
			"3map",
			"find-last",
			"selector-as",
			"2map-as",
			"2map-reduce",
			"accumulate",
			"each",
			"each-index",
			"accumulate*-as",
			"when-empty",
			"all?",
			"collector-as",
			"push-either",
			"new-like",
			"collector-for",
			"2selector",
			"push-if",
			"2all?",
			"map-reduce",
			"3each",
			"any?",
			"trim-slice",
			"2reduce",
			"change-nth",
			"produce-as",
			"2each",
			"trim",
			"trim-head",
			"cartesian-find",
			"map-index",
			"if-zero",
			"each-integer",
			"unless-zero",
			"(find-integer)",
			"when-zero",
			"find-last-integer",
			"(all-integers?)",
			"times",
			"(each-integer)",
			"find-integer",
			"all-integers?",
			"unless-negative",
			"if-positive",
			"when-positive",
			"when-negative",
			"unless-positive",
			"if-negative",
			"case",
			"2cleave",
			"cond>quot",
			"case>quot",
			"3cleave",
			"wrong-values",
			"to-fixed-point",
			"alist>quot",
			"cond",
			"cleave",
			"call-effect",
			"recursive-hashcode",
			"spread",
			"deep-spread>quot",
			"2||",
			"0||",
			"n||",
			"0&&",
			"2&&",
			"3||",
			"1||",
			"1&&",
			"n&&",
			"3&&",
			"smart-unless*",
			"keep-inputs",
			"reduce-outputs",
			"smart-when*",
			"cleave>array",
			"smart-with",
			"smart-apply",
			"smart-if",
			"inputs/outputs",
			"output>sequence-n",
			"map-outputs",
			"map-reduce-outputs",
			"dropping",
			"output>array",
			"smart-map-reduce",
			"smart-2map-reduce",
			"output>array-n",
			"nullary",
			"input<sequence",
			"append-outputs",
			"drop-inputs",
			"inputs",
			"smart-2reduce",
			"drop-outputs",
			"smart-reduce",
			"preserving",
			"smart-when",
			"outputs",
			"append-outputs-as",
			"smart-unless",
			"smart-if*",
			"sum-outputs",
			"input<sequence-unsafe",
			"output>sequence"
		];
		factor$1.combinators.pattern = arrToWordsRegExp(combinators);
		Prism$2.languages.factor = factor$1;
	})(Prism$1);
}
$false.displayName = "false";
$false.aliases = [];
function $false(Prism$1) {
	(function(Prism$2) {
		Prism$2.languages["false"] = {
			comment: { pattern: /\{[^}]*\}/ },
			string: {
				pattern: /"[^"]*"/,
				greedy: true
			},
			"character-code": {
				pattern: /'(?:[^\r]|\r\n?)/,
				alias: "number"
			},
			"assembler-code": {
				pattern: /\d+`/,
				alias: "important"
			},
			number: /\d+/,
			operator: /[-!#$%&'*+,./:;=>?@\\^_`|~ßø]/,
			punctuation: /\[|\]/,
			variable: /[a-z]/,
			"non-standard": {
				pattern: /[()<BDO®]/,
				alias: "bold"
			}
		};
	})(Prism$1);
}
firestoreSecurityRules.displayName = "firestore-security-rules";
firestoreSecurityRules.aliases = [];
function firestoreSecurityRules(Prism$1) {
	Prism$1.register(clike);
	Prism$1.languages["firestore-security-rules"] = Prism$1.languages.extend("clike", {
		comment: /\/\/.*/,
		keyword: /\b(?:allow|function|if|match|null|return|rules_version|service)\b/,
		operator: /&&|\|\||[<>!=]=?|[-+*/%]|\b(?:in|is)\b/
	});
	delete Prism$1.languages["firestore-security-rules"]["class-name"];
	Prism$1.languages.insertBefore("firestore-security-rules", "keyword", {
		path: {
			pattern: /(^|[\s(),])(?:\/(?:[\w\xA0-\uFFFF]+|\{[\w\xA0-\uFFFF]+(?:=\*\*)?\}|\$\([\w\xA0-\uFFFF.]+\)))+/,
			lookbehind: true,
			greedy: true,
			inside: {
				variable: {
					pattern: /\{[\w\xA0-\uFFFF]+(?:=\*\*)?\}|\$\([\w\xA0-\uFFFF.]+\)/,
					inside: {
						operator: /=/,
						keyword: /\*\*/,
						punctuation: /[.$(){}]/
					}
				},
				punctuation: /\//
			}
		},
		method: {
			pattern: /(\ballow\s+)[a-z]+(?:\s*,\s*[a-z]+)*(?=\s*[:;])/,
			lookbehind: true,
			alias: "builtin",
			inside: { punctuation: /,/ }
		}
	});
}
flow$2.displayName = "flow";
flow$2.aliases = [];
function flow$2(Prism$1) {
	Prism$1.register(javascript);
	(function(Prism$2) {
		Prism$2.languages.flow = Prism$2.languages.extend("javascript", {});
		Prism$2.languages.insertBefore("flow", "keyword", { type: [{
			pattern: /\b(?:[Bb]oolean|Function|[Nn]umber|[Ss]tring|[Ss]ymbol|any|mixed|null|void)\b/,
			alias: "class-name"
		}] });
		Prism$2.languages.flow["function-variable"].pattern = /(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=\s*(?:function\b|(?:\([^()]*\)(?:\s*:\s*\w+)?|(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/i;
		delete Prism$2.languages.flow["parameter"];
		Prism$2.languages.insertBefore("flow", "operator", { "flow-punctuation": {
			pattern: /\{\||\|\}/,
			alias: "punctuation"
		} });
		if (!Array.isArray(Prism$2.languages.flow.keyword)) Prism$2.languages.flow.keyword = [Prism$2.languages.flow.keyword];
		Prism$2.languages.flow.keyword.unshift({
			pattern: /(^|[^$]\b)(?:Class|declare|opaque|type)\b(?!\$)/,
			lookbehind: true
		}, {
			pattern: /(^|[^$]\B)\$(?:Diff|Enum|Exact|Keys|ObjMap|PropertyType|Record|Shape|Subtype|Supertype|await)\b(?!\$)/,
			lookbehind: true
		});
	})(Prism$1);
}
fortran.displayName = "fortran";
fortran.aliases = [];
function fortran(Prism$1) {
	Prism$1.languages.fortran = {
		"quoted-number": {
			pattern: /[BOZ](['"])[A-F0-9]+\1/i,
			alias: "number"
		},
		string: {
			pattern: /(?:\b\w+_)?(['"])(?:\1\1|&(?:\r\n?|\n)(?:[ \t]*!.*(?:\r\n?|\n)|(?![ \t]*!))|(?!\1).)*(?:\1|&)/,
			inside: { comment: {
				pattern: /(&(?:\r\n?|\n)\s*)!.*/,
				lookbehind: true
			} }
		},
		comment: {
			pattern: /!.*/,
			greedy: true
		},
		boolean: /\.(?:FALSE|TRUE)\.(?:_\w+)?/i,
		number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[ED][+-]?\d+)?(?:_\w+)?/i,
		keyword: [
			/\b(?:CHARACTER|COMPLEX|DOUBLE ?PRECISION|INTEGER|LOGICAL|REAL)\b/i,
			/\b(?:END ?)?(?:BLOCK ?DATA|DO|FILE|FORALL|FUNCTION|IF|INTERFACE|MODULE(?! PROCEDURE)|PROGRAM|SELECT|SUBROUTINE|TYPE|WHERE)\b/i,
			/\b(?:ALLOCATABLE|ALLOCATE|BACKSPACE|CALL|CASE|CLOSE|COMMON|CONTAINS|CONTINUE|CYCLE|DATA|DEALLOCATE|DIMENSION|DO|END|EQUIVALENCE|EXIT|EXTERNAL|FORMAT|GO ?TO|IMPLICIT(?: NONE)?|INQUIRE|INTENT|INTRINSIC|MODULE PROCEDURE|NAMELIST|NULLIFY|OPEN|OPTIONAL|PARAMETER|POINTER|PRINT|PRIVATE|PUBLIC|READ|RETURN|REWIND|SAVE|SELECT|STOP|TARGET|WHILE|WRITE)\b/i,
			/\b(?:ASSIGNMENT|DEFAULT|ELEMENTAL|ELSE|ELSEIF|ELSEWHERE|ENTRY|IN|INCLUDE|INOUT|KIND|NULL|ONLY|OPERATOR|OUT|PURE|RECURSIVE|RESULT|SEQUENCE|STAT|THEN|USE)\b/i
		],
		operator: [/\*\*|\/\/|=>|[=\/]=|[<>]=?|::|[+\-*=%]|\.[A-Z]+\./i, {
			pattern: /(^|(?!\().)\/(?!\))/,
			lookbehind: true
		}],
		punctuation: /\(\/|\/\)|[(),;:&]/
	};
}
ftl.displayName = "ftl";
ftl.aliases = [];
function ftl(Prism$1) {
	Prism$1.register(markupTemplating);
	(function(Prism$2) {
		var FTL_EXPR = /[^<()"']|\((?:<expr>)*\)|<(?!#--)|<#--(?:[^-]|-(?!->))*-->|"(?:[^\\"]|\\.)*"|'(?:[^\\']|\\.)*'/.source;
		for (var i = 0; i < 2; i++) FTL_EXPR = FTL_EXPR.replace(/<expr>/g, function() {
			return FTL_EXPR;
		});
		FTL_EXPR = FTL_EXPR.replace(/<expr>/g, /[^\s\S]/.source);
		var ftl$1 = {
			comment: /<#--[\s\S]*?-->/,
			string: [{
				pattern: /\br("|')(?:(?!\1)[^\\]|\\.)*\1/,
				greedy: true
			}, {
				pattern: RegExp(/("|')(?:(?!\1|\$\{)[^\\]|\\.|\$\{(?:(?!\})(?:<expr>))*\})*\1/.source.replace(/<expr>/g, function() {
					return FTL_EXPR;
				})),
				greedy: true,
				inside: { interpolation: {
					pattern: RegExp(/((?:^|[^\\])(?:\\\\)*)\$\{(?:(?!\})(?:<expr>))*\}/.source.replace(/<expr>/g, function() {
						return FTL_EXPR;
					})),
					lookbehind: true,
					inside: {
						"interpolation-punctuation": {
							pattern: /^\$\{|\}$/,
							alias: "punctuation"
						},
						rest: null
					}
				} }
			}],
			keyword: /\b(?:as)\b/,
			boolean: /\b(?:false|true)\b/,
			"builtin-function": {
				pattern: /((?:^|[^?])\?\s*)\w+/,
				lookbehind: true,
				alias: "function"
			},
			function: /\b\w+(?=\s*\()/,
			number: /\b\d+(?:\.\d+)?\b/,
			operator: /\.\.[<*!]?|->|--|\+\+|&&|\|\||\?{1,2}|[-+*/%!=<>]=?|\b(?:gt|gte|lt|lte)\b/,
			punctuation: /[,;.:()[\]{}]/
		};
		ftl$1.string[1].inside.interpolation.inside.rest = ftl$1;
		Prism$2.languages.ftl = {
			"ftl-comment": {
				pattern: /^<#--[\s\S]*/,
				alias: "comment"
			},
			"ftl-directive": {
				pattern: /^<[\s\S]+>$/,
				inside: {
					directive: {
						pattern: /(^<\/?)[#@][a-z]\w*/i,
						lookbehind: true,
						alias: "keyword"
					},
					punctuation: /^<\/?|\/?>$/,
					content: {
						pattern: /\s*\S[\s\S]*/,
						alias: "ftl",
						inside: ftl$1
					}
				}
			},
			"ftl-interpolation": {
				pattern: /^\$\{[\s\S]*\}$/,
				inside: {
					punctuation: /^\$\{|\}$/,
					content: {
						pattern: /\s*\S[\s\S]*/,
						alias: "ftl",
						inside: ftl$1
					}
				}
			}
		};
		Prism$2.hooks.add("before-tokenize", function(env$1) {
			var pattern = RegExp(/<#--[\s\S]*?-->|<\/?[#@][a-zA-Z](?:<expr>)*?>|\$\{(?:<expr>)*?\}/.source.replace(/<expr>/g, function() {
				return FTL_EXPR;
			}), "gi");
			Prism$2.languages["markup-templating"].buildPlaceholders(env$1, "ftl", pattern);
		});
		Prism$2.hooks.add("after-tokenize", function(env$1) {
			Prism$2.languages["markup-templating"].tokenizePlaceholders(env$1, "ftl");
		});
	})(Prism$1);
}
gml.displayName = "gml";
gml.aliases = ["gamemakerlanguage"];
function gml(Prism$1) {
	Prism$1.register(clike);
	Prism$1.languages.gamemakerlanguage = Prism$1.languages.gml = Prism$1.languages.extend("clike", {
		keyword: /\b(?:break|case|continue|default|do|else|enum|exit|for|globalvar|if|repeat|return|switch|until|var|while)\b/,
		number: /(?:\b0x[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ulf]{0,4}/i,
		operator: /--|\+\+|[-+%/=]=?|!=|\*\*?=?|<[<=>]?|>[=>]?|&&?|\^\^?|\|\|?|~|\b(?:and|at|not|or|with|xor)\b/,
		constant: /\b(?:GM_build_date|GM_version|action_(?:continue|restart|reverse|stop)|all|gamespeed_(?:fps|microseconds)|global|local|noone|other|pi|pointer_(?:invalid|null)|self|timezone_(?:local|utc)|undefined|ev_(?:create|destroy|step|alarm|keyboard|mouse|collision|other|draw|draw_(?:begin|end|post|pre)|keypress|keyrelease|trigger|(?:left|middle|no|right)_button|(?:left|middle|right)_press|(?:left|middle|right)_release|mouse_(?:enter|leave|wheel_down|wheel_up)|global_(?:left|middle|right)_button|global_(?:left|middle|right)_press|global_(?:left|middle|right)_release|joystick(?:1|2)_(?:button1|button2|button3|button4|button5|button6|button7|button8|down|left|right|up)|outside|boundary|game_start|game_end|room_start|room_end|no_more_lives|animation_end|end_of_path|no_more_health|user\d|gui|gui_begin|gui_end|step_(?:begin|end|normal))|vk_(?:alt|anykey|backspace|control|delete|down|end|enter|escape|home|insert|left|nokey|pagedown|pageup|pause|printscreen|return|right|shift|space|tab|up|f\d|numpad\d|add|decimal|divide|lalt|lcontrol|lshift|multiply|ralt|rcontrol|rshift|subtract)|achievement_(?:filter_(?:all_players|favorites_only|friends_only)|friends_info|info|leaderboard_info|our_info|pic_loaded|show_(?:achievement|bank|friend_picker|leaderboard|profile|purchase_prompt|ui)|type_challenge|type_score_challenge)|asset_(?:font|object|path|room|script|shader|sound|sprite|tiles|timeline|unknown)|audio_(?:3d|falloff_(?:exponent_distance|exponent_distance_clamped|inverse_distance|inverse_distance_clamped|linear_distance|linear_distance_clamped|none)|mono|new_system|old_system|stereo)|bm_(?:add|complex|dest_alpha|dest_color|dest_colour|inv_dest_alpha|inv_dest_color|inv_dest_colour|inv_src_alpha|inv_src_color|inv_src_colour|max|normal|one|src_alpha|src_alpha_sat|src_color|src_colour|subtract|zero)|browser_(?:chrome|firefox|ie|ie_mobile|not_a_browser|opera|safari|safari_mobile|tizen|unknown|windows_store)|buffer_(?:bool|f16|f32|f64|fast|fixed|generalerror|grow|invalidtype|network|outofbounds|outofspace|s16|s32|s8|seek_end|seek_relative|seek_start|string|text|u16|u32|u64|u8|vbuffer|wrap)|c_(?:aqua|black|blue|dkgray|fuchsia|gray|green|lime|ltgray|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)|cmpfunc_(?:always|equal|greater|greaterequal|less|lessequal|never|notequal)|cr_(?:appstart|arrow|beam|cross|default|drag|handpoint|hourglass|none|size_all|size_nesw|size_ns|size_nwse|size_we|uparrow)|cull_(?:clockwise|counterclockwise|noculling)|device_(?:emulator|tablet)|device_ios_(?:ipad|ipad_retina|iphone|iphone5|iphone6|iphone6plus|iphone_retina|unknown)|display_(?:landscape|landscape_flipped|portrait|portrait_flipped)|dll_(?:cdecl|cdel|stdcall)|ds_type_(?:grid|list|map|priority|queue|stack)|ef_(?:cloud|ellipse|explosion|firework|flare|rain|ring|smoke|smokeup|snow|spark|star)|fa_(?:archive|bottom|center|directory|hidden|left|middle|readonly|right|sysfile|top|volumeid)|fb_login_(?:default|fallback_to_webview|forcing_safari|forcing_webview|no_fallback_to_webview|use_system_account)|iap_(?:available|canceled|ev_consume|ev_product|ev_purchase|ev_restore|ev_storeload|failed|purchased|refunded|status_available|status_loading|status_processing|status_restoring|status_unavailable|status_uninitialised|storeload_failed|storeload_ok|unavailable)|leaderboard_type_(?:number|time_mins_secs)|lighttype_(?:dir|point)|matrix_(?:projection|view|world)|mb_(?:any|left|middle|none|right)|network_(?:config_(?:connect_timeout|disable_reliable_udp|enable_reliable_udp|use_non_blocking_socket)|socket_(?:bluetooth|tcp|udp)|type_(?:connect|data|disconnect|non_blocking_connect))|of_challenge_(?:lose|tie|win)|os_(?:android|ios|linux|macosx|ps3|ps4|psvita|unknown|uwp|win32|win8native|windows|winphone|xboxone)|phy_debug_render_(?:aabb|collision_pairs|coms|core_shapes|joints|obb|shapes)|phy_joint_(?:anchor_1_x|anchor_1_y|anchor_2_x|anchor_2_y|angle|angle_limits|damping_ratio|frequency|length_1|length_2|lower_angle_limit|max_force|max_length|max_motor_force|max_motor_torque|max_torque|motor_force|motor_speed|motor_torque|reaction_force_x|reaction_force_y|reaction_torque|speed|translation|upper_angle_limit)|phy_particle_data_flag_(?:category|color|colour|position|typeflags|velocity)|phy_particle_flag_(?:colormixing|colourmixing|elastic|powder|spring|tensile|viscous|wall|water|zombie)|phy_particle_group_flag_(?:rigid|solid)|pr_(?:linelist|linestrip|pointlist|trianglefan|trianglelist|trianglestrip)|ps_(?:distr|shape)_(?:diamond|ellipse|gaussian|invgaussian|line|linear|rectangle)|pt_shape_(?:circle|cloud|disk|explosion|flare|line|pixel|ring|smoke|snow|spark|sphere|square|star)|ty_(?:real|string)|gp_(?:face\d|axislh|axislv|axisrh|axisrv|padd|padl|padr|padu|select|shoulderl|shoulderlb|shoulderr|shoulderrb|start|stickl|stickr)|lb_disp_(?:none|numeric|time_ms|time_sec)|lb_sort_(?:ascending|descending|none)|ov_(?:achievements|community|friends|gamegroup|players|settings)|ugc_(?:filetype_(?:community|microtrans)|list_(?:Favorited|Followed|Published|Subscribed|UsedOrPlayed|VotedDown|VotedOn|VotedUp|WillVoteLater)|match_(?:AllGuides|Artwork|Collections|ControllerBindings|IntegratedGuides|Items|Items_Mtx|Items_ReadyToUse|Screenshots|UsableInGame|Videos|WebGuides)|query_(?:AcceptedForGameRankedByAcceptanceDate|CreatedByFriendsRankedByPublicationDate|FavoritedByFriendsRankedByPublicationDate|NotYetRated)|query_RankedBy(?:NumTimesReported|PublicationDate|TextSearch|TotalVotesAsc|Trend|Vote|VotesUp)|result_success|sortorder_CreationOrder(?:Asc|Desc)|sortorder_(?:ForModeration|LastUpdatedDesc|SubscriptionDateDesc|TitleAsc|VoteScoreDesc)|visibility_(?:friends_only|private|public))|vertex_usage_(?:binormal|blendindices|blendweight|color|colour|depth|fog|normal|position|psize|sample|tangent|texcoord|textcoord)|vertex_type_(?:float\d|color|colour|ubyte4)|input_type|layerelementtype_(?:background|instance|oldtilemap|particlesystem|sprite|tile|tilemap|undefined)|se_(?:chorus|compressor|echo|equalizer|flanger|gargle|none|reverb)|text_type|tile_(?:flip|index_mask|mirror|rotate)|(?:obj|rm|scr|spr)\w+)\b/,
		variable: /\b(?:alarm|application_surface|async_load|background_(?:alpha|blend|color|colour|foreground|height|hspeed|htiled|index|showcolor|showcolour|visible|vspeed|vtiled|width|x|xscale|y|yscale)|bbox_(?:bottom|left|right|top)|browser_(?:height|width)|caption_(?:health|lives|score)|current_(?:day|hour|minute|month|second|time|weekday|year)|cursor_sprite|debug_mode|delta_time|direction|display_aa|error_(?:last|occurred)|event_(?:action|number|object|type)|fps|fps_real|friction|game_(?:display|project|save)_(?:id|name)|gamemaker_(?:pro|registered|version)|gravity|gravity_direction|(?:h|v)speed|health|iap_data|id|image_(?:alpha|angle|blend|depth|index|number|speed|xscale|yscale)|instance_(?:count|id)|keyboard_(?:key|lastchar|lastkey|string)|layer|lives|mask_index|mouse_(?:button|lastbutton|x|y)|object_index|os_(?:browser|device|type|version)|path_(?:endaction|index|orientation|position|positionprevious|scale|speed)|persistent|phy_(?:rotation|(?:col_normal|collision|com|linear_velocity|position|speed)_(?:x|y)|angular_(?:damping|velocity)|position_(?:x|y)previous|speed|linear_damping|bullet|fixed_rotation|active|mass|inertia|dynamic|kinematic|sleeping|collision_points)|pointer_(?:invalid|null)|room|room_(?:caption|first|height|last|persistent|speed|width)|score|secure_mode|show_(?:health|lives|score)|solid|speed|sprite_(?:height|index|width|xoffset|yoffset)|temp_directory|timeline_(?:index|loop|position|running|speed)|transition_(?:color|kind|steps)|undefined|view_(?:angle|current|enabled|(?:h|v)(?:border|speed)|(?:h|w|x|y)port|(?:h|w|x|y)view|object|surface_id|visible)|visible|webgl_enabled|working_directory|(?:x|y)(?:previous|start)|x|y|argument(?:_relitive|_count|\d)|argument|global|local|other|self)\b/
	});
}
gap.displayName = "gap";
gap.aliases = [];
function gap(Prism$1) {
	Prism$1.languages.gap = {
		shell: {
			pattern: /^gap>[\s\S]*?(?=^gap>|$(?![\s\S]))/m,
			greedy: true,
			inside: {
				gap: {
					pattern: /^(gap>).+(?:(?:\r(?:\n|(?!\n))|\n)>.*)*/,
					lookbehind: true,
					inside: null
				},
				punctuation: /^gap>/
			}
		},
		comment: {
			pattern: /#.*/,
			greedy: true
		},
		string: {
			pattern: /(^|[^\\'"])(?:'(?:[^\r\n\\']|\\.){1,10}'|"(?:[^\r\n\\"]|\\.)*"(?!")|"""[\s\S]*?""")/,
			lookbehind: true,
			greedy: true,
			inside: { continuation: {
				pattern: /([\r\n])>/,
				lookbehind: true,
				alias: "punctuation"
			} }
		},
		keyword: /\b(?:Assert|Info|IsBound|QUIT|TryNextMethod|Unbind|and|atomic|break|continue|do|elif|else|end|fi|for|function|if|in|local|mod|not|od|or|quit|readonly|readwrite|rec|repeat|return|then|until|while)\b/,
		boolean: /\b(?:false|true)\b/,
		function: /\b[a-z_]\w*(?=\s*\()/i,
		number: {
			pattern: /(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
			lookbehind: true
		},
		continuation: {
			pattern: /([\r\n])>/,
			lookbehind: true,
			alias: "punctuation"
		},
		operator: /->|[-+*/^~=!]|<>|[<>]=?|:=|\.\./,
		punctuation: /[()[\]{},;.:]/
	};
	Prism$1.languages.gap.shell.inside.gap.inside = Prism$1.languages.gap;
}
gcode.displayName = "gcode";
gcode.aliases = [];
function gcode(Prism$1) {
	Prism$1.languages.gcode = {
		comment: /;.*|\B\(.*?\)\B/,
		string: {
			pattern: /"(?:""|[^"])*"/,
			greedy: true
		},
		keyword: /\b[GM]\d+(?:\.\d+)?\b/,
		property: /\b[A-Z]/,
		checksum: {
			pattern: /(\*)\d+/,
			lookbehind: true,
			alias: "number"
		},
		punctuation: /[:*]/
	};
}
gdscript.displayName = "gdscript";
gdscript.aliases = [];
function gdscript(Prism$1) {
	Prism$1.languages.gdscript = {
		comment: /#.*/,
		string: {
			pattern: /@?(?:("|')(?:(?!\1)[^\n\\]|\\[\s\S])*\1(?!"|')|"""(?:[^\\]|\\[\s\S])*?""")/,
			greedy: true
		},
		"class-name": {
			pattern: /(^(?:class|class_name|extends)[ \t]+|^export\([ \t]*|\bas[ \t]+|(?:\b(?:const|var)[ \t]|[,(])[ \t]*\w+[ \t]*:[ \t]*|->[ \t]*)[a-zA-Z_]\w*/m,
			lookbehind: true
		},
		keyword: /\b(?:and|as|assert|break|breakpoint|class|class_name|const|continue|elif|else|enum|export|extends|for|func|if|in|is|master|mastersync|match|not|null|onready|or|pass|preload|puppet|puppetsync|remote|remotesync|return|self|setget|signal|static|tool|var|while|yield)\b/,
		function: /\b[a-z_]\w*(?=[ \t]*\()/i,
		variable: /\$\w+/,
		number: [/\b0b[01_]+\b|\b0x[\da-fA-F_]+\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.[\d_]+)(?:e[+-]?[\d_]+)?\b/, /\b(?:INF|NAN|PI|TAU)\b/],
		constant: /\b[A-Z][A-Z_\d]*\b/,
		boolean: /\b(?:false|true)\b/,
		operator: /->|:=|&&|\|\||<<|>>|[-+*/%&|!<>=]=?|[~^]/,
		punctuation: /[.:,;()[\]{}]/
	};
}
gedcom.displayName = "gedcom";
gedcom.aliases = [];
function gedcom(Prism$1) {
	Prism$1.languages.gedcom = {
		"line-value": {
			pattern: /(^[\t ]*\d+ +(?:@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@ +)?\w+ ).+/m,
			lookbehind: true,
			inside: { pointer: {
				pattern: /^@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@$/,
				alias: "variable"
			} }
		},
		record: {
			pattern: /(^[\t ]*\d+ +(?:@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@ +)?)\w+/m,
			lookbehind: true,
			alias: "tag"
		},
		level: {
			pattern: /(^[\t ]*)\d+/m,
			lookbehind: true,
			alias: "number"
		},
		pointer: {
			pattern: /@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@/,
			alias: "variable"
		}
	};
}
gettext.displayName = "gettext";
gettext.aliases = ["po"];
function gettext(Prism$1) {
	Prism$1.languages.gettext = {
		comment: [
			{
				pattern: /# .*/,
				greedy: true,
				alias: "translator-comment"
			},
			{
				pattern: /#\..*/,
				greedy: true,
				alias: "extracted-comment"
			},
			{
				pattern: /#:.*/,
				greedy: true,
				alias: "reference-comment"
			},
			{
				pattern: /#,.*/,
				greedy: true,
				alias: "flag-comment"
			},
			{
				pattern: /#\|.*/,
				greedy: true,
				alias: "previously-untranslated-comment"
			},
			{
				pattern: /#.*/,
				greedy: true
			}
		],
		string: {
			pattern: /(^|[^\\])"(?:[^"\\]|\\.)*"/,
			lookbehind: true,
			greedy: true
		},
		keyword: /^msg(?:ctxt|id|id_plural|str)\b/m,
		number: /\b\d+\b/,
		punctuation: /[\[\]]/
	};
	Prism$1.languages.po = Prism$1.languages.gettext;
}
gherkin.displayName = "gherkin";
gherkin.aliases = [];
function gherkin(Prism$1) {
	(function(Prism$2) {
		var tableRow$1 = /(?:\r?\n|\r)[ \t]*\|.+\|(?:(?!\|).)*/.source;
		Prism$2.languages.gherkin = {
			pystring: {
				pattern: /("""|''')[\s\S]+?\1/,
				alias: "string"
			},
			comment: {
				pattern: /(^[ \t]*)#.*/m,
				lookbehind: true
			},
			tag: {
				pattern: /(^[ \t]*)@\S*/m,
				lookbehind: true
			},
			feature: {
				pattern: /((?:^|\r?\n|\r)[ \t]*)(?:Ability|Ahoy matey!|Arwedd|Aspekt|Besigheid Behoefte|Business Need|Caracteristica|Característica|Egenskab|Egenskap|Eiginleiki|Feature|Fīča|Fitur|Fonctionnalité|Fonksyonalite|Funcionalidade|Funcionalitat|Functionalitate|Funcţionalitate|Funcționalitate|Functionaliteit|Fungsi|Funkcia|Funkcija|Funkcionalitāte|Funkcionalnost|Funkcja|Funksie|Funktionalität|Funktionalitéit|Funzionalità|Hwaet|Hwæt|Jellemző|Karakteristik|Lastnost|Mak|Mogucnost|laH|Mogućnost|Moznosti|Možnosti|OH HAI|Omadus|Ominaisuus|Osobina|Özellik|Potrzeba biznesowa|perbogh|poQbogh malja'|Požadavek|Požiadavka|Pretty much|Qap|Qu'meH 'ut|Savybė|Tính năng|Trajto|Vermoë|Vlastnosť|Właściwość|Značilnost|Δυνατότητα|Λειτουργία|Могућност|Мөмкинлек|Особина|Свойство|Үзенчәлеклелек|Функционал|Функционалност|Функция|Функціонал|תכונה|خاصية|خصوصیت|صلاحیت|کاروبار کی ضرورت|وِیژگی|रूप लेख|ਖਾਸੀਅਤ|ਨਕਸ਼ ਨੁਹਾਰ|ਮੁਹਾਂਦਰਾ|గుణము|ಹೆಚ್ಚಳ|ความต้องการทางธุรกิจ|ความสามารถ|โครงหลัก|기능|フィーチャ|功能|機能):(?:[^:\r\n]+(?:\r?\n|\r|$))*/,
				lookbehind: true,
				inside: {
					important: {
						pattern: /(:)[^\r\n]+/,
						lookbehind: true
					},
					keyword: /[^:\r\n]+:/
				}
			},
			scenario: {
				pattern: /(^[ \t]*)(?:Abstract Scenario|Abstrakt Scenario|Achtergrond|Aer|Ær|Agtergrond|All y'all|Antecedentes|Antecedents|Atburðarás|Atburðarásir|Awww, look mate|B4|Background|Baggrund|Bakgrund|Bakgrunn|Bakgrunnur|Beispiele|Beispiller|Bối cảnh|Cefndir|Cenario|Cenário|Cenario de Fundo|Cenário de Fundo|Cenarios|Cenários|Contesto|Context|Contexte|Contexto|Conto|Contoh|Contone|Dæmi|Dasar|Dead men tell no tales|Delineacao do Cenario|Delineação do Cenário|Dis is what went down|Dữ liệu|Dyagram Senaryo|Dyagram senaryo|Egzanp|Ejemplos|Eksempler|Ekzemploj|Enghreifftiau|Esbozo do escenario|Escenari|Escenario|Esempi|Esquema de l'escenari|Esquema del escenario|Esquema do Cenario|Esquema do Cenário|EXAMPLZ|Examples|Exempel|Exemple|Exemples|Exemplos|First off|Fono|Forgatókönyv|Forgatókönyv vázlat|Fundo|Geçmiş|Grundlage|Hannergrond|ghantoH|Háttér|Heave to|Istorik|Juhtumid|Keadaan|Khung kịch bản|Khung tình huống|Kịch bản|Koncept|Konsep skenario|Kontèks|Kontekst|Kontekstas|Konteksts|Kontext|Konturo de la scenaro|Latar Belakang|lut chovnatlh|lut|lutmey|Lýsing Atburðarásar|Lýsing Dæma|MISHUN SRSLY|MISHUN|Menggariskan Senario|mo'|Náčrt Scenára|Náčrt Scénáře|Náčrt Scenáru|Oris scenarija|Örnekler|Osnova|Osnova Scenára|Osnova scénáře|Osnutek|Ozadje|Paraugs|Pavyzdžiai|Példák|Piemēri|Plan du scénario|Plan du Scénario|Plan Senaryo|Plan senaryo|Plang vum Szenario|Pozadí|Pozadie|Pozadina|Príklady|Příklady|Primer|Primeri|Primjeri|Przykłady|Raamstsenaarium|Reckon it's like|Rerefons|Scenár|Scénář|Scenarie|Scenarij|Scenarijai|Scenarijaus šablonas|Scenariji|Scenārijs|Scenārijs pēc parauga|Scenarijus|Scenario|Scénario|Scenario Amlinellol|Scenario Outline|Scenario Template|Scenariomal|Scenariomall|Scenarios|Scenariu|Scenariusz|Scenaro|Schema dello scenario|Se ðe|Se the|Se þe|Senario|Senaryo Deskripsyon|Senaryo deskripsyon|Senaryo|Senaryo taslağı|Shiver me timbers|Situācija|Situai|Situasie Uiteensetting|Situasie|Skenario konsep|Skenario|Skica|Structura scenariu|Structură scenariu|Struktura scenarija|Stsenaarium|Swa hwaer swa|Swa|Swa hwær swa|Szablon scenariusza|Szenario|Szenariogrundriss|Tapaukset|Tapaus|Tapausaihio|Taust|Tausta|Template Keadaan|Template Senario|Template Situai|The thing of it is|Tình huống|Variantai|Voorbeelde|Voorbeelden|Wharrimean is|Yo-ho-ho|You'll wanna|Założenia|Παραδείγματα|Περιγραφή Σεναρίου|Σενάρια|Σενάριο|Υπόβαθρο|Кереш|Контекст|Концепт|Мисаллар|Мисоллар|Основа|Передумова|Позадина|Предистория|Предыстория|Приклади|Пример|Примери|Примеры|Рамка на сценарий|Скица|Структура сценарија|Структура сценария|Структура сценарію|Сценарий|Сценарий структураси|Сценарийның төзелеше|Сценарији|Сценарио|Сценарій|Тарих|Үрнәкләр|דוגמאות|רקע|תבנית תרחיש|תרחיש|الخلفية|الگوی سناریو|امثلة|پس منظر|زمینه|سناریو|سيناريو|سيناريو مخطط|مثالیں|منظر نامے کا خاکہ|منظرنامہ|نمونه ها|उदाहरण|परिदृश्य|परिदृश्य रूपरेखा|पृष्ठभूमि|ਉਦਾਹਰਨਾਂ|ਪਟਕਥਾ|ਪਟਕਥਾ ਢਾਂਚਾ|ਪਟਕਥਾ ਰੂਪ ਰੇਖਾ|ਪਿਛੋਕੜ|ఉదాహరణలు|కథనం|నేపథ్యం|సన్నివేశం|ಉದಾಹರಣೆಗಳು|ಕಥಾಸಾರಾಂಶ|ವಿವರಣೆ|ಹಿನ್ನೆಲೆ|โครงสร้างของเหตุการณ์|ชุดของตัวอย่าง|ชุดของเหตุการณ์|แนวคิด|สรุปเหตุการณ์|เหตุการณ์|배경|시나리오|시나리오 개요|예|サンプル|シナリオ|シナリオアウトライン|シナリオテンプレ|シナリオテンプレート|テンプレ|例|例子|剧本|剧本大纲|劇本|劇本大綱|场景|场景大纲|場景|場景大綱|背景):[^:\r\n]*/m,
				lookbehind: true,
				inside: {
					important: {
						pattern: /(:)[^\r\n]*/,
						lookbehind: true
					},
					keyword: /[^:\r\n]+:/
				}
			},
			"table-body": {
				pattern: RegExp("(" + tableRow$1 + ")(?:" + tableRow$1 + ")+"),
				lookbehind: true,
				inside: {
					outline: {
						pattern: /<[^>]+>/,
						alias: "variable"
					},
					td: {
						pattern: /\s*[^\s|][^|]*/,
						alias: "string"
					},
					punctuation: /\|/
				}
			},
			"table-head": {
				pattern: RegExp(tableRow$1),
				inside: {
					th: {
						pattern: /\s*[^\s|][^|]*/,
						alias: "variable"
					},
					punctuation: /\|/
				}
			},
			atrule: {
				pattern: /(^[ \t]+)(?:'a|'ach|'ej|7|a|A také|A taktiež|A tiež|A zároveň|Aber|Ac|Adott|Akkor|Ak|Aleshores|Ale|Ali|Allora|Alors|Als|Ama|Amennyiben|Amikor|Ampak|an|AN|Ananging|And y'all|And|Angenommen|Anrhegedig a|An|Apabila|Atès|Atesa|Atunci|Avast!|Aye|A|awer|Bagi|Banjur|Bet|Biết|Blimey!|Buh|But at the end of the day I reckon|But y'all|But|BUT|Cal|Când|Cand|Cando|Ce|Cuando|Če|Ða ðe|Ða|Dadas|Dada|Dados|Dado|DaH ghu' bejlu'|dann|Dann|Dano|Dan|Dar|Dat fiind|Data|Date fiind|Date|Dati fiind|Dati|Daţi fiind|Dați fiind|DEN|Dato|De|Den youse gotta|Dengan|Diberi|Diyelim ki|Donada|Donat|Donitaĵo|Do|Dun|Duota|Ðurh|Eeldades|Ef|Eğer ki|Entao|Então|Entón|E|En|Entonces|Epi|És|Etant donnée|Etant donné|Et|Étant données|Étant donnée|Étant donné|Etant données|Etant donnés|Étant donnés|Fakat|Gangway!|Gdy|Gegeben seien|Gegeben sei|Gegeven|Gegewe|ghu' noblu'|Gitt|Given y'all|Given|Givet|Givun|Ha|Cho|I CAN HAZ|In|Ir|It's just unbelievable|I|Ja|Jeśli|Jeżeli|Kad|Kada|Kadar|Kai|Kaj|Když|Keď|Kemudian|Ketika|Khi|Kiedy|Ko|Kuid|Kui|Kun|Lan|latlh|Le sa a|Let go and haul|Le|Lè sa a|Lè|Logo|Lorsqu'<|Lorsque|mä|Maar|Mais|Mając|Ma|Majd|Maka|Manawa|Mas|Men|Menawa|Mutta|Nalika|Nalikaning|Nanging|Når|När|Nato|Nhưng|Niin|Njuk|O zaman|Och|Og|Oletetaan|Ond|Onda|Oraz|Pak|Pero|Però|Podano|Pokiaľ|Pokud|Potem|Potom|Privzeto|Pryd|Quan|Quand|Quando|qaSDI'|Så|Sed|Se|Siis|Sipoze ke|Sipoze Ke|Sipoze|Si|Şi|Și|Soit|Stel|Tada|Tad|Takrat|Tak|Tapi|Ter|Tetapi|Tha the|Tha|Then y'all|Then|Thì|Thurh|Toda|Too right|Un|Und|ugeholl|Và|vaj|Vendar|Ve|wann|Wanneer|WEN|Wenn|When y'all|When|Wtedy|Wun|Y'know|Yeah nah|Yna|Youse know like when|Youse know when youse got|Y|Za predpokladu|Za předpokladu|Zadan|Zadani|Zadano|Zadate|Zadato|Zakładając|Zaradi|Zatati|Þa þe|Þa|Þá|Þegar|Þurh|Αλλά|Δεδομένου|Και|Όταν|Τότε|А також|Агар|Але|Али|Аммо|А|Әгәр|Әйтик|Әмма|Бирок|Ва|Вә|Дадено|Дано|Допустим|Если|Задате|Задати|Задато|И|І|К тому же|Када|Кад|Когато|Когда|Коли|Ләкин|Лекин|Нәтиҗәдә|Нехай|Но|Онда|Припустимо, що|Припустимо|Пусть|Также|Та|Тогда|Тоді|То|Унда|Һәм|Якщо|אבל|אזי|אז|בהינתן|וגם|כאשר|آنگاه|اذاً|اگر|اما|اور|با فرض|بالفرض|بفرض|پھر|تب|ثم|جب|عندما|فرض کیا|لكن|لیکن|متى|هنگامی|و|अगर|और|कदा|किन्तु|चूंकि|जब|तथा|तदा|तब|परन्तु|पर|यदि|ਅਤੇ|ਜਦੋਂ|ਜਿਵੇਂ ਕਿ|ਜੇਕਰ|ਤਦ|ਪਰ|అప్పుడు|ఈ పరిస్థితిలో|కాని|చెప్పబడినది|మరియు|ಆದರೆ|ನಂತರ|ನೀಡಿದ|ಮತ್ತು|ಸ್ಥಿತಿಯನ್ನು|กำหนดให้|ดังนั้น|แต่|เมื่อ|และ|그러면<|그리고<|단<|만약<|만일<|먼저<|조건<|하지만<|かつ<|しかし<|ただし<|ならば<|もし<|並且<|但し<|但是<|假如<|假定<|假設<|假设<|前提<|同时<|同時<|并且<|当<|當<|而且<|那么<|那麼<)(?=[ \t])/m,
				lookbehind: true
			},
			string: {
				pattern: /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/,
				inside: { outline: {
					pattern: /<[^>]+>/,
					alias: "variable"
				} }
			},
			outline: {
				pattern: /<[^>]+>/,
				alias: "variable"
			}
		};
	})(Prism$1);
}
git.displayName = "git";
git.aliases = [];
function git(Prism$1) {
	Prism$1.languages.git = {
		comment: /^#.*/m,
		deleted: /^[-–].*/m,
		inserted: /^\+.*/m,
		string: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
		command: {
			pattern: /^.*\$ git .*$/m,
			inside: { parameter: /\s--?\w+/ }
		},
		coord: /^@@.*@@$/m,
		"commit-sha1": /^commit \w{40}$/m
	};
}
glsl.displayName = "glsl";
glsl.aliases = [];
function glsl(Prism$1) {
	Prism$1.register(c$1);
	Prism$1.languages.glsl = Prism$1.languages.extend("c", { keyword: /\b(?:active|asm|atomic_uint|attribute|[ibdu]?vec[234]|bool|break|buffer|case|cast|centroid|class|coherent|common|const|continue|d?mat[234](?:x[234])?|default|discard|do|double|else|enum|extern|external|false|filter|fixed|flat|float|for|fvec[234]|goto|half|highp|hvec[234]|[iu]?sampler2DMS(?:Array)?|[iu]?sampler2DRect|[iu]?samplerBuffer|[iu]?samplerCube|[iu]?samplerCubeArray|[iu]?sampler[123]D|[iu]?sampler[12]DArray|[iu]?image2DMS(?:Array)?|[iu]?image2DRect|[iu]?imageBuffer|[iu]?imageCube|[iu]?imageCubeArray|[iu]?image[123]D|[iu]?image[12]DArray|if|in|inline|inout|input|int|interface|invariant|layout|long|lowp|mediump|namespace|noinline|noperspective|out|output|partition|patch|precise|precision|public|readonly|resource|restrict|return|sample|sampler[12]DArrayShadow|sampler[12]DShadow|sampler2DRectShadow|sampler3DRect|samplerCubeArrayShadow|samplerCubeShadow|shared|short|sizeof|smooth|static|struct|subroutine|superp|switch|template|this|true|typedef|uint|uniform|union|unsigned|using|varying|void|volatile|while|writeonly)\b/ });
}
gn.displayName = "gn";
gn.aliases = ["gni"];
function gn(Prism$1) {
	Prism$1.languages.gn = {
		comment: {
			pattern: /#.*/,
			greedy: true
		},
		"string-literal": {
			pattern: /(^|[^\\"])"(?:[^\r\n"\\]|\\.)*"/,
			lookbehind: true,
			greedy: true,
			inside: {
				interpolation: {
					pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\{[\s\S]*?\}|[a-zA-Z_]\w*|0x[a-fA-F0-9]{2})/,
					lookbehind: true,
					inside: {
						number: /^\$0x[\s\S]{2}$/,
						variable: /^\$\w+$/,
						"interpolation-punctuation": {
							pattern: /^\$\{|\}$/,
							alias: "punctuation"
						},
						expression: {
							pattern: /[\s\S]+/,
							inside: null
						}
					}
				},
				string: /[\s\S]+/
			}
		},
		keyword: /\b(?:else|if)\b/,
		boolean: /\b(?:false|true)\b/,
		"builtin-function": {
			pattern: /\b(?:assert|defined|foreach|import|pool|print|template|tool|toolchain)(?=\s*\()/i,
			alias: "keyword"
		},
		function: /\b[a-z_]\w*(?=\s*\()/i,
		constant: /\b(?:current_cpu|current_os|current_toolchain|default_toolchain|host_cpu|host_os|root_build_dir|root_gen_dir|root_out_dir|target_cpu|target_gen_dir|target_os|target_out_dir)\b/,
		number: /-?\b\d+\b/,
		operator: /[-+!=<>]=?|&&|\|\|/,
		punctuation: /[(){}[\],.]/
	};
	Prism$1.languages.gn["string-literal"].inside["interpolation"].inside["expression"].inside = Prism$1.languages.gn;
	Prism$1.languages.gni = Prism$1.languages.gn;
}
linkerScript.displayName = "linker-script";
linkerScript.aliases = ["ld"];
function linkerScript(Prism$1) {
	Prism$1.languages["linker-script"] = {
		comment: {
			pattern: /(^|\s)\/\*[\s\S]*?(?:$|\*\/)/,
			lookbehind: true,
			greedy: true
		},
		identifier: {
			pattern: /"[^"\r\n]*"/,
			greedy: true
		},
		"location-counter": {
			pattern: /\B\.\B/,
			alias: "important"
		},
		section: {
			pattern: /(^|[^\w*])\.\w+\b/,
			lookbehind: true,
			alias: "keyword"
		},
		function: /\b[A-Z][A-Z_]*(?=\s*\()/,
		number: /\b(?:0[xX][a-fA-F0-9]+|\d+)[KM]?\b/,
		operator: />>=?|<<=?|->|\+\+|--|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?/,
		punctuation: /[(){},;]/
	};
	Prism$1.languages["ld"] = Prism$1.languages["linker-script"];
}
goModule.displayName = "go-module";
goModule.aliases = ["go-mod"];
function goModule(Prism$1) {
	Prism$1.languages["go-mod"] = Prism$1.languages["go-module"] = {
		comment: {
			pattern: /\/\/.*/,
			greedy: true
		},
		version: {
			pattern: /(^|[\s()[\],])v\d+\.\d+\.\d+(?:[+-][-+.\w]*)?(?![^\s()[\],])/,
			lookbehind: true,
			alias: "number"
		},
		"go-version": {
			pattern: /((?:^|\s)go\s+)\d+(?:\.\d+){1,2}/,
			lookbehind: true,
			alias: "number"
		},
		keyword: {
			pattern: /^([ \t]*)(?:exclude|go|module|replace|require|retract)\b/m,
			lookbehind: true
		},
		operator: /=>/,
		punctuation: /[()[\],]/
	};
}
gradle.displayName = "gradle";
gradle.aliases = [];
function gradle(Prism$1) {
	Prism$1.register(clike);
	(function(Prism$2) {
		var interpolation = {
			pattern: /((?:^|[^\\$])(?:\\{2})*)\$(?:\w+|\{[^{}]*\})/,
			lookbehind: true,
			inside: {
				"interpolation-punctuation": {
					pattern: /^\$\{?|\}$/,
					alias: "punctuation"
				},
				expression: {
					pattern: /[\s\S]+/,
					inside: null
				}
			}
		};
		Prism$2.languages.gradle = Prism$2.languages.extend("clike", {
			string: {
				pattern: /'''(?:[^\\]|\\[\s\S])*?'''|'(?:\\.|[^\\'\r\n])*'/,
				greedy: true
			},
			keyword: /\b(?:apply|def|dependencies|else|if|implementation|import|plugin|plugins|project|repositories|repository|sourceSets|tasks|val)\b/,
			number: /\b(?:0b[01_]+|0x[\da-f_]+(?:\.[\da-f_p\-]+)?|[\d_]+(?:\.[\d_]+)?(?:e[+-]?\d+)?)[glidf]?\b/i,
			operator: {
				pattern: /(^|[^.])(?:~|==?~?|\?[.:]?|\*(?:[.=]|\*=?)?|\.[@&]|\.\.<|\.\.(?!\.)|-[-=>]?|\+[+=]?|!=?|<(?:<=?|=>?)?|>(?:>>?=?|=)?|&[&=]?|\|[|=]?|\/=?|\^=?|%=?)/,
				lookbehind: true
			},
			punctuation: /\.+|[{}[\];(),:$]/
		});
		Prism$2.languages.insertBefore("gradle", "string", {
			shebang: {
				pattern: /#!.+/,
				alias: "comment",
				greedy: true
			},
			"interpolation-string": {
				pattern: /"""(?:[^\\]|\\[\s\S])*?"""|(["/])(?:\\.|(?!\1)[^\\\r\n])*\1|\$\/(?:[^/$]|\$(?:[/$]|(?![/$]))|\/(?!\$))*\/\$/,
				greedy: true,
				inside: {
					interpolation,
					string: /[\s\S]+/
				}
			}
		});
		Prism$2.languages.insertBefore("gradle", "punctuation", { "spock-block": /\b(?:and|cleanup|expect|given|setup|then|when|where):/ });
		Prism$2.languages.insertBefore("gradle", "function", { annotation: {
			pattern: /(^|[^.])@\w+/,
			lookbehind: true,
			alias: "punctuation"
		} });
		interpolation.inside.expression.inside = Prism$2.languages.gradle;
	})(Prism$1);
}
graphql.displayName = "graphql";
graphql.aliases = [];
function graphql(Prism$1) {
	Prism$1.languages.graphql = {
		comment: /#.*/,
		description: {
			pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i,
			greedy: true,
			alias: "string",
			inside: { "language-markdown": {
				pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/,
				lookbehind: true,
				inside: Prism$1.languages.markdown
			} }
		},
		string: {
			pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/,
			greedy: true
		},
		number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
		boolean: /\b(?:false|true)\b/,
		variable: /\$[a-z_]\w*/i,
		directive: {
			pattern: /@[a-z_]\w*/i,
			alias: "function"
		},
		"attr-name": {
			pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i,
			greedy: true
		},
		"atom-input": {
			pattern: /\b[A-Z]\w*Input\b/,
			alias: "class-name"
		},
		scalar: /\b(?:Boolean|Float|ID|Int|String)\b/,
		constant: /\b[A-Z][A-Z_\d]*\b/,
		"class-name": {
			pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/,
			lookbehind: true
		},
		fragment: {
			pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/,
			lookbehind: true,
			alias: "function"
		},
		"definition-mutation": {
			pattern: /(\bmutation\s+)[a-zA-Z_]\w*/,
			lookbehind: true,
			alias: "function"
		},
		"definition-query": {
			pattern: /(\bquery\s+)[a-zA-Z_]\w*/,
			lookbehind: true,
			alias: "function"
		},
		keyword: /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/,
		operator: /[!=|&]|\.{3}/,
		"property-query": /\w+(?=\s*\()/,
		object: /\w+(?=\s*\{)/,
		punctuation: /[!(){}\[\]:=,]/,
		property: /\w+/
	};
	Prism$1.hooks.add("after-tokenize", function afterTokenizeGraphql(env$1) {
		if (env$1.language !== "graphql") return;
		var validTokens = env$1.tokens.filter(function(token) {
			return typeof token !== "string" && token.type !== "comment" && token.type !== "scalar";
		});
		var currentIndex = 0;
		function getToken(offset) {
			return validTokens[currentIndex + offset];
		}
		function isTokenType(types, offset) {
			offset = offset || 0;
			for (var i$1 = 0; i$1 < types.length; i$1++) {
				var token = getToken(i$1 + offset);
				if (!token || token.type !== types[i$1]) return false;
			}
			return true;
		}
		function findClosingBracket(open, close) {
			var stackHeight = 1;
			for (var i$1 = currentIndex; i$1 < validTokens.length; i$1++) {
				var token = validTokens[i$1];
				var content$2 = token.content;
				if (token.type === "punctuation" && typeof content$2 === "string") {
					if (open.test(content$2)) stackHeight++;
					else if (close.test(content$2)) {
						stackHeight--;
						if (stackHeight === 0) return i$1;
					}
				}
			}
			return -1;
		}
		function addAlias(token, alias$1) {
			var aliases = token.alias;
			if (!aliases) token.alias = aliases = [];
			else if (!Array.isArray(aliases)) token.alias = aliases = [aliases];
			aliases.push(alias$1);
		}
		for (; currentIndex < validTokens.length;) {
			var startToken = validTokens[currentIndex++];
			if (startToken.type === "keyword" && startToken.content === "mutation") {
				var inputVariables = [];
				if (isTokenType(["definition-mutation", "punctuation"]) && getToken(1).content === "(") {
					currentIndex += 2;
					var definitionEnd = findClosingBracket(/^\($/, /^\)$/);
					if (definitionEnd === -1) continue;
					for (; currentIndex < definitionEnd; currentIndex++) {
						var t = getToken(0);
						if (t.type === "variable") {
							addAlias(t, "variable-input");
							inputVariables.push(t.content);
						}
					}
					currentIndex = definitionEnd + 1;
				}
				if (isTokenType(["punctuation", "property-query"]) && getToken(0).content === "{") {
					currentIndex++;
					addAlias(getToken(0), "property-mutation");
					if (inputVariables.length > 0) {
						var mutationEnd = findClosingBracket(/^\{$/, /^\}$/);
						if (mutationEnd === -1) continue;
						for (var i = currentIndex; i < mutationEnd; i++) {
							var varToken = validTokens[i];
							if (varToken.type === "variable" && inputVariables.indexOf(varToken.content) >= 0) addAlias(varToken, "variable-input");
						}
					}
				}
			}
		}
	});
}
groovy.displayName = "groovy";
groovy.aliases = [];
function groovy(Prism$1) {
	Prism$1.register(clike);
	(function(Prism$2) {
		var interpolation = {
			pattern: /((?:^|[^\\$])(?:\\{2})*)\$(?:\w+|\{[^{}]*\})/,
			lookbehind: true,
			inside: {
				"interpolation-punctuation": {
					pattern: /^\$\{?|\}$/,
					alias: "punctuation"
				},
				expression: {
					pattern: /[\s\S]+/,
					inside: null
				}
			}
		};
		Prism$2.languages.groovy = Prism$2.languages.extend("clike", {
			string: {
				pattern: /'''(?:[^\\]|\\[\s\S])*?'''|'(?:\\.|[^\\'\r\n])*'/,
				greedy: true
			},
			keyword: /\b(?:abstract|as|assert|boolean|break|byte|case|catch|char|class|const|continue|def|default|do|double|else|enum|extends|final|finally|float|for|goto|if|implements|import|in|instanceof|int|interface|long|native|new|package|private|protected|public|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|trait|transient|try|void|volatile|while)\b/,
			number: /\b(?:0b[01_]+|0x[\da-f_]+(?:\.[\da-f_p\-]+)?|[\d_]+(?:\.[\d_]+)?(?:e[+-]?\d+)?)[glidf]?\b/i,
			operator: {
				pattern: /(^|[^.])(?:~|==?~?|\?[.:]?|\*(?:[.=]|\*=?)?|\.[@&]|\.\.<|\.\.(?!\.)|-[-=>]?|\+[+=]?|!=?|<(?:<=?|=>?)?|>(?:>>?=?|=)?|&[&=]?|\|[|=]?|\/=?|\^=?|%=?)/,
				lookbehind: true
			},
			punctuation: /\.+|[{}[\];(),:$]/
		});
		Prism$2.languages.insertBefore("groovy", "string", {
			shebang: {
				pattern: /#!.+/,
				alias: "comment",
				greedy: true
			},
			"interpolation-string": {
				pattern: /"""(?:[^\\]|\\[\s\S])*?"""|(["/])(?:\\.|(?!\1)[^\\\r\n])*\1|\$\/(?:[^/$]|\$(?:[/$]|(?![/$]))|\/(?!\$))*\/\$/,
				greedy: true,
				inside: {
					interpolation,
					string: /[\s\S]+/
				}
			}
		});
		Prism$2.languages.insertBefore("groovy", "punctuation", { "spock-block": /\b(?:and|cleanup|expect|given|setup|then|when|where):/ });
		Prism$2.languages.insertBefore("groovy", "function", { annotation: {
			pattern: /(^|[^.])@\w+/,
			lookbehind: true,
			alias: "punctuation"
		} });
		interpolation.inside.expression.inside = Prism$2.languages.groovy;
	})(Prism$1);
}
textile.displayName = "textile";
textile.aliases = [];
function textile(Prism$1) {
	Prism$1.register(markup);
	(function(Prism$2) {
		var modifierRegex = /\([^|()\n]+\)|\[[^\]\n]+\]|\{[^}\n]+\}/.source;
		var parenthesesRegex = /\)|\((?![^|()\n]+\))/.source;
		function withModifier(source, flags) {
			return RegExp(source.replace(/<MOD>/g, function() {
				return "(?:" + modifierRegex + ")";
			}).replace(/<PAR>/g, function() {
				return "(?:" + parenthesesRegex + ")";
			}), flags || "");
		}
		var modifierTokens = {
			css: {
				pattern: /\{[^{}]+\}/,
				inside: { rest: Prism$2.languages.css }
			},
			"class-id": {
				pattern: /(\()[^()]+(?=\))/,
				lookbehind: true,
				alias: "attr-value"
			},
			lang: {
				pattern: /(\[)[^\[\]]+(?=\])/,
				lookbehind: true,
				alias: "attr-value"
			},
			punctuation: /[\\\/]\d+|\S/
		};
		var textile$1 = Prism$2.languages.textile = Prism$2.languages.extend("markup", { phrase: {
			pattern: /(^|\r|\n)\S[\s\S]*?(?=$|\r?\n\r?\n|\r\r)/,
			lookbehind: true,
			inside: {
				"block-tag": {
					pattern: withModifier(/^[a-z]\w*(?:<MOD>|<PAR>|[<>=])*\./.source),
					inside: {
						modifier: {
							pattern: withModifier(/(^[a-z]\w*)(?:<MOD>|<PAR>|[<>=])+(?=\.)/.source),
							lookbehind: true,
							inside: modifierTokens
						},
						tag: /^[a-z]\w*/,
						punctuation: /\.$/
					}
				},
				list: {
					pattern: withModifier(/^[*#]+<MOD>*\s+\S.*/.source, "m"),
					inside: {
						modifier: {
							pattern: withModifier(/(^[*#]+)<MOD>+/.source),
							lookbehind: true,
							inside: modifierTokens
						},
						punctuation: /^[*#]+/
					}
				},
				table: {
					pattern: withModifier(/^(?:(?:<MOD>|<PAR>|[<>=^~])+\.\s*)?(?:\|(?:(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+\.|(?!(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+\.))[^|]*)+\|/.source, "m"),
					inside: {
						modifier: {
							pattern: withModifier(/(^|\|(?:\r?\n|\r)?)(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+(?=\.)/.source),
							lookbehind: true,
							inside: modifierTokens
						},
						punctuation: /\||^\./
					}
				},
				inline: {
					pattern: withModifier(/(^|[^a-zA-Z\d])(\*\*|__|\?\?|[*_%@+\-^~])<MOD>*.+?\2(?![a-zA-Z\d])/.source),
					lookbehind: true,
					inside: {
						bold: {
							pattern: withModifier(/(^(\*\*?)<MOD>*).+?(?=\2)/.source),
							lookbehind: true
						},
						italic: {
							pattern: withModifier(/(^(__?)<MOD>*).+?(?=\2)/.source),
							lookbehind: true
						},
						cite: {
							pattern: withModifier(/(^\?\?<MOD>*).+?(?=\?\?)/.source),
							lookbehind: true,
							alias: "string"
						},
						code: {
							pattern: withModifier(/(^@<MOD>*).+?(?=@)/.source),
							lookbehind: true,
							alias: "keyword"
						},
						inserted: {
							pattern: withModifier(/(^\+<MOD>*).+?(?=\+)/.source),
							lookbehind: true
						},
						deleted: {
							pattern: withModifier(/(^-<MOD>*).+?(?=-)/.source),
							lookbehind: true
						},
						span: {
							pattern: withModifier(/(^%<MOD>*).+?(?=%)/.source),
							lookbehind: true
						},
						modifier: {
							pattern: withModifier(/(^\*\*|__|\?\?|[*_%@+\-^~])<MOD>+/.source),
							lookbehind: true,
							inside: modifierTokens
						},
						punctuation: /[*_%?@+\-^~]+/
					}
				},
				"link-ref": {
					pattern: /^\[[^\]]+\]\S+$/m,
					inside: {
						string: {
							pattern: /(^\[)[^\]]+(?=\])/,
							lookbehind: true
						},
						url: {
							pattern: /(^\])\S+$/,
							lookbehind: true
						},
						punctuation: /[\[\]]/
					}
				},
				link: {
					pattern: withModifier(/"<MOD>*[^"]+":.+?(?=[^\w/]?(?:\s|$))/.source),
					inside: {
						text: {
							pattern: withModifier(/(^"<MOD>*)[^"]+(?=")/.source),
							lookbehind: true
						},
						modifier: {
							pattern: withModifier(/(^")<MOD>+/.source),
							lookbehind: true,
							inside: modifierTokens
						},
						url: {
							pattern: /(:).+/,
							lookbehind: true
						},
						punctuation: /[":]/
					}
				},
				image: {
					pattern: withModifier(/!(?:<MOD>|<PAR>|[<>=])*(?![<>=])[^!\s()]+(?:\([^)]+\))?!(?::.+?(?=[^\w/]?(?:\s|$)))?/.source),
					inside: {
						source: {
							pattern: withModifier(/(^!(?:<MOD>|<PAR>|[<>=])*)(?![<>=])[^!\s()]+(?:\([^)]+\))?(?=!)/.source),
							lookbehind: true,
							alias: "url"
						},
						modifier: {
							pattern: withModifier(/(^!)(?:<MOD>|<PAR>|[<>=])+/.source),
							lookbehind: true,
							inside: modifierTokens
						},
						url: {
							pattern: /(:).+/,
							lookbehind: true
						},
						punctuation: /[!:]/
					}
				},
				footnote: {
					pattern: /\b\[\d+\]/,
					alias: "comment",
					inside: { punctuation: /\[|\]/ }
				},
				acronym: {
					pattern: /\b[A-Z\d]+\([^)]+\)/,
					inside: {
						comment: {
							pattern: /(\()[^()]+(?=\))/,
							lookbehind: true
						},
						punctuation: /[()]/
					}
				},
				mark: {
					pattern: /\b\((?:C|R|TM)\)/,
					alias: "comment",
					inside: { punctuation: /[()]/ }
				}
			}
		} });
		var phraseInside = textile$1["phrase"].inside;
		var nestedPatterns = {
			inline: phraseInside["inline"],
			link: phraseInside["link"],
			image: phraseInside["image"],
			footnote: phraseInside["footnote"],
			acronym: phraseInside["acronym"],
			mark: phraseInside["mark"]
		};
		textile$1.tag.pattern = /<\/?(?!\d)[a-z0-9]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i;
		var phraseInlineInside = phraseInside["inline"].inside;
		phraseInlineInside["bold"].inside = nestedPatterns;
		phraseInlineInside["italic"].inside = nestedPatterns;
		phraseInlineInside["inserted"].inside = nestedPatterns;
		phraseInlineInside["deleted"].inside = nestedPatterns;
		phraseInlineInside["span"].inside = nestedPatterns;
		var phraseTableInside = phraseInside["table"].inside;
		phraseTableInside["inline"] = nestedPatterns["inline"];
		phraseTableInside["link"] = nestedPatterns["link"];
		phraseTableInside["image"] = nestedPatterns["image"];
		phraseTableInside["footnote"] = nestedPatterns["footnote"];
		phraseTableInside["acronym"] = nestedPatterns["acronym"];
		phraseTableInside["mark"] = nestedPatterns["mark"];
	})(Prism$1);
}
haml.displayName = "haml";
haml.aliases = [];
function haml(Prism$1) {
	Prism$1.register(ruby);
	(function(Prism$2) {
		Prism$2.languages.haml = {
			"multiline-comment": {
				pattern: /((?:^|\r?\n|\r)([\t ]*))(?:\/|-#).*(?:(?:\r?\n|\r)\2[\t ].+)*/,
				lookbehind: true,
				alias: "comment"
			},
			"multiline-code": [{
				pattern: /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*,[\t ]*(?:(?:\r?\n|\r)\2[\t ].*,[\t ]*)*(?:(?:\r?\n|\r)\2[\t ].+)/,
				lookbehind: true,
				inside: Prism$2.languages.ruby
			}, {
				pattern: /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*\|[\t ]*(?:(?:\r?\n|\r)\2[\t ].*\|[\t ]*)*/,
				lookbehind: true,
				inside: Prism$2.languages.ruby
			}],
			filter: {
				pattern: /((?:^|\r?\n|\r)([\t ]*)):[\w-]+(?:(?:\r?\n|\r)(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/,
				lookbehind: true,
				inside: { "filter-name": {
					pattern: /^:[\w-]+/,
					alias: "symbol"
				} }
			},
			markup: {
				pattern: /((?:^|\r?\n|\r)[\t ]*)<.+/,
				lookbehind: true,
				inside: Prism$2.languages.markup
			},
			doctype: {
				pattern: /((?:^|\r?\n|\r)[\t ]*)!!!(?: .+)?/,
				lookbehind: true
			},
			tag: {
				pattern: /((?:^|\r?\n|\r)[\t ]*)[%.#][\w\-#.]*[\w\-](?:\([^)]+\)|\{(?:\{[^}]+\}|[^{}])+\}|\[[^\]]+\])*[\/<>]*/,
				lookbehind: true,
				inside: {
					attributes: [
						{
							pattern: /(^|[^#])\{(?:\{[^}]+\}|[^{}])+\}/,
							lookbehind: true,
							inside: Prism$2.languages.ruby
						},
						{
							pattern: /\([^)]+\)/,
							inside: {
								"attr-value": {
									pattern: /(=\s*)(?:"(?:\\.|[^\\"\r\n])*"|[^)\s]+)/,
									lookbehind: true
								},
								"attr-name": /[\w:-]+(?=\s*!?=|\s*[,)])/,
								punctuation: /[=(),]/
							}
						},
						{
							pattern: /\[[^\]]+\]/,
							inside: Prism$2.languages.ruby
						}
					],
					punctuation: /[<>]/
				}
			},
			code: {
				pattern: /((?:^|\r?\n|\r)[\t ]*(?:[~-]|[&!]?=)).+/,
				lookbehind: true,
				inside: Prism$2.languages.ruby
			},
			interpolation: {
				pattern: /#\{[^}]+\}/,
				inside: {
					delimiter: {
						pattern: /^#\{|\}$/,
						alias: "punctuation"
					},
					ruby: {
						pattern: /[\s\S]+/,
						inside: Prism$2.languages.ruby
					}
				}
			},
			punctuation: {
				pattern: /((?:^|\r?\n|\r)[\t ]*)[~=\-&!]+/,
				lookbehind: true
			}
		};
		var filter_pattern = "((?:^|\\r?\\n|\\r)([\\t ]*)):{{filter_name}}(?:(?:\\r?\\n|\\r)(?:\\2[\\t ].+|\\s*?(?=\\r?\\n|\\r)))+";
		var filters = [
			"css",
			{
				filter: "coffee",
				language: "coffeescript"
			},
			"erb",
			"javascript",
			"less",
			"markdown",
			"ruby",
			"scss",
			"textile"
		];
		var all_filters = {};
		for (var i = 0, l$1 = filters.length; i < l$1; i++) {
			var filter$1 = filters[i];
			filter$1 = typeof filter$1 === "string" ? {
				filter: filter$1,
				language: filter$1
			} : filter$1;
			if (Prism$2.languages[filter$1.language]) all_filters["filter-" + filter$1.filter] = {
				pattern: RegExp(filter_pattern.replace("{{filter_name}}", function() {
					return filter$1.filter;
				})),
				lookbehind: true,
				inside: {
					"filter-name": {
						pattern: /^:[\w-]+/,
						alias: "symbol"
					},
					text: {
						pattern: /[\s\S]+/,
						alias: [filter$1.language, "language-" + filter$1.language],
						inside: Prism$2.languages[filter$1.language]
					}
				}
			};
		}
		Prism$2.languages.insertBefore("haml", "filter", all_filters);
	})(Prism$1);
}
handlebars.displayName = "handlebars";
handlebars.aliases = ["hbs", "mustache"];
function handlebars(Prism$1) {
	Prism$1.register(markupTemplating);
	(function(Prism$2) {
		Prism$2.languages.handlebars = {
			comment: /\{\{![\s\S]*?\}\}/,
			delimiter: {
				pattern: /^\{\{\{?|\}\}\}?$/,
				alias: "punctuation"
			},
			string: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
			number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][+-]?\d+)?/,
			boolean: /\b(?:false|true)\b/,
			block: {
				pattern: /^(\s*(?:~\s*)?)[#\/]\S+?(?=\s*(?:~\s*)?$|\s)/,
				lookbehind: true,
				alias: "keyword"
			},
			brackets: {
				pattern: /\[[^\]]+\]/,
				inside: {
					punctuation: /\[|\]/,
					variable: /[\s\S]+/
				}
			},
			punctuation: /[!"#%&':()*+,.\/;<=>@\[\\\]^`{|}~]/,
			variable: /[^!"#%&'()*+,\/;<=>@\[\\\]^`{|}~\s]+/
		};
		Prism$2.hooks.add("before-tokenize", function(env$1) {
			var handlebarsPattern = /\{\{\{[\s\S]+?\}\}\}|\{\{[\s\S]+?\}\}/g;
			Prism$2.languages["markup-templating"].buildPlaceholders(env$1, "handlebars", handlebarsPattern);
		});
		Prism$2.hooks.add("after-tokenize", function(env$1) {
			Prism$2.languages["markup-templating"].tokenizePlaceholders(env$1, "handlebars");
		});
		Prism$2.languages.hbs = Prism$2.languages.handlebars;
		Prism$2.languages.mustache = Prism$2.languages.handlebars;
	})(Prism$1);
}
haskell.displayName = "haskell";
haskell.aliases = ["hs"];
function haskell(Prism$1) {
	Prism$1.languages.haskell = {
		comment: {
			pattern: /(^|[^-!#$%*+=?&@|~.:<>^\\\/])(?:--(?:(?=.)[^-!#$%*+=?&@|~.:<>^\\\/].*|$)|\{-[\s\S]*?-\})/m,
			lookbehind: true
		},
		char: {
			pattern: /'(?:[^\\']|\\(?:[abfnrtv\\"'&]|\^[A-Z@[\]^_]|ACK|BEL|BS|CAN|CR|DC1|DC2|DC3|DC4|DEL|DLE|EM|ENQ|EOT|ESC|ETB|ETX|FF|FS|GS|HT|LF|NAK|NUL|RS|SI|SO|SOH|SP|STX|SUB|SYN|US|VT|\d+|o[0-7]+|x[0-9a-fA-F]+))'/,
			alias: "string"
		},
		string: {
			pattern: /"(?:[^\\"]|\\(?:\S|\s+\\))*"/,
			greedy: true
		},
		keyword: /\b(?:case|class|data|deriving|do|else|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b/,
		"import-statement": {
			pattern: /(^[\t ]*)import\s+(?:qualified\s+)?(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*(?:\s+as\s+(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
			lookbehind: true,
			inside: {
				keyword: /\b(?:as|hiding|import|qualified)\b/,
				punctuation: /\./
			}
		},
		builtin: /\b(?:abs|acos|acosh|all|and|any|appendFile|approxRational|asTypeOf|asin|asinh|atan|atan2|atanh|basicIORun|break|catch|ceiling|chr|compare|concat|concatMap|const|cos|cosh|curry|cycle|decodeFloat|denominator|digitToInt|div|divMod|drop|dropWhile|either|elem|encodeFloat|enumFrom|enumFromThen|enumFromThenTo|enumFromTo|error|even|exp|exponent|fail|filter|flip|floatDigits|floatRadix|floatRange|floor|fmap|foldl|foldl1|foldr|foldr1|fromDouble|fromEnum|fromInt|fromInteger|fromIntegral|fromRational|fst|gcd|getChar|getContents|getLine|group|head|id|inRange|index|init|intToDigit|interact|ioError|isAlpha|isAlphaNum|isAscii|isControl|isDenormalized|isDigit|isHexDigit|isIEEE|isInfinite|isLower|isNaN|isNegativeZero|isOctDigit|isPrint|isSpace|isUpper|iterate|last|lcm|length|lex|lexDigits|lexLitChar|lines|log|logBase|lookup|map|mapM|mapM_|max|maxBound|maximum|maybe|min|minBound|minimum|mod|negate|not|notElem|null|numerator|odd|or|ord|otherwise|pack|pi|pred|primExitWith|print|product|properFraction|putChar|putStr|putStrLn|quot|quotRem|range|rangeSize|read|readDec|readFile|readFloat|readHex|readIO|readInt|readList|readLitChar|readLn|readOct|readParen|readSigned|reads|readsPrec|realToFrac|recip|rem|repeat|replicate|return|reverse|round|scaleFloat|scanl|scanl1|scanr|scanr1|seq|sequence|sequence_|show|showChar|showInt|showList|showLitChar|showParen|showSigned|showString|shows|showsPrec|significand|signum|sin|sinh|snd|sort|span|splitAt|sqrt|subtract|succ|sum|tail|take|takeWhile|tan|tanh|threadToIOResult|toEnum|toInt|toInteger|toLower|toRational|toUpper|truncate|uncurry|undefined|unlines|until|unwords|unzip|unzip3|userError|words|writeFile|zip|zip3|zipWith|zipWith3)\b/,
		number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0o[0-7]+|0x[0-9a-f]+)\b/i,
		operator: [
			{
				pattern: /`(?:[A-Z][\w']*\.)*[_a-z][\w']*`/,
				greedy: true
			},
			{
				pattern: /(\s)\.(?=\s)/,
				lookbehind: true
			},
			/[-!#$%*+=?&@|~:<>^\\\/][-!#$%*+=?&@|~.:<>^\\\/]*|\.[-!#$%*+=?&@|~.:<>^\\\/]+/
		],
		hvariable: {
			pattern: /\b(?:[A-Z][\w']*\.)*[_a-z][\w']*/,
			inside: { punctuation: /\./ }
		},
		constant: {
			pattern: /\b(?:[A-Z][\w']*\.)*[A-Z][\w']*/,
			inside: { punctuation: /\./ }
		},
		punctuation: /[{}[\];(),.:]/
	};
	Prism$1.languages.hs = Prism$1.languages.haskell;
}
haxe.displayName = "haxe";
haxe.aliases = [];
function haxe(Prism$1) {
	Prism$1.register(clike);
	Prism$1.languages.haxe = Prism$1.languages.extend("clike", {
		string: {
			pattern: /"(?:[^"\\]|\\[\s\S])*"/,
			greedy: true
		},
		"class-name": [{
			pattern: /(\b(?:abstract|class|enum|extends|implements|interface|new|typedef)\s+)[A-Z_]\w*/,
			lookbehind: true
		}, /\b[A-Z]\w*/],
		keyword: /\bthis\b|\b(?:abstract|as|break|case|cast|catch|class|continue|default|do|dynamic|else|enum|extends|extern|final|for|from|function|if|implements|import|in|inline|interface|macro|new|null|operator|overload|override|package|private|public|return|static|super|switch|throw|to|try|typedef|untyped|using|var|while)(?!\.)\b/,
		function: {
			pattern: /\b[a-z_]\w*(?=\s*(?:<[^<>]*>\s*)?\()/i,
			greedy: true
		},
		operator: /\.{3}|\+\+|--|&&|\|\||->|=>|(?:<<?|>{1,3}|[-+*/%!=&|^])=?|[?:~]/
	});
	Prism$1.languages.insertBefore("haxe", "string", { "string-interpolation": {
		pattern: /'(?:[^'\\]|\\[\s\S])*'/,
		greedy: true,
		inside: {
			interpolation: {
				pattern: /(^|[^\\])\$(?:\w+|\{[^{}]+\})/,
				lookbehind: true,
				inside: {
					"interpolation-punctuation": {
						pattern: /^\$\{?|\}$/,
						alias: "punctuation"
					},
					expression: {
						pattern: /[\s\S]+/,
						inside: Prism$1.languages.haxe
					}
				}
			},
			string: /[\s\S]+/
		}
	} });
	Prism$1.languages.insertBefore("haxe", "class-name", { regex: {
		pattern: /~\/(?:[^\/\\\r\n]|\\.)+\/[a-z]*/,
		greedy: true,
		inside: {
			"regex-flags": /\b[a-z]+$/,
			"regex-source": {
				pattern: /^(~\/)[\s\S]+(?=\/$)/,
				lookbehind: true,
				alias: "language-regex",
				inside: Prism$1.languages.regex
			},
			"regex-delimiter": /^~\/|\/$/
		}
	} });
	Prism$1.languages.insertBefore("haxe", "keyword", {
		preprocessor: {
			pattern: /#(?:else|elseif|end|if)\b.*/,
			alias: "property"
		},
		metadata: {
			pattern: /@:?[\w.]+/,
			alias: "symbol"
		},
		reification: {
			pattern: /\$(?:\w+|(?=\{))/,
			alias: "important"
		}
	});
}
hcl.displayName = "hcl";
hcl.aliases = [];
function hcl(Prism$1) {
	Prism$1.languages.hcl = {
		comment: /(?:\/\/|#).*|\/\*[\s\S]*?(?:\*\/|$)/,
		heredoc: {
			pattern: /<<-?(\w+\b)[\s\S]*?^[ \t]*\1/m,
			greedy: true,
			alias: "string"
		},
		keyword: [
			{
				pattern: /(?:data|resource)\s+(?:"(?:\\[\s\S]|[^\\"])*")(?=\s+"[\w-]+"\s+\{)/i,
				inside: { type: {
					pattern: /(resource|data|\s+)(?:"(?:\\[\s\S]|[^\\"])*")/i,
					lookbehind: true,
					alias: "variable"
				} }
			},
			{
				pattern: /(?:backend|module|output|provider|provisioner|variable)\s+(?:[\w-]+|"(?:\\[\s\S]|[^\\"])*")\s+(?=\{)/i,
				inside: { type: {
					pattern: /(backend|module|output|provider|provisioner|variable)\s+(?:[\w-]+|"(?:\\[\s\S]|[^\\"])*")\s+/i,
					lookbehind: true,
					alias: "variable"
				} }
			},
			/[\w-]+(?=\s+\{)/
		],
		property: [/[-\w\.]+(?=\s*=(?!=))/, /"(?:\\[\s\S]|[^\\"])+"(?=\s*[:=])/],
		string: {
			pattern: /"(?:[^\\$"]|\\[\s\S]|\$(?:(?=")|\$+(?!\$)|[^"${])|\$\{(?:[^{}"]|"(?:[^\\"]|\\[\s\S])*")*\})*"/,
			greedy: true,
			inside: { interpolation: {
				pattern: /(^|[^$])\$\{(?:[^{}"]|"(?:[^\\"]|\\[\s\S])*")*\}/,
				lookbehind: true,
				inside: {
					type: {
						pattern: /(\b(?:count|data|local|module|path|self|terraform|var)\b\.)[\w\*]+/i,
						lookbehind: true,
						alias: "variable"
					},
					keyword: /\b(?:count|data|local|module|path|self|terraform|var)\b/i,
					function: /\w+(?=\()/,
					string: {
						pattern: /"(?:\\[\s\S]|[^\\"])*"/,
						greedy: true
					},
					number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
					punctuation: /[!\$#%&'()*+,.\/;<=>@\[\\\]^`{|}~?:]/
				}
			} }
		},
		number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
		boolean: /\b(?:false|true)\b/i,
		punctuation: /[=\[\]{}]/
	};
}
hlsl.displayName = "hlsl";
hlsl.aliases = [];
function hlsl(Prism$1) {
	Prism$1.register(c$1);
	Prism$1.languages.hlsl = Prism$1.languages.extend("c", {
		"class-name": [Prism$1.languages.c["class-name"], /\b(?:AppendStructuredBuffer|BlendState|Buffer|ByteAddressBuffer|CompileShader|ComputeShader|ConsumeStructuredBuffer|DepthStencilState|DepthStencilView|DomainShader|GeometryShader|Hullshader|InputPatch|LineStream|OutputPatch|PixelShader|PointStream|RWBuffer|RWByteAddressBuffer|RWStructuredBuffer|RWTexture(?:1D|1DArray|2D|2DArray|3D)|RasterizerState|RenderTargetView|SamplerComparisonState|SamplerState|StructuredBuffer|Texture(?:1D|1DArray|2D|2DArray|2DMS|2DMSArray|3D|Cube|CubeArray)|TriangleStream|VertexShader)\b/],
		keyword: [/\b(?:asm|asm_fragment|auto|break|case|catch|cbuffer|centroid|char|class|column_major|compile|compile_fragment|const|const_cast|continue|default|delete|discard|do|dynamic_cast|else|enum|explicit|export|extern|for|friend|fxgroup|goto|groupshared|if|in|inline|inout|interface|line|lineadj|linear|long|matrix|mutable|namespace|new|nointerpolation|noperspective|operator|out|packoffset|pass|pixelfragment|point|precise|private|protected|public|register|reinterpret_cast|return|row_major|sample|sampler|shared|short|signed|sizeof|snorm|stateblock|stateblock_state|static|static_cast|string|struct|switch|tbuffer|technique|technique10|technique11|template|texture|this|throw|triangle|triangleadj|try|typedef|typename|uniform|union|unorm|unsigned|using|vector|vertexfragment|virtual|void|volatile|while)\b/, /\b(?:bool|double|dword|float|half|int|min(?:10float|12int|16(?:float|int|uint))|uint)(?:[1-4](?:x[1-4])?)?\b/],
		number: /(?:(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?|\b0x[\da-fA-F]+)[fFhHlLuU]?\b/,
		boolean: /\b(?:false|true)\b/
	});
}
hoon.displayName = "hoon";
hoon.aliases = [];
function hoon(Prism$1) {
	Prism$1.languages.hoon = {
		comment: {
			pattern: /::.*/,
			greedy: true
		},
		string: {
			pattern: /"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'/,
			greedy: true
		},
		constant: /%(?:\.[ny]|[\w-]+)/,
		"class-name": /@(?:[a-z0-9-]*[a-z0-9])?|\*/i,
		function: /(?:\+[-+] {2})?(?:[a-z](?:[a-z0-9-]*[a-z0-9])?)/,
		keyword: /\.[\^\+\*=\?]|![><:\.=\?!]|=[>|:,\.\-\^<+;/~\*\?]|\?[>|:\.\-\^<\+&~=@!]|\|[\$_%:\.\-\^~\*=@\?]|\+[|\$\+\*]|:[_\-\^\+~\*]|%[_:\.\-\^\+~\*=]|\^[|:\.\-\+&~\*=\?]|\$[|_%:<>\-\^&~@=\?]|;[:<\+;\/~\*=]|~[>|\$_%<\+\/&=\?!]|--|==/
	};
}
hpkp.displayName = "hpkp";
hpkp.aliases = [];
function hpkp(Prism$1) {
	Prism$1.languages.hpkp = {
		directive: {
			pattern: /\b(?:includeSubDomains|max-age|pin-sha256|preload|report-to|report-uri|strict)(?=[\s;=]|$)/i,
			alias: "property"
		},
		operator: /=/,
		punctuation: /;/
	};
}
hsts.displayName = "hsts";
hsts.aliases = [];
function hsts(Prism$1) {
	Prism$1.languages.hsts = {
		directive: {
			pattern: /\b(?:includeSubDomains|max-age|preload)(?=[\s;=]|$)/i,
			alias: "property"
		},
		operator: /=/,
		punctuation: /;/
	};
}
uri.displayName = "uri";
uri.aliases = ["url"];
function uri(Prism$1) {
	Prism$1.languages.uri = {
		scheme: {
			pattern: /^[a-z][a-z0-9+.-]*:/im,
			greedy: true,
			inside: { "scheme-delimiter": /:$/ }
		},
		fragment: {
			pattern: /#[\w\-.~!$&'()*+,;=%:@/?]*/,
			inside: { "fragment-delimiter": /^#/ }
		},
		query: {
			pattern: /\?[\w\-.~!$&'()*+,;=%:@/?]*/,
			inside: {
				"query-delimiter": {
					pattern: /^\?/,
					greedy: true
				},
				"pair-delimiter": /[&;]/,
				pair: {
					pattern: /^[^=][\s\S]*/,
					inside: {
						key: /^[^=]+/,
						value: {
							pattern: /(^=)[\s\S]+/,
							lookbehind: true
						}
					}
				}
			}
		},
		authority: {
			pattern: RegExp(/^\/\//.source + /(?:[\w\-.~!$&'()*+,;=%:]*@)?/.source + ("(?:" + /\[(?:[0-9a-fA-F:.]{2,48}|v[0-9a-fA-F]+\.[\w\-.~!$&'()*+,;=]+)\]/.source + "|" + /[\w\-.~!$&'()*+,;=%]*/.source + ")") + /(?::\d*)?/.source, "m"),
			inside: {
				"authority-delimiter": /^\/\//,
				"user-info-segment": {
					pattern: /^[\w\-.~!$&'()*+,;=%:]*@/,
					inside: {
						"user-info-delimiter": /@$/,
						"user-info": /^[\w\-.~!$&'()*+,;=%:]+/
					}
				},
				"port-segment": {
					pattern: /:\d*$/,
					inside: {
						"port-delimiter": /^:/,
						port: /^\d+/
					}
				},
				host: {
					pattern: /[\s\S]+/,
					inside: {
						"ip-literal": {
							pattern: /^\[[\s\S]+\]$/,
							inside: {
								"ip-literal-delimiter": /^\[|\]$/,
								"ipv-future": /^v[\s\S]+/,
								"ipv6-address": /^[\s\S]+/
							}
						},
						"ipv4-address": /^(?:(?:[03-9]\d?|[12]\d{0,2})\.){3}(?:[03-9]\d?|[12]\d{0,2})$/
					}
				}
			}
		},
		path: {
			pattern: /^[\w\-.~!$&'()*+,;=%:@/]+/m,
			inside: { "path-separator": /\// }
		}
	};
	Prism$1.languages.url = Prism$1.languages.uri;
}
http.displayName = "http";
http.aliases = [];
function http(Prism$1) {
	(function(Prism$2) {
		function headerValueOf(name$2) {
			return RegExp("(^(?:" + name$2 + "):[ 	]*(?![ 	]))[^]+", "i");
		}
		Prism$2.languages.http = {
			"request-line": {
				pattern: /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\s(?:https?:\/\/|\/)\S*\sHTTP\/[\d.]+/m,
				inside: {
					method: {
						pattern: /^[A-Z]+\b/,
						alias: "property"
					},
					"request-target": {
						pattern: /^(\s)(?:https?:\/\/|\/)\S*(?=\s)/,
						lookbehind: true,
						alias: "url",
						inside: Prism$2.languages.uri
					},
					"http-version": {
						pattern: /^(\s)HTTP\/[\d.]+/,
						lookbehind: true,
						alias: "property"
					}
				}
			},
			"response-status": {
				pattern: /^HTTP\/[\d.]+ \d+ .+/m,
				inside: {
					"http-version": {
						pattern: /^HTTP\/[\d.]+/,
						alias: "property"
					},
					"status-code": {
						pattern: /^(\s)\d+(?=\s)/,
						lookbehind: true,
						alias: "number"
					},
					"reason-phrase": {
						pattern: /^(\s).+/,
						lookbehind: true,
						alias: "string"
					}
				}
			},
			header: {
				pattern: /^[\w-]+:.+(?:(?:\r\n?|\n)[ \t].+)*/m,
				inside: {
					"header-value": [
						{
							pattern: headerValueOf(/Content-Security-Policy/.source),
							lookbehind: true,
							alias: ["csp", "languages-csp"],
							inside: Prism$2.languages.csp
						},
						{
							pattern: headerValueOf(/Public-Key-Pins(?:-Report-Only)?/.source),
							lookbehind: true,
							alias: ["hpkp", "languages-hpkp"],
							inside: Prism$2.languages.hpkp
						},
						{
							pattern: headerValueOf(/Strict-Transport-Security/.source),
							lookbehind: true,
							alias: ["hsts", "languages-hsts"],
							inside: Prism$2.languages.hsts
						},
						{
							pattern: headerValueOf(/[^:]+/.source),
							lookbehind: true
						}
					],
					"header-name": {
						pattern: /^[^:]+/,
						alias: "keyword"
					},
					punctuation: /^:/
				}
			}
		};
		var langs = Prism$2.languages;
		var httpLanguages = {
			"application/javascript": langs.javascript,
			"application/json": langs.json || langs.javascript,
			"application/xml": langs.xml,
			"text/xml": langs.xml,
			"text/html": langs.html,
			"text/css": langs.css,
			"text/plain": langs.plain
		};
		var suffixTypes = {
			"application/json": true,
			"application/xml": true
		};
		function getSuffixPattern(contentType$1) {
			var suffix = contentType$1.replace(/^[a-z]+\//, "");
			var suffixPattern = "\\w+/(?:[\\w.-]+\\+)+" + suffix + "(?![+\\w.-])";
			return "(?:" + contentType$1 + "|" + suffixPattern + ")";
		}
		var options;
		for (var contentType in httpLanguages) if (httpLanguages[contentType]) {
			options = options || {};
			var pattern = suffixTypes[contentType] ? getSuffixPattern(contentType) : contentType;
			options[contentType.replace(/\//g, "-")] = {
				pattern: RegExp("(" + /content-type:\s*/.source + pattern + /(?:(?:\r\n?|\n)[\w-].*)*(?:\r(?:\n|(?!\n))|\n)/.source + ")" + /[^ \t\w-][\s\S]*/.source, "i"),
				lookbehind: true,
				inside: httpLanguages[contentType]
			};
		}
		if (options) Prism$2.languages.insertBefore("http", "header", options);
	})(Prism$1);
}
ichigojam.displayName = "ichigojam";
ichigojam.aliases = [];
function ichigojam(Prism$1) {
	Prism$1.languages.ichigojam = {
		comment: /(?:\B'|REM)(?:[^\n\r]*)/i,
		string: {
			pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
			greedy: true
		},
		number: /\B#[0-9A-F]+|\B`[01]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
		keyword: /\b(?:BEEP|BPS|CASE|CLEAR|CLK|CLO|CLP|CLS|CLT|CLV|CONT|COPY|ELSE|END|FILE|FILES|FOR|GOSUB|GOTO|GSB|IF|INPUT|KBD|LED|LET|LIST|LOAD|LOCATE|LRUN|NEW|NEXT|OUT|PLAY|POKE|PRINT|PWM|REM|RENUM|RESET|RETURN|RIGHT|RTN|RUN|SAVE|SCROLL|SLEEP|SRND|STEP|STOP|SUB|TEMPO|THEN|TO|UART|VIDEO|WAIT)(?:\$|\b)/i,
		function: /\b(?:ABS|ANA|ASC|BIN|BTN|DEC|END|FREE|HELP|HEX|I2CR|I2CW|IN|INKEY|LEN|LINE|PEEK|RND|SCR|SOUND|STR|TICK|USR|VER|VPEEK|ZER)(?:\$|\b)/i,
		label: /(?:\B@\S+)/,
		operator: /<[=>]?|>=?|\|\||&&|[+\-*\/=|&^~!]|\b(?:AND|NOT|OR)\b/i,
		punctuation: /[\[,;:()\]]/
	};
}
icon.displayName = "icon";
icon.aliases = [];
function icon(Prism$1) {
	Prism$1.languages.icon = {
		comment: /#.*/,
		string: {
			pattern: /(["'])(?:(?!\1)[^\\\r\n_]|\\.|_(?!\1)(?:\r\n|[\s\S]))*\1/,
			greedy: true
		},
		number: /\b(?:\d+r[a-z\d]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b|\.\d+\b/i,
		"builtin-keyword": {
			pattern: /&(?:allocated|ascii|clock|collections|cset|current|date|dateline|digits|dump|e|error(?:number|text|value)?|errout|fail|features|file|host|input|lcase|letters|level|line|main|null|output|phi|pi|pos|progname|random|regions|source|storage|subject|time|trace|ucase|version)\b/,
			alias: "variable"
		},
		directive: {
			pattern: /\$\w+/,
			alias: "builtin"
		},
		keyword: /\b(?:break|by|case|create|default|do|else|end|every|fail|global|if|initial|invocable|link|local|next|not|of|procedure|record|repeat|return|static|suspend|then|to|until|while)\b/,
		function: /\b(?!\d)\w+(?=\s*[({]|\s*!\s*\[)/,
		operator: /[+-]:(?!=)|(?:[\/?@^%&]|\+\+?|--?|==?=?|~==?=?|\*\*?|\|\|\|?|<(?:->?|<?=?)|>>?=?)(?::=)?|:(?:=:?)?|[!.\\|~]/,
		punctuation: /[\[\](){},;]/
	};
}
icuMessageFormat.displayName = "icu-message-format";
icuMessageFormat.aliases = [];
function icuMessageFormat(Prism$1) {
	(function(Prism$2) {
		function nested(source, level) {
			if (level <= 0) return /[]/.source;
			else return source.replace(/<SELF>/g, function() {
				return nested(source, level - 1);
			});
		}
		var stringPattern = /'[{}:=,](?:[^']|'')*'(?!')/;
		var escape$1 = {
			pattern: /''/,
			greedy: true,
			alias: "operator"
		};
		var string$2 = {
			pattern: stringPattern,
			greedy: true,
			inside: { escape: escape$1 }
		};
		var argumentSource = nested(/\{(?:[^{}']|'(?![{},'])|''|<STR>|<SELF>)*\}/.source.replace(/<STR>/g, function() {
			return stringPattern.source;
		}), 8);
		var nestedMessage = {
			pattern: RegExp(argumentSource),
			inside: {
				message: {
					pattern: /^(\{)[\s\S]+(?=\}$)/,
					lookbehind: true,
					inside: null
				},
				"message-delimiter": {
					pattern: /./,
					alias: "punctuation"
				}
			}
		};
		Prism$2.languages["icu-message-format"] = {
			argument: {
				pattern: RegExp(argumentSource),
				greedy: true,
				inside: {
					content: {
						pattern: /^(\{)[\s\S]+(?=\}$)/,
						lookbehind: true,
						inside: {
							"argument-name": {
								pattern: /^(\s*)[^{}:=,\s]+/,
								lookbehind: true
							},
							"choice-style": {
								pattern: /^(\s*,\s*choice\s*,\s*)\S(?:[\s\S]*\S)?/,
								lookbehind: true,
								inside: {
									punctuation: /\|/,
									range: {
										pattern: /^(\s*)[+-]?(?:\d+(?:\.\d*)?|\u221e)\s*[<#\u2264]/,
										lookbehind: true,
										inside: {
											operator: /[<#\u2264]/,
											number: /\S+/
										}
									},
									rest: null
								}
							},
							"plural-style": {
								pattern: /^(\s*,\s*(?:plural|selectordinal)\s*,\s*)\S(?:[\s\S]*\S)?/,
								lookbehind: true,
								inside: {
									offset: /^offset:\s*\d+/,
									"nested-message": nestedMessage,
									selector: {
										pattern: /=\d+|[^{}:=,\s]+/,
										inside: { keyword: /^(?:few|many|one|other|two|zero)$/ }
									}
								}
							},
							"select-style": {
								pattern: /^(\s*,\s*select\s*,\s*)\S(?:[\s\S]*\S)?/,
								lookbehind: true,
								inside: {
									"nested-message": nestedMessage,
									selector: {
										pattern: /[^{}:=,\s]+/,
										inside: { keyword: /^other$/ }
									}
								}
							},
							keyword: /\b(?:choice|plural|select|selectordinal)\b/,
							"arg-type": {
								pattern: /\b(?:date|duration|number|ordinal|spellout|time)\b/,
								alias: "keyword"
							},
							"arg-skeleton": {
								pattern: /(,\s*)::[^{}:=,\s]+/,
								lookbehind: true
							},
							"arg-style": {
								pattern: /(,\s*)(?:currency|full|integer|long|medium|percent|short)(?=\s*$)/,
								lookbehind: true
							},
							"arg-style-text": {
								pattern: RegExp(/(^\s*,\s*(?=\S))/.source + nested(/(?:[^{}']|'[^']*'|\{(?:<SELF>)?\})+/.source, 8) + "$"),
								lookbehind: true,
								alias: "string"
							},
							punctuation: /,/
						}
					},
					"argument-delimiter": {
						pattern: /./,
						alias: "operator"
					}
				}
			},
			escape: escape$1,
			string: string$2
		};
		nestedMessage.inside.message.inside = Prism$2.languages["icu-message-format"];
		Prism$2.languages["icu-message-format"].argument.inside.content.inside["choice-style"].inside.rest = Prism$2.languages["icu-message-format"];
	})(Prism$1);
}
idris.displayName = "idris";
idris.aliases = ["idr"];
function idris(Prism$1) {
	Prism$1.register(haskell);
	Prism$1.languages.idris = Prism$1.languages.extend("haskell", {
		comment: { pattern: /(?:(?:--|\|\|\|).*$|\{-[\s\S]*?-\})/m },
		keyword: /\b(?:Type|case|class|codata|constructor|corecord|data|do|dsl|else|export|if|implementation|implicit|import|impossible|in|infix|infixl|infixr|instance|interface|let|module|mutual|namespace|of|parameters|partial|postulate|private|proof|public|quoteGoal|record|rewrite|syntax|then|total|using|where|with)\b/,
		builtin: void 0
	});
	Prism$1.languages.insertBefore("idris", "keyword", { "import-statement": {
		pattern: /(^\s*import\s+)(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*/m,
		lookbehind: true,
		inside: { punctuation: /\./ }
	} });
	Prism$1.languages.idr = Prism$1.languages.idris;
}
ignore$1.displayName = "ignore";
ignore$1.aliases = [
	"gitignore",
	"hgignore",
	"npmignore"
];
function ignore$1(Prism$1) {
	(function(Prism$2) {
		Prism$2.languages.ignore = {
			comment: /^#.*/m,
			entry: {
				pattern: /\S(?:.*(?:(?:\\ )|\S))?/,
				alias: "string",
				inside: {
					operator: /^!|\*\*?|\?/,
					regex: {
						pattern: /(^|[^\\])\[[^\[\]]*\]/,
						lookbehind: true
					},
					punctuation: /\//
				}
			}
		};
		Prism$2.languages.gitignore = Prism$2.languages.ignore;
		Prism$2.languages.hgignore = Prism$2.languages.ignore;
		Prism$2.languages.npmignore = Prism$2.languages.ignore;
	})(Prism$1);
}
inform7.displayName = "inform7";
inform7.aliases = [];
function inform7(Prism$1) {
	Prism$1.languages.inform7 = {
		string: {
			pattern: /"[^"]*"/,
			inside: { substitution: {
				pattern: /\[[^\[\]]+\]/,
				inside: { delimiter: {
					pattern: /\[|\]/,
					alias: "punctuation"
				} }
			} }
		},
		comment: {
			pattern: /\[[^\[\]]+\]/,
			greedy: true
		},
		title: {
			pattern: /^[ \t]*(?:book|chapter|part(?! of)|section|table|volume)\b.+/im,
			alias: "important"
		},
		number: {
			pattern: /(^|[^-])(?:\b\d+(?:\.\d+)?(?:\^\d+)?(?:(?!\d)\w+)?|\b(?:eight|eleven|five|four|nine|one|seven|six|ten|three|twelve|two))\b(?!-)/i,
			lookbehind: true
		},
		verb: {
			pattern: /(^|[^-])\b(?:answering|applying to|are|asking|attacking|be(?:ing)?|burning|buying|called|carries|carry(?! out)|carrying|climbing|closing|conceal(?:ing|s)?|consulting|contain(?:ing|s)?|cutting|drinking|dropping|eating|enclos(?:es?|ing)|entering|examining|exiting|getting|giving|going|ha(?:s|ve|ving)|hold(?:ing|s)?|impl(?:ies|y)|incorporat(?:es?|ing)|inserting|is|jumping|kissing|listening|locking|looking|mean(?:ing|s)?|opening|provid(?:es?|ing)|pulling|pushing|putting|relat(?:es?|ing)|removing|searching|see(?:ing|s)?|setting|showing|singing|sleeping|smelling|squeezing|support(?:ing|s)?|swearing|switching|taking|tasting|telling|thinking|throwing|touching|turning|tying|unlock(?:ing|s)?|var(?:ies|y|ying)|waiting|waking|waving|wear(?:ing|s)?)\b(?!-)/i,
			lookbehind: true,
			alias: "operator"
		},
		keyword: {
			pattern: /(^|[^-])\b(?:after|before|carry out|check|continue the action|definition(?= *:)|do nothing|else|end (?:if|the story|unless)|every turn|if|include|instead(?: of)?|let|move|no|now|otherwise|repeat|report|resume the story|rule for|running through|say(?:ing)?|stop the action|test|try(?:ing)?|understand|unless|use|when|while|yes)\b(?!-)/i,
			lookbehind: true
		},
		property: {
			pattern: /(^|[^-])\b(?:adjacent(?! to)|carried|closed|concealed|contained|dark|described|edible|empty|enclosed|enterable|even|female|fixed in place|full|handled|held|improper-named|incorporated|inedible|invisible|lighted|lit|lock(?:able|ed)|male|marked for listing|mentioned|negative|neuter|non-(?:empty|full|recurring)|odd|opaque|open(?:able)?|plural-named|portable|positive|privately-named|proper-named|provided|publically-named|pushable between rooms|recurring|related|rubbing|scenery|seen|singular-named|supported|swinging|switch(?:able|ed(?: off| on)?)|touch(?:able|ed)|transparent|unconcealed|undescribed|unlit|unlocked|unmarked for listing|unmentioned|unopenable|untouchable|unvisited|variable|visible|visited|wearable|worn)\b(?!-)/i,
			lookbehind: true,
			alias: "symbol"
		},
		position: {
			pattern: /(^|[^-])\b(?:above|adjacent to|back side of|below|between|down|east|everywhere|front side|here|in|inside(?: from)?|north(?:east|west)?|nowhere|on(?: top of)?|other side|outside(?: from)?|parts? of|regionally in|south(?:east|west)?|through|up|west|within)\b(?!-)/i,
			lookbehind: true,
			alias: "keyword"
		},
		type: {
			pattern: /(^|[^-])\b(?:actions?|activit(?:ies|y)|actors?|animals?|backdrops?|containers?|devices?|directions?|doors?|holders?|kinds?|lists?|m[ae]n|nobody|nothing|nouns?|numbers?|objects?|people|persons?|player(?:'s holdall)?|regions?|relations?|rooms?|rule(?:book)?s?|scenes?|someone|something|supporters?|tables?|texts?|things?|time|vehicles?|wom[ae]n)\b(?!-)/i,
			lookbehind: true,
			alias: "variable"
		},
		punctuation: /[.,:;(){}]/
	};
	Prism$1.languages.inform7["string"].inside["substitution"].inside.rest = Prism$1.languages.inform7;
	Prism$1.languages.inform7["string"].inside["substitution"].inside.rest.text = {
		pattern: /\S(?:\s*\S)*/,
		alias: "comment"
	};
}
io.displayName = "io";
io.aliases = [];
function io(Prism$1) {
	Prism$1.languages.io = {
		comment: {
			pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*|#.*)/,
			lookbehind: true,
			greedy: true
		},
		"triple-quoted-string": {
			pattern: /"""(?:\\[\s\S]|(?!""")[^\\])*"""/,
			greedy: true,
			alias: "string"
		},
		string: {
			pattern: /"(?:\\.|[^\\\r\n"])*"/,
			greedy: true
		},
		keyword: /\b(?:activate|activeCoroCount|asString|block|break|call|catch|clone|collectGarbage|compileString|continue|do|doFile|doMessage|doString|else|elseif|exit|for|foreach|forward|getEnvironmentVariable|getSlot|hasSlot|if|ifFalse|ifNil|ifNilEval|ifTrue|isActive|isNil|isResumable|list|message|method|parent|pass|pause|perform|performWithArgList|print|println|proto|raise|raiseResumable|removeSlot|resend|resume|schedulerSleepSeconds|self|sender|setSchedulerSleepSeconds|setSlot|shallowCopy|slotNames|super|system|then|thisBlock|thisContext|try|type|uniqueId|updateSlot|wait|while|write|yield)\b/,
		builtin: /\b(?:Array|AudioDevice|AudioMixer|BigNum|Block|Box|Buffer|CFunction|CGI|Color|Curses|DBM|DNSResolver|DOConnection|DOProxy|DOServer|Date|Directory|Duration|DynLib|Error|Exception|FFT|File|Fnmatch|Font|Future|GL|GLE|GLScissor|GLU|GLUCylinder|GLUQuadric|GLUSphere|GLUT|Host|Image|Importer|LinkList|List|Lobby|Locals|MD5|MP3Decoder|MP3Encoder|Map|Message|Movie|Notification|Number|Object|OpenGL|Point|Protos|Random|Regex|SGML|SGMLElement|SGMLParser|SQLite|Sequence|Server|ShowMessage|SleepyCat|SleepyCatCursor|Socket|SocketManager|Sound|Soup|Store|String|Tree|UDPSender|UPDReceiver|URL|User|Warning|WeakLink)\b/,
		boolean: /\b(?:false|nil|true)\b/,
		number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e-?\d+)?/i,
		operator: /[=!*/%+\-^&|]=|>>?=?|<<?=?|:?:?=|\+\+?|--?|\*\*?|\/\/?|%|\|\|?|&&?|\b(?:and|not|or|return)\b|@@?|\?\??|\.\./,
		punctuation: /[{}[\];(),.:]/
	};
}
j.displayName = "j";
j.aliases = [];
function j(Prism$1) {
	Prism$1.languages.j = {
		comment: {
			pattern: /\bNB\..*/,
			greedy: true
		},
		string: {
			pattern: /'(?:''|[^'\r\n])*'/,
			greedy: true
		},
		keyword: /\b(?:(?:CR|LF|adverb|conjunction|def|define|dyad|monad|noun|verb)\b|(?:assert|break|case|catch[dt]?|continue|do|else|elseif|end|fcase|for|for_\w+|goto_\w+|if|label_\w+|return|select|throw|try|while|whilst)\.)/,
		verb: {
			pattern: /(?!\^:|;\.|[=!][.:])(?:\{(?:\.|::?)?|p(?:\.\.?|:)|[=!\]]|[<>+*\-%$|,#][.:]?|[?^]\.?|[;\[]:?|[~}"i][.:]|[ACeEIjLor]\.|(?:[_\/\\qsux]|_?\d):)/,
			alias: "keyword"
		},
		number: /\b_?(?:(?!\d:)\d+(?:\.\d+)?(?:(?:ad|ar|[ejpx])_?\d+(?:\.\d+)?)*(?:b_?[\da-z]+(?:\.[\da-z]+)?)?|_\b(?!\.))/,
		adverb: {
			pattern: /[~}]|[\/\\]\.?|[bfM]\.|t[.:]/,
			alias: "builtin"
		},
		operator: /[=a][.:]|_\./,
		conjunction: {
			pattern: /&(?:\.:?|:)?|[.:@][.:]?|[!D][.:]|[;dHT]\.|`:?|[\^LS]:|"/,
			alias: "variable"
		},
		punctuation: /[()]/
	};
}
javadoclike.displayName = "javadoclike";
javadoclike.aliases = [];
function javadoclike(Prism$1) {
	(function(Prism$2) {
		var javaDocLike = Prism$2.languages.javadoclike = {
			parameter: {
				pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*@(?:arg|arguments|param)\s+)\w+/m,
				lookbehind: true
			},
			keyword: {
				pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*|\{)@[a-z][a-zA-Z-]+\b/m,
				lookbehind: true
			},
			punctuation: /[{}]/
		};
		function docCommentSupport(lang$1, callback) {
			var tokenName = "doc-comment";
			var grammar = Prism$2.languages[lang$1];
			if (!grammar) return;
			var token = grammar[tokenName];
			if (!token) {
				var definition$2 = {};
				definition$2[tokenName] = {
					pattern: /(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/,
					lookbehind: true,
					alias: "comment"
				};
				grammar = Prism$2.languages.insertBefore(lang$1, "comment", definition$2);
				token = grammar[tokenName];
			}
			if (token instanceof RegExp) token = grammar[tokenName] = { pattern: token };
			if (Array.isArray(token)) for (var i = 0, l$1 = token.length; i < l$1; i++) {
				if (token[i] instanceof RegExp) token[i] = { pattern: token[i] };
				callback(token[i]);
			}
			else callback(token);
		}
		function addSupport(languages, docLanguage) {
			if (typeof languages === "string") languages = [languages];
			languages.forEach(function(lang$1) {
				docCommentSupport(lang$1, function(pattern) {
					if (!pattern.inside) pattern.inside = {};
					pattern.inside.rest = docLanguage;
				});
			});
		}
		Object.defineProperty(javaDocLike, "addSupport", { value: addSupport });
		javaDocLike.addSupport([
			"java",
			"javascript",
			"php"
		], javaDocLike);
	})(Prism$1);
}
scala.displayName = "scala";
scala.aliases = [];
function scala(Prism$1) {
	Prism$1.register(java);
	Prism$1.languages.scala = Prism$1.languages.extend("java", {
		"triple-quoted-string": {
			pattern: /"""[\s\S]*?"""/,
			greedy: true,
			alias: "string"
		},
		string: {
			pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
			greedy: true
		},
		keyword: /<-|=>|\b(?:abstract|case|catch|class|def|derives|do|else|enum|extends|extension|final|finally|for|forSome|given|if|implicit|import|infix|inline|lazy|match|new|null|object|opaque|open|override|package|private|protected|return|sealed|self|super|this|throw|trait|transparent|try|type|using|val|var|while|with|yield)\b/,
		number: /\b0x(?:[\da-f]*\.)?[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e\d+)?[dfl]?/i,
		builtin: /\b(?:Any|AnyRef|AnyVal|Boolean|Byte|Char|Double|Float|Int|Long|Nothing|Short|String|Unit)\b/,
		symbol: /'[^\d\s\\]\w*/
	});
	Prism$1.languages.insertBefore("scala", "triple-quoted-string", { "string-interpolation": {
		pattern: /\b[a-z]\w*(?:"""(?:[^$]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*?"""|"(?:[^$"\r\n]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*")/i,
		greedy: true,
		inside: {
			id: {
				pattern: /^\w+/,
				greedy: true,
				alias: "function"
			},
			escape: {
				pattern: /\\\$"|\$[$"]/,
				greedy: true,
				alias: "symbol"
			},
			interpolation: {
				pattern: /\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
				greedy: true,
				inside: {
					punctuation: /^\$\{?|\}$/,
					expression: {
						pattern: /[\s\S]+/,
						inside: Prism$1.languages.scala
					}
				}
			},
			string: /[\s\S]+/
		}
	} });
	delete Prism$1.languages.scala["class-name"];
	delete Prism$1.languages.scala["function"];
	delete Prism$1.languages.scala["constant"];
}
javadoc.displayName = "javadoc";
javadoc.aliases = [];
function javadoc(Prism$1) {
	Prism$1.register(java);
	Prism$1.register(javadoclike);
	Prism$1.register(markup);
	(function(Prism$2) {
		var codeLinePattern = /(^(?:[\t ]*(?:\*\s*)*))[^*\s].*$/m;
		var memberReference = /#\s*\w+(?:\s*\([^()]*\))?/.source;
		var reference = /(?:\b[a-zA-Z]\w+\s*\.\s*)*\b[A-Z]\w*(?:\s*<mem>)?|<mem>/.source.replace(/<mem>/g, function() {
			return memberReference;
		});
		Prism$2.languages.javadoc = Prism$2.languages.extend("javadoclike", {});
		Prism$2.languages.insertBefore("javadoc", "keyword", {
			reference: {
				pattern: RegExp(/(@(?:exception|link|linkplain|see|throws|value)\s+(?:\*\s*)?)/.source + "(?:" + reference + ")"),
				lookbehind: true,
				inside: {
					function: {
						pattern: /(#\s*)\w+(?=\s*\()/,
						lookbehind: true
					},
					field: {
						pattern: /(#\s*)\w+/,
						lookbehind: true
					},
					namespace: {
						pattern: /\b(?:[a-z]\w*\s*\.\s*)+/,
						inside: { punctuation: /\./ }
					},
					"class-name": /\b[A-Z]\w*/,
					keyword: Prism$2.languages.java.keyword,
					punctuation: /[#()[\],.]/
				}
			},
			"class-name": {
				pattern: /(@param\s+)<[A-Z]\w*>/,
				lookbehind: true,
				inside: { punctuation: /[.<>]/ }
			},
			"code-section": [{
				pattern: /(\{@code\s+(?!\s))(?:[^\s{}]|\s+(?![\s}])|\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\})+(?=\s*\})/,
				lookbehind: true,
				inside: { code: {
					pattern: codeLinePattern,
					lookbehind: true,
					inside: Prism$2.languages.java,
					alias: "language-java"
				} }
			}, {
				pattern: /(<(code|pre|tt)>(?!<code>)\s*)\S(?:\S|\s+\S)*?(?=\s*<\/\2>)/,
				lookbehind: true,
				inside: { line: {
					pattern: codeLinePattern,
					lookbehind: true,
					inside: {
						tag: Prism$2.languages.markup.tag,
						entity: Prism$2.languages.markup.entity,
						code: {
							pattern: /.+/,
							inside: Prism$2.languages.java,
							alias: "language-java"
						}
					}
				} }
			}],
			tag: Prism$2.languages.markup.tag,
			entity: Prism$2.languages.markup.entity
		});
		Prism$2.languages.javadoclike.addSupport("java", Prism$2.languages.javadoc);
	})(Prism$1);
}
javastacktrace.displayName = "javastacktrace";
javastacktrace.aliases = [];
function javastacktrace(Prism$1) {
	Prism$1.languages.javastacktrace = {
		summary: {
			pattern: /^([\t ]*)(?:(?:Caused by:|Suppressed:|Exception in thread "[^"]*")[\t ]+)?[\w$.]+(?::.*)?$/m,
			lookbehind: true,
			inside: {
				keyword: {
					pattern: /^([\t ]*)(?:(?:Caused by|Suppressed)(?=:)|Exception in thread)/m,
					lookbehind: true
				},
				string: {
					pattern: /^(\s*)"[^"]*"/,
					lookbehind: true
				},
				exceptions: {
					pattern: /^(:?\s*)[\w$.]+(?=:|$)/,
					lookbehind: true,
					inside: {
						"class-name": /[\w$]+$/,
						namespace: /\b[a-z]\w*\b/,
						punctuation: /\./
					}
				},
				message: {
					pattern: /(:\s*)\S.*/,
					lookbehind: true,
					alias: "string"
				},
				punctuation: /:/
			}
		},
		"stack-frame": {
			pattern: /^([\t ]*)at (?:[\w$./]|@[\w$.+-]*\/)+(?:<init>)?\([^()]*\)/m,
			lookbehind: true,
			inside: {
				keyword: {
					pattern: /^(\s*)at(?= )/,
					lookbehind: true
				},
				source: [{
					pattern: /(\()\w+\.\w+:\d+(?=\))/,
					lookbehind: true,
					inside: {
						file: /^\w+\.\w+/,
						punctuation: /:/,
						"line-number": {
							pattern: /\b\d+\b/,
							alias: "number"
						}
					}
				}, {
					pattern: /(\()[^()]*(?=\))/,
					lookbehind: true,
					inside: { keyword: /^(?:Native Method|Unknown Source)$/ }
				}],
				"class-name": /[\w$]+(?=\.(?:<init>|[\w$]+)\()/,
				function: /(?:<init>|[\w$]+)(?=\()/,
				"class-loader": {
					pattern: /(\s)[a-z]\w*(?:\.[a-z]\w*)*(?=\/[\w@$.]*\/)/,
					lookbehind: true,
					alias: "namespace",
					inside: { punctuation: /\./ }
				},
				module: {
					pattern: /([\s/])[a-z]\w*(?:\.[a-z]\w*)*(?:@[\w$.+-]*)?(?=\/)/,
					lookbehind: true,
					inside: {
						version: {
							pattern: /(@)[\s\S]+/,
							lookbehind: true,
							alias: "number"
						},
						punctuation: /[@.]/
					}
				},
				namespace: {
					pattern: /(?:\b[a-z]\w*\.)+/,
					inside: { punctuation: /\./ }
				},
				punctuation: /[()/.]/
			}
		},
		more: {
			pattern: /^([\t ]*)\.{3} \d+ [a-z]+(?: [a-z]+)*/m,
			lookbehind: true,
			inside: {
				punctuation: /\.{3}/,
				number: /\d+/,
				keyword: /\b[a-z]+(?: [a-z]+)*\b/
			}
		}
	};
}
jexl.displayName = "jexl";
jexl.aliases = [];
function jexl(Prism$1) {
	Prism$1.languages.jexl = {
		string: /(["'])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
		transform: {
			pattern: /(\|\s*)[a-zA-Zа-яА-Я_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\wа-яА-Я\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*/,
			alias: "function",
			lookbehind: true
		},
		function: /[a-zA-Zа-яА-Я_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\wа-яА-Я\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*\s*(?=\()/,
		number: /\b\d+(?:\.\d+)?\b|\B\.\d+\b/,
		operator: /[<>!]=?|-|\+|&&|==|\|\|?|\/\/?|[?:*^%]/,
		boolean: /\b(?:false|true)\b/,
		keyword: /\bin\b/,
		punctuation: /[{}[\](),.]/
	};
}
jolie.displayName = "jolie";
jolie.aliases = [];
function jolie(Prism$1) {
	Prism$1.register(clike);
	Prism$1.languages.jolie = Prism$1.languages.extend("clike", {
		string: {
			pattern: /(^|[^\\])"(?:\\[\s\S]|[^"\\])*"/,
			lookbehind: true,
			greedy: true
		},
		"class-name": {
			pattern: /((?:\b(?:as|courier|embed|in|inputPort|outputPort|service)\b|@)[ \t]*)\w+/,
			lookbehind: true
		},
		keyword: /\b(?:as|cH|comp|concurrent|constants|courier|cset|csets|default|define|else|embed|embedded|execution|exit|extender|for|foreach|forward|from|global|if|import|in|include|init|inputPort|install|instanceof|interface|is_defined|linkIn|linkOut|main|new|nullProcess|outputPort|over|private|provide|public|scope|sequential|service|single|spawn|synchronized|this|throw|throws|type|undef|until|while|with)\b/,
		function: /\b[a-z_]\w*(?=[ \t]*[@(])/i,
		number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?l?/i,
		operator: /-[-=>]?|\+[+=]?|<[<=]?|[>=*!]=?|&&|\|\||[?\/%^@|]/,
		punctuation: /[()[\]{},;.:]/,
		builtin: /\b(?:Byte|any|bool|char|double|enum|float|int|length|long|ranges|regex|string|undefined|void)\b/
	});
	Prism$1.languages.insertBefore("jolie", "keyword", {
		aggregates: {
			pattern: /(\bAggregates\s*:\s*)(?:\w+(?:\s+with\s+\w+)?\s*,\s*)*\w+(?:\s+with\s+\w+)?/,
			lookbehind: true,
			inside: {
				keyword: /\bwith\b/,
				"class-name": /\w+/,
				punctuation: /,/
			}
		},
		redirects: {
			pattern: /(\bRedirects\s*:\s*)(?:\w+\s*=>\s*\w+\s*,\s*)*(?:\w+\s*=>\s*\w+)/,
			lookbehind: true,
			inside: {
				punctuation: /,/,
				"class-name": /\w+/,
				operator: /=>/
			}
		},
		property: { pattern: /\b(?:Aggregates|[Ii]nterfaces|Java|Javascript|Jolie|[Ll]ocation|OneWay|[Pp]rotocol|Redirects|RequestResponse)\b(?=[ \t]*:)/ }
	});
}
jq.displayName = "jq";
jq.aliases = [];
function jq(Prism$1) {
	(function(Prism$2) {
		var interpolation = /\\\((?:[^()]|\([^()]*\))*\)/.source;
		var string$2 = RegExp(/(^|[^\\])"(?:[^"\r\n\\]|\\[^\r\n(]|__)*"/.source.replace(/__/g, function() {
			return interpolation;
		}));
		var stringInterpolation = { interpolation: {
			pattern: RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + interpolation),
			lookbehind: true,
			inside: {
				content: {
					pattern: /^(\\\()[\s\S]+(?=\)$)/,
					lookbehind: true,
					inside: null
				},
				punctuation: /^\\\(|\)$/
			}
		} };
		var jq$1 = Prism$2.languages.jq = {
			comment: /#.*/,
			property: {
				pattern: RegExp(string$2.source + /(?=\s*:(?!:))/.source),
				lookbehind: true,
				greedy: true,
				inside: stringInterpolation
			},
			string: {
				pattern: string$2,
				lookbehind: true,
				greedy: true,
				inside: stringInterpolation
			},
			function: {
				pattern: /(\bdef\s+)[a-z_]\w+/i,
				lookbehind: true
			},
			variable: /\B\$\w+/,
			"property-literal": {
				pattern: /\b[a-z_]\w*(?=\s*:(?!:))/i,
				alias: "property"
			},
			keyword: /\b(?:as|break|catch|def|elif|else|end|foreach|if|import|include|label|module|modulemeta|null|reduce|then|try|while)\b/,
			boolean: /\b(?:false|true)\b/,
			number: /(?:\b\d+\.|\B\.)?\b\d+(?:[eE][+-]?\d+)?\b/,
			operator: [{
				pattern: /\|=?/,
				alias: "pipe"
			}, /\.\.|[!=<>]?=|\?\/\/|\/\/=?|[-+*/%]=?|[<>?]|\b(?:and|not|or)\b/],
			"c-style-function": {
				pattern: /\b[a-z_]\w*(?=\s*\()/i,
				alias: "function"
			},
			punctuation: /::|[()\[\]{},:;]|\.(?=\s*[\[\w$])/,
			dot: {
				pattern: /\./,
				alias: "important"
			}
		};
		stringInterpolation.interpolation.inside.content.inside = jq$1;
	})(Prism$1);
}
jsTemplates.displayName = "js-templates";
jsTemplates.aliases = [];
function jsTemplates(Prism$1) {
	Prism$1.register(javascript);
	(function(Prism$2) {
		var templateString = Prism$2.languages.javascript["template-string"];
		var templateLiteralPattern = templateString.pattern.source;
		var interpolationObject = templateString.inside["interpolation"];
		var interpolationPunctuationObject = interpolationObject.inside["interpolation-punctuation"];
		var interpolationPattern = interpolationObject.pattern.source;
		function createTemplate(language, tag) {
			if (!Prism$2.languages[language]) return void 0;
			return {
				pattern: RegExp("((?:" + tag + ")\\s*)" + templateLiteralPattern),
				lookbehind: true,
				greedy: true,
				inside: {
					"template-punctuation": {
						pattern: /^`|`$/,
						alias: "string"
					},
					"embedded-code": {
						pattern: /[\s\S]+/,
						alias: language
					}
				}
			};
		}
		Prism$2.languages.javascript["template-string"] = [
			createTemplate("css", /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),
			createTemplate("html", /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source),
			createTemplate("svg", /\bsvg/.source),
			createTemplate("markdown", /\b(?:markdown|md)/.source),
			createTemplate("graphql", /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source),
			createTemplate("sql", /\bsql/.source),
			templateString
		].filter(Boolean);
		function getPlaceholder(counter, language) {
			return "___" + language.toUpperCase() + "_" + counter + "___";
		}
		function tokenizeWithHooks(code$3, grammar, language) {
			var env$1 = {
				code: code$3,
				grammar,
				language
			};
			Prism$2.hooks.run("before-tokenize", env$1);
			env$1.tokens = Prism$2.tokenize(env$1.code, env$1.grammar);
			Prism$2.hooks.run("after-tokenize", env$1);
			return env$1.tokens;
		}
		function tokenizeInterpolationExpression(expression) {
			var tempGrammar = {};
			tempGrammar["interpolation-punctuation"] = interpolationPunctuationObject;
			var tokens = Prism$2.tokenize(expression, tempGrammar);
			if (tokens.length === 3) {
				var args = [1, 1];
				args.push.apply(args, tokenizeWithHooks(tokens[1], Prism$2.languages.javascript, "javascript"));
				tokens.splice.apply(tokens, args);
			}
			return new Prism$2.Token("interpolation", tokens, interpolationObject.alias, expression);
		}
		function tokenizeEmbedded(code$3, grammar, language) {
			var _tokens = Prism$2.tokenize(code$3, { interpolation: {
				pattern: RegExp(interpolationPattern),
				lookbehind: true
			} });
			var placeholderCounter = 0;
			var placeholderMap = {};
			var embeddedCode = _tokens.map(function(token) {
				if (typeof token === "string") return token;
				else {
					var interpolationExpression = token.content;
					var placeholder;
					while (code$3.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1);
					placeholderMap[placeholder] = interpolationExpression;
					return placeholder;
				}
			}).join("");
			var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language);
			var placeholders = Object.keys(placeholderMap);
			placeholderCounter = 0;
			function walkTokens(tokens) {
				for (var i = 0; i < tokens.length; i++) {
					if (placeholderCounter >= placeholders.length) return;
					var token = tokens[i];
					if (typeof token === "string" || typeof token.content === "string") {
						var placeholder = placeholders[placeholderCounter];
						var s$2 = typeof token === "string" ? token : token.content;
						var index$1 = s$2.indexOf(placeholder);
						if (index$1 !== -1) {
							++placeholderCounter;
							var before = s$2.substring(0, index$1);
							var middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);
							var after = s$2.substring(index$1 + placeholder.length);
							var replacement = [];
							if (before) replacement.push(before);
							replacement.push(middle);
							if (after) {
								var afterTokens = [after];
								walkTokens(afterTokens);
								replacement.push.apply(replacement, afterTokens);
							}
							if (typeof token === "string") {
								tokens.splice.apply(tokens, [i, 1].concat(replacement));
								i += replacement.length - 1;
							} else token.content = replacement;
						}
					} else {
						var content$2 = token.content;
						if (Array.isArray(content$2)) walkTokens(content$2);
						else walkTokens([content$2]);
					}
				}
			}
			walkTokens(embeddedTokens);
			return new Prism$2.Token(language, embeddedTokens, "language-" + language, code$3);
		}
		var supportedLanguages = {
			javascript: true,
			js: true,
			typescript: true,
			ts: true,
			jsx: true,
			tsx: true
		};
		Prism$2.hooks.add("after-tokenize", function(env$1) {
			if (!(env$1.language in supportedLanguages)) return;
			function findTemplateStrings(tokens) {
				for (var i = 0, l$1 = tokens.length; i < l$1; i++) {
					var token = tokens[i];
					if (typeof token === "string") continue;
					var content$2 = token.content;
					if (!Array.isArray(content$2)) {
						if (typeof content$2 !== "string") findTemplateStrings([content$2]);
						continue;
					}
					if (token.type === "template-string") {
						var embedded = content$2[1];
						if (content$2.length === 3 && typeof embedded !== "string" && embedded.type === "embedded-code") {
							var code$3 = stringContent(embedded);
							var alias$1 = embedded.alias;
							var language = Array.isArray(alias$1) ? alias$1[0] : alias$1;
							var grammar = Prism$2.languages[language];
							if (!grammar) continue;
							content$2[1] = tokenizeEmbedded(code$3, grammar, language);
						}
					} else findTemplateStrings(content$2);
				}
			}
			findTemplateStrings(env$1.tokens);
		});
		function stringContent(value) {
			if (typeof value === "string") return value;
			else if (Array.isArray(value)) return value.map(stringContent).join("");
			else return stringContent(value.content);
		}
	})(Prism$1);
}
jsdoc.displayName = "jsdoc";
jsdoc.aliases = [];
function jsdoc(Prism$1) {
	Prism$1.register(javadoclike);
	Prism$1.register(javascript);
	Prism$1.register(typescript);
	(function(Prism$2) {
		var javascript$1 = Prism$2.languages.javascript;
		var type = /\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})+\}/.source;
		var parameterPrefix = "(@(?:arg|argument|param|property)\\s+(?:" + type + "\\s+)?)";
		Prism$2.languages.jsdoc = Prism$2.languages.extend("javadoclike", { parameter: {
			pattern: RegExp(parameterPrefix + /(?:(?!\s)[$\w\xA0-\uFFFF.])+(?=\s|$)/.source),
			lookbehind: true,
			inside: { punctuation: /\./ }
		} });
		Prism$2.languages.insertBefore("jsdoc", "keyword", {
			"optional-parameter": {
				pattern: RegExp(parameterPrefix + /\[(?:(?!\s)[$\w\xA0-\uFFFF.])+(?:=[^[\]]+)?\](?=\s|$)/.source),
				lookbehind: true,
				inside: {
					parameter: {
						pattern: /(^\[)[$\w\xA0-\uFFFF\.]+/,
						lookbehind: true,
						inside: { punctuation: /\./ }
					},
					code: {
						pattern: /(=)[\s\S]*(?=\]$)/,
						lookbehind: true,
						inside: javascript$1,
						alias: "language-javascript"
					},
					punctuation: /[=[\]]/
				}
			},
			"class-name": [{
				pattern: RegExp(/(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\s+(?:<TYPE>\s+)?)[A-Z]\w*(?:\.[A-Z]\w*)*/.source.replace(/<TYPE>/g, function() {
					return type;
				})),
				lookbehind: true,
				inside: { punctuation: /\./ }
			}, {
				pattern: RegExp("(@[a-z]+\\s+)" + type),
				lookbehind: true,
				inside: {
					string: javascript$1.string,
					number: javascript$1.number,
					boolean: javascript$1.boolean,
					keyword: Prism$2.languages.typescript.keyword,
					operator: /=>|\.\.\.|[&|?:*]/,
					punctuation: /[.,;=<>{}()[\]]/
				}
			}],
			example: {
				pattern: /(@example\s+(?!\s))(?:[^@\s]|\s+(?!\s))+?(?=\s*(?:\*\s*)?(?:@\w|\*\/))/,
				lookbehind: true,
				inside: { code: {
					pattern: /^([\t ]*(?:\*\s*)?)\S.*$/m,
					lookbehind: true,
					inside: javascript$1,
					alias: "language-javascript"
				} }
			}
		});
		Prism$2.languages.javadoclike.addSupport("javascript", Prism$2.languages.jsdoc);
	})(Prism$1);
}
n4js.displayName = "n4js";
n4js.aliases = ["n4jsd"];
function n4js(Prism$1) {
	Prism$1.register(javascript);
	Prism$1.languages.n4js = Prism$1.languages.extend("javascript", { keyword: /\b(?:Array|any|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|module|new|null|number|package|private|protected|public|return|set|static|string|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/ });
	Prism$1.languages.insertBefore("n4js", "constant", { annotation: {
		pattern: /@+\w+/,
		alias: "operator"
	} });
	Prism$1.languages.n4jsd = Prism$1.languages.n4js;
}
jsExtras.displayName = "js-extras";
jsExtras.aliases = [];
function jsExtras(Prism$1) {
	Prism$1.register(javascript);
	(function(Prism$2) {
		Prism$2.languages.insertBefore("javascript", "function-variable", { "method-variable": {
			pattern: RegExp("(\\.\\s*)" + Prism$2.languages.javascript["function-variable"].pattern.source),
			lookbehind: true,
			alias: [
				"function-variable",
				"method",
				"function",
				"property-access"
			]
		} });
		Prism$2.languages.insertBefore("javascript", "function", { method: {
			pattern: RegExp("(\\.\\s*)" + Prism$2.languages.javascript["function"].source),
			lookbehind: true,
			alias: ["function", "property-access"]
		} });
		Prism$2.languages.insertBefore("javascript", "constant", { "known-class-name": [{
			pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/,
			alias: "class-name"
		}, {
			pattern: /\b(?:[A-Z]\w*)Error\b/,
			alias: "class-name"
		}] });
		function withId(source, flags) {
			return RegExp(source.replace(/<ID>/g, function() {
				return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
			}), flags);
		}
		Prism$2.languages.insertBefore("javascript", "keyword", {
			imports: {
				pattern: withId(/(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source),
				lookbehind: true,
				inside: Prism$2.languages.javascript
			},
			exports: {
				pattern: withId(/(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source),
				lookbehind: true,
				inside: Prism$2.languages.javascript
			}
		});
		Prism$2.languages.javascript["keyword"].unshift({
			pattern: /\b(?:as|default|export|from|import)\b/,
			alias: "module"
		}, {
			pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,
			alias: "control-flow"
		}, {
			pattern: /\bnull\b/,
			alias: ["null", "nil"]
		}, {
			pattern: /\bundefined\b/,
			alias: "nil"
		});
		Prism$2.languages.insertBefore("javascript", "operator", {
			spread: {
				pattern: /\.{3}/,
				alias: "operator"
			},
			arrow: {
				pattern: /=>/,
				alias: "operator"
			}
		});
		Prism$2.languages.insertBefore("javascript", "punctuation", {
			"property-access": {
				pattern: withId(/(\.\s*)#?<ID>/.source),
				lookbehind: true
			},
			"maybe-class-name": {
				pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/,
				lookbehind: true
			},
			dom: {
				pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/,
				alias: "variable"
			},
			console: {
				pattern: /\bconsole(?=\s*\.)/,
				alias: "class-name"
			}
		});
		var maybeClassNameTokens = [
			"function",
			"function-variable",
			"method",
			"method-variable",
			"property-access"
		];
		for (var i = 0; i < maybeClassNameTokens.length; i++) {
			var token = maybeClassNameTokens[i];
			var value = Prism$2.languages.javascript[token];
			if (Prism$2.util.type(value) === "RegExp") value = Prism$2.languages.javascript[token] = { pattern: value };
			var inside = value.inside || {};
			value.inside = inside;
			inside["maybe-class-name"] = /^[A-Z][\s\S]*/;
		}
	})(Prism$1);
}
json5.displayName = "json5";
json5.aliases = [];
function json5(Prism$1) {
	Prism$1.register(json);
	(function(Prism$2) {
		var string$2 = /("|')(?:\\(?:\r\n?|\n|.)|(?!\1)[^\\\r\n])*\1/;
		Prism$2.languages.json5 = Prism$2.languages.extend("json", {
			property: [{
				pattern: RegExp(string$2.source + "(?=\\s*:)"),
				greedy: true
			}, {
				pattern: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/,
				alias: "unquoted"
			}],
			string: {
				pattern: string$2,
				greedy: true
			},
			number: /[+-]?\b(?:NaN|Infinity|0x[a-fA-F\d]+)\b|[+-]?(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+\b)?/
		});
	})(Prism$1);
}
jsonp.displayName = "jsonp";
jsonp.aliases = [];
function jsonp(Prism$1) {
	Prism$1.register(json);
	Prism$1.languages.jsonp = Prism$1.languages.extend("json", { punctuation: /[{}[\]();,.]/ });
	Prism$1.languages.insertBefore("jsonp", "punctuation", { function: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*\()/ });
}
jsstacktrace.displayName = "jsstacktrace";
jsstacktrace.aliases = [];
function jsstacktrace(Prism$1) {
	Prism$1.languages.jsstacktrace = {
		"error-message": {
			pattern: /^\S.*/m,
			alias: "string"
		},
		"stack-frame": {
			pattern: /(^[ \t]+)at[ \t].*/m,
			lookbehind: true,
			inside: {
				"not-my-code": {
					pattern: /^at[ \t]+(?!\s)(?:node\.js|<unknown>|.*(?:node_modules|\(<anonymous>\)|\(<unknown>|<anonymous>$|\(internal\/|\(node\.js)).*/m,
					alias: "comment"
				},
				filename: {
					pattern: /(\bat\s+(?!\s)|\()(?:[a-zA-Z]:)?[^():]+(?=:)/,
					lookbehind: true,
					alias: "url"
				},
				function: {
					pattern: /(\bat\s+(?:new\s+)?)(?!\s)[_$a-zA-Z\xA0-\uFFFF<][.$\w\xA0-\uFFFF<>]*/,
					lookbehind: true,
					inside: { punctuation: /\./ }
				},
				punctuation: /[()]/,
				keyword: /\b(?:at|new)\b/,
				alias: {
					pattern: /\[(?:as\s+)?(?!\s)[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\]/,
					alias: "variable"
				},
				"line-number": {
					pattern: /:\d+(?::\d+)?\b/,
					alias: "number",
					inside: { punctuation: /:/ }
				}
			}
		}
	};
}
julia.displayName = "julia";
julia.aliases = [];
function julia(Prism$1) {
	Prism$1.languages.julia = {
		comment: {
			pattern: /(^|[^\\])(?:#=(?:[^#=]|=(?!#)|#(?!=)|#=(?:[^#=]|=(?!#)|#(?!=))*=#)*=#|#.*)/,
			lookbehind: true
		},
		regex: {
			pattern: /r"(?:\\.|[^"\\\r\n])*"[imsx]{0,4}/,
			greedy: true
		},
		string: {
			pattern: /"""[\s\S]+?"""|(?:\b\w+)?"(?:\\.|[^"\\\r\n])*"|`(?:[^\\`\r\n]|\\.)*`/,
			greedy: true
		},
		char: {
			pattern: /(^|[^\w'])'(?:\\[^\r\n][^'\r\n]*|[^\\\r\n])'/,
			lookbehind: true,
			greedy: true
		},
		keyword: /\b(?:abstract|baremodule|begin|bitstype|break|catch|ccall|const|continue|do|else|elseif|end|export|finally|for|function|global|if|immutable|import|importall|in|let|local|macro|module|print|println|quote|return|struct|try|type|typealias|using|while)\b/,
		boolean: /\b(?:false|true)\b/,
		number: /(?:\b(?=\d)|\B(?=\.))(?:0[box])?(?:[\da-f]+(?:_[\da-f]+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[efp][+-]?\d+(?:_\d+)*)?j?/i,
		operator: /&&|\|\||[-+*^%÷⊻&$\\]=?|\/[\/=]?|!=?=?|\|[=>]?|<(?:<=?|[=:|])?|>(?:=|>>?=?)?|==?=?|[~≠≤≥'√∛]/,
		punctuation: /::?|[{}[\]();,.?]/,
		constant: /\b(?:(?:Inf|NaN)(?:16|32|64)?|im|pi)\b|[πℯ]/
	};
}
keepalived.displayName = "keepalived";
keepalived.aliases = [];
function keepalived(Prism$1) {
	Prism$1.languages.keepalived = {
		comment: {
			pattern: /[#!].*/,
			greedy: true
		},
		string: {
			pattern: /(^|[^\\])(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/,
			lookbehind: true,
			greedy: true
		},
		ip: {
			pattern: RegExp(/\b(?:(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){5}:(?:[\da-f]{1,4}:)?[\da-f]{1,4}|(?:[\da-f]{1,4}:){4}:(?:[\da-f]{1,4}:){0,2}[\da-f]{1,4}|(?:[\da-f]{1,4}:){3}:(?:[\da-f]{1,4}:){0,3}[\da-f]{1,4}|(?:[\da-f]{1,4}:){2}:(?:[\da-f]{1,4}:){0,4}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}<ipv4>|(?:[\da-f]{1,4}:){0,5}:<ipv4>|::(?:[\da-f]{1,4}:){0,5}<ipv4>|[\da-f]{1,4}::(?:[\da-f]{1,4}:){0,5}[\da-f]{1,4}|::(?:[\da-f]{1,4}:){0,6}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:)(?:\/\d{1,3})?|<ipv4>(?:\/\d{1,2})?)\b/.source.replace(/<ipv4>/g, function() {
				return /(?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d))/.source;
			}), "i"),
			alias: "number"
		},
		path: {
			pattern: /(\s)\/(?:[^\/\s]+\/)*[^\/\s]*|\b[a-zA-Z]:\\(?:[^\\\s]+\\)*[^\\\s]*/,
			lookbehind: true,
			alias: "string"
		},
		variable: /\$\{?\w+\}?/,
		email: {
			pattern: /[\w-]+@[\w-]+(?:\.[\w-]{2,3}){1,2}/,
			alias: "string"
		},
		"conditional-configuration": {
			pattern: /@\^?[\w-]+/,
			alias: "variable"
		},
		operator: /=/,
		property: /\b(?:BFD_CHECK|DNS_CHECK|FILE_CHECK|HTTP_GET|MISC_CHECK|NAME|PING_CHECK|SCRIPTS|SMTP_CHECK|SSL|SSL_GET|TCP_CHECK|UDP_CHECK|accept|advert_int|alpha|auth_pass|auth_type|authentication|bfd_cpu_affinity|bfd_instance|bfd_no_swap|bfd_priority|bfd_process_name|bfd_rlimit_rttime|bfd_rt_priority|bind_if|bind_port|bindto|ca|certificate|check_unicast_src|checker|checker_cpu_affinity|checker_log_all_failures|checker_no_swap|checker_priority|checker_rlimit_rttime|checker_rt_priority|child_wait_time|connect_ip|connect_port|connect_timeout|dbus_service_name|debug|default_interface|delay|delay_before_retry|delay_loop|digest|dont_track_primary|dynamic|dynamic_interfaces|enable_(?:dbus|script_security|sni|snmp_checker|snmp_rfc|snmp_rfcv2|snmp_rfcv3|snmp_vrrp|traps)|end|fall|fast_recovery|file|flag-[123]|fork_delay|full_command|fwmark|garp_group|garp_interval|garp_lower_prio_delay|garp_lower_prio_repeat|garp_master_delay|garp_master_refresh|garp_master_refresh_repeat|garp_master_repeat|global_defs|global_tracking|gna_interval|group|ha_suspend|hashed|helo_name|higher_prio_send_advert|hoplimit|http_protocol|hysteresis|idle_tx|include|inhibit_on_failure|init_fail|init_file|instance|interface|interfaces|interval|ip_family|ipvs_process_name|keepalived.conf|kernel_rx_buf_size|key|linkbeat_interfaces|linkbeat_use_polling|log_all_failures|log_unknown_vrids|lower_prio_no_advert|lthreshold|lvs_flush|lvs_flush_onstop|lvs_method|lvs_netlink_cmd_rcv_bufs|lvs_netlink_cmd_rcv_bufs_force|lvs_netlink_monitor_rcv_bufs|lvs_netlink_monitor_rcv_bufs_force|lvs_notify_fifo|lvs_notify_fifo_script|lvs_sched|lvs_sync_daemon|max_auto_priority|max_hops|mcast_src_ip|mh-fallback|mh-port|min_auto_priority_delay|min_rx|min_tx|misc_dynamic|misc_path|misc_timeout|multiplier|name|namespace_with_ipsets|native_ipv6|neighbor_ip|net_namespace|net_namespace_ipvs|nftables|nftables_counters|nftables_ifindex|nftables_priority|no_accept|no_checker_emails|no_email_faults|nopreempt|notification_email|notification_email_from|notify|notify_backup|notify_deleted|notify_down|notify_fault|notify_fifo|notify_fifo_script|notify_master|notify_master_rx_lower_pri|notify_priority_changes|notify_stop|notify_up|old_unicast_checksum|omega|ops|param_match|passive|password|path|persistence_engine|persistence_granularity|persistence_timeout|preempt|preempt_delay|priority|process|process_monitor_rcv_bufs|process_monitor_rcv_bufs_force|process_name|process_names|promote_secondaries|protocol|proxy_arp|proxy_arp_pvlan|quorum|quorum_down|quorum_max|quorum_up|random_seed|real_server|regex|regex_max_offset|regex_min_offset|regex_no_match|regex_options|regex_stack|reload_repeat|reload_time_file|require_reply|retry|rise|router_id|rs_init_notifies|script|script_user|sh-fallback|sh-port|shutdown_script|shutdown_script_timeout|skip_check_adv_addr|smtp_alert|smtp_alert_checker|smtp_alert_vrrp|smtp_connect_timeout|smtp_helo_name|smtp_server|snmp_socket|sorry_server|sorry_server_inhibit|sorry_server_lvs_method|source_ip|start|startup_script|startup_script_timeout|state|static_ipaddress|static_routes|static_rules|status_code|step|strict_mode|sync_group_tracking_weight|terminate_delay|timeout|track_bfd|track_file|track_group|track_interface|track_process|track_script|track_src_ip|ttl|type|umask|unicast_peer|unicast_src_ip|unicast_ttl|url|use_ipvlan|use_pid_dir|use_vmac|user|uthreshold|val[123]|version|virtual_ipaddress|virtual_ipaddress_excluded|virtual_router_id|virtual_routes|virtual_rules|virtual_server|virtual_server_group|virtualhost|vmac_xmit_base|vrrp|vrrp_(?:check_unicast_src|cpu_affinity|garp_interval|garp_lower_prio_delay|garp_lower_prio_repeat|garp_master_delay|garp_master_refresh|garp_master_refresh_repeat|garp_master_repeat|gna_interval|higher_prio_send_advert|instance|ipsets|iptables|lower_prio_no_advert|mcast_group4|mcast_group6|min_garp|netlink_cmd_rcv_bufs|netlink_cmd_rcv_bufs_force|netlink_monitor_rcv_bufs|netlink_monitor_rcv_bufs_force|no_swap|notify_fifo|notify_fifo_script|notify_priority_changes|priority|process_name|rlimit_rttime|rt_priority|rx_bufs_multiplier|rx_bufs_policy|script|skip_check_adv_addr|startup_delay|strict|sync_group|track_process|version)|warmup|weight)\b/,
		constant: /\b(?:A|AAAA|AH|BACKUP|CNAME|DR|MASTER|MX|NAT|NS|PASS|SCTP|SOA|TCP|TUN|TXT|UDP|dh|fo|lblc|lblcr|lc|mh|nq|ovf|rr|sed|sh|wlc|wrr)\b/,
		number: {
			pattern: /(^|[^\w.-])-?\d+(?:\.\d+)?/,
			lookbehind: true
		},
		boolean: /\b(?:false|no|off|on|true|yes)\b/,
		punctuation: /[\{\}]/
	};
}
keyman.displayName = "keyman";
keyman.aliases = [];
function keyman(Prism$1) {
	Prism$1.languages.keyman = {
		comment: {
			pattern: /\bc .*/i,
			greedy: true
		},
		string: {
			pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
			greedy: true
		},
		"virtual-key": {
			pattern: /\[\s*(?:(?:ALT|CAPS|CTRL|LALT|LCTRL|NCAPS|RALT|RCTRL|SHIFT)\s+)*(?:[TKU]_[\w?]+|[A-E]\d\d?|"[^"\r\n]*"|'[^'\r\n]*')\s*\]/i,
			greedy: true,
			alias: "function"
		},
		"header-keyword": {
			pattern: /&\w+/,
			alias: "bold"
		},
		"header-statement": {
			pattern: /\b(?:bitmap|bitmaps|caps always off|caps on only|copyright|hotkey|language|layout|message|name|shift frees caps|version)\b/i,
			alias: "bold"
		},
		"rule-keyword": {
			pattern: /\b(?:any|baselayout|beep|call|context|deadkey|dk|if|index|layer|notany|nul|outs|platform|reset|return|save|set|store|use)\b/i,
			alias: "keyword"
		},
		"structural-keyword": {
			pattern: /\b(?:ansi|begin|group|match|newcontext|nomatch|postkeystroke|readonly|unicode|using keys)\b/i,
			alias: "keyword"
		},
		"compile-target": {
			pattern: /\$(?:keyman|keymanonly|keymanweb|kmfl|weaver):/i,
			alias: "property"
		},
		number: /\b(?:U\+[\dA-F]+|d\d+|x[\da-f]+|\d+)\b/i,
		operator: /[+>\\$]|\.\./,
		punctuation: /[()=,]/
	};
}
kumir.displayName = "kumir";
kumir.aliases = ["kum"];
function kumir(Prism$1) {
	(function(Prism$2) {
		var nonId = /\s\x00-\x1f\x22-\x2f\x3a-\x3f\x5b-\x5e\x60\x7b-\x7e/.source;
		function wrapId(pattern, flags) {
			return RegExp(pattern.replace(/<nonId>/g, nonId), flags);
		}
		Prism$2.languages.kumir = {
			comment: { pattern: /\|.*/ },
			prolog: {
				pattern: /#.*/,
				greedy: true
			},
			string: {
				pattern: /"[^\n\r"]*"|'[^\n\r']*'/,
				greedy: true
			},
			boolean: {
				pattern: wrapId(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/.source),
				lookbehind: true
			},
			"operator-word": {
				pattern: wrapId(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/.source),
				lookbehind: true,
				alias: "keyword"
			},
			"system-variable": {
				pattern: wrapId(/(^|[<nonId>])знач(?=[<nonId>]|$)/.source),
				lookbehind: true,
				alias: "keyword"
			},
			type: [{
				pattern: wrapId(/(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\x20*таб)?(?=[<nonId>]|$)/.source),
				lookbehind: true,
				alias: "builtin"
			}, {
				pattern: wrapId(/(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/.source),
				lookbehind: true,
				alias: "important"
			}],
			keyword: {
				pattern: wrapId(/(^|[<nonId>])(?:алг|арг(?:\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\x20+|_)исп)?|кц(?:(?:\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/.source),
				lookbehind: true
			},
			name: {
				pattern: wrapId(/(^|[<nonId>])[^\d<nonId>][^<nonId>]*(?:\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source),
				lookbehind: true
			},
			number: {
				pattern: wrapId(/(^|[<nonId>])(?:\B\$[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?=[<nonId>]|$)/.source, "i"),
				lookbehind: true
			},
			punctuation: /:=|[(),:;\[\]]/,
			"operator-char": {
				pattern: /\*\*?|<[=>]?|>=?|[-+/=]/,
				alias: "operator"
			}
		};
		Prism$2.languages.kum = Prism$2.languages.kumir;
	})(Prism$1);
}
kusto.displayName = "kusto";
kusto.aliases = [];
function kusto(Prism$1) {
	Prism$1.languages.kusto = {
		comment: {
			pattern: /\/\/.*/,
			greedy: true
		},
		string: {
			pattern: /```[\s\S]*?```|[hH]?(?:"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\.)*'|@(?:"[^\r\n"]*"|'[^\r\n']*'))/,
			greedy: true
		},
		verb: {
			pattern: /(\|\s*)[a-z][\w-]*/i,
			lookbehind: true,
			alias: "keyword"
		},
		command: {
			pattern: /\.[a-z][a-z\d-]*\b/,
			alias: "keyword"
		},
		"class-name": /\b(?:bool|datetime|decimal|dynamic|guid|int|long|real|string|timespan)\b/,
		keyword: /\b(?:access|alias|and|anti|as|asc|auto|between|by|(?:contains|(?:ends|starts)with|has(?:perfix|suffix)?)(?:_cs)?|database|declare|desc|external|from|fullouter|has_all|in|ingestion|inline|inner|innerunique|into|(?:left|right)(?:anti(?:semi)?|inner|outer|semi)?|let|like|local|not|of|on|or|pattern|print|query_parameters|range|restrict|schema|set|step|table|tables|to|view|where|with|matches\s+regex|nulls\s+(?:first|last))(?![\w-])/,
		boolean: /\b(?:false|null|true)\b/,
		function: /\b[a-z_]\w*(?=\s*\()/,
		datetime: [{
			pattern: /\b(?:(?:Fri|Friday|Mon|Monday|Sat|Saturday|Sun|Sunday|Thu|Thursday|Tue|Tuesday|Wed|Wednesday)\s*,\s*)?\d{1,2}(?:\s+|-)(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)(?:\s+|-)\d{2}\s+\d{2}:\d{2}(?::\d{2})?(?:\s*(?:\b(?:[A-Z]|(?:[ECMT][DS]|GM|U)T)|[+-]\d{4}))?\b/,
			alias: "number"
		}, {
			pattern: /[+-]?\b(?:\d{4}-\d{2}-\d{2}(?:[ T]\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)?|\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)Z?/,
			alias: "number"
		}],
		number: /\b(?:0x[0-9A-Fa-f]+|\d+(?:\.\d+)?(?:[Ee][+-]?\d+)?)(?:(?:min|sec|[mnµ]s|[dhms]|microsecond|tick)\b)?|[+-]?\binf\b/,
		operator: /=>|[!=]~|[!=<>]=?|[-+*/%|]|\.\./,
		punctuation: /[()\[\]{},;.:]/
	};
}
latex.displayName = "latex";
latex.aliases = ["context", "tex"];
function latex(Prism$1) {
	(function(Prism$2) {
		var funcPattern = /\\(?:[^a-z()[\]]|[a-z*]+)/i;
		var insideEqu = { "equation-command": {
			pattern: funcPattern,
			alias: "regex"
		} };
		Prism$2.languages.latex = {
			comment: /%.*/,
			cdata: {
				pattern: /(\\begin\{((?:lstlisting|verbatim)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
				lookbehind: true
			},
			equation: [{
				pattern: /\$\$(?:\\[\s\S]|[^\\$])+\$\$|\$(?:\\[\s\S]|[^\\$])+\$|\\\([\s\S]*?\\\)|\\\[[\s\S]*?\\\]/,
				inside: insideEqu,
				alias: "string"
			}, {
				pattern: /(\\begin\{((?:align|eqnarray|equation|gather|math|multline)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
				lookbehind: true,
				inside: insideEqu,
				alias: "string"
			}],
			keyword: {
				pattern: /(\\(?:begin|cite|documentclass|end|label|ref|usepackage)(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
				lookbehind: true
			},
			url: {
				pattern: /(\\url\{)[^}]+(?=\})/,
				lookbehind: true
			},
			headline: {
				pattern: /(\\(?:chapter|frametitle|paragraph|part|section|subparagraph|subsection|subsubparagraph|subsubsection|subsubsubparagraph)\*?(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
				lookbehind: true,
				alias: "class-name"
			},
			function: {
				pattern: funcPattern,
				alias: "selector"
			},
			punctuation: /[[\]{}&]/
		};
		Prism$2.languages.tex = Prism$2.languages.latex;
		Prism$2.languages.context = Prism$2.languages.latex;
	})(Prism$1);
}
latte.displayName = "latte";
latte.aliases = [];
function latte(Prism$1) {
	Prism$1.register(clike);
	Prism$1.register(markupTemplating);
	Prism$1.register(php);
	(function(Prism$2) {
		Prism$2.languages.latte = {
			comment: /^\{\*[\s\S]*/,
			"latte-tag": {
				pattern: /(^\{(?:\/(?=[a-z]))?)(?:[=_]|[a-z]\w*\b(?!\())/i,
				lookbehind: true,
				alias: "important"
			},
			delimiter: {
				pattern: /^\{\/?|\}$/,
				alias: "punctuation"
			},
			php: {
				pattern: /\S(?:[\s\S]*\S)?/,
				alias: "language-php",
				inside: Prism$2.languages.php
			}
		};
		var markupLatte = Prism$2.languages.extend("markup", {});
		Prism$2.languages.insertBefore("inside", "attr-value", { "n-attr": {
			pattern: /n:[\w-]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+))?/,
			inside: {
				"attr-name": {
					pattern: /^[^\s=]+/,
					alias: "important"
				},
				"attr-value": {
					pattern: /=[\s\S]+/,
					inside: {
						punctuation: [/^=/, {
							pattern: /^(\s*)["']|["']$/,
							lookbehind: true
						}],
						php: {
							pattern: /\S(?:[\s\S]*\S)?/,
							inside: Prism$2.languages.php
						}
					}
				}
			}
		} }, markupLatte.tag);
		Prism$2.hooks.add("before-tokenize", function(env$1) {
			if (env$1.language !== "latte") return;
			var lattePattern = /\{\*[\s\S]*?\*\}|\{[^'"\s{}*](?:[^"'/{}]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|\/\*(?:[^*]|\*(?!\/))*\*\/)*\}/g;
			Prism$2.languages["markup-templating"].buildPlaceholders(env$1, "latte", lattePattern);
			env$1.grammar = markupLatte;
		});
		Prism$2.hooks.add("after-tokenize", function(env$1) {
			Prism$2.languages["markup-templating"].tokenizePlaceholders(env$1, "latte");
		});
	})(Prism$1);
}
scheme.displayName = "scheme";
scheme.aliases = [];
function scheme(Prism$1) {
	(function(Prism$2) {
		Prism$2.languages.scheme = {
			comment: /;.*|#;\s*(?:\((?:[^()]|\([^()]*\))*\)|\[(?:[^\[\]]|\[[^\[\]]*\])*\])|#\|(?:[^#|]|#(?!\|)|\|(?!#)|#\|(?:[^#|]|#(?!\|)|\|(?!#))*\|#)*\|#/,
			string: {
				pattern: /"(?:[^"\\]|\\.)*"/,
				greedy: true
			},
			symbol: {
				pattern: /'[^()\[\]#'\s]+/,
				greedy: true
			},
			char: {
				pattern: /#\\(?:[ux][a-fA-F\d]+\b|[-a-zA-Z]+\b|[\uD800-\uDBFF][\uDC00-\uDFFF]|\S)/,
				greedy: true
			},
			"lambda-parameter": [{
				pattern: /((?:^|[^'`#])[(\[]lambda\s+)(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)/,
				lookbehind: true
			}, {
				pattern: /((?:^|[^'`#])[(\[]lambda\s+[(\[])[^()\[\]']+/,
				lookbehind: true
			}],
			keyword: {
				pattern: /((?:^|[^'`#])[(\[])(?:begin|case(?:-lambda)?|cond(?:-expand)?|define(?:-library|-macro|-record-type|-syntax|-values)?|defmacro|delay(?:-force)?|do|else|except|export|guard|if|import|include(?:-ci|-library-declarations)?|lambda|let(?:rec)?(?:-syntax|-values|\*)?|let\*-values|only|parameterize|prefix|(?:quasi-?)?quote|rename|set!|syntax-(?:case|rules)|unless|unquote(?:-splicing)?|when)(?=[()\[\]\s]|$)/,
				lookbehind: true
			},
			builtin: {
				pattern: /((?:^|[^'`#])[(\[])(?:abs|and|append|apply|assoc|ass[qv]|binary-port\?|boolean=?\?|bytevector(?:-append|-copy|-copy!|-length|-u8-ref|-u8-set!|\?)?|caar|cadr|call-with-(?:current-continuation|port|values)|call\/cc|car|cdar|cddr|cdr|ceiling|char(?:->integer|-ready\?|\?|<\?|<=\?|=\?|>\?|>=\?)|close-(?:input-port|output-port|port)|complex\?|cons|current-(?:error|input|output)-port|denominator|dynamic-wind|eof-object\??|eq\?|equal\?|eqv\?|error|error-object(?:-irritants|-message|\?)|eval|even\?|exact(?:-integer-sqrt|-integer\?|\?)?|expt|features|file-error\?|floor(?:-quotient|-remainder|\/)?|flush-output-port|for-each|gcd|get-output-(?:bytevector|string)|inexact\??|input-port(?:-open\?|\?)|integer(?:->char|\?)|lcm|length|list(?:->string|->vector|-copy|-ref|-set!|-tail|\?)?|make-(?:bytevector|list|parameter|string|vector)|map|max|member|memq|memv|min|modulo|negative\?|newline|not|null\?|number(?:->string|\?)|numerator|odd\?|open-(?:input|output)-(?:bytevector|string)|or|output-port(?:-open\?|\?)|pair\?|peek-char|peek-u8|port\?|positive\?|procedure\?|quotient|raise|raise-continuable|rational\?|rationalize|read-(?:bytevector|bytevector!|char|error\?|line|string|u8)|real\?|remainder|reverse|round|set-c[ad]r!|square|string(?:->list|->number|->symbol|->utf8|->vector|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?|<\?|<=\?|=\?|>\?|>=\?)?|substring|symbol(?:->string|\?|=\?)|syntax-error|textual-port\?|truncate(?:-quotient|-remainder|\/)?|u8-ready\?|utf8->string|values|vector(?:->list|->string|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?)?|with-exception-handler|write-(?:bytevector|char|string|u8)|zero\?)(?=[()\[\]\s]|$)/,
				lookbehind: true
			},
			operator: {
				pattern: /((?:^|[^'`#])[(\[])(?:[-+*%/]|[<>]=?|=>?)(?=[()\[\]\s]|$)/,
				lookbehind: true
			},
			number: {
				pattern: RegExp(SortedBNF({
					"<ureal dec>": /\d+(?:\/\d+)|(?:\d+(?:\.\d*)?|\.\d+)(?:[esfdl][+-]?\d+)?/.source,
					"<real dec>": /[+-]?<ureal dec>|[+-](?:inf|nan)\.0/.source,
					"<imaginary dec>": /[+-](?:<ureal dec>|(?:inf|nan)\.0)?i/.source,
					"<complex dec>": /<real dec>(?:@<real dec>|<imaginary dec>)?|<imaginary dec>/.source,
					"<num dec>": /(?:#d(?:#[ei])?|#[ei](?:#d)?)?<complex dec>/.source,
					"<ureal box>": /[0-9a-f]+(?:\/[0-9a-f]+)?/.source,
					"<real box>": /[+-]?<ureal box>|[+-](?:inf|nan)\.0/.source,
					"<imaginary box>": /[+-](?:<ureal box>|(?:inf|nan)\.0)?i/.source,
					"<complex box>": /<real box>(?:@<real box>|<imaginary box>)?|<imaginary box>/.source,
					"<num box>": /#[box](?:#[ei])?|(?:#[ei])?#[box]<complex box>/.source,
					"<number>": /(^|[()\[\]\s])(?:<num dec>|<num box>)(?=[()\[\]\s]|$)/.source
				}), "i"),
				lookbehind: true
			},
			boolean: {
				pattern: /(^|[()\[\]\s])#(?:[ft]|false|true)(?=[()\[\]\s]|$)/,
				lookbehind: true
			},
			function: {
				pattern: /((?:^|[^'`#])[(\[])(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)(?=[()\[\]\s]|$)/,
				lookbehind: true
			},
			identifier: {
				pattern: /(^|[()\[\]\s])\|(?:[^\\|]|\\.)*\|(?=[()\[\]\s]|$)/,
				lookbehind: true,
				greedy: true
			},
			punctuation: /[()\[\]']/
		};
		function SortedBNF(grammar) {
			for (var key in grammar) grammar[key] = grammar[key].replace(/<[\w\s]+>/g, function(key$1) {
				return "(?:" + grammar[key$1].trim() + ")";
			});
			return grammar[key];
		}
	})(Prism$1);
}
lilypond.displayName = "lilypond";
lilypond.aliases = ["ly"];
function lilypond(Prism$1) {
	Prism$1.register(scheme);
	(function(Prism$2) {
		var schemeExpression = /\((?:[^();"#\\]|\\[\s\S]|;.*(?!.)|"(?:[^"\\]|\\.)*"|#(?:\{(?:(?!#\})[\s\S])*#\}|[^{])|<expr>)*\)/.source;
		var recursivenessLog2 = 5;
		for (var i = 0; i < recursivenessLog2; i++) schemeExpression = schemeExpression.replace(/<expr>/g, function() {
			return schemeExpression;
		});
		schemeExpression = schemeExpression.replace(/<expr>/g, /[^\s\S]/.source);
		var lilypond$1 = Prism$2.languages.lilypond = {
			comment: /%(?:(?!\{).*|\{[\s\S]*?%\})/,
			"embedded-scheme": {
				pattern: RegExp(/(^|[=\s])#(?:"(?:[^"\\]|\\.)*"|[^\s()"]*(?:[^\s()]|<expr>))/.source.replace(/<expr>/g, function() {
					return schemeExpression;
				}), "m"),
				lookbehind: true,
				greedy: true,
				inside: {
					scheme: {
						pattern: /^(#)[\s\S]+$/,
						lookbehind: true,
						alias: "language-scheme",
						inside: {
							"embedded-lilypond": {
								pattern: /#\{[\s\S]*?#\}/,
								greedy: true,
								inside: {
									punctuation: /^#\{|#\}$/,
									lilypond: {
										pattern: /[\s\S]+/,
										alias: "language-lilypond",
										inside: null
									}
								}
							},
							rest: Prism$2.languages.scheme
						}
					},
					punctuation: /#/
				}
			},
			string: {
				pattern: /"(?:[^"\\]|\\.)*"/,
				greedy: true
			},
			"class-name": {
				pattern: /(\\new\s+)[\w-]+/,
				lookbehind: true
			},
			keyword: {
				pattern: /\\[a-z][-\w]*/i,
				inside: { punctuation: /^\\/ }
			},
			operator: /[=|]|<<|>>/,
			punctuation: {
				pattern: /(^|[a-z\d])(?:'+|,+|[_^]?-[_^]?(?:[-+^!>._]|(?=\d))|[_^]\.?|[.!])|[{}()[\]<>^~]|\\[()[\]<>\\!]|--|__/,
				lookbehind: true
			},
			number: /\b\d+(?:\/\d+)?\b/
		};
		lilypond$1["embedded-scheme"].inside["scheme"].inside["embedded-lilypond"].inside["lilypond"].inside = lilypond$1;
		Prism$2.languages.ly = lilypond$1;
	})(Prism$1);
}
liquid.displayName = "liquid";
liquid.aliases = [];
function liquid(Prism$1) {
	Prism$1.register(markupTemplating);
	Prism$1.languages.liquid = {
		comment: {
			pattern: /(^\{%\s*comment\s*%\})[\s\S]+(?=\{%\s*endcomment\s*%\}$)/,
			lookbehind: true
		},
		delimiter: {
			pattern: /^\{(?:\{\{|[%\{])-?|-?(?:\}\}|[%\}])\}$/,
			alias: "punctuation"
		},
		string: {
			pattern: /"[^"]*"|'[^']*'/,
			greedy: true
		},
		keyword: /\b(?:as|assign|break|(?:end)?(?:capture|case|comment|for|form|if|paginate|raw|style|tablerow|unless)|continue|cycle|decrement|echo|else|elsif|in|include|increment|limit|liquid|offset|range|render|reversed|section|when|with)\b/,
		object: /\b(?:address|all_country_option_tags|article|block|blog|cart|checkout|collection|color|country|country_option_tags|currency|current_page|current_tags|customer|customer_address|date|discount_allocation|discount_application|external_video|filter|filter_value|font|forloop|fulfillment|generic_file|gift_card|group|handle|image|line_item|link|linklist|localization|location|measurement|media|metafield|model|model_source|order|page|page_description|page_image|page_title|part|policy|product|product_option|recommendations|request|robots|routes|rule|script|search|selling_plan|selling_plan_allocation|selling_plan_group|shipping_method|shop|shop_locale|sitemap|store_availability|tax_line|template|theme|transaction|unit_price_measurement|user_agent|variant|video|video_source)\b/,
		function: [{
			pattern: /(\|\s*)\w+/,
			lookbehind: true,
			alias: "filter"
		}, {
			pattern: /(\.\s*)(?:first|last|size)/,
			lookbehind: true
		}],
		boolean: /\b(?:false|nil|true)\b/,
		range: {
			pattern: /\.\./,
			alias: "operator"
		},
		number: /\b\d+(?:\.\d+)?\b/,
		operator: /[!=]=|<>|[<>]=?|[|?:=-]|\b(?:and|contains(?=\s)|or)\b/,
		punctuation: /[.,\[\]()]/,
		empty: {
			pattern: /\bempty\b/,
			alias: "keyword"
		}
	};
	Prism$1.hooks.add("before-tokenize", function(env$1) {
		var liquidPattern = /\{%\s*comment\s*%\}[\s\S]*?\{%\s*endcomment\s*%\}|\{(?:%[\s\S]*?%|\{\{[\s\S]*?\}\}|\{[\s\S]*?\})\}/g;
		var insideRaw = false;
		Prism$1.languages["markup-templating"].buildPlaceholders(env$1, "liquid", liquidPattern, function(match) {
			var tagMatch = /^\{%-?\s*(\w+)/.exec(match);
			if (tagMatch) {
				var tag = tagMatch[1];
				if (tag === "raw" && !insideRaw) {
					insideRaw = true;
					return true;
				} else if (tag === "endraw") {
					insideRaw = false;
					return true;
				}
			}
			return !insideRaw;
		});
	});
	Prism$1.hooks.add("after-tokenize", function(env$1) {
		Prism$1.languages["markup-templating"].tokenizePlaceholders(env$1, "liquid");
	});
}
lisp.displayName = "lisp";
lisp.aliases = [
	"elisp",
	"emacs",
	"emacs-lisp"
];
function lisp(Prism$1) {
	(function(Prism$2) {
		function simple_form(name$2) {
			return RegExp(/(\()/.source + "(?:" + name$2 + ")" + /(?=[\s\)])/.source);
		}
		function primitive(pattern) {
			return RegExp(/([\s([])/.source + "(?:" + pattern + ")" + /(?=[\s)])/.source);
		}
		var symbol = /(?!\d)[-+*/~!@$%^=<>{}\w]+/.source;
		var marker = "&" + symbol;
		var par = "(\\()";
		var endpar = "(?=\\))";
		var space$1 = "(?=\\s)";
		var nestedPar = /(?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\))*\))*/.source;
		var language = {
			heading: {
				pattern: /;;;.*/,
				alias: ["comment", "title"]
			},
			comment: /;.*/,
			string: {
				pattern: /"(?:[^"\\]|\\.)*"/,
				greedy: true,
				inside: {
					argument: /[-A-Z]+(?=[.,\s])/,
					symbol: RegExp("`" + symbol + "'")
				}
			},
			"quoted-symbol": {
				pattern: RegExp("#?'" + symbol),
				alias: ["variable", "symbol"]
			},
			"lisp-property": {
				pattern: RegExp(":" + symbol),
				alias: "property"
			},
			splice: {
				pattern: RegExp(",@?" + symbol),
				alias: ["symbol", "variable"]
			},
			keyword: [{
				pattern: RegExp(par + "(?:and|(?:cl-)?letf|cl-loop|cond|cons|error|if|(?:lexical-)?let\\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)" + space$1),
				lookbehind: true
			}, {
				pattern: RegExp(par + "(?:append|by|collect|concat|do|finally|for|in|return)" + space$1),
				lookbehind: true
			}],
			declare: {
				pattern: simple_form(/declare/.source),
				lookbehind: true,
				alias: "keyword"
			},
			interactive: {
				pattern: simple_form(/interactive/.source),
				lookbehind: true,
				alias: "keyword"
			},
			boolean: {
				pattern: primitive(/nil|t/.source),
				lookbehind: true
			},
			number: {
				pattern: primitive(/[-+]?\d+(?:\.\d*)?/.source),
				lookbehind: true
			},
			defvar: {
				pattern: RegExp(par + "def(?:const|custom|group|var)\\s+" + symbol),
				lookbehind: true,
				inside: {
					keyword: /^def[a-z]+/,
					variable: RegExp(symbol)
				}
			},
			defun: {
				pattern: RegExp(par + /(?:cl-)?(?:defmacro|defun\*?)\s+/.source + symbol + /\s+\(/.source + nestedPar + /\)/.source),
				lookbehind: true,
				greedy: true,
				inside: {
					keyword: /^(?:cl-)?def\S+/,
					arguments: null,
					function: {
						pattern: RegExp("(^\\s)" + symbol),
						lookbehind: true
					},
					punctuation: /[()]/
				}
			},
			lambda: {
				pattern: RegExp(par + "lambda\\s+\\(\\s*(?:&?" + symbol + "(?:\\s+&?" + symbol + ")*\\s*)?\\)"),
				lookbehind: true,
				greedy: true,
				inside: {
					keyword: /^lambda/,
					arguments: null,
					punctuation: /[()]/
				}
			},
			car: {
				pattern: RegExp(par + symbol),
				lookbehind: true
			},
			punctuation: [/(?:['`,]?\(|[)\[\]])/, {
				pattern: /(\s)\.(?=\s)/,
				lookbehind: true
			}]
		};
		var arg = {
			"lisp-marker": RegExp(marker),
			varform: {
				pattern: RegExp(/\(/.source + symbol + /\s+(?=\S)/.source + nestedPar + /\)/.source),
				inside: language
			},
			argument: {
				pattern: RegExp(/(^|[\s(])/.source + symbol),
				lookbehind: true,
				alias: "variable"
			},
			rest: language
		};
		var forms = "\\S+(?:\\s+\\S+)*";
		var arglist = {
			pattern: RegExp(par + nestedPar + endpar),
			lookbehind: true,
			inside: {
				"rest-vars": {
					pattern: RegExp("&(?:body|rest)\\s+" + forms),
					inside: arg
				},
				"other-marker-vars": {
					pattern: RegExp("&(?:aux|optional)\\s+" + forms),
					inside: arg
				},
				keys: {
					pattern: RegExp("&key\\s+" + forms + "(?:\\s+&allow-other-keys)?"),
					inside: arg
				},
				argument: {
					pattern: RegExp(symbol),
					alias: "variable"
				},
				punctuation: /[()]/
			}
		};
		language["lambda"].inside.arguments = arglist;
		language["defun"].inside.arguments = Prism$2.util.clone(arglist);
		language["defun"].inside.arguments.inside.sublist = arglist;
		Prism$2.languages.lisp = language;
		Prism$2.languages.elisp = language;
		Prism$2.languages.emacs = language;
		Prism$2.languages["emacs-lisp"] = language;
	})(Prism$1);
}
livescript.displayName = "livescript";
livescript.aliases = [];
function livescript(Prism$1) {
	Prism$1.languages.livescript = {
		comment: [{
			pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
			lookbehind: true
		}, {
			pattern: /(^|[^\\])#.*/,
			lookbehind: true
		}],
		"interpolated-string": {
			pattern: /(^|[^"])("""|")(?:\\[\s\S]|(?!\2)[^\\])*\2(?!")/,
			lookbehind: true,
			greedy: true,
			inside: {
				variable: {
					pattern: /(^|[^\\])#[a-z_](?:-?[a-z]|[\d_])*/m,
					lookbehind: true
				},
				interpolation: {
					pattern: /(^|[^\\])#\{[^}]+\}/m,
					lookbehind: true,
					inside: { "interpolation-punctuation": {
						pattern: /^#\{|\}$/,
						alias: "variable"
					} }
				},
				string: /[\s\S]+/
			}
		},
		string: [
			{
				pattern: /('''|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,
				greedy: true
			},
			{
				pattern: /<\[[\s\S]*?\]>/,
				greedy: true
			},
			/\\[^\s,;\])}]+/
		],
		regex: [{
			pattern: /\/\/(?:\[[^\r\n\]]*\]|\\.|(?!\/\/)[^\\\[])+\/\/[gimyu]{0,5}/,
			greedy: true,
			inside: { comment: {
				pattern: /(^|[^\\])#.*/,
				lookbehind: true
			} }
		}, {
			pattern: /\/(?:\[[^\r\n\]]*\]|\\.|[^/\\\r\n\[])+\/[gimyu]{0,5}/,
			greedy: true
		}],
		keyword: {
			pattern: /(^|(?!-).)\b(?:break|case|catch|class|const|continue|default|do|else|extends|fallthrough|finally|for(?: ever)?|function|if|implements|it|let|loop|new|null|otherwise|own|return|super|switch|that|then|this|throw|try|unless|until|var|void|when|while|yield)(?!-)\b/m,
			lookbehind: true
		},
		"keyword-operator": {
			pattern: /(^|[^-])\b(?:(?:delete|require|typeof)!|(?:and|by|delete|export|from|import(?: all)?|in|instanceof|is(?: not|nt)?|not|of|or|til|to|typeof|with|xor)(?!-)\b)/m,
			lookbehind: true,
			alias: "operator"
		},
		boolean: {
			pattern: /(^|[^-])\b(?:false|no|off|on|true|yes)(?!-)\b/m,
			lookbehind: true
		},
		argument: {
			pattern: /(^|(?!\.&\.)[^&])&(?!&)\d*/m,
			lookbehind: true,
			alias: "variable"
		},
		number: /\b(?:\d+~[\da-z]+|\d[\d_]*(?:\.\d[\d_]*)?(?:[a-z]\w*)?)/i,
		identifier: /[a-z_](?:-?[a-z]|[\d_])*/i,
		operator: [{
			pattern: /( )\.(?= )/,
			lookbehind: true
		}, /\.(?:[=~]|\.\.?)|\.(?:[&|^]|<<|>>>?)\.|:(?:=|:=?)|&&|\|[|>]|<(?:<<?<?|--?!?|~~?!?|[|=?])?|>[>=?]?|-(?:->?|>)?|\+\+?|@@?|%%?|\*\*?|!(?:~?=|--?>|~?~>)?|~(?:~?>|=)?|==?|\^\^?|[\/?]/],
		punctuation: /[(){}\[\]|.,:;`]/
	};
	Prism$1.languages.livescript["interpolated-string"].inside["interpolation"].inside.rest = Prism$1.languages.livescript;
}
llvm.displayName = "llvm";
llvm.aliases = [];
function llvm(Prism$1) {
	(function(Prism$2) {
		Prism$2.languages.llvm = {
			comment: /;.*/,
			string: {
				pattern: /"[^"]*"/,
				greedy: true
			},
			boolean: /\b(?:false|true)\b/,
			variable: /[%@!#](?:(?!\d)(?:[-$.\w]|\\[a-f\d]{2})+|\d+)/i,
			label: /(?!\d)(?:[-$.\w]|\\[a-f\d]{2})+:/i,
			type: {
				pattern: /\b(?:double|float|fp128|half|i[1-9]\d*|label|metadata|ppc_fp128|token|void|x86_fp80|x86_mmx)\b/,
				alias: "class-name"
			},
			keyword: /\b[a-z_][a-z_0-9]*\b/,
			number: /[+-]?\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b0x[\dA-Fa-f]+\b|\b0xK[\dA-Fa-f]{20}\b|\b0x[ML][\dA-Fa-f]{32}\b|\b0xH[\dA-Fa-f]{4}\b/,
			punctuation: /[{}[\];(),.!*=<>]/
		};
	})(Prism$1);
}
log.displayName = "log";
log.aliases = [];
function log(Prism$1) {
	Prism$1.languages.log = {
		string: {
			pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?![st] | \w)(?:[^'\\\r\n]|\\.)*'/,
			greedy: true
		},
		exception: {
			pattern: /(^|[^\w.])[a-z][\w.]*(?:Error|Exception):.*(?:(?:\r\n?|\n)[ \t]*(?:at[ \t].+|\.{3}.*|Caused by:.*))+(?:(?:\r\n?|\n)[ \t]*\.\.\. .*)?/,
			lookbehind: true,
			greedy: true,
			alias: ["javastacktrace", "language-javastacktrace"],
			inside: Prism$1.languages["javastacktrace"] || {
				keyword: /\bat\b/,
				function: /[a-z_][\w$]*(?=\()/,
				punctuation: /[.:()]/
			}
		},
		level: [
			{
				pattern: /\b(?:ALERT|CRIT|CRITICAL|EMERG|EMERGENCY|ERR|ERROR|FAILURE|FATAL|SEVERE)\b/,
				alias: ["error", "important"]
			},
			{
				pattern: /\b(?:WARN|WARNING|WRN)\b/,
				alias: ["warning", "important"]
			},
			{
				pattern: /\b(?:DISPLAY|INF|INFO|NOTICE|STATUS)\b/,
				alias: ["info", "keyword"]
			},
			{
				pattern: /\b(?:DBG|DEBUG|FINE)\b/,
				alias: ["debug", "keyword"]
			},
			{
				pattern: /\b(?:FINER|FINEST|TRACE|TRC|VERBOSE|VRB)\b/,
				alias: ["trace", "comment"]
			}
		],
		property: {
			pattern: /((?:^|[\]|])[ \t]*)[a-z_](?:[\w-]|\b\/\b)*(?:[. ]\(?\w(?:[\w-]|\b\/\b)*\)?)*:(?=\s)/im,
			lookbehind: true
		},
		separator: {
			pattern: /(^|[^-+])-{3,}|={3,}|\*{3,}|- - /m,
			lookbehind: true,
			alias: "comment"
		},
		url: /\b(?:file|ftp|https?):\/\/[^\s|,;'"]*[^\s|,;'">.]/,
		email: {
			pattern: /(^|\s)[-\w+.]+@[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)+(?=\s)/,
			lookbehind: true,
			alias: "url"
		},
		"ip-address": {
			pattern: /\b(?:\d{1,3}(?:\.\d{1,3}){3})\b/,
			alias: "constant"
		},
		"mac-address": {
			pattern: /\b[a-f0-9]{2}(?::[a-f0-9]{2}){5}\b/i,
			alias: "constant"
		},
		domain: {
			pattern: /(^|\s)[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)*\.[a-z][a-z0-9-]+(?=\s)/,
			lookbehind: true,
			alias: "constant"
		},
		uuid: {
			pattern: /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/i,
			alias: "constant"
		},
		hash: {
			pattern: /\b(?:[a-f0-9]{32}){1,2}\b/i,
			alias: "constant"
		},
		"file-path": {
			pattern: /\b[a-z]:[\\/][^\s|,;:(){}\[\]"']+|(^|[\s:\[\](>|])\.{0,2}\/\w[^\s|,;:(){}\[\]"']*/i,
			lookbehind: true,
			greedy: true,
			alias: "string"
		},
		date: {
			pattern: RegExp(/\b\d{4}[-/]\d{2}[-/]\d{2}(?:T(?=\d{1,2}:)|(?=\s\d{1,2}:))/.source + "|" + /\b\d{1,4}[-/ ](?:\d{1,2}|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)[-/ ]\d{2,4}T?\b/.source + "|" + /\b(?:(?:Fri|Mon|Sat|Sun|Thu|Tue|Wed)(?:\s{1,2}(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep))?|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)\s{1,2}\d{1,2}\b/.source, "i"),
			alias: "number"
		},
		time: {
			pattern: /\b\d{1,2}:\d{1,2}:\d{1,2}(?:[.,:]\d+)?(?:\s?[+-]\d{2}:?\d{2}|Z)?\b/,
			alias: "number"
		},
		boolean: /\b(?:false|null|true)\b/i,
		number: {
			pattern: /(^|[^.\w])(?:0x[a-f0-9]+|0o[0-7]+|0b[01]+|v?\d[\da-f]*(?:\.\d+)*(?:e[+-]?\d+)?[a-z]{0,3}\b)\b(?!\.\w)/i,
			lookbehind: true
		},
		operator: /[;:?<=>~/@!$%&+\-|^(){}*#]/,
		punctuation: /[\[\].,]/
	};
}
lolcode.displayName = "lolcode";
lolcode.aliases = [];
function lolcode(Prism$1) {
	Prism$1.languages.lolcode = {
		comment: [/\bOBTW\s[\s\S]*?\sTLDR\b/, /\bBTW.+/],
		string: {
			pattern: /"(?::.|[^":])*"/,
			inside: {
				variable: /:\{[^}]+\}/,
				symbol: [
					/:\([a-f\d]+\)/i,
					/:\[[^\]]+\]/,
					/:[)>o":]/
				]
			},
			greedy: true
		},
		number: /(?:\B-)?(?:\b\d+(?:\.\d*)?|\B\.\d+)/,
		symbol: {
			pattern: /(^|\s)(?:A )?(?:BUKKIT|NOOB|NUMBAR|NUMBR|TROOF|YARN)(?=\s|,|$)/,
			lookbehind: true,
			inside: { keyword: /A(?=\s)/ }
		},
		label: {
			pattern: /((?:^|\s)(?:IM IN YR|IM OUTTA YR) )[a-zA-Z]\w*/,
			lookbehind: true,
			alias: "string"
		},
		function: {
			pattern: /((?:^|\s)(?:HOW IZ I|I IZ|IZ) )[a-zA-Z]\w*/,
			lookbehind: true
		},
		keyword: [{
			pattern: /(^|\s)(?:AN|FOUND YR|GIMMEH|GTFO|HAI|HAS A|HOW IZ I|I HAS A|I IZ|IF U SAY SO|IM IN YR|IM OUTTA YR|IS NOW(?: A)?|ITZ(?: A)?|IZ|KTHX|KTHXBYE|LIEK(?: A)?|MAEK|MEBBE|MKAY|NERFIN|NO WAI|O HAI IM|O RLY\?|OIC|OMG|OMGWTF|R|SMOOSH|SRS|TIL|UPPIN|VISIBLE|WILE|WTF\?|YA RLY|YR)(?=\s|,|$)/,
			lookbehind: true
		}, /'Z(?=\s|,|$)/],
		boolean: {
			pattern: /(^|\s)(?:FAIL|WIN)(?=\s|,|$)/,
			lookbehind: true
		},
		variable: {
			pattern: /(^|\s)IT(?=\s|,|$)/,
			lookbehind: true
		},
		operator: {
			pattern: /(^|\s)(?:NOT|BOTH SAEM|DIFFRINT|(?:ALL|ANY|BIGGR|BOTH|DIFF|EITHER|MOD|PRODUKT|QUOSHUNT|SMALLR|SUM|WON) OF)(?=\s|,|$)/,
			lookbehind: true
		},
		punctuation: /\.{3}|…|,|!/
	};
}
magma.displayName = "magma";
magma.aliases = [];
function magma(Prism$1) {
	Prism$1.languages.magma = {
		output: {
			pattern: /^(>.*(?:\r(?:\n|(?!\n))|\n))(?!>)(?:.+|(?:\r(?:\n|(?!\n))|\n)(?!>).*)(?:(?:\r(?:\n|(?!\n))|\n)(?!>).*)*/m,
			lookbehind: true,
			greedy: true
		},
		comment: {
			pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
			greedy: true
		},
		string: {
			pattern: /(^|[^\\"])"(?:[^\r\n\\"]|\\.)*"/,
			lookbehind: true,
			greedy: true
		},
		keyword: /\b(?:_|adj|and|assert|assert2|assert3|assigned|break|by|case|cat|catch|clear|cmpeq|cmpne|continue|declare|default|delete|diff|div|do|elif|else|end|eq|error|eval|exists|exit|for|forall|forward|fprintf|freeze|function|ge|gt|if|iload|import|in|intrinsic|is|join|le|load|local|lt|meet|mod|ne|not|notadj|notin|notsubset|or|print|printf|procedure|quit|random|read|readi|repeat|require|requirege|requirerange|restore|return|save|sdiff|select|subset|then|time|to|try|until|vprint|vprintf|vtime|when|where|while|xor)\b/,
		boolean: /\b(?:false|true)\b/,
		generator: {
			pattern: /\b[a-z_]\w*(?=\s*<)/i,
			alias: "class-name"
		},
		function: /\b[a-z_]\w*(?=\s*\()/i,
		number: {
			pattern: /(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
			lookbehind: true
		},
		operator: /->|[-+*/^~!|#=]|:=|\.\./,
		punctuation: /[()[\]{}<>,;.:]/
	};
}
mata.displayName = "mata";
mata.aliases = [];
function mata(Prism$1) {
	(function(Prism$2) {
		var orgType = /\b(?:(?:col|row)?vector|matrix|scalar)\b/.source;
		var type = /\bvoid\b|<org>|\b(?:complex|numeric|pointer(?:\s*\([^()]*\))?|real|string|(?:class|struct)\s+\w+|transmorphic)(?:\s*<org>)?/.source.replace(/<org>/g, orgType);
		Prism$2.languages.mata = {
			comment: {
				pattern: /\/\/.*|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\//,
				greedy: true
			},
			string: {
				pattern: /"[^"\r\n]*"|[‘`']".*?"[’`']/,
				greedy: true
			},
			"class-name": {
				pattern: /(\b(?:class|extends|struct)\s+)\w+(?=\s*(?:\{|\bextends\b))/,
				lookbehind: true
			},
			type: {
				pattern: RegExp(type),
				alias: "class-name",
				inside: {
					punctuation: /[()]/,
					keyword: /\b(?:class|function|struct|void)\b/
				}
			},
			keyword: /\b(?:break|class|continue|do|else|end|extends|external|final|for|function|goto|if|pragma|private|protected|public|return|static|struct|unset|unused|version|virtual|while)\b/,
			constant: /\bNULL\b/,
			number: {
				pattern: /(^|[^\w.])(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|\d[a-f0-9]*(?:\.[a-f0-9]+)?x[+-]?\d+)i?(?![\w.])/i,
				lookbehind: true
			},
			missing: {
				pattern: /(^|[^\w.])(?:\.[a-z]?)(?![\w.])/,
				lookbehind: true,
				alias: "symbol"
			},
			function: /\b[a-z_]\w*(?=\s*\()/i,
			operator: /\.\.|\+\+|--|&&|\|\||:?(?:[!=<>]=|[+\-*/^<>&|:])|[!?=\\#’`']/,
			punctuation: /[()[\]{},;.]/
		};
	})(Prism$1);
}
matlab.displayName = "matlab";
matlab.aliases = [];
function matlab(Prism$1) {
	Prism$1.languages.matlab = {
		comment: [/%\{[\s\S]*?\}%/, /%.+/],
		string: {
			pattern: /\B'(?:''|[^'\r\n])*'/,
			greedy: true
		},
		number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?(?:[ij])?|\b[ij]\b/,
		keyword: /\b(?:NaN|break|case|catch|continue|else|elseif|end|for|function|if|inf|otherwise|parfor|pause|pi|return|switch|try|while)\b/,
		function: /\b(?!\d)\w+(?=\s*\()/,
		operator: /\.?[*^\/\\']|[+\-:@]|[<>=~]=?|&&?|\|\|?/,
		punctuation: /\.{3}|[.,;\[\](){}!]/
	};
}
maxscript.displayName = "maxscript";
maxscript.aliases = [];
function maxscript(Prism$1) {
	(function(Prism$2) {
		var keywords = /\b(?:about|and|animate|as|at|attributes|by|case|catch|collect|continue|coordsys|do|else|exit|fn|for|from|function|global|if|in|local|macroscript|mapped|max|not|of|off|on|or|parameters|persistent|plugin|rcmenu|return|rollout|set|struct|then|throw|to|tool|try|undo|utility|when|where|while|with)\b/i;
		Prism$2.languages.maxscript = {
			comment: {
				pattern: /\/\*[\s\S]*?(?:\*\/|$)|--.*/,
				greedy: true
			},
			string: {
				pattern: /(^|[^"\\@])(?:"(?:[^"\\]|\\[\s\S])*"|@"[^"]*")/,
				lookbehind: true,
				greedy: true
			},
			path: {
				pattern: /\$(?:[\w/\\.*?]|'[^']*')*/,
				greedy: true,
				alias: "string"
			},
			"function-call": {
				pattern: RegExp("((?:" + (/^/.source + "|" + /[;=<>+\-*/^({\[]/.source + "|" + /\b(?:and|by|case|catch|collect|do|else|if|in|not|or|return|then|to|try|where|while|with)\b/.source) + ")[ 	]*)(?!" + keywords.source + ")" + /[a-z_]\w*\b/.source + "(?=[ 	]*(?:" + ("(?!" + keywords.source + ")" + /[a-z_]/.source + "|" + /\d|-\.?\d/.source + "|" + /[({'"$@#?]/.source) + "))", "im"),
				lookbehind: true,
				greedy: true,
				alias: "function"
			},
			"function-definition": {
				pattern: /(\b(?:fn|function)\s+)\w+\b/i,
				lookbehind: true,
				alias: "function"
			},
			argument: {
				pattern: /\b[a-z_]\w*(?=:)/i,
				alias: "attr-name"
			},
			keyword: keywords,
			boolean: /\b(?:false|true)\b/,
			time: {
				pattern: /(^|[^\w.])(?:(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?[msft])+|\d+:\d+(?:\.\d*)?)(?![\w.:])/,
				lookbehind: true,
				alias: "number"
			},
			number: [{
				pattern: /(^|[^\w.])(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?|0x[a-fA-F0-9]+)(?![\w.:])/,
				lookbehind: true
			}, /\b(?:e|pi)\b/],
			constant: /\b(?:dontcollect|ok|silentValue|undefined|unsupplied)\b/,
			color: {
				pattern: /\b(?:black|blue|brown|gray|green|orange|red|white|yellow)\b/i,
				alias: "constant"
			},
			operator: /[-+*/<>=!]=?|[&^?]|#(?!\()/,
			punctuation: /[()\[\]{}.:,;]|#(?=\()|\\$/m
		};
	})(Prism$1);
}
mel.displayName = "mel";
mel.aliases = [];
function mel(Prism$1) {
	Prism$1.languages.mel = {
		comment: {
			pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
			greedy: true
		},
		code: {
			pattern: /`(?:\\.|[^\\`])*`/,
			greedy: true,
			alias: "italic",
			inside: {
				delimiter: {
					pattern: /^`|`$/,
					alias: "punctuation"
				},
				statement: {
					pattern: /[\s\S]+/,
					inside: null
				}
			}
		},
		string: {
			pattern: /"(?:\\.|[^\\"\r\n])*"/,
			greedy: true
		},
		variable: /\$\w+/,
		number: /\b0x[\da-fA-F]+\b|\b\d+(?:\.\d*)?|\B\.\d+/,
		flag: {
			pattern: /-[^\d\W]\w*/,
			alias: "operator"
		},
		keyword: /\b(?:break|case|continue|default|do|else|float|for|global|if|in|int|matrix|proc|return|string|switch|vector|while)\b/,
		function: {
			pattern: /((?:^|[{;])[ \t]*)[a-z_]\w*\b(?!\s*(?:\.(?!\.)|[[{=]))|\b[a-z_]\w*(?=[ \t]*\()/im,
			lookbehind: true,
			greedy: true
		},
		"tensor-punctuation": {
			pattern: /<<|>>/,
			alias: "punctuation"
		},
		operator: /\+[+=]?|-[-=]?|&&|\|\||[<>]=?|[*\/!=]=?|[%^]/,
		punctuation: /[.,:;?\[\](){}]/
	};
	Prism$1.languages.mel["code"].inside["statement"].inside = Prism$1.languages.mel;
}
mermaid.displayName = "mermaid";
mermaid.aliases = [];
function mermaid(Prism$1) {
	Prism$1.languages.mermaid = {
		comment: {
			pattern: /%%.*/,
			greedy: true
		},
		style: {
			pattern: /^([ \t]*(?:classDef|linkStyle|style)[ \t]+[\w$-]+[ \t]+)\w.*[^\s;]/m,
			lookbehind: true,
			inside: {
				property: /\b\w[\w-]*(?=[ \t]*:)/,
				operator: /:/,
				punctuation: /,/
			}
		},
		"inter-arrow-label": {
			pattern: /([^<>ox.=-])(?:-[-.]|==)(?![<>ox.=-])[ \t]*(?:"[^"\r\n]*"|[^\s".=-](?:[^\r\n.=-]*[^\s.=-])?)[ \t]*(?:\.+->?|--+[->]|==+[=>])(?![<>ox.=-])/,
			lookbehind: true,
			greedy: true,
			inside: {
				arrow: {
					pattern: /(?:\.+->?|--+[->]|==+[=>])$/,
					alias: "operator"
				},
				label: {
					pattern: /^([\s\S]{2}[ \t]*)\S(?:[\s\S]*\S)?/,
					lookbehind: true,
					alias: "property"
				},
				"arrow-head": {
					pattern: /^\S+/,
					alias: ["arrow", "operator"]
				}
			}
		},
		arrow: [
			{
				pattern: /(^|[^{}|o.-])[|}][|o](?:--|\.\.)[|o][|{](?![{}|o.-])/,
				lookbehind: true,
				alias: "operator"
			},
			{
				pattern: /(^|[^<>ox.=-])(?:[<ox](?:==+|--+|-\.*-)[>ox]?|(?:==+|--+|-\.*-)[>ox]|===+|---+|-\.+-)(?![<>ox.=-])/,
				lookbehind: true,
				alias: "operator"
			},
			{
				pattern: /(^|[^<>()x-])(?:--?(?:>>|[x>)])(?![<>()x])|(?:<<|[x<(])--?(?!-))/,
				lookbehind: true,
				alias: "operator"
			},
			{
				pattern: /(^|[^<>|*o.-])(?:[*o]--|--[*o]|<\|?(?:--|\.\.)|(?:--|\.\.)\|?>|--|\.\.)(?![<>|*o.-])/,
				lookbehind: true,
				alias: "operator"
			}
		],
		label: {
			pattern: /(^|[^|<])\|(?:[^\r\n"|]|"[^"\r\n]*")+\|/,
			lookbehind: true,
			greedy: true,
			alias: "property"
		},
		text: {
			pattern: /(?:[(\[{]+|\b>)(?:[^\r\n"()\[\]{}]|"[^"\r\n]*")+(?:[)\]}]+|>)/,
			alias: "string"
		},
		string: {
			pattern: /"[^"\r\n]*"/,
			greedy: true
		},
		annotation: {
			pattern: /<<(?:abstract|choice|enumeration|fork|interface|join|service)>>|\[\[(?:choice|fork|join)\]\]/i,
			alias: "important"
		},
		keyword: [{
			pattern: /(^[ \t]*)(?:action|callback|class|classDef|classDiagram|click|direction|erDiagram|flowchart|gantt|gitGraph|graph|journey|link|linkStyle|pie|requirementDiagram|sequenceDiagram|stateDiagram|stateDiagram-v2|style|subgraph)(?![\w$-])/m,
			lookbehind: true,
			greedy: true
		}, {
			pattern: /(^[ \t]*)(?:activate|alt|and|as|autonumber|deactivate|else|end(?:[ \t]+note)?|loop|opt|par|participant|rect|state|note[ \t]+(?:over|(?:left|right)[ \t]+of))(?![\w$-])/im,
			lookbehind: true,
			greedy: true
		}],
		entity: /#[a-z0-9]+;/,
		operator: {
			pattern: /(\w[ \t]*)&(?=[ \t]*\w)|:::|:/,
			lookbehind: true
		},
		punctuation: /[(){};]/
	};
}
metafont.displayName = "metafont";
metafont.aliases = [];
function metafont(Prism$1) {
	Prism$1.languages.metafont = {
		comment: {
			pattern: /%.*/,
			greedy: true
		},
		string: {
			pattern: /"[^\r\n"]*"/,
			greedy: true
		},
		number: /\d*\.?\d+/,
		boolean: /\b(?:false|true)\b/,
		punctuation: [
			/[,;()]/,
			{
				pattern: /(^|[^{}])(?:\{|\})(?![{}])/,
				lookbehind: true
			},
			{
				pattern: /(^|[^[])\[(?!\[)/,
				lookbehind: true
			},
			{
				pattern: /(^|[^\]])\](?!\])/,
				lookbehind: true
			}
		],
		constant: [
			{
				pattern: /(^|[^!?])\?\?\?(?![!?])/,
				lookbehind: true
			},
			{
				pattern: /(^|[^/*\\])(?:\\|\\\\)(?![/*\\])/,
				lookbehind: true
			},
			/\b(?:_|blankpicture|bp|cc|cm|dd|ditto|down|eps|epsilon|fullcircle|halfcircle|identity|in|infinity|left|mm|nullpen|nullpicture|origin|pc|penrazor|penspeck|pensquare|penstroke|proof|pt|quartercircle|relax|right|smoke|unitpixel|unitsquare|up)\b/
		],
		quantity: {
			pattern: /\b(?:autorounding|blacker|boundarychar|charcode|chardp|chardx|chardy|charext|charht|charic|charwd|currentwindow|day|designsize|displaying|fillin|fontmaking|granularity|hppp|join_radius|month|o_correction|pausing|pen_(?:bot|lft|rt|top)|pixels_per_inch|proofing|showstopping|smoothing|time|tolerance|tracingcapsules|tracingchoices|tracingcommands|tracingedges|tracingequations|tracingmacros|tracingonline|tracingoutput|tracingpens|tracingrestores|tracingspecs|tracingstats|tracingtitles|turningcheck|vppp|warningcheck|xoffset|year|yoffset)\b/,
			alias: "keyword"
		},
		command: {
			pattern: /\b(?:addto|batchmode|charlist|cull|display|errhelp|errmessage|errorstopmode|everyjob|extensible|fontdimen|headerbyte|inner|interim|let|ligtable|message|newinternal|nonstopmode|numspecial|openwindow|outer|randomseed|save|scrollmode|shipout|show|showdependencies|showstats|showtoken|showvariable|special)\b/,
			alias: "builtin"
		},
		operator: [
			{
				pattern: /(^|[^>=<:|])(?:<|<=|=|=:|\|=:|\|=:>|=:\|>|=:\||\|=:\||\|=:\|>|\|=:\|>>|>|>=|:|:=|<>|::|\|\|:)(?![>=<:|])/,
				lookbehind: true
			},
			{
				pattern: /(^|[^+-])(?:\+|\+\+|-{1,3}|\+-\+)(?![+-])/,
				lookbehind: true
			},
			{
				pattern: /(^|[^/*\\])(?:\*|\*\*|\/)(?![/*\\])/,
				lookbehind: true
			},
			{
				pattern: /(^|[^.])(?:\.{2,3})(?!\.)/,
				lookbehind: true
			},
			{
				pattern: /(^|[^@#&$])&(?![@#&$])/,
				lookbehind: true
			},
			/\b(?:and|not|or)\b/
		],
		macro: {
			pattern: /\b(?:abs|beginchar|bot|byte|capsule_def|ceiling|change_width|clear_pen_memory|clearit|clearpen|clearxy|counterclockwise|cullit|cutdraw|cutoff|decr|define_blacker_pixels|define_corrected_pixels|define_good_x_pixels|define_good_y_pixels|define_horizontal_corrected_pixels|define_pixels|define_whole_blacker_pixels|define_whole_pixels|define_whole_vertical_blacker_pixels|define_whole_vertical_pixels|dir|direction|directionpoint|div|dotprod|downto|draw|drawdot|endchar|erase|fill|filldraw|fix_units|flex|font_coding_scheme|font_extra_space|font_identifier|font_normal_shrink|font_normal_space|font_normal_stretch|font_quad|font_size|font_slant|font_x_height|gfcorners|gobble|gobbled|good\.(?:bot|lft|rt|top|x|y)|grayfont|hide|hround|imagerules|incr|interact|interpath|intersectionpoint|inverse|italcorr|killtext|labelfont|labels|lft|loggingall|lowres_fix|makegrid|makelabel(?:\.(?:bot|lft|rt|top)(?:\.nodot)?)?|max|min|mod|mode_def|mode_setup|nodisplays|notransforms|numtok|openit|penlabels|penpos|pickup|proofoffset|proofrule|proofrulethickness|range|reflectedabout|rotatedabout|rotatedaround|round|rt|savepen|screenchars|screenrule|screenstrokes|shipit|showit|slantfont|softjoin|solve|stop|superellipse|tensepath|thru|titlefont|top|tracingall|tracingnone|undraw|undrawdot|unfill|unfilldraw|upto|vround)\b/,
			alias: "function"
		},
		builtin: /\b(?:ASCII|angle|char|cosd|decimal|directiontime|floor|hex|intersectiontimes|jobname|known|length|makepath|makepen|mexp|mlog|normaldeviate|oct|odd|pencircle|penoffset|point|postcontrol|precontrol|reverse|rotated|sind|sqrt|str|subpath|substring|totalweight|turningnumber|uniformdeviate|unknown|xpart|xxpart|xypart|ypart|yxpart|yypart)\b/,
		keyword: /\b(?:also|at|atleast|begingroup|charexists|contour|controls|curl|cycle|def|delimiters|doublepath|dropping|dump|else|elseif|end|enddef|endfor|endgroup|endinput|exitif|exitunless|expandafter|fi|for|forever|forsuffixes|from|if|input|inwindow|keeping|kern|of|primarydef|quote|readstring|scaled|scantokens|secondarydef|shifted|skipto|slanted|step|tension|tertiarydef|to|transformed|until|vardef|withpen|withweight|xscaled|yscaled|zscaled)\b/,
		type: {
			pattern: /\b(?:boolean|expr|numeric|pair|path|pen|picture|primary|secondary|string|suffix|tertiary|text|transform)\b/,
			alias: "property"
		},
		variable: {
			pattern: /(^|[^@#&$])(?:@#|#@|#|@)(?![@#&$])|\b(?:aspect_ratio|currentpen|currentpicture|currenttransform|d|extra_beginchar|extra_endchar|extra_setup|h|localfont|mag|mode|screen_cols|screen_rows|w|whatever|x|y|z)\b/,
			lookbehind: true
		}
	};
}
mizar.displayName = "mizar";
mizar.aliases = [];
function mizar(Prism$1) {
	Prism$1.languages.mizar = {
		comment: /::.+/,
		keyword: /@proof\b|\b(?:according|aggregate|all|and|antonym|are|as|associativity|assume|asymmetry|attr|be|begin|being|by|canceled|case|cases|clusters?|coherence|commutativity|compatibility|connectedness|consider|consistency|constructors|contradiction|correctness|def|deffunc|define|definitions?|defpred|do|does|end|environ|equals|ex|exactly|existence|for|from|func|given|hence|hereby|holds|idempotence|identity|iff?|implies|involutiveness|irreflexivity|is|it|let|means|mode|non|not|notations?|now|of|or|otherwise|over|per|pred|prefix|projectivity|proof|provided|qua|reconsider|redefine|reduce|reducibility|reflexivity|registrations?|requirements|reserve|sch|schemes?|section|selector|set|sethood|st|struct|such|suppose|symmetry|synonym|take|that|the|then|theorems?|thesis|thus|to|transitivity|uniqueness|vocabular(?:ies|y)|when|where|with|wrt)\b/,
		parameter: {
			pattern: /\$(?:10|\d)/,
			alias: "variable"
		},
		variable: /\b\w+(?=:)/,
		number: /(?:\b|-)\d+\b/,
		operator: /\.\.\.|->|&|\.?=/,
		punctuation: /\(#|#\)|[,:;\[\](){}]/
	};
}
mongodb.displayName = "mongodb";
mongodb.aliases = [];
function mongodb(Prism$1) {
	Prism$1.register(javascript);
	(function(Prism$2) {
		var operators = [
			"$eq",
			"$gt",
			"$gte",
			"$in",
			"$lt",
			"$lte",
			"$ne",
			"$nin",
			"$and",
			"$not",
			"$nor",
			"$or",
			"$exists",
			"$type",
			"$expr",
			"$jsonSchema",
			"$mod",
			"$regex",
			"$text",
			"$where",
			"$geoIntersects",
			"$geoWithin",
			"$near",
			"$nearSphere",
			"$all",
			"$elemMatch",
			"$size",
			"$bitsAllClear",
			"$bitsAllSet",
			"$bitsAnyClear",
			"$bitsAnySet",
			"$comment",
			"$elemMatch",
			"$meta",
			"$slice",
			"$currentDate",
			"$inc",
			"$min",
			"$max",
			"$mul",
			"$rename",
			"$set",
			"$setOnInsert",
			"$unset",
			"$addToSet",
			"$pop",
			"$pull",
			"$push",
			"$pullAll",
			"$each",
			"$position",
			"$slice",
			"$sort",
			"$bit",
			"$addFields",
			"$bucket",
			"$bucketAuto",
			"$collStats",
			"$count",
			"$currentOp",
			"$facet",
			"$geoNear",
			"$graphLookup",
			"$group",
			"$indexStats",
			"$limit",
			"$listLocalSessions",
			"$listSessions",
			"$lookup",
			"$match",
			"$merge",
			"$out",
			"$planCacheStats",
			"$project",
			"$redact",
			"$replaceRoot",
			"$replaceWith",
			"$sample",
			"$set",
			"$skip",
			"$sort",
			"$sortByCount",
			"$unionWith",
			"$unset",
			"$unwind",
			"$setWindowFields",
			"$abs",
			"$accumulator",
			"$acos",
			"$acosh",
			"$add",
			"$addToSet",
			"$allElementsTrue",
			"$and",
			"$anyElementTrue",
			"$arrayElemAt",
			"$arrayToObject",
			"$asin",
			"$asinh",
			"$atan",
			"$atan2",
			"$atanh",
			"$avg",
			"$binarySize",
			"$bsonSize",
			"$ceil",
			"$cmp",
			"$concat",
			"$concatArrays",
			"$cond",
			"$convert",
			"$cos",
			"$dateFromParts",
			"$dateToParts",
			"$dateFromString",
			"$dateToString",
			"$dayOfMonth",
			"$dayOfWeek",
			"$dayOfYear",
			"$degreesToRadians",
			"$divide",
			"$eq",
			"$exp",
			"$filter",
			"$first",
			"$floor",
			"$function",
			"$gt",
			"$gte",
			"$hour",
			"$ifNull",
			"$in",
			"$indexOfArray",
			"$indexOfBytes",
			"$indexOfCP",
			"$isArray",
			"$isNumber",
			"$isoDayOfWeek",
			"$isoWeek",
			"$isoWeekYear",
			"$last",
			"$last",
			"$let",
			"$literal",
			"$ln",
			"$log",
			"$log10",
			"$lt",
			"$lte",
			"$ltrim",
			"$map",
			"$max",
			"$mergeObjects",
			"$meta",
			"$min",
			"$millisecond",
			"$minute",
			"$mod",
			"$month",
			"$multiply",
			"$ne",
			"$not",
			"$objectToArray",
			"$or",
			"$pow",
			"$push",
			"$radiansToDegrees",
			"$range",
			"$reduce",
			"$regexFind",
			"$regexFindAll",
			"$regexMatch",
			"$replaceOne",
			"$replaceAll",
			"$reverseArray",
			"$round",
			"$rtrim",
			"$second",
			"$setDifference",
			"$setEquals",
			"$setIntersection",
			"$setIsSubset",
			"$setUnion",
			"$size",
			"$sin",
			"$slice",
			"$split",
			"$sqrt",
			"$stdDevPop",
			"$stdDevSamp",
			"$strcasecmp",
			"$strLenBytes",
			"$strLenCP",
			"$substr",
			"$substrBytes",
			"$substrCP",
			"$subtract",
			"$sum",
			"$switch",
			"$tan",
			"$toBool",
			"$toDate",
			"$toDecimal",
			"$toDouble",
			"$toInt",
			"$toLong",
			"$toObjectId",
			"$toString",
			"$toLower",
			"$toUpper",
			"$trim",
			"$trunc",
			"$type",
			"$week",
			"$year",
			"$zip",
			"$count",
			"$dateAdd",
			"$dateDiff",
			"$dateSubtract",
			"$dateTrunc",
			"$getField",
			"$rand",
			"$sampleRate",
			"$setField",
			"$unsetField",
			"$comment",
			"$explain",
			"$hint",
			"$max",
			"$maxTimeMS",
			"$min",
			"$orderby",
			"$query",
			"$returnKey",
			"$showDiskLoc",
			"$natural"
		];
		var builtinFunctions = [
			"ObjectId",
			"Code",
			"BinData",
			"DBRef",
			"Timestamp",
			"NumberLong",
			"NumberDecimal",
			"MaxKey",
			"MinKey",
			"RegExp",
			"ISODate",
			"UUID"
		];
		operators = operators.map(function(operator) {
			return operator.replace("$", "\\$");
		});
		var operatorsSource = "(?:" + operators.join("|") + ")\\b";
		Prism$2.languages.mongodb = Prism$2.languages.extend("javascript", {});
		Prism$2.languages.insertBefore("mongodb", "string", { property: {
			pattern: /(?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)(?=\s*:)/,
			greedy: true,
			inside: { keyword: RegExp("^(['\"])?" + operatorsSource + "(?:\\1)?$") }
		} });
		Prism$2.languages.mongodb.string.inside = {
			url: {
				pattern: /https?:\/\/[-\w@:%.+~#=]{1,256}\.[a-z0-9()]{1,6}\b[-\w()@:%+.~#?&/=]*/i,
				greedy: true
			},
			entity: {
				pattern: /\b(?:(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d\d?|2[0-4]\d|25[0-5])\b/,
				greedy: true
			}
		};
		Prism$2.languages.insertBefore("mongodb", "constant", { builtin: {
			pattern: RegExp("\\b(?:" + builtinFunctions.join("|") + ")\\b"),
			alias: "keyword"
		} });
	})(Prism$1);
}
monkey.displayName = "monkey";
monkey.aliases = [];
function monkey(Prism$1) {
	Prism$1.languages.monkey = {
		comment: {
			pattern: /^#Rem\s[\s\S]*?^#End|'.+/im,
			greedy: true
		},
		string: {
			pattern: /"[^"\r\n]*"/,
			greedy: true
		},
		preprocessor: {
			pattern: /(^[ \t]*)#.+/m,
			lookbehind: true,
			greedy: true,
			alias: "property"
		},
		function: /\b\w+(?=\()/,
		"type-char": {
			pattern: /\b[?%#$]/,
			alias: "class-name"
		},
		number: {
			pattern: /((?:\.\.)?)(?:(?:\b|\B-\.?|\B\.)\d+(?:(?!\.\.)\.\d*)?|\$[\da-f]+)/i,
			lookbehind: true
		},
		keyword: /\b(?:Abstract|Array|Bool|Case|Catch|Class|Const|Continue|Default|Eachin|Else|ElseIf|End|EndIf|Exit|Extends|Extern|False|Field|Final|Float|For|Forever|Function|Global|If|Implements|Import|Inline|Int|Interface|Local|Method|Module|New|Next|Null|Object|Private|Property|Public|Repeat|Return|Select|Self|Step|Strict|String|Super|Then|Throw|To|True|Try|Until|Void|Wend|While)\b/i,
		operator: /\.\.|<[=>]?|>=?|:?=|(?:[+\-*\/&~|]|\b(?:Mod|Shl|Shr)\b)=?|\b(?:And|Not|Or)\b/i,
		punctuation: /[.,:;()\[\]]/
	};
}
moonscript.displayName = "moonscript";
moonscript.aliases = ["moon"];
function moonscript(Prism$1) {
	Prism$1.languages.moonscript = {
		comment: /--.*/,
		string: [{
			pattern: /'[^']*'|\[(=*)\[[\s\S]*?\]\1\]/,
			greedy: true
		}, {
			pattern: /"[^"]*"/,
			greedy: true,
			inside: { interpolation: {
				pattern: /#\{[^{}]*\}/,
				inside: {
					moonscript: {
						pattern: /(^#\{)[\s\S]+(?=\})/,
						lookbehind: true,
						inside: null
					},
					"interpolation-punctuation": {
						pattern: /#\{|\}/,
						alias: "punctuation"
					}
				}
			} }
		}],
		"class-name": [{
			pattern: /(\b(?:class|extends)[ \t]+)\w+/,
			lookbehind: true
		}, /\b[A-Z]\w*/],
		keyword: /\b(?:class|continue|do|else|elseif|export|extends|for|from|if|import|in|local|nil|return|self|super|switch|then|unless|using|when|while|with)\b/,
		variable: /@@?\w*/,
		property: {
			pattern: /\b(?!\d)\w+(?=:)|(:)(?!\d)\w+/,
			lookbehind: true
		},
		function: {
			pattern: /\b(?:_G|_VERSION|assert|collectgarbage|coroutine\.(?:create|resume|running|status|wrap|yield)|debug\.(?:debug|getfenv|gethook|getinfo|getlocal|getmetatable|getregistry|getupvalue|setfenv|sethook|setlocal|setmetatable|setupvalue|traceback)|dofile|error|getfenv|getmetatable|io\.(?:close|flush|input|lines|open|output|popen|read|stderr|stdin|stdout|tmpfile|type|write)|ipairs|load|loadfile|loadstring|math\.(?:abs|acos|asin|atan|atan2|ceil|cos|cosh|deg|exp|floor|fmod|frexp|ldexp|log|log10|max|min|modf|pi|pow|rad|random|randomseed|sin|sinh|sqrt|tan|tanh)|module|next|os\.(?:clock|date|difftime|execute|exit|getenv|remove|rename|setlocale|time|tmpname)|package\.(?:cpath|loaded|loadlib|path|preload|seeall)|pairs|pcall|print|rawequal|rawget|rawset|require|select|setfenv|setmetatable|string\.(?:byte|char|dump|find|format|gmatch|gsub|len|lower|match|rep|reverse|sub|upper)|table\.(?:concat|insert|maxn|remove|sort)|tonumber|tostring|type|unpack|xpcall)\b/,
			inside: { punctuation: /\./ }
		},
		boolean: /\b(?:false|true)\b/,
		number: /(?:\B\.\d+|\b\d+\.\d+|\b\d+(?=[eE]))(?:[eE][-+]?\d+)?\b|\b(?:0x[a-fA-F\d]+|\d+)(?:U?LL)?\b/,
		operator: /\.{3}|[-=]>|~=|(?:[-+*/%<>!=]|\.\.)=?|[:#^]|\b(?:and|or)\b=?|\b(?:not)\b/,
		punctuation: /[.,()[\]{}\\]/
	};
	Prism$1.languages.moonscript.string[1].inside.interpolation.inside.moonscript.inside = Prism$1.languages.moonscript;
	Prism$1.languages.moon = Prism$1.languages.moonscript;
}
n1ql.displayName = "n1ql";
n1ql.aliases = [];
function n1ql(Prism$1) {
	Prism$1.languages.n1ql = {
		comment: {
			pattern: /\/\*[\s\S]*?(?:$|\*\/)|--.*/,
			greedy: true
		},
		string: {
			pattern: /(["'])(?:\\[\s\S]|(?!\1)[^\\]|\1\1)*\1/,
			greedy: true
		},
		identifier: {
			pattern: /`(?:\\[\s\S]|[^\\`]|``)*`/,
			greedy: true
		},
		parameter: /\$[\w.]+/,
		keyword: /\b(?:ADVISE|ALL|ALTER|ANALYZE|AS|ASC|AT|BEGIN|BINARY|BOOLEAN|BREAK|BUCKET|BUILD|BY|CALL|CAST|CLUSTER|COLLATE|COLLECTION|COMMIT|COMMITTED|CONNECT|CONTINUE|CORRELATE|CORRELATED|COVER|CREATE|CURRENT|DATABASE|DATASET|DATASTORE|DECLARE|DECREMENT|DELETE|DERIVED|DESC|DESCRIBE|DISTINCT|DO|DROP|EACH|ELEMENT|EXCEPT|EXCLUDE|EXECUTE|EXPLAIN|FETCH|FILTER|FLATTEN|FLUSH|FOLLOWING|FOR|FORCE|FROM|FTS|FUNCTION|GOLANG|GRANT|GROUP|GROUPS|GSI|HASH|HAVING|IF|IGNORE|ILIKE|INCLUDE|INCREMENT|INDEX|INFER|INLINE|INNER|INSERT|INTERSECT|INTO|IS|ISOLATION|JAVASCRIPT|JOIN|KEY|KEYS|KEYSPACE|KNOWN|LANGUAGE|LAST|LEFT|LET|LETTING|LEVEL|LIMIT|LSM|MAP|MAPPING|MATCHED|MATERIALIZED|MERGE|MINUS|MISSING|NAMESPACE|NEST|NL|NO|NTH_VALUE|NULL|NULLS|NUMBER|OBJECT|OFFSET|ON|OPTION|OPTIONS|ORDER|OTHERS|OUTER|OVER|PARSE|PARTITION|PASSWORD|PATH|POOL|PRECEDING|PREPARE|PRIMARY|PRIVATE|PRIVILEGE|PROBE|PROCEDURE|PUBLIC|RANGE|RAW|REALM|REDUCE|RENAME|RESPECT|RETURN|RETURNING|REVOKE|RIGHT|ROLE|ROLLBACK|ROW|ROWS|SATISFIES|SAVEPOINT|SCHEMA|SCOPE|SELECT|SELF|SEMI|SET|SHOW|SOME|START|STATISTICS|STRING|SYSTEM|TIES|TO|TRAN|TRANSACTION|TRIGGER|TRUNCATE|UNBOUNDED|UNDER|UNION|UNIQUE|UNKNOWN|UNNEST|UNSET|UPDATE|UPSERT|USE|USER|USING|VALIDATE|VALUE|VALUES|VIA|VIEW|WHERE|WHILE|WINDOW|WITH|WORK|XOR)\b/i,
		function: /\b[a-z_]\w*(?=\s*\()/i,
		boolean: /\b(?:FALSE|TRUE)\b/i,
		number: /(?:\b\d+\.|\B\.)\d+e[+\-]?\d+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
		operator: /[-+*\/%]|!=|==?|\|\||<[>=]?|>=?|\b(?:AND|ANY|ARRAY|BETWEEN|CASE|ELSE|END|EVERY|EXISTS|FIRST|IN|LIKE|NOT|OR|THEN|VALUED|WHEN|WITHIN)\b/i,
		punctuation: /[;[\](),.{}:]/
	};
}
nand2tetrisHdl.displayName = "nand2tetris-hdl";
nand2tetrisHdl.aliases = [];
function nand2tetrisHdl(Prism$1) {
	Prism$1.languages["nand2tetris-hdl"] = {
		comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
		keyword: /\b(?:BUILTIN|CHIP|CLOCKED|IN|OUT|PARTS)\b/,
		boolean: /\b(?:false|true)\b/,
		function: /\b[A-Za-z][A-Za-z0-9]*(?=\()/,
		number: /\b\d+\b/,
		operator: /=|\.\./,
		punctuation: /[{}[\];(),:]/
	};
}
naniscript.displayName = "naniscript";
naniscript.aliases = ["nani"];
function naniscript(Prism$1) {
	(function(Prism$2) {
		var expressionDef = /\{[^\r\n\[\]{}]*\}/;
		var params = {
			"quoted-string": {
				pattern: /"(?:[^"\\]|\\.)*"/,
				alias: "operator"
			},
			"command-param-id": {
				pattern: /(\s)\w+:/,
				lookbehind: true,
				alias: "property"
			},
			"command-param-value": [
				{
					pattern: expressionDef,
					alias: "selector"
				},
				{
					pattern: /([\t ])\S+/,
					lookbehind: true,
					greedy: true,
					alias: "operator"
				},
				{
					pattern: /\S(?:.*\S)?/,
					alias: "operator"
				}
			]
		};
		Prism$2.languages.naniscript = {
			comment: {
				pattern: /^([\t ]*);.*/m,
				lookbehind: true
			},
			define: {
				pattern: /^>.+/m,
				alias: "tag",
				inside: {
					value: {
						pattern: /(^>\w+[\t ]+)(?!\s)[^{}\r\n]+/,
						lookbehind: true,
						alias: "operator"
					},
					key: {
						pattern: /(^>)\w+/,
						lookbehind: true
					}
				}
			},
			label: {
				pattern: /^([\t ]*)#[\t ]*\w+[\t ]*$/m,
				lookbehind: true,
				alias: "regex"
			},
			command: {
				pattern: /^([\t ]*)@\w+(?=[\t ]|$).*/m,
				lookbehind: true,
				alias: "function",
				inside: {
					"command-name": /^@\w+/,
					expression: {
						pattern: expressionDef,
						greedy: true,
						alias: "selector"
					},
					"command-params": {
						pattern: /\s*\S[\s\S]*/,
						inside: params
					}
				}
			},
			"generic-text": {
				pattern: /(^[ \t]*)[^#@>;\s].*/m,
				lookbehind: true,
				alias: "punctuation",
				inside: {
					"escaped-char": /\\[{}\[\]"]/,
					expression: {
						pattern: expressionDef,
						greedy: true,
						alias: "selector"
					},
					"inline-command": {
						pattern: /\[[\t ]*\w[^\r\n\[\]]*\]/,
						greedy: true,
						alias: "function",
						inside: {
							"command-params": {
								pattern: /(^\[[\t ]*\w+\b)[\s\S]+(?=\]$)/,
								lookbehind: true,
								inside: params
							},
							"command-param-name": {
								pattern: /^(\[[\t ]*)\w+/,
								lookbehind: true,
								alias: "name"
							},
							"start-stop-char": /[\[\]]/
						}
					}
				}
			}
		};
		Prism$2.languages.nani = Prism$2.languages["naniscript"];
		Prism$2.hooks.add("after-tokenize", function(env$1) {
			var tokens = env$1.tokens;
			tokens.forEach(function(token) {
				if (typeof token !== "string" && token.type === "generic-text") {
					var content$2 = getTextContent(token);
					if (!isBracketsBalanced(content$2)) {
						token.type = "bad-line";
						token.content = content$2;
					}
				}
			});
		});
		function isBracketsBalanced(input) {
			var brackets = "[]{}";
			var stack = [];
			for (var i = 0; i < input.length; i++) {
				var bracket = input[i];
				var bracketsIndex = brackets.indexOf(bracket);
				if (bracketsIndex !== -1) {
					if (bracketsIndex % 2 === 0) stack.push(bracketsIndex + 1);
					else if (stack.pop() !== bracketsIndex) return false;
				}
			}
			return stack.length === 0;
		}
		function getTextContent(token) {
			if (typeof token === "string") return token;
			else if (Array.isArray(token)) return token.map(getTextContent).join("");
			else return getTextContent(token.content);
		}
	})(Prism$1);
}
nasm.displayName = "nasm";
nasm.aliases = [];
function nasm(Prism$1) {
	Prism$1.languages.nasm = {
		comment: /;.*$/m,
		string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
		label: {
			pattern: /(^\s*)[A-Za-z._?$][\w.?$@~#]*:/m,
			lookbehind: true,
			alias: "function"
		},
		keyword: [
			/\[?BITS (?:16|32|64)\]?/,
			{
				pattern: /(^\s*)section\s*[a-z.]+:?/im,
				lookbehind: true
			},
			/(?:extern|global)[^;\r\n]*/i,
			/(?:CPU|DEFAULT|FLOAT).*$/m
		],
		register: {
			pattern: /\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|di|si|sp)|[cdefgs]s)\b/i,
			alias: "variable"
		},
		number: /(?:\b|(?=\$))(?:0[hx](?:\.[\da-f]+|[\da-f]+(?:\.[\da-f]+)?)(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|(?:\d+(?:\.\d+)?|\.\d+)(?:\.?e[+-]?\d+)?[dt]?)\b/i,
		operator: /[\[\]*+\-\/%<>=&|$!]/
	};
}
neon.displayName = "neon";
neon.aliases = [];
function neon(Prism$1) {
	Prism$1.languages.neon = {
		comment: {
			pattern: /#.*/,
			greedy: true
		},
		datetime: {
			pattern: /(^|[[{(=:,\s])\d\d\d\d-\d\d?-\d\d?(?:(?:[Tt]| +)\d\d?:\d\d:\d\d(?:\.\d*)? *(?:Z|[-+]\d\d?(?::?\d\d)?)?)?(?=$|[\]}),\s])/,
			lookbehind: true,
			alias: "number"
		},
		key: {
			pattern: /(^|[[{(,\s])[^,:=[\]{}()'"\s]+(?=\s*:(?:$|[\]}),\s])|\s*=)/,
			lookbehind: true,
			alias: "property"
		},
		number: {
			pattern: /(^|[[{(=:,\s])[+-]?(?:0x[\da-fA-F]+|0o[0-7]+|0b[01]+|(?:\d+(?:\.\d*)?|\.?\d+)(?:[eE][+-]?\d+)?)(?=$|[\]}),:=\s])/,
			lookbehind: true
		},
		boolean: {
			pattern: /(^|[[{(=:,\s])(?:false|no|true|yes)(?=$|[\]}),:=\s])/i,
			lookbehind: true
		},
		null: {
			pattern: /(^|[[{(=:,\s])(?:null)(?=$|[\]}),:=\s])/i,
			lookbehind: true,
			alias: "keyword"
		},
		string: {
			pattern: /(^|[[{(=:,\s])(?:('''|""")\r?\n(?:(?:[^\r\n]|\r?\n(?![\t ]*\2))*\r?\n)?[\t ]*\2|'[^'\r\n]*'|"(?:\\.|[^\\"\r\n])*")/,
			lookbehind: true,
			greedy: true
		},
		literal: {
			pattern: /(^|[[{(=:,\s])(?:[^#"',:=[\]{}()\s`-]|[:-][^"',=[\]{}()\s])(?:[^,:=\]})(\s]|:(?![\s,\]})]|$)|[ \t]+[^#,:=\]})(\s])*/,
			lookbehind: true,
			alias: "string"
		},
		punctuation: /[,:=[\]{}()-]/
	};
}
nevod.displayName = "nevod";
nevod.aliases = [];
function nevod(Prism$1) {
	Prism$1.languages.nevod = {
		comment: /\/\/.*|(?:\/\*[\s\S]*?(?:\*\/|$))/,
		string: {
			pattern: /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))!?\*?/,
			greedy: true,
			inside: { "string-attrs": /!$|!\*$|\*$/ }
		},
		namespace: {
			pattern: /(@namespace\s+)[a-zA-Z0-9\-.]+(?=\s*\{)/,
			lookbehind: true
		},
		pattern: {
			pattern: /(@pattern\s+)?#?[a-zA-Z0-9\-.]+(?:\s*\(\s*(?:~\s*)?[a-zA-Z0-9\-.]+\s*(?:,\s*(?:~\s*)?[a-zA-Z0-9\-.]*)*\))?(?=\s*=)/,
			lookbehind: true,
			inside: {
				"pattern-name": {
					pattern: /^#?[a-zA-Z0-9\-.]+/,
					alias: "class-name"
				},
				fields: {
					pattern: /\(.*\)/,
					inside: {
						"field-name": {
							pattern: /[a-zA-Z0-9\-.]+/,
							alias: "variable"
						},
						punctuation: /[,()]/,
						operator: {
							pattern: /~/,
							alias: "field-hidden-mark"
						}
					}
				}
			}
		},
		search: {
			pattern: /(@search\s+|#)[a-zA-Z0-9\-.]+(?:\.\*)?(?=\s*;)/,
			alias: "function",
			lookbehind: true
		},
		keyword: /@(?:having|inside|namespace|outside|pattern|require|search|where)\b/,
		"standard-pattern": {
			pattern: /\b(?:Alpha|AlphaNum|Any|Blank|End|LineBreak|Num|NumAlpha|Punct|Space|Start|Symbol|Word|WordBreak)\b(?:\([a-zA-Z0-9\-.,\s+]*\))?/,
			inside: {
				"standard-pattern-name": {
					pattern: /^[a-zA-Z0-9\-.]+/,
					alias: "builtin"
				},
				quantifier: {
					pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
					alias: "number"
				},
				"standard-pattern-attr": {
					pattern: /[a-zA-Z0-9\-.]+/,
					alias: "builtin"
				},
				punctuation: /[,()]/
			}
		},
		quantifier: {
			pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
			alias: "number"
		},
		operator: [
			{
				pattern: /=/,
				alias: "pattern-def"
			},
			{
				pattern: /&/,
				alias: "conjunction"
			},
			{
				pattern: /~/,
				alias: "exception"
			},
			{
				pattern: /\?/,
				alias: "optionality"
			},
			{
				pattern: /[[\]]/,
				alias: "repetition"
			},
			{
				pattern: /[{}]/,
				alias: "variation"
			},
			{
				pattern: /[+_]/,
				alias: "sequence"
			},
			{
				pattern: /\.{2,3}/,
				alias: "span"
			}
		],
		"field-capture": [{
			pattern: /([a-zA-Z0-9\-.]+\s*\()\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+(?:\s*,\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+)*(?=\s*\))/,
			lookbehind: true,
			inside: {
				"field-name": {
					pattern: /[a-zA-Z0-9\-.]+/,
					alias: "variable"
				},
				colon: /:/
			}
		}, {
			pattern: /[a-zA-Z0-9\-.]+\s*:/,
			inside: {
				"field-name": {
					pattern: /[a-zA-Z0-9\-.]+/,
					alias: "variable"
				},
				colon: /:/
			}
		}],
		punctuation: /[:;,()]/,
		name: /[a-zA-Z0-9\-.]+/
	};
}
nginx.displayName = "nginx";
nginx.aliases = [];
function nginx(Prism$1) {
	(function(Prism$2) {
		var variable = /\$(?:\w[a-z\d]*(?:_[^\x00-\x1F\s"'\\()$]*)?|\{[^}\s"'\\]+\})/i;
		Prism$2.languages.nginx = {
			comment: {
				pattern: /(^|[\s{};])#.*/,
				lookbehind: true,
				greedy: true
			},
			directive: {
				pattern: /(^|\s)\w(?:[^;{}"'\\\s]|\\.|"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'|\s+(?:#.*(?!.)|(?![#\s])))*?(?=\s*[;{])/,
				lookbehind: true,
				greedy: true,
				inside: {
					string: {
						pattern: /((?:^|[^\\])(?:\\\\)*)(?:"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')/,
						lookbehind: true,
						greedy: true,
						inside: {
							escape: {
								pattern: /\\["'\\nrt]/,
								alias: "entity"
							},
							variable
						}
					},
					comment: {
						pattern: /(\s)#.*/,
						lookbehind: true,
						greedy: true
					},
					keyword: {
						pattern: /^\S+/,
						greedy: true
					},
					boolean: {
						pattern: /(\s)(?:off|on)(?!\S)/,
						lookbehind: true
					},
					number: {
						pattern: /(\s)\d+[a-z]*(?!\S)/i,
						lookbehind: true
					},
					variable
				}
			},
			punctuation: /[{};]/
		};
	})(Prism$1);
}
nim.displayName = "nim";
nim.aliases = [];
function nim(Prism$1) {
	Prism$1.languages.nim = {
		comment: {
			pattern: /#.*/,
			greedy: true
		},
		string: {
			pattern: /(?:\b(?!\d)(?:\w|\\x[89a-fA-F][0-9a-fA-F])+)?(?:"""[\s\S]*?"""(?!")|"(?:\\[\s\S]|""|[^"\\])*")/,
			greedy: true
		},
		char: {
			pattern: /'(?:\\(?:\d+|x[\da-fA-F]{0,2}|.)|[^'])'/,
			greedy: true
		},
		function: {
			pattern: /(?:(?!\d)(?:\w|\\x[89a-fA-F][0-9a-fA-F])+|`[^`\r\n]+`)\*?(?:\[[^\]]+\])?(?=\s*\()/,
			greedy: true,
			inside: { operator: /\*$/ }
		},
		identifier: {
			pattern: /`[^`\r\n]+`/,
			greedy: true,
			inside: { punctuation: /`/ }
		},
		number: /\b(?:0[xXoObB][\da-fA-F_]+|\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:[eE][+-]?\d[\d_]*)?)(?:'?[iuf]\d*)?/,
		keyword: /\b(?:addr|as|asm|atomic|bind|block|break|case|cast|concept|const|continue|converter|defer|discard|distinct|do|elif|else|end|enum|except|export|finally|for|from|func|generic|if|import|include|interface|iterator|let|macro|method|mixin|nil|object|out|proc|ptr|raise|ref|return|static|template|try|tuple|type|using|var|when|while|with|without|yield)\b/,
		operator: {
			pattern: /(^|[({\[](?=\.\.)|(?![({\[]\.).)(?:(?:[=+\-*\/<>@$~&%|!?^:\\]|\.\.|\.(?![)}\]]))+|\b(?:and|div|in|is|isnot|mod|not|notin|of|or|shl|shr|xor)\b)/m,
			lookbehind: true
		},
		punctuation: /[({\[]\.|\.[)}\]]|[`(){}\[\],:]/
	};
}
nix.displayName = "nix";
nix.aliases = [];
function nix(Prism$1) {
	Prism$1.languages.nix = {
		comment: {
			pattern: /\/\*[\s\S]*?\*\/|#.*/,
			greedy: true
		},
		string: {
			pattern: /"(?:[^"\\]|\\[\s\S])*"|''(?:(?!'')[\s\S]|''(?:'|\\|\$\{))*''/,
			greedy: true,
			inside: { interpolation: {
				pattern: /(^|(?:^|(?!'').)[^\\])\$\{(?:[^{}]|\{[^}]*\})*\}/,
				lookbehind: true,
				inside: null
			} }
		},
		url: [/\b(?:[a-z]{3,7}:\/\/)[\w\-+%~\/.:#=?&]+/, {
			pattern: /([^\/])(?:[\w\-+%~.:#=?&]*(?!\/\/)[\w\-+%~\/.:#=?&])?(?!\/\/)\/[\w\-+%~\/.:#=?&]*/,
			lookbehind: true
		}],
		antiquotation: {
			pattern: /\$(?=\{)/,
			alias: "important"
		},
		number: /\b\d+\b/,
		keyword: /\b(?:assert|builtins|else|if|in|inherit|let|null|or|then|with)\b/,
		function: /\b(?:abort|add|all|any|attrNames|attrValues|baseNameOf|compareVersions|concatLists|currentSystem|deepSeq|derivation|dirOf|div|elem(?:At)?|fetch(?:Tarball|url)|filter(?:Source)?|fromJSON|genList|getAttr|getEnv|hasAttr|hashString|head|import|intersectAttrs|is(?:Attrs|Bool|Function|Int|List|Null|String)|length|lessThan|listToAttrs|map|mul|parseDrvName|pathExists|read(?:Dir|File)|removeAttrs|replaceStrings|seq|sort|stringLength|sub(?:string)?|tail|throw|to(?:File|JSON|Path|String|XML)|trace|typeOf)\b|\bfoldl'\B/,
		boolean: /\b(?:false|true)\b/,
		operator: /[=!<>]=?|\+\+?|\|\||&&|\/\/|->?|[?@]/,
		punctuation: /[{}()[\].,:;]/
	};
	Prism$1.languages.nix.string.inside.interpolation.inside = Prism$1.languages.nix;
}
nsis.displayName = "nsis";
nsis.aliases = [];
function nsis(Prism$1) {
	Prism$1.languages.nsis = {
		comment: {
			pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|[#;].*)/,
			lookbehind: true,
			greedy: true
		},
		string: {
			pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
			greedy: true
		},
		keyword: {
			pattern: /(^[\t ]*)(?:Abort|Add(?:BrandingImage|Size)|AdvSplash|Allow(?:RootDirInstall|SkipFiles)|AutoCloseWindow|BG(?:Font|Gradient|Image)|Banner|BrandingText|BringToFront|CRCCheck|Call(?:InstDLL)?|Caption|ChangeUI|CheckBitmap|ClearErrors|CompletedText|ComponentText|CopyFiles|Create(?:Directory|Font|ShortCut)|Delete(?:INISec|INIStr|RegKey|RegValue)?|Detail(?:Print|sButtonText)|Dialer|Dir(?:Text|Var|Verify)|EnableWindow|Enum(?:RegKey|RegValue)|Exch|Exec(?:Shell(?:Wait)?|Wait)?|ExpandEnvStrings|File(?:BufSize|Close|ErrorText|Open|Read|ReadByte|ReadUTF16LE|ReadWord|Seek|Write|WriteByte|WriteUTF16LE|WriteWord)?|Find(?:Close|First|Next|Window)|FlushINI|Get(?:CurInstType|CurrentAddress|DLLVersion(?:Local)?|DlgItem|ErrorLevel|FileTime(?:Local)?|FullPathName|Function(?:Address|End)?|InstDirError|KnownFolderPath|LabelAddress|TempFileName|WinVer)|Goto|HideWindow|Icon|If(?:Abort|Errors|FileExists|RebootFlag|RtlLanguage|ShellVarContextAll|Silent)|InitPluginsDir|InstProgressFlags|Inst(?:Type(?:GetText|SetText)?)|Install(?:ButtonText|Colors|Dir(?:RegKey)?)|Int(?:64|Ptr)?CmpU?|Int(?:64)?Fmt|Int(?:Ptr)?Op|IsWindow|Lang(?:DLL|String)|License(?:BkColor|Data|ForceSelection|LangString|Text)|LoadLanguageFile|LockWindow|Log(?:Set|Text)|Manifest(?:DPIAware|SupportedOS)|Math|MessageBox|MiscButtonText|NSISdl|Name|Nop|OutFile|PE(?:DllCharacteristics|SubsysVer)|Page(?:Callbacks)?|Pop|Push|Quit|RMDir|Read(?:EnvStr|INIStr|RegDWORD|RegStr)|Reboot|RegDLL|Rename|RequestExecutionLevel|ReserveFile|Return|SearchPath|Section(?:End|GetFlags|GetInstTypes|GetSize|GetText|Group|In|SetFlags|SetInstTypes|SetSize|SetText)?|SendMessage|Set(?:AutoClose|BrandingImage|Compress|Compressor(?:DictSize)?|CtlColors|CurInstType|DatablockOptimize|DateSave|Details(?:Print|View)|ErrorLevel|Errors|FileAttributes|Font|OutPath|Overwrite|PluginUnload|RebootFlag|RegView|ShellVarContext|Silent)|Show(?:InstDetails|UninstDetails|Window)|Silent(?:Install|UnInstall)|Sleep|SpaceTexts|Splash|StartMenu|Str(?:CmpS?|Cpy|Len)|SubCaption|System|Target|UnRegDLL|Unicode|UninstPage|Uninstall(?:ButtonText|Caption|Icon|SubCaption|Text)|UserInfo|VI(?:AddVersionKey|FileVersion|ProductVersion)|VPatch|Var|WindowIcon|Write(?:INIStr|Reg(?:Bin|DWORD|ExpandStr|MultiStr|None|Str)|Uninstaller)|XPStyle|ns(?:Dialogs|Exec))\b/m,
			lookbehind: true
		},
		property: /\b(?:ARCHIVE|FILE_(?:ATTRIBUTE_ARCHIVE|ATTRIBUTE_NORMAL|ATTRIBUTE_OFFLINE|ATTRIBUTE_READONLY|ATTRIBUTE_SYSTEM|ATTRIBUTE_TEMPORARY)|HK(?:(?:CR|CU|LM)(?:32|64)?|DD|PD|U)|HKEY_(?:CLASSES_ROOT|CURRENT_CONFIG|CURRENT_USER|DYN_DATA|LOCAL_MACHINE|PERFORMANCE_DATA|USERS)|ID(?:ABORT|CANCEL|IGNORE|NO|OK|RETRY|YES)|MB_(?:ABORTRETRYIGNORE|DEFBUTTON1|DEFBUTTON2|DEFBUTTON3|DEFBUTTON4|ICONEXCLAMATION|ICONINFORMATION|ICONQUESTION|ICONSTOP|OK|OKCANCEL|RETRYCANCEL|RIGHT|RTLREADING|SETFOREGROUND|TOPMOST|USERICON|YESNO)|NORMAL|OFFLINE|READONLY|SHCTX|SHELL_CONTEXT|SYSTEM|TEMPORARY|admin|all|auto|both|colored|false|force|hide|highest|lastused|leave|listonly|none|normal|notset|off|on|open|print|show|silent|silentlog|smooth|textonly|true|user)\b/,
		constant: /\$\{[!\w\.:\^-]+\}|\$\([!\w\.:\^-]+\)/,
		variable: /\$\w[\w\.]*/,
		number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
		operator: /--?|\+\+?|<=?|>=?|==?=?|&&?|\|\|?|[?*\/~^%]/,
		punctuation: /[{}[\];(),.:]/,
		important: {
			pattern: /(^[\t ]*)!(?:addincludedir|addplugindir|appendfile|cd|define|delfile|echo|else|endif|error|execute|finalize|getdllversion|gettlbversion|if|ifdef|ifmacrodef|ifmacrondef|ifndef|include|insertmacro|macro|macroend|makensis|packhdr|pragma|searchparse|searchreplace|system|tempfile|undef|verbose|warning)\b/im,
			lookbehind: true
		}
	};
}
ocaml.displayName = "ocaml";
ocaml.aliases = [];
function ocaml(Prism$1) {
	Prism$1.languages.ocaml = {
		comment: {
			pattern: /\(\*[\s\S]*?\*\)/,
			greedy: true
		},
		char: {
			pattern: /'(?:[^\\\r\n']|\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,
			greedy: true
		},
		string: [{
			pattern: /"(?:\\(?:[\s\S]|\r\n)|[^\\\r\n"])*"/,
			greedy: true
		}, {
			pattern: /\{([a-z_]*)\|[\s\S]*?\|\1\}/,
			greedy: true
		}],
		number: [
			/\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\b/i,
			/\b0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]*)?(?:p[+-]?\d[\d_]*)?(?!\w)/i,
			/\b\d[\d_]*(?:\.[\d_]*)?(?:e[+-]?\d[\d_]*)?(?!\w)/i
		],
		directive: {
			pattern: /\B#\w+/,
			alias: "property"
		},
		label: {
			pattern: /\B~\w+/,
			alias: "property"
		},
		"type-variable": {
			pattern: /\B'\w+/,
			alias: "function"
		},
		variant: {
			pattern: /`\w+/,
			alias: "symbol"
		},
		keyword: /\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\b/,
		boolean: /\b(?:false|true)\b/,
		"operator-like-punctuation": {
			pattern: /\[[<>|]|[>|]\]|\{<|>\}/,
			alias: "punctuation"
		},
		operator: /\.[.~]|:[=>]|[=<>@^|&+\-*\/$%!?~][!$%&*+\-.\/:<=>?@^|~]*|\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\b/,
		punctuation: /;;|::|[(){}\[\].,:;#]|\b_\b/
	};
}
odin.displayName = "odin";
odin.aliases = [];
function odin(Prism$1) {
	(function(Prism$2) {
		var escapes = /\\(?:["'\\abefnrtv]|0[0-7]{2}|U[\dA-Fa-f]{6}|u[\dA-Fa-f]{4}|x[\dA-Fa-f]{2})/;
		Prism$2.languages.odin = {
			comment: [
				{
					pattern: /\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:\*(?!\/)|[^*])*(?:\*\/|$))*(?:\*\/|$)/,
					greedy: true
				},
				{
					pattern: /#![^\n\r]*/,
					greedy: true
				},
				{
					pattern: /\/\/[^\n\r]*/,
					greedy: true
				}
			],
			char: {
				pattern: /'(?:\\(?:.|[0Uux][0-9A-Fa-f]{1,6})|[^\n\r'\\])'/,
				greedy: true,
				inside: { symbol: escapes }
			},
			string: [{
				pattern: /`[^`]*`/,
				greedy: true
			}, {
				pattern: /"(?:\\.|[^\n\r"\\])*"/,
				greedy: true,
				inside: { symbol: escapes }
			}],
			directive: {
				pattern: /#\w+/,
				alias: "property"
			},
			number: /\b0(?:b[01_]+|d[\d_]+|h_*(?:(?:(?:[\dA-Fa-f]_*){8}){1,2}|(?:[\dA-Fa-f]_*){4})|o[0-7_]+|x[\dA-F_a-f]+|z[\dAB_ab]+)\b|(?:\b\d+(?:\.(?!\.)\d*)?|\B\.\d+)(?:[Ee][+-]?\d*)?[ijk]?(?!\w)/,
			discard: {
				pattern: /\b_\b/,
				alias: "keyword"
			},
			"procedure-definition": {
				pattern: /\b\w+(?=[ \t]*(?::\s*){2}proc\b)/,
				alias: "function"
			},
			keyword: /\b(?:asm|auto_cast|bit_set|break|case|cast|context|continue|defer|distinct|do|dynamic|else|enum|fallthrough|for|foreign|if|import|in|map|matrix|not_in|or_else|or_return|package|proc|return|struct|switch|transmute|typeid|union|using|when|where)\b/,
			"procedure-name": {
				pattern: /\b\w+(?=[ \t]*\()/,
				alias: "function"
			},
			boolean: /\b(?:false|nil|true)\b/,
			"constant-parameter-sign": {
				pattern: /\$/,
				alias: "important"
			},
			undefined: {
				pattern: /---/,
				alias: "operator"
			},
			arrow: {
				pattern: /->/,
				alias: "punctuation"
			},
			operator: /\+\+|--|\.\.[<=]?|(?:&~|[-!*+/=~]|[%&<>|]{1,2})=?|[?^]/,
			punctuation: /[(),.:;@\[\]{}]/
		};
	})(Prism$1);
}
opencl.displayName = "opencl";
opencl.aliases = [];
function opencl(Prism$1) {
	Prism$1.register(c$1);
	(function(Prism$2) {
		Prism$2.languages.opencl = Prism$2.languages.extend("c", {
			keyword: /\b(?:(?:__)?(?:constant|global|kernel|local|private|read_only|read_write|write_only)|__attribute__|auto|(?:bool|u?(?:char|int|long|short)|half|quad)(?:2|3|4|8|16)?|break|case|complex|const|continue|(?:double|float)(?:16(?:x(?:1|2|4|8|16))?|1x(?:1|2|4|8|16)|2(?:x(?:1|2|4|8|16))?|3|4(?:x(?:1|2|4|8|16))?|8(?:x(?:1|2|4|8|16))?)?|default|do|else|enum|extern|for|goto|if|imaginary|inline|packed|pipe|register|restrict|return|signed|sizeof|static|struct|switch|typedef|uniform|union|unsigned|void|volatile|while)\b/,
			number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[fuhl]{0,4}/i,
			boolean: /\b(?:false|true)\b/,
			"constant-opencl-kernel": {
				pattern: /\b(?:CHAR_(?:BIT|MAX|MIN)|CLK_(?:ADDRESS_(?:CLAMP(?:_TO_EDGE)?|NONE|REPEAT)|FILTER_(?:LINEAR|NEAREST)|(?:GLOBAL|LOCAL)_MEM_FENCE|NORMALIZED_COORDS_(?:FALSE|TRUE))|CL_(?:BGRA|(?:HALF_)?FLOAT|INTENSITY|LUMINANCE|A?R?G?B?[Ax]?|(?:(?:UN)?SIGNED|[US]NORM)_(?:INT(?:8|16|32))|UNORM_(?:INT_101010|SHORT_(?:555|565)))|(?:DBL|FLT|HALF)_(?:DIG|EPSILON|(?:MAX|MIN)(?:(?:_10)?_EXP)?|MANT_DIG)|FLT_RADIX|HUGE_VALF?|(?:INT|LONG|SCHAR|SHRT)_(?:MAX|MIN)|INFINITY|MAXFLOAT|M_(?:[12]_PI|2_SQRTPI|E|LN(?:2|10)|LOG(?:2|10)E?|PI(?:_[24])?|SQRT(?:1_2|2))(?:_F|_H)?|NAN|(?:UCHAR|UINT|ULONG|USHRT)_MAX)\b/,
				alias: "constant"
			}
		});
		Prism$2.languages.insertBefore("opencl", "class-name", { "builtin-type": {
			pattern: /\b(?:_cl_(?:command_queue|context|device_id|event|kernel|mem|platform_id|program|sampler)|cl_(?:image_format|mem_fence_flags)|clk_event_t|event_t|image(?:1d_(?:array_|buffer_)?t|2d_(?:array_(?:depth_|msaa_depth_|msaa_)?|depth_|msaa_depth_|msaa_)?t|3d_t)|intptr_t|ndrange_t|ptrdiff_t|queue_t|reserve_id_t|sampler_t|size_t|uintptr_t)\b/,
			alias: "keyword"
		} });
		var attributes$1 = {
			"type-opencl-host": {
				pattern: /\b(?:cl_(?:GLenum|GLint|GLuin|addressing_mode|bitfield|bool|buffer_create_type|build_status|channel_(?:order|type)|(?:u?(?:char|int|long|short)|double|float)(?:2|3|4|8|16)?|command_(?:queue(?:_info|_properties)?|type)|context(?:_info|_properties)?|device_(?:exec_capabilities|fp_config|id|info|local_mem_type|mem_cache_type|type)|(?:event|sampler)(?:_info)?|filter_mode|half|image_info|kernel(?:_info|_work_group_info)?|map_flags|mem(?:_flags|_info|_object_type)?|platform_(?:id|info)|profiling_info|program(?:_build_info|_info)?))\b/,
				alias: "keyword"
			},
			"boolean-opencl-host": {
				pattern: /\bCL_(?:FALSE|TRUE)\b/,
				alias: "boolean"
			},
			"constant-opencl-host": {
				pattern: /\bCL_(?:A|ABGR|ADDRESS_(?:CLAMP(?:_TO_EDGE)?|MIRRORED_REPEAT|NONE|REPEAT)|ARGB|BGRA|BLOCKING|BUFFER_CREATE_TYPE_REGION|BUILD_(?:ERROR|IN_PROGRESS|NONE|PROGRAM_FAILURE|SUCCESS)|COMMAND_(?:ACQUIRE_GL_OBJECTS|BARRIER|COPY_(?:BUFFER(?:_RECT|_TO_IMAGE)?|IMAGE(?:_TO_BUFFER)?)|FILL_(?:BUFFER|IMAGE)|MAP(?:_BUFFER|_IMAGE)|MARKER|MIGRATE(?:_SVM)?_MEM_OBJECTS|NATIVE_KERNEL|NDRANGE_KERNEL|READ_(?:BUFFER(?:_RECT)?|IMAGE)|RELEASE_GL_OBJECTS|SVM_(?:FREE|MAP|MEMCPY|MEMFILL|UNMAP)|TASK|UNMAP_MEM_OBJECT|USER|WRITE_(?:BUFFER(?:_RECT)?|IMAGE))|COMPILER_NOT_AVAILABLE|COMPILE_PROGRAM_FAILURE|COMPLETE|CONTEXT_(?:DEVICES|INTEROP_USER_SYNC|NUM_DEVICES|PLATFORM|PROPERTIES|REFERENCE_COUNT)|DEPTH(?:_STENCIL)?|DEVICE_(?:ADDRESS_BITS|AFFINITY_DOMAIN_(?:L[1-4]_CACHE|NEXT_PARTITIONABLE|NUMA)|AVAILABLE|BUILT_IN_KERNELS|COMPILER_AVAILABLE|DOUBLE_FP_CONFIG|ENDIAN_LITTLE|ERROR_CORRECTION_SUPPORT|EXECUTION_CAPABILITIES|EXTENSIONS|GLOBAL_(?:MEM_(?:CACHELINE_SIZE|CACHE_SIZE|CACHE_TYPE|SIZE)|VARIABLE_PREFERRED_TOTAL_SIZE)|HOST_UNIFIED_MEMORY|IL_VERSION|IMAGE(?:2D_MAX_(?:HEIGHT|WIDTH)|3D_MAX_(?:DEPTH|HEIGHT|WIDTH)|_BASE_ADDRESS_ALIGNMENT|_MAX_ARRAY_SIZE|_MAX_BUFFER_SIZE|_PITCH_ALIGNMENT|_SUPPORT)|LINKER_AVAILABLE|LOCAL_MEM_SIZE|LOCAL_MEM_TYPE|MAX_(?:CLOCK_FREQUENCY|COMPUTE_UNITS|CONSTANT_ARGS|CONSTANT_BUFFER_SIZE|GLOBAL_VARIABLE_SIZE|MEM_ALLOC_SIZE|NUM_SUB_GROUPS|ON_DEVICE_(?:EVENTS|QUEUES)|PARAMETER_SIZE|PIPE_ARGS|READ_IMAGE_ARGS|READ_WRITE_IMAGE_ARGS|SAMPLERS|WORK_GROUP_SIZE|WORK_ITEM_DIMENSIONS|WORK_ITEM_SIZES|WRITE_IMAGE_ARGS)|MEM_BASE_ADDR_ALIGN|MIN_DATA_TYPE_ALIGN_SIZE|NAME|NATIVE_VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT)|NOT_(?:AVAILABLE|FOUND)|OPENCL_C_VERSION|PARENT_DEVICE|PARTITION_(?:AFFINITY_DOMAIN|BY_AFFINITY_DOMAIN|BY_COUNTS|BY_COUNTS_LIST_END|EQUALLY|FAILED|MAX_SUB_DEVICES|PROPERTIES|TYPE)|PIPE_MAX_(?:ACTIVE_RESERVATIONS|PACKET_SIZE)|PLATFORM|PREFERRED_(?:GLOBAL_ATOMIC_ALIGNMENT|INTEROP_USER_SYNC|LOCAL_ATOMIC_ALIGNMENT|PLATFORM_ATOMIC_ALIGNMENT|VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT))|PRINTF_BUFFER_SIZE|PROFILE|PROFILING_TIMER_RESOLUTION|QUEUE_(?:ON_(?:DEVICE_(?:MAX_SIZE|PREFERRED_SIZE|PROPERTIES)|HOST_PROPERTIES)|PROPERTIES)|REFERENCE_COUNT|SINGLE_FP_CONFIG|SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS|SVM_(?:ATOMICS|CAPABILITIES|COARSE_GRAIN_BUFFER|FINE_GRAIN_BUFFER|FINE_GRAIN_SYSTEM)|TYPE(?:_ACCELERATOR|_ALL|_CPU|_CUSTOM|_DEFAULT|_GPU)?|VENDOR(?:_ID)?|VERSION)|DRIVER_VERSION|EVENT_(?:COMMAND_(?:EXECUTION_STATUS|QUEUE|TYPE)|CONTEXT|REFERENCE_COUNT)|EXEC_(?:KERNEL|NATIVE_KERNEL|STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST)|FILTER_(?:LINEAR|NEAREST)|FLOAT|FP_(?:CORRECTLY_ROUNDED_DIVIDE_SQRT|DENORM|FMA|INF_NAN|ROUND_TO_INF|ROUND_TO_NEAREST|ROUND_TO_ZERO|SOFT_FLOAT)|GLOBAL|HALF_FLOAT|IMAGE_(?:ARRAY_SIZE|BUFFER|DEPTH|ELEMENT_SIZE|FORMAT|FORMAT_MISMATCH|FORMAT_NOT_SUPPORTED|HEIGHT|NUM_MIP_LEVELS|NUM_SAMPLES|ROW_PITCH|SLICE_PITCH|WIDTH)|INTENSITY|INVALID_(?:ARG_INDEX|ARG_SIZE|ARG_VALUE|BINARY|BUFFER_SIZE|BUILD_OPTIONS|COMMAND_QUEUE|COMPILER_OPTIONS|CONTEXT|DEVICE|DEVICE_PARTITION_COUNT|DEVICE_QUEUE|DEVICE_TYPE|EVENT|EVENT_WAIT_LIST|GLOBAL_OFFSET|GLOBAL_WORK_SIZE|GL_OBJECT|HOST_PTR|IMAGE_DESCRIPTOR|IMAGE_FORMAT_DESCRIPTOR|IMAGE_SIZE|KERNEL|KERNEL_ARGS|KERNEL_DEFINITION|KERNEL_NAME|LINKER_OPTIONS|MEM_OBJECT|MIP_LEVEL|OPERATION|PIPE_SIZE|PLATFORM|PROGRAM|PROGRAM_EXECUTABLE|PROPERTY|QUEUE_PROPERTIES|SAMPLER|VALUE|WORK_DIMENSION|WORK_GROUP_SIZE|WORK_ITEM_SIZE)|KERNEL_(?:ARG_(?:ACCESS_(?:NONE|QUALIFIER|READ_ONLY|READ_WRITE|WRITE_ONLY)|ADDRESS_(?:CONSTANT|GLOBAL|LOCAL|PRIVATE|QUALIFIER)|INFO_NOT_AVAILABLE|NAME|TYPE_(?:CONST|NAME|NONE|PIPE|QUALIFIER|RESTRICT|VOLATILE))|ATTRIBUTES|COMPILE_NUM_SUB_GROUPS|COMPILE_WORK_GROUP_SIZE|CONTEXT|EXEC_INFO_SVM_FINE_GRAIN_SYSTEM|EXEC_INFO_SVM_PTRS|FUNCTION_NAME|GLOBAL_WORK_SIZE|LOCAL_MEM_SIZE|LOCAL_SIZE_FOR_SUB_GROUP_COUNT|MAX_NUM_SUB_GROUPS|MAX_SUB_GROUP_SIZE_FOR_NDRANGE|NUM_ARGS|PREFERRED_WORK_GROUP_SIZE_MULTIPLE|PRIVATE_MEM_SIZE|PROGRAM|REFERENCE_COUNT|SUB_GROUP_COUNT_FOR_NDRANGE|WORK_GROUP_SIZE)|LINKER_NOT_AVAILABLE|LINK_PROGRAM_FAILURE|LOCAL|LUMINANCE|MAP_(?:FAILURE|READ|WRITE|WRITE_INVALIDATE_REGION)|MEM_(?:ALLOC_HOST_PTR|ASSOCIATED_MEMOBJECT|CONTEXT|COPY_HOST_PTR|COPY_OVERLAP|FLAGS|HOST_NO_ACCESS|HOST_PTR|HOST_READ_ONLY|HOST_WRITE_ONLY|KERNEL_READ_AND_WRITE|MAP_COUNT|OBJECT_(?:ALLOCATION_FAILURE|BUFFER|IMAGE1D|IMAGE1D_ARRAY|IMAGE1D_BUFFER|IMAGE2D|IMAGE2D_ARRAY|IMAGE3D|PIPE)|OFFSET|READ_ONLY|READ_WRITE|REFERENCE_COUNT|SIZE|SVM_ATOMICS|SVM_FINE_GRAIN_BUFFER|TYPE|USES_SVM_POINTER|USE_HOST_PTR|WRITE_ONLY)|MIGRATE_MEM_OBJECT_(?:CONTENT_UNDEFINED|HOST)|MISALIGNED_SUB_BUFFER_OFFSET|NONE|NON_BLOCKING|OUT_OF_(?:HOST_MEMORY|RESOURCES)|PIPE_(?:MAX_PACKETS|PACKET_SIZE)|PLATFORM_(?:EXTENSIONS|HOST_TIMER_RESOLUTION|NAME|PROFILE|VENDOR|VERSION)|PROFILING_(?:COMMAND_(?:COMPLETE|END|QUEUED|START|SUBMIT)|INFO_NOT_AVAILABLE)|PROGRAM_(?:BINARIES|BINARY_SIZES|BINARY_TYPE(?:_COMPILED_OBJECT|_EXECUTABLE|_LIBRARY|_NONE)?|BUILD_(?:GLOBAL_VARIABLE_TOTAL_SIZE|LOG|OPTIONS|STATUS)|CONTEXT|DEVICES|IL|KERNEL_NAMES|NUM_DEVICES|NUM_KERNELS|REFERENCE_COUNT|SOURCE)|QUEUED|QUEUE_(?:CONTEXT|DEVICE|DEVICE_DEFAULT|ON_DEVICE|ON_DEVICE_DEFAULT|OUT_OF_ORDER_EXEC_MODE_ENABLE|PROFILING_ENABLE|PROPERTIES|REFERENCE_COUNT|SIZE)|R|RA|READ_(?:ONLY|WRITE)_CACHE|RG|RGB|RGBA|RGBx|RGx|RUNNING|Rx|SAMPLER_(?:ADDRESSING_MODE|CONTEXT|FILTER_MODE|LOD_MAX|LOD_MIN|MIP_FILTER_MODE|NORMALIZED_COORDS|REFERENCE_COUNT)|(?:UN)?SIGNED_INT(?:8|16|32)|SNORM_INT(?:8|16)|SUBMITTED|SUCCESS|UNORM_INT(?:8|16|24|_101010|_101010_2)|UNORM_SHORT_(?:555|565)|VERSION_(?:1_0|1_1|1_2|2_0|2_1)|sBGRA|sRGB|sRGBA|sRGBx)\b/,
				alias: "constant"
			},
			"function-opencl-host": {
				pattern: /\bcl(?:BuildProgram|CloneKernel|CompileProgram|Create(?:Buffer|CommandQueue(?:WithProperties)?|Context|ContextFromType|Image|Image2D|Image3D|Kernel|KernelsInProgram|Pipe|ProgramWith(?:Binary|BuiltInKernels|IL|Source)|Sampler|SamplerWithProperties|SubBuffer|SubDevices|UserEvent)|Enqueue(?:(?:Barrier|Marker)(?:WithWaitList)?|Copy(?:Buffer(?:Rect|ToImage)?|Image(?:ToBuffer)?)|(?:Fill|Map)(?:Buffer|Image)|MigrateMemObjects|NDRangeKernel|NativeKernel|(?:Read|Write)(?:Buffer(?:Rect)?|Image)|SVM(?:Free|Map|MemFill|Memcpy|MigrateMem|Unmap)|Task|UnmapMemObject|WaitForEvents)|Finish|Flush|Get(?:CommandQueueInfo|ContextInfo|Device(?:AndHostTimer|IDs|Info)|Event(?:Profiling)?Info|ExtensionFunctionAddress(?:ForPlatform)?|HostTimer|ImageInfo|Kernel(?:ArgInfo|Info|SubGroupInfo|WorkGroupInfo)|MemObjectInfo|PipeInfo|Platform(?:IDs|Info)|Program(?:Build)?Info|SamplerInfo|SupportedImageFormats)|LinkProgram|(?:Release|Retain)(?:CommandQueue|Context|Device|Event|Kernel|MemObject|Program|Sampler)|SVM(?:Alloc|Free)|Set(?:CommandQueueProperty|DefaultDeviceCommandQueue|EventCallback|Kernel|Kernel(?:Arg(?:SVMPointer)?|ExecInfo)|MemObjectDestructorCallback|UserEventStatus)|Unload(?:Platform)?Compiler|WaitForEvents)\b/,
				alias: "function"
			}
		};
		Prism$2.languages.insertBefore("c", "keyword", attributes$1);
		if (Prism$2.languages.cpp) {
			attributes$1["type-opencl-host-cpp"] = {
				pattern: /\b(?:Buffer|BufferGL|BufferRenderGL|CommandQueue|Context|Device|DeviceCommandQueue|EnqueueArgs|Event|Image|Image1D|Image1DArray|Image1DBuffer|Image2D|Image2DArray|Image2DGL|Image3D|Image3DGL|ImageFormat|ImageGL|Kernel|KernelFunctor|LocalSpaceArg|Memory|NDRange|Pipe|Platform|Program|SVMAllocator|SVMTraitAtomic|SVMTraitCoarse|SVMTraitFine|SVMTraitReadOnly|SVMTraitReadWrite|SVMTraitWriteOnly|Sampler|UserEvent)\b/,
				alias: "keyword"
			};
			Prism$2.languages.insertBefore("cpp", "keyword", attributes$1);
		}
	})(Prism$1);
}
openqasm.displayName = "openqasm";
openqasm.aliases = ["qasm"];
function openqasm(Prism$1) {
	Prism$1.languages.openqasm = {
		comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
		string: {
			pattern: /"[^"\r\n\t]*"|'[^'\r\n\t]*'/,
			greedy: true
		},
		keyword: /\b(?:CX|OPENQASM|U|barrier|boxas|boxto|break|const|continue|ctrl|def|defcal|defcalgrammar|delay|else|end|for|gate|gphase|if|in|include|inv|kernel|lengthof|let|measure|pow|reset|return|rotary|stretchinf|while)\b|#pragma\b/,
		"class-name": /\b(?:angle|bit|bool|creg|fixed|float|int|length|qreg|qubit|stretch|uint)\b/,
		function: /\b(?:cos|exp|ln|popcount|rotl|rotr|sin|sqrt|tan)\b(?=\s*\()/,
		constant: /\b(?:euler|pi|tau)\b|π|𝜏|ℇ/,
		number: {
			pattern: /(^|[^.\w$])(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?(?:dt|ns|us|µs|ms|s)?/i,
			lookbehind: true
		},
		operator: /->|>>=?|<<=?|&&|\|\||\+\+|--|[!=<>&|~^+\-*/%]=?|@/,
		punctuation: /[(){}\[\];,:.]/
	};
	Prism$1.languages.qasm = Prism$1.languages.openqasm;
}
oz.displayName = "oz";
oz.aliases = [];
function oz(Prism$1) {
	Prism$1.languages.oz = {
		comment: {
			pattern: /\/\*[\s\S]*?\*\/|%.*/,
			greedy: true
		},
		string: {
			pattern: /"(?:[^"\\]|\\[\s\S])*"/,
			greedy: true
		},
		atom: {
			pattern: /'(?:[^'\\]|\\[\s\S])*'/,
			greedy: true,
			alias: "builtin"
		},
		keyword: /\$|\[\]|\b(?:_|at|attr|case|catch|choice|class|cond|declare|define|dis|else(?:case|if)?|end|export|fail|false|feat|finally|from|fun|functor|if|import|in|local|lock|meth|nil|not|of|or|prepare|proc|prop|raise|require|self|skip|then|thread|true|try|unit)\b/,
		function: [/\b[a-z][A-Za-z\d]*(?=\()/, {
			pattern: /(\{)[A-Z][A-Za-z\d]*\b/,
			lookbehind: true
		}],
		number: /\b(?:0[bx][\da-f]+|\d+(?:\.\d*)?(?:e~?\d+)?)\b|&(?:[^\\]|\\(?:\d{3}|.))/i,
		variable: /`(?:[^`\\]|\\.)+`/,
		"attr-name": /\b\w+(?=[ \t]*:(?![:=]))/,
		operator: /:(?:=|::?)|<[-:=]?|=(?:=|<?:?)|>=?:?|\\=:?|!!?|[|#+\-*\/,~^@]|\b(?:andthen|div|mod|orelse)\b/,
		punctuation: /[\[\](){}.:;?]/
	};
}
parigp.displayName = "parigp";
parigp.aliases = [];
function parigp(Prism$1) {
	Prism$1.languages.parigp = {
		comment: /\/\*[\s\S]*?\*\/|\\\\.*/,
		string: {
			pattern: /"(?:[^"\\\r\n]|\\.)*"/,
			greedy: true
		},
		keyword: function() {
			var keywords = [
				"breakpoint",
				"break",
				"dbg_down",
				"dbg_err",
				"dbg_up",
				"dbg_x",
				"forcomposite",
				"fordiv",
				"forell",
				"forpart",
				"forprime",
				"forstep",
				"forsubgroup",
				"forvec",
				"for",
				"iferr",
				"if",
				"local",
				"my",
				"next",
				"return",
				"until",
				"while"
			];
			keywords = keywords.map(function(keyword) {
				return keyword.split("").join(" *");
			}).join("|");
			return RegExp("\\b(?:" + keywords + ")\\b");
		}(),
		function: /\b\w(?:[\w ]*\w)?(?= *\()/,
		number: {
			pattern: /((?:\. *\. *)?)(?:\b\d(?: *\d)*(?: *(?!\. *\.)\.(?: *\d)*)?|\. *\d(?: *\d)*)(?: *e *(?:[+-] *)?\d(?: *\d)*)?/i,
			lookbehind: true
		},
		operator: /\. *\.|[*\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\+(?: *[+=])?|-(?: *[-=>])?|<(?: *>|(?: *<)?(?: *=)?)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\(?: *\/)?(?: *=)?|&(?: *&)?|\| *\||['#~^]/,
		punctuation: /[\[\]{}().,:;|]/
	};
}
parser.displayName = "parser";
parser.aliases = [];
function parser(Prism$1) {
	Prism$1.register(markup);
	(function(Prism$2) {
		var parser$1 = Prism$2.languages.parser = Prism$2.languages.extend("markup", {
			keyword: {
				pattern: /(^|[^^])(?:\^(?:case|eval|for|if|switch|throw)\b|@(?:BASE|CLASS|GET(?:_DEFAULT)?|OPTIONS|SET_DEFAULT|USE)\b)/,
				lookbehind: true
			},
			variable: {
				pattern: /(^|[^^])\B\$(?:\w+|(?=[.{]))(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
				lookbehind: true,
				inside: { punctuation: /\.|:+/ }
			},
			function: {
				pattern: /(^|[^^])\B[@^]\w+(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
				lookbehind: true,
				inside: {
					keyword: {
						pattern: /(^@)(?:GET_|SET_)/,
						lookbehind: true
					},
					punctuation: /\.|:+/
				}
			},
			escape: {
				pattern: /\^(?:[$^;@()\[\]{}"':]|#[a-f\d]*)/i,
				alias: "builtin"
			},
			punctuation: /[\[\](){};]/
		});
		parser$1 = Prism$2.languages.insertBefore("parser", "keyword", {
			"parser-comment": {
				pattern: /(\s)#.*/,
				lookbehind: true,
				alias: "comment"
			},
			expression: {
				pattern: /(^|[^^])\((?:[^()]|\((?:[^()]|\((?:[^()])*\))*\))*\)/,
				greedy: true,
				lookbehind: true,
				inside: {
					string: {
						pattern: /(^|[^^])(["'])(?:(?!\2)[^^]|\^[\s\S])*\2/,
						lookbehind: true
					},
					keyword: parser$1.keyword,
					variable: parser$1.variable,
					function: parser$1.function,
					boolean: /\b(?:false|true)\b/,
					number: /\b(?:0x[a-f\d]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?)\b/i,
					escape: parser$1.escape,
					operator: /[~+*\/\\%]|!(?:\|\|?|=)?|&&?|\|\|?|==|<[<=]?|>[>=]?|-[fd]?|\b(?:def|eq|ge|gt|in|is|le|lt|ne)\b/,
					punctuation: parser$1.punctuation
				}
			}
		});
		Prism$2.languages.insertBefore("inside", "punctuation", {
			expression: parser$1.expression,
			keyword: parser$1.keyword,
			variable: parser$1.variable,
			function: parser$1.function,
			escape: parser$1.escape,
			"parser-punctuation": {
				pattern: parser$1.punctuation,
				alias: "punctuation"
			}
		}, parser$1["tag"].inside["attr-value"]);
	})(Prism$1);
}
pascal.displayName = "pascal";
pascal.aliases = ["objectpascal"];
function pascal(Prism$1) {
	Prism$1.languages.pascal = {
		directive: {
			pattern: /\{\$[\s\S]*?\}/,
			greedy: true,
			alias: ["marco", "property"]
		},
		comment: {
			pattern: /\(\*[\s\S]*?\*\)|\{[\s\S]*?\}|\/\/.*/,
			greedy: true
		},
		string: {
			pattern: /(?:'(?:''|[^'\r\n])*'(?!')|#[&$%]?[a-f\d]+)+|\^[a-z]/i,
			greedy: true
		},
		asm: {
			pattern: /(\basm\b)[\s\S]+?(?=\bend\s*[;[])/i,
			lookbehind: true,
			greedy: true,
			inside: null
		},
		keyword: [
			{
				pattern: /(^|[^&])\b(?:absolute|array|asm|begin|case|const|constructor|destructor|do|downto|else|end|file|for|function|goto|if|implementation|inherited|inline|interface|label|nil|object|of|operator|packed|procedure|program|record|reintroduce|repeat|self|set|string|then|to|type|unit|until|uses|var|while|with)\b/i,
				lookbehind: true
			},
			{
				pattern: /(^|[^&])\b(?:dispose|exit|false|new|true)\b/i,
				lookbehind: true
			},
			{
				pattern: /(^|[^&])\b(?:class|dispinterface|except|exports|finalization|finally|initialization|inline|library|on|out|packed|property|raise|resourcestring|threadvar|try)\b/i,
				lookbehind: true
			},
			{
				pattern: /(^|[^&])\b(?:absolute|abstract|alias|assembler|bitpacked|break|cdecl|continue|cppdecl|cvar|default|deprecated|dynamic|enumerator|experimental|export|external|far|far16|forward|generic|helper|implements|index|interrupt|iochecks|local|message|name|near|nodefault|noreturn|nostackframe|oldfpccall|otherwise|overload|override|pascal|platform|private|protected|public|published|read|register|reintroduce|result|safecall|saveregisters|softfloat|specialize|static|stdcall|stored|strict|unaligned|unimplemented|varargs|virtual|write)\b/i,
				lookbehind: true
			}
		],
		number: [/(?:[&%]\d+|\$[a-f\d]+)/i, /\b\d+(?:\.\d+)?(?:e[+-]?\d+)?/i],
		operator: [/\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=]/, {
			pattern: /(^|[^&])\b(?:and|as|div|exclude|in|include|is|mod|not|or|shl|shr|xor)\b/,
			lookbehind: true
		}],
		punctuation: /\(\.|\.\)|[()\[\]:;,.]/
	};
	Prism$1.languages.pascal.asm.inside = Prism$1.languages.extend("pascal", {
		asm: void 0,
		keyword: void 0,
		operator: void 0
	});
	Prism$1.languages.objectpascal = Prism$1.languages.pascal;
}
pascaligo.displayName = "pascaligo";
pascaligo.aliases = [];
function pascaligo(Prism$1) {
	(function(Prism$2) {
		var braces = /\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\)/.source;
		var type = /(?:\b\w+(?:<braces>)?|<braces>)/.source.replace(/<braces>/g, function() {
			return braces;
		});
		var pascaligo$1 = Prism$2.languages.pascaligo = {
			comment: /\(\*[\s\S]+?\*\)|\/\/.*/,
			string: {
				pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1|\^[a-z]/i,
				greedy: true
			},
			"class-name": [
				{
					pattern: RegExp(/(\btype\s+\w+\s+is\s+)<type>/.source.replace(/<type>/g, function() {
						return type;
					}), "i"),
					lookbehind: true,
					inside: null
				},
				{
					pattern: RegExp(/<type>(?=\s+is\b)/.source.replace(/<type>/g, function() {
						return type;
					}), "i"),
					inside: null
				},
				{
					pattern: RegExp(/(:\s*)<type>/.source.replace(/<type>/g, function() {
						return type;
					})),
					lookbehind: true,
					inside: null
				}
			],
			keyword: {
				pattern: /(^|[^&])\b(?:begin|block|case|const|else|end|fail|for|from|function|if|is|nil|of|remove|return|skip|then|type|var|while|with)\b/i,
				lookbehind: true
			},
			boolean: {
				pattern: /(^|[^&])\b(?:False|True)\b/i,
				lookbehind: true
			},
			builtin: {
				pattern: /(^|[^&])\b(?:bool|int|list|map|nat|record|string|unit)\b/i,
				lookbehind: true
			},
			function: /\b\w+(?=\s*\()/,
			number: [/%[01]+|&[0-7]+|\$[a-f\d]+/i, /\b\d+(?:\.\d+)?(?:e[+-]?\d+)?(?:mtz|n)?/i],
			operator: /->|=\/=|\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=|]|\b(?:and|mod|or)\b/,
			punctuation: /\(\.|\.\)|[()\[\]:;,.{}]/
		};
		var classNameInside = [
			"comment",
			"keyword",
			"builtin",
			"operator",
			"punctuation"
		].reduce(function(accum, key) {
			accum[key] = pascaligo$1[key];
			return accum;
		}, {});
		pascaligo$1["class-name"].forEach(function(p$1) {
			p$1.inside = classNameInside;
		});
	})(Prism$1);
}
psl.displayName = "psl";
psl.aliases = [];
function psl(Prism$1) {
	Prism$1.languages.psl = {
		comment: {
			pattern: /#.*/,
			greedy: true
		},
		string: {
			pattern: /"(?:\\.|[^\\"])*"/,
			greedy: true,
			inside: { symbol: /\\[ntrbA-Z"\\]/ }
		},
		"heredoc-string": {
			pattern: /<<<([a-zA-Z_]\w*)[\r\n](?:.*[\r\n])*?\1\b/,
			alias: "string",
			greedy: true
		},
		keyword: /\b(?:__multi|__single|case|default|do|else|elsif|exit|export|for|foreach|function|if|last|line|local|next|requires|return|switch|until|while|word)\b/,
		constant: /\b(?:ALARM|CHART_ADD_GRAPH|CHART_DELETE_GRAPH|CHART_DESTROY|CHART_LOAD|CHART_PRINT|EOF|OFFLINE|OK|PSL_PROF_LOG|R_CHECK_HORIZ|R_CHECK_VERT|R_CLICKER|R_COLUMN|R_FRAME|R_ICON|R_LABEL|R_LABEL_CENTER|R_LIST_MULTIPLE|R_LIST_MULTIPLE_ND|R_LIST_SINGLE|R_LIST_SINGLE_ND|R_MENU|R_POPUP|R_POPUP_SCROLLED|R_RADIO_HORIZ|R_RADIO_VERT|R_ROW|R_SCALE_HORIZ|R_SCALE_VERT|R_SEP_HORIZ|R_SEP_VERT|R_SPINNER|R_TEXT_FIELD|R_TEXT_FIELD_LABEL|R_TOGGLE|TRIM_LEADING|TRIM_LEADING_AND_TRAILING|TRIM_REDUNDANT|TRIM_TRAILING|VOID|WARN)\b/,
		boolean: /\b(?:FALSE|False|NO|No|TRUE|True|YES|Yes|false|no|true|yes)\b/,
		variable: /\b(?:PslDebug|errno|exit_status)\b/,
		builtin: {
			pattern: /\b(?:PslExecute|PslFunctionCall|PslFunctionExists|PslSetOptions|_snmp_debug|acos|add_diary|annotate|annotate_get|ascii_to_ebcdic|asctime|asin|atan|atexit|batch_set|blackout|cat|ceil|chan_exists|change_state|close|code_cvt|cond_signal|cond_wait|console_type|convert_base|convert_date|convert_locale_date|cos|cosh|create|date|dcget_text|destroy|destroy_lock|dget_text|difference|dump_hist|ebcdic_to_ascii|encrypt|event_archive|event_catalog_get|event_check|event_query|event_range_manage|event_range_query|event_report|event_schedule|event_trigger|event_trigger2|execute|exists|exp|fabs|file|floor|fmod|fopen|fseek|ftell|full_discovery|get|get_chan_info|get_ranges|get_text|get_vars|getenv|gethostinfo|getpid|getpname|grep|history|history_get_retention|in_transition|index|int|internal|intersection|is_var|isnumber|join|kill|length|lines|lock|lock_info|log|log10|loge|matchline|msg_check|msg_get_format|msg_get_severity|msg_printf|msg_sprintf|ntharg|nthargf|nthline|nthlinef|num_bytes|num_consoles|pconfig|popen|poplines|pow|print|printf|proc_exists|process|random|read|readln|refresh_parameters|remote_check|remote_close|remote_event_query|remote_event_trigger|remote_file_send|remote_open|remove|replace|rindex|sec_check_priv|sec_store_get|sec_store_set|set|set_alarm_ranges|set_locale|share|sin|sinh|sleep|snmp_agent_config|snmp_agent_start|snmp_agent_stop|snmp_close|snmp_config|snmp_get|snmp_get_next|snmp_h_get|snmp_h_get_next|snmp_h_set|snmp_open|snmp_set|snmp_trap_ignore|snmp_trap_listen|snmp_trap_raise_std_trap|snmp_trap_receive|snmp_trap_register_im|snmp_trap_send|snmp_walk|sopen|sort|splitline|sprintf|sqrt|srandom|str_repeat|strcasecmp|subset|substr|system|tail|tan|tanh|text_domain|time|tmpnam|tolower|toupper|trace_psl_process|trim|union|unique|unlock|unset|va_arg|va_start|write)\b/,
			alias: "builtin-function"
		},
		"foreach-variable": {
			pattern: /(\bforeach\s+(?:(?:\w+\b|"(?:\\.|[^\\"])*")\s+){0,2})[_a-zA-Z]\w*(?=\s*\()/,
			lookbehind: true,
			greedy: true
		},
		function: /\b[_a-z]\w*\b(?=\s*\()/i,
		number: /\b(?:0x[0-9a-f]+|\d+(?:\.\d+)?)\b/i,
		operator: /--|\+\+|&&=?|\|\|=?|<<=?|>>=?|[=!]~|[-+*/%&|^!=<>]=?|\.|[:?]/,
		punctuation: /[(){}\[\];,]/
	};
}
pcaxis.displayName = "pcaxis";
pcaxis.aliases = ["px"];
function pcaxis(Prism$1) {
	Prism$1.languages.pcaxis = {
		string: /"[^"]*"/,
		keyword: {
			pattern: /((?:^|;)\s*)[-A-Z\d]+(?:\s*\[[-\w]+\])?(?:\s*\("[^"]*"(?:,\s*"[^"]*")*\))?(?=\s*=)/,
			lookbehind: true,
			greedy: true,
			inside: {
				keyword: /^[-A-Z\d]+/,
				language: {
					pattern: /^(\s*)\[[-\w]+\]/,
					lookbehind: true,
					inside: {
						punctuation: /^\[|\]$/,
						property: /[-\w]+/
					}
				},
				"sub-key": {
					pattern: /^(\s*)\S[\s\S]*/,
					lookbehind: true,
					inside: {
						parameter: {
							pattern: /"[^"]*"/,
							alias: "property"
						},
						punctuation: /^\(|\)$|,/
					}
				}
			}
		},
		operator: /=/,
		tlist: {
			pattern: /TLIST\s*\(\s*\w+(?:(?:\s*,\s*"[^"]*")+|\s*,\s*"[^"]*"-"[^"]*")?\s*\)/,
			greedy: true,
			inside: {
				function: /^TLIST/,
				property: {
					pattern: /^(\s*\(\s*)\w+/,
					lookbehind: true
				},
				string: /"[^"]*"/,
				punctuation: /[(),]/,
				operator: /-/
			}
		},
		punctuation: /[;,]/,
		number: {
			pattern: /(^|\s)\d+(?:\.\d+)?(?!\S)/,
			lookbehind: true
		},
		boolean: /NO|YES/
	};
	Prism$1.languages.px = Prism$1.languages.pcaxis;
}
peoplecode.displayName = "peoplecode";
peoplecode.aliases = ["pcode"];
function peoplecode(Prism$1) {
	Prism$1.languages.peoplecode = {
		comment: RegExp([
			/\/\*[\s\S]*?\*\//.source,
			/\bREM[^;]*;/.source,
			/<\*(?:[^<*]|\*(?!>)|<(?!\*)|<\*(?:(?!\*>)[\s\S])*\*>)*\*>/.source,
			/\/\+[\s\S]*?\+\//.source
		].join("|")),
		string: {
			pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
			greedy: true
		},
		variable: /%\w+/,
		"function-definition": {
			pattern: /((?:^|[^\w-])(?:function|method)\s+)\w+/i,
			lookbehind: true,
			alias: "function"
		},
		"class-name": {
			pattern: /((?:^|[^-\w])(?:as|catch|class|component|create|extends|global|implements|instance|local|of|property|returns)\s+)\w+(?::\w+)*/i,
			lookbehind: true,
			inside: { punctuation: /:/ }
		},
		keyword: /\b(?:abstract|alias|as|catch|class|component|constant|create|declare|else|end-(?:class|evaluate|for|function|get|if|method|set|try|while)|evaluate|extends|for|function|get|global|if|implements|import|instance|library|local|method|null|of|out|peopleCode|private|program|property|protected|readonly|ref|repeat|returns?|set|step|then|throw|to|try|until|value|when(?:-other)?|while)\b/i,
		"operator-keyword": {
			pattern: /\b(?:and|not|or)\b/i,
			alias: "operator"
		},
		function: /[_a-z]\w*(?=\s*\()/i,
		boolean: /\b(?:false|true)\b/i,
		number: /\b\d+(?:\.\d+)?\b/,
		operator: /<>|[<>]=?|!=|\*\*|[-+*/|=@]/,
		punctuation: /[:.;,()[\]]/
	};
	Prism$1.languages.pcode = Prism$1.languages.peoplecode;
}
phpdoc.displayName = "phpdoc";
phpdoc.aliases = [];
function phpdoc(Prism$1) {
	Prism$1.register(javadoclike);
	Prism$1.register(php);
	(function(Prism$2) {
		var typeExpression = /(?:\b[a-zA-Z]\w*|[|\\[\]])+/.source;
		Prism$2.languages.phpdoc = Prism$2.languages.extend("javadoclike", { parameter: {
			pattern: RegExp("(@(?:global|param|property(?:-read|-write)?|var)\\s+(?:" + typeExpression + "\\s+)?)\\$\\w+"),
			lookbehind: true
		} });
		Prism$2.languages.insertBefore("phpdoc", "keyword", { "class-name": [{
			pattern: RegExp("(@(?:global|package|param|property(?:-read|-write)?|return|subpackage|throws|var)\\s+)" + typeExpression),
			lookbehind: true,
			inside: {
				keyword: /\b(?:array|bool|boolean|callback|double|false|float|int|integer|mixed|null|object|resource|self|string|true|void)\b/,
				punctuation: /[|\\[\]()]/
			}
		}] });
		Prism$2.languages.javadoclike.addSupport("php", Prism$2.languages.phpdoc);
	})(Prism$1);
}
phpExtras.displayName = "php-extras";
phpExtras.aliases = [];
function phpExtras(Prism$1) {
	Prism$1.register(php);
	Prism$1.languages.insertBefore("php", "variable", {
		this: {
			pattern: /\$this\b/,
			alias: "keyword"
		},
		global: /\$(?:GLOBALS|HTTP_RAW_POST_DATA|_(?:COOKIE|ENV|FILES|GET|POST|REQUEST|SERVER|SESSION)|argc|argv|http_response_header|php_errormsg)\b/,
		scope: {
			pattern: /\b[\w\\]+::/,
			inside: {
				keyword: /\b(?:parent|self|static)\b/,
				punctuation: /::|\\/
			}
		}
	});
}
plantUml.displayName = "plant-uml";
plantUml.aliases = ["plantuml"];
function plantUml(Prism$1) {
	(function(Prism$2) {
		var variable = /\$\w+|%[a-z]+%/;
		var arrowAttr = /\[[^[\]]*\]/.source;
		var arrowDirection = /(?:[drlu]|do|down|le|left|ri|right|up)/.source;
		var arrowBody = "(?:-+" + arrowDirection + "-+|\\.+" + arrowDirection + "\\.+|-+(?:" + arrowAttr + "-*)?|" + arrowAttr + "-+|\\.+(?:" + arrowAttr + "\\.*)?|" + arrowAttr + "\\.+)";
		var arrowLeft = /(?:<{1,2}|\/{1,2}|\\{1,2}|<\||[#*^+}xo])/.source;
		var arrowRight = /(?:>{1,2}|\/{1,2}|\\{1,2}|\|>|[#*^+{xo])/.source;
		var arrowPrefix = /[[?]?[ox]?/.source;
		var arrowSuffix = /[ox]?[\]?]?/.source;
		var arrow = arrowPrefix + "(?:" + arrowBody + arrowRight + "|" + arrowLeft + arrowBody + "(?:" + arrowRight + ")?)" + arrowSuffix;
		Prism$2.languages["plant-uml"] = {
			comment: {
				pattern: /(^[ \t]*)(?:'.*|\/'[\s\S]*?'\/)/m,
				lookbehind: true,
				greedy: true
			},
			preprocessor: {
				pattern: /(^[ \t]*)!.*/m,
				lookbehind: true,
				greedy: true,
				alias: "property",
				inside: { variable }
			},
			delimiter: {
				pattern: /(^[ \t]*)@(?:end|start)uml\b/m,
				lookbehind: true,
				greedy: true,
				alias: "punctuation"
			},
			arrow: {
				pattern: RegExp(/(^|[^-.<>?|\\[\]ox])/.source + arrow + /(?![-.<>?|\\\]ox])/.source),
				lookbehind: true,
				greedy: true,
				alias: "operator",
				inside: {
					expression: {
						pattern: /(\[)[^[\]]+(?=\])/,
						lookbehind: true,
						inside: null
					},
					punctuation: /\[(?=$|\])|^\]/
				}
			},
			string: {
				pattern: /"[^"]*"/,
				greedy: true
			},
			text: {
				pattern: /(\[[ \t]*[\r\n]+(?![\r\n]))[^\]]*(?=\])/,
				lookbehind: true,
				greedy: true,
				alias: "string"
			},
			keyword: [
				{
					pattern: /^([ \t]*)(?:abstract\s+class|end\s+(?:box|fork|group|merge|note|ref|split|title)|(?:fork|split)(?:\s+again)?|activate|actor|agent|alt|annotation|artifact|autoactivate|autonumber|backward|binary|boundary|box|break|caption|card|case|circle|class|clock|cloud|collections|component|concise|control|create|critical|database|deactivate|destroy|detach|diamond|else|elseif|end|end[hr]note|endif|endswitch|endwhile|entity|enum|file|folder|footer|frame|group|[hr]?note|header|hexagon|hide|if|interface|label|legend|loop|map|namespace|network|newpage|node|nwdiag|object|opt|package|page|par|participant|person|queue|rectangle|ref|remove|repeat|restore|return|robust|scale|set|show|skinparam|stack|start|state|stop|storage|switch|title|together|usecase|usecase\/|while)(?=\s|$)/m,
					lookbehind: true,
					greedy: true
				},
				/\b(?:elseif|equals|not|while)(?=\s*\()/,
				/\b(?:as|is|then)\b/
			],
			divider: {
				pattern: /^==.+==$/m,
				greedy: true,
				alias: "important"
			},
			time: {
				pattern: /@(?:\d+(?:[:/]\d+){2}|[+-]?\d+|:[a-z]\w*(?:[+-]\d+)?)\b/i,
				greedy: true,
				alias: "number"
			},
			color: {
				pattern: /#(?:[a-z_]+|[a-fA-F0-9]+)\b/,
				alias: "symbol"
			},
			variable,
			punctuation: /[:,;()[\]{}]|\.{3}/
		};
		Prism$2.languages["plant-uml"].arrow.inside.expression.inside = Prism$2.languages["plant-uml"];
		Prism$2.languages["plantuml"] = Prism$2.languages["plant-uml"];
	})(Prism$1);
}
plsql.displayName = "plsql";
plsql.aliases = [];
function plsql(Prism$1) {
	Prism$1.register(sql);
	Prism$1.languages.plsql = Prism$1.languages.extend("sql", {
		comment: {
			pattern: /\/\*[\s\S]*?\*\/|--.*/,
			greedy: true
		},
		keyword: /\b(?:A|ACCESSIBLE|ADD|AGENT|AGGREGATE|ALL|ALTER|AND|ANY|ARRAY|AS|ASC|AT|ATTRIBUTE|AUTHID|AVG|BEGIN|BETWEEN|BFILE_BASE|BINARY|BLOB_BASE|BLOCK|BODY|BOTH|BOUND|BULK|BY|BYTE|C|CALL|CALLING|CASCADE|CASE|CHAR|CHARACTER|CHARSET|CHARSETFORM|CHARSETID|CHAR_BASE|CHECK|CLOB_BASE|CLONE|CLOSE|CLUSTER|CLUSTERS|COLAUTH|COLLECT|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPILED|COMPRESS|CONNECT|CONSTANT|CONSTRUCTOR|CONTEXT|CONTINUE|CONVERT|COUNT|CRASH|CREATE|CREDENTIAL|CURRENT|CURSOR|CUSTOMDATUM|DANGLING|DATA|DATE|DATE_BASE|DAY|DECLARE|DEFAULT|DEFINE|DELETE|DESC|DETERMINISTIC|DIRECTORY|DISTINCT|DOUBLE|DROP|DURATION|ELEMENT|ELSE|ELSIF|EMPTY|END|ESCAPE|EXCEPT|EXCEPTION|EXCEPTIONS|EXCLUSIVE|EXECUTE|EXISTS|EXIT|EXTERNAL|FETCH|FINAL|FIRST|FIXED|FLOAT|FOR|FORALL|FORCE|FROM|FUNCTION|GENERAL|GOTO|GRANT|GROUP|HASH|HAVING|HEAP|HIDDEN|HOUR|IDENTIFIED|IF|IMMEDIATE|IMMUTABLE|IN|INCLUDING|INDEX|INDEXES|INDICATOR|INDICES|INFINITE|INSERT|INSTANTIABLE|INT|INTERFACE|INTERSECT|INTERVAL|INTO|INVALIDATE|IS|ISOLATION|JAVA|LANGUAGE|LARGE|LEADING|LENGTH|LEVEL|LIBRARY|LIKE|LIKE2|LIKE4|LIKEC|LIMIT|LIMITED|LOCAL|LOCK|LONG|LOOP|MAP|MAX|MAXLEN|MEMBER|MERGE|MIN|MINUS|MINUTE|MOD|MODE|MODIFY|MONTH|MULTISET|MUTABLE|NAME|NAN|NATIONAL|NATIVE|NCHAR|NEW|NOCOMPRESS|NOCOPY|NOT|NOWAIT|NULL|NUMBER_BASE|OBJECT|OCICOLL|OCIDATE|OCIDATETIME|OCIDURATION|OCIINTERVAL|OCILOBLOCATOR|OCINUMBER|OCIRAW|OCIREF|OCIREFCURSOR|OCIROWID|OCISTRING|OCITYPE|OF|OLD|ON|ONLY|OPAQUE|OPEN|OPERATOR|OPTION|OR|ORACLE|ORADATA|ORDER|ORGANIZATION|ORLANY|ORLVARY|OTHERS|OUT|OVERLAPS|OVERRIDING|PACKAGE|PARALLEL_ENABLE|PARAMETER|PARAMETERS|PARENT|PARTITION|PASCAL|PERSISTABLE|PIPE|PIPELINED|PLUGGABLE|POLYMORPHIC|PRAGMA|PRECISION|PRIOR|PRIVATE|PROCEDURE|PUBLIC|RAISE|RANGE|RAW|READ|RECORD|REF|REFERENCE|RELIES_ON|REM|REMAINDER|RENAME|RESOURCE|RESULT|RESULT_CACHE|RETURN|RETURNING|REVERSE|REVOKE|ROLLBACK|ROW|SAMPLE|SAVE|SAVEPOINT|SB1|SB2|SB4|SECOND|SEGMENT|SELECT|SELF|SEPARATE|SEQUENCE|SERIALIZABLE|SET|SHARE|SHORT|SIZE|SIZE_T|SOME|SPARSE|SQL|SQLCODE|SQLDATA|SQLNAME|SQLSTATE|STANDARD|START|STATIC|STDDEV|STORED|STRING|STRUCT|STYLE|SUBMULTISET|SUBPARTITION|SUBSTITUTABLE|SUBTYPE|SUM|SYNONYM|TABAUTH|TABLE|TDO|THE|THEN|TIME|TIMESTAMP|TIMEZONE_ABBR|TIMEZONE_HOUR|TIMEZONE_MINUTE|TIMEZONE_REGION|TO|TRAILING|TRANSACTION|TRANSACTIONAL|TRUSTED|TYPE|UB1|UB2|UB4|UNDER|UNION|UNIQUE|UNPLUG|UNSIGNED|UNTRUSTED|UPDATE|USE|USING|VALIST|VALUE|VALUES|VARIABLE|VARIANCE|VARRAY|VARYING|VIEW|VIEWS|VOID|WHEN|WHERE|WHILE|WITH|WORK|WRAPPED|WRITE|YEAR|ZONE)\b/i,
		operator: /:=?|=>|[<>^~!]=|\.\.|\|\||\*\*|[-+*/%<>=@]/
	});
	Prism$1.languages.insertBefore("plsql", "operator", { label: {
		pattern: /<<\s*\w+\s*>>/,
		alias: "symbol"
	} });
}
powerquery.displayName = "powerquery";
powerquery.aliases = ["mscript", "pq"];
function powerquery(Prism$1) {
	Prism$1.languages.powerquery = {
		comment: {
			pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
			lookbehind: true,
			greedy: true
		},
		"quoted-identifier": {
			pattern: /#"(?:[^"\r\n]|"")*"(?!")/,
			greedy: true
		},
		string: {
			pattern: /(?:#!)?"(?:[^"\r\n]|"")*"(?!")/,
			greedy: true
		},
		constant: [
			/\bDay\.(?:Friday|Monday|Saturday|Sunday|Thursday|Tuesday|Wednesday)\b/,
			/\bTraceLevel\.(?:Critical|Error|Information|Verbose|Warning)\b/,
			/\bOccurrence\.(?:All|First|Last)\b/,
			/\bOrder\.(?:Ascending|Descending)\b/,
			/\bRoundingMode\.(?:AwayFromZero|Down|ToEven|TowardZero|Up)\b/,
			/\bMissingField\.(?:Error|Ignore|UseNull)\b/,
			/\bQuoteStyle\.(?:Csv|None)\b/,
			/\bJoinKind\.(?:FullOuter|Inner|LeftAnti|LeftOuter|RightAnti|RightOuter)\b/,
			/\bGroupKind\.(?:Global|Local)\b/,
			/\bExtraValues\.(?:Error|Ignore|List)\b/,
			/\bJoinAlgorithm\.(?:Dynamic|LeftHash|LeftIndex|PairwiseHash|RightHash|RightIndex|SortMerge)\b/,
			/\bJoinSide\.(?:Left|Right)\b/,
			/\bPrecision\.(?:Decimal|Double)\b/,
			/\bRelativePosition\.From(?:End|Start)\b/,
			/\bTextEncoding\.(?:Ascii|BigEndianUnicode|Unicode|Utf16|Utf8|Windows)\b/,
			/\b(?:Any|Binary|Date|DateTime|DateTimeZone|Duration|Function|Int16|Int32|Int64|Int8|List|Logical|None|Number|Record|Table|Text|Time)\.Type\b/,
			/\bnull\b/
		],
		boolean: /\b(?:false|true)\b/,
		keyword: /\b(?:and|as|each|else|error|if|in|is|let|meta|not|nullable|optional|or|otherwise|section|shared|then|try|type)\b|#(?:binary|date|datetime|datetimezone|duration|infinity|nan|sections|shared|table|time)\b/,
		function: {
			pattern: /(^|[^#\w.])[a-z_][\w.]*(?=\s*\()/i,
			lookbehind: true
		},
		"data-type": {
			pattern: /\b(?:any|anynonnull|binary|date|datetime|datetimezone|duration|function|list|logical|none|number|record|table|text|time)\b/,
			alias: "class-name"
		},
		number: {
			pattern: /\b0x[\da-f]+\b|(?:[+-]?(?:\b\d+\.)?\b\d+|[+-]\.\d+|(^|[^.])\B\.\d+)(?:e[+-]?\d+)?\b/i,
			lookbehind: true
		},
		operator: /[-+*\/&?@^]|<(?:=>?|>)?|>=?|=>?|\.\.\.?/,
		punctuation: /[,;\[\](){}]/
	};
	Prism$1.languages.pq = Prism$1.languages["powerquery"];
	Prism$1.languages.mscript = Prism$1.languages["powerquery"];
}
powershell.displayName = "powershell";
powershell.aliases = [];
function powershell(Prism$1) {
	(function(Prism$2) {
		var powershell$1 = Prism$2.languages.powershell = {
			comment: [{
				pattern: /(^|[^`])<#[\s\S]*?#>/,
				lookbehind: true
			}, {
				pattern: /(^|[^`])#.*/,
				lookbehind: true
			}],
			string: [{
				pattern: /"(?:`[\s\S]|[^`"])*"/,
				greedy: true,
				inside: null
			}, {
				pattern: /'(?:[^']|'')*'/,
				greedy: true
			}],
			namespace: /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
			boolean: /\$(?:false|true)\b/i,
			variable: /\$\w+\b/,
			function: [/\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i, /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i],
			keyword: /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
			operator: {
				pattern: /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
				lookbehind: true
			},
			punctuation: /[|{}[\];(),.]/
		};
		powershell$1.string[0].inside = {
			function: {
				pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
				lookbehind: true,
				inside: powershell$1
			},
			boolean: powershell$1.boolean,
			variable: powershell$1.variable
		};
	})(Prism$1);
}
processing.displayName = "processing";
processing.aliases = [];
function processing(Prism$1) {
	Prism$1.register(clike);
	Prism$1.languages.processing = Prism$1.languages.extend("clike", {
		keyword: /\b(?:break|case|catch|class|continue|default|else|extends|final|for|if|implements|import|new|null|private|public|return|static|super|switch|this|try|void|while)\b/,
		function: /\b\w+(?=\s*\()/,
		operator: /<[<=]?|>[>=]?|&&?|\|\|?|[%?]|[!=+\-*\/]=?/
	});
	Prism$1.languages.insertBefore("processing", "number", {
		constant: /\b(?!XML\b)[A-Z][A-Z\d_]+\b/,
		type: {
			pattern: /\b(?:boolean|byte|char|color|double|float|int|[A-Z]\w*)\b/,
			alias: "class-name"
		}
	});
}
prolog.displayName = "prolog";
prolog.aliases = [];
function prolog(Prism$1) {
	Prism$1.languages.prolog = {
		comment: {
			pattern: /\/\*[\s\S]*?\*\/|%.*/,
			greedy: true
		},
		string: {
			pattern: /(["'])(?:\1\1|\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1(?!\1)/,
			greedy: true
		},
		builtin: /\b(?:fx|fy|xf[xy]?|yfx?)\b/,
		function: /\b[a-z]\w*(?:(?=\()|\/\d+)/,
		number: /\b\d+(?:\.\d*)?/,
		operator: /[:\\=><\-?*@\/;+^|!$.]+|\b(?:is|mod|not|xor)\b/,
		punctuation: /[(){}\[\],]/
	};
}
promql.displayName = "promql";
promql.aliases = [];
function promql(Prism$1) {
	(function(Prism$2) {
		var aggregations = [
			"sum",
			"min",
			"max",
			"avg",
			"group",
			"stddev",
			"stdvar",
			"count",
			"count_values",
			"bottomk",
			"topk",
			"quantile"
		];
		var vectorMatching = [
			"on",
			"ignoring",
			"group_right",
			"group_left",
			"by",
			"without"
		];
		var offsetModifier = ["offset"];
		var keywords = aggregations.concat(vectorMatching, offsetModifier);
		Prism$2.languages.promql = {
			comment: {
				pattern: /(^[ \t]*)#.*/m,
				lookbehind: true
			},
			"vector-match": {
				pattern: new RegExp("((?:" + vectorMatching.join("|") + ")\\s*)\\([^)]*\\)"),
				lookbehind: true,
				inside: {
					"label-key": {
						pattern: /\b[^,]+\b/,
						alias: "attr-name"
					},
					punctuation: /[(),]/
				}
			},
			"context-labels": {
				pattern: /\{[^{}]*\}/,
				inside: {
					"label-key": {
						pattern: /\b[a-z_]\w*(?=\s*(?:=|![=~]))/,
						alias: "attr-name"
					},
					"label-value": {
						pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
						greedy: true,
						alias: "attr-value"
					},
					punctuation: /\{|\}|=~?|![=~]|,/
				}
			},
			"context-range": [{
				pattern: /\[[\w\s:]+\]/,
				inside: {
					punctuation: /\[|\]|:/,
					"range-duration": {
						pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
						alias: "number"
					}
				}
			}, {
				pattern: /(\boffset\s+)\w+/,
				lookbehind: true,
				inside: { "range-duration": {
					pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
					alias: "number"
				} }
			}],
			keyword: new RegExp("\\b(?:" + keywords.join("|") + ")\\b", "i"),
			function: /\b[a-z_]\w*(?=\s*\()/i,
			number: /[-+]?(?:(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[-+]?\d+)?\b|\b(?:0x[0-9a-f]+|nan|inf)\b)/i,
			operator: /[\^*/%+-]|==|!=|<=|<|>=|>|\b(?:and|or|unless)\b/i,
			punctuation: /[{};()`,.[\]]/
		};
	})(Prism$1);
}
properties.displayName = "properties";
properties.aliases = [];
function properties(Prism$1) {
	Prism$1.languages.properties = {
		comment: /^[ \t]*[#!].*$/m,
		value: {
			pattern: /(^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?: *[=:] *(?! )| ))(?:\\(?:\r\n|[\s\S])|[^\\\r\n])+/m,
			lookbehind: true,
			alias: "attr-value"
		},
		key: {
			pattern: /^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?= *[=:]| )/m,
			alias: "attr-name"
		},
		punctuation: /[=:]/
	};
}
protobuf.displayName = "protobuf";
protobuf.aliases = [];
function protobuf(Prism$1) {
	Prism$1.register(clike);
	(function(Prism$2) {
		var builtinTypes = /\b(?:bool|bytes|double|s?fixed(?:32|64)|float|[su]?int(?:32|64)|string)\b/;
		Prism$2.languages.protobuf = Prism$2.languages.extend("clike", {
			"class-name": [{
				pattern: /(\b(?:enum|extend|message|service)\s+)[A-Za-z_]\w*(?=\s*\{)/,
				lookbehind: true
			}, {
				pattern: /(\b(?:rpc\s+\w+|returns)\s*\(\s*(?:stream\s+)?)\.?[A-Za-z_]\w*(?:\.[A-Za-z_]\w*)*(?=\s*\))/,
				lookbehind: true
			}],
			keyword: /\b(?:enum|extend|extensions|import|message|oneof|option|optional|package|public|repeated|required|reserved|returns|rpc(?=\s+\w)|service|stream|syntax|to)\b(?!\s*=\s*\d)/,
			function: /\b[a-z_]\w*(?=\s*\()/i
		});
		Prism$2.languages.insertBefore("protobuf", "operator", {
			map: {
				pattern: /\bmap<\s*[\w.]+\s*,\s*[\w.]+\s*>(?=\s+[a-z_]\w*\s*[=;])/i,
				alias: "class-name",
				inside: {
					punctuation: /[<>.,]/,
					builtin: builtinTypes
				}
			},
			builtin: builtinTypes,
			"positional-class-name": {
				pattern: /(?:\b|\B\.)[a-z_]\w*(?:\.[a-z_]\w*)*(?=\s+[a-z_]\w*\s*[=;])/i,
				alias: "class-name",
				inside: { punctuation: /\./ }
			},
			annotation: {
				pattern: /(\[\s*)[a-z_]\w*(?=\s*=)/i,
				lookbehind: true
			}
		});
	})(Prism$1);
}
stylus.displayName = "stylus";
stylus.aliases = [];
function stylus(Prism$1) {
	(function(Prism$2) {
		var unit = {
			pattern: /(\b\d+)(?:%|[a-z]+)/,
			lookbehind: true
		};
		var number$2 = {
			pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
			lookbehind: true
		};
		var inside = {
			comment: {
				pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
				lookbehind: true
			},
			url: {
				pattern: /\burl\((["']?).*?\1\)/i,
				greedy: true
			},
			string: {
				pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
				greedy: true
			},
			interpolation: null,
			func: null,
			important: /\B!(?:important|optional)\b/i,
			keyword: {
				pattern: /(^|\s+)(?:(?:else|for|if|return|unless)(?=\s|$)|@[\w-]+)/,
				lookbehind: true
			},
			hexcode: /#[\da-f]{3,6}/i,
			color: [/\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i, {
				pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
				inside: {
					unit,
					number: number$2,
					function: /[\w-]+(?=\()/,
					punctuation: /[(),]/
				}
			}],
			entity: /\\[\da-f]{1,8}/i,
			unit,
			boolean: /\b(?:false|true)\b/,
			operator: [/~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.{2,3}|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/],
			number: number$2,
			punctuation: /[{}()\[\];:,]/
		};
		inside["interpolation"] = {
			pattern: /\{[^\r\n}:]+\}/,
			alias: "variable",
			inside: {
				delimiter: {
					pattern: /^\{|\}$/,
					alias: "punctuation"
				},
				rest: inside
			}
		};
		inside["func"] = {
			pattern: /[\w-]+\([^)]*\).*/,
			inside: {
				function: /^[^(]+/,
				rest: inside
			}
		};
		Prism$2.languages.stylus = {
			"atrule-declaration": {
				pattern: /(^[ \t]*)@.+/m,
				lookbehind: true,
				inside: {
					atrule: /^@[\w-]+/,
					rest: inside
				}
			},
			"variable-declaration": {
				pattern: /(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:\{[^{}]*\}|\S.*|$)/m,
				lookbehind: true,
				inside: {
					variable: /^\S+/,
					rest: inside
				}
			},
			statement: {
				pattern: /(^[ \t]*)(?:else|for|if|return|unless)[ \t].+/m,
				lookbehind: true,
				inside: {
					keyword: /^\S+/,
					rest: inside
				}
			},
			"property-declaration": {
				pattern: /((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)(?!\s)[^{\r\n]*(?:;|[^{\r\n,]$(?!(?:\r?\n|\r)(?:\{|\2[ \t])))/m,
				lookbehind: true,
				inside: {
					property: {
						pattern: /^[^\s:]+/,
						inside: { interpolation: inside.interpolation }
					},
					rest: inside
				}
			},
			selector: {
				pattern: /(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t])))/m,
				lookbehind: true,
				inside: {
					interpolation: inside.interpolation,
					comment: inside.comment,
					punctuation: /[{},]/
				}
			},
			func: inside.func,
			string: inside.string,
			comment: {
				pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
				lookbehind: true,
				greedy: true
			},
			interpolation: inside.interpolation,
			punctuation: /[{}()\[\];:.]/
		};
	})(Prism$1);
}
twig.displayName = "twig";
twig.aliases = [];
function twig(Prism$1) {
	Prism$1.register(markupTemplating);
	Prism$1.languages.twig = {
		comment: /^\{#[\s\S]*?#\}$/,
		"tag-name": {
			pattern: /(^\{%-?\s*)\w+/,
			lookbehind: true,
			alias: "keyword"
		},
		delimiter: {
			pattern: /^\{[{%]-?|-?[%}]\}$/,
			alias: "punctuation"
		},
		string: {
			pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
			inside: { punctuation: /^['"]|['"]$/ }
		},
		keyword: /\b(?:even|if|odd)\b/,
		boolean: /\b(?:false|null|true)\b/,
		number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
		operator: [{
			pattern: /(\s)(?:and|b-and|b-or|b-xor|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
			lookbehind: true
		}, /[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/],
		punctuation: /[()\[\]{}:.,]/
	};
	Prism$1.hooks.add("before-tokenize", function(env$1) {
		if (env$1.language !== "twig") return;
		var pattern = /\{(?:#[\s\S]*?#|%[\s\S]*?%|\{[\s\S]*?\})\}/g;
		Prism$1.languages["markup-templating"].buildPlaceholders(env$1, "twig", pattern);
	});
	Prism$1.hooks.add("after-tokenize", function(env$1) {
		Prism$1.languages["markup-templating"].tokenizePlaceholders(env$1, "twig");
	});
}
pug.displayName = "pug";
pug.aliases = [];
function pug(Prism$1) {
	Prism$1.register(javascript);
	Prism$1.register(markup);
	(function(Prism$2) {
		Prism$2.languages.pug = {
			comment: {
				pattern: /(^([\t ]*))\/\/.*(?:(?:\r?\n|\r)\2[\t ].+)*/m,
				lookbehind: true
			},
			"multiline-script": {
				pattern: /(^([\t ]*)script\b.*\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
				lookbehind: true,
				inside: Prism$2.languages.javascript
			},
			filter: {
				pattern: /(^([\t ]*)):.+(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
				lookbehind: true,
				inside: {
					"filter-name": {
						pattern: /^:[\w-]+/,
						alias: "variable"
					},
					text: /\S[\s\S]*/
				}
			},
			"multiline-plain-text": {
				pattern: /(^([\t ]*)[\w\-#.]+\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
				lookbehind: true
			},
			markup: {
				pattern: /(^[\t ]*)<.+/m,
				lookbehind: true,
				inside: Prism$2.languages.markup
			},
			doctype: {
				pattern: /((?:^|\n)[\t ]*)doctype(?: .+)?/,
				lookbehind: true
			},
			"flow-control": {
				pattern: /(^[\t ]*)(?:case|default|each|else|if|unless|when|while)\b(?: .+)?/m,
				lookbehind: true,
				inside: {
					each: {
						pattern: /^each .+? in\b/,
						inside: {
							keyword: /\b(?:each|in)\b/,
							punctuation: /,/
						}
					},
					branch: {
						pattern: /^(?:case|default|else|if|unless|when|while)\b/,
						alias: "keyword"
					},
					rest: Prism$2.languages.javascript
				}
			},
			keyword: {
				pattern: /(^[\t ]*)(?:append|block|extends|include|prepend)\b.+/m,
				lookbehind: true
			},
			mixin: [{
				pattern: /(^[\t ]*)mixin .+/m,
				lookbehind: true,
				inside: {
					keyword: /^mixin/,
					function: /\w+(?=\s*\(|\s*$)/,
					punctuation: /[(),.]/
				}
			}, {
				pattern: /(^[\t ]*)\+.+/m,
				lookbehind: true,
				inside: {
					name: {
						pattern: /^\+\w+/,
						alias: "function"
					},
					rest: Prism$2.languages.javascript
				}
			}],
			script: {
				pattern: /(^[\t ]*script(?:(?:&[^(]+)?\([^)]+\))*[\t ]).+/m,
				lookbehind: true,
				inside: Prism$2.languages.javascript
			},
			"plain-text": {
				pattern: /(^[\t ]*(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?[\t ]).+/m,
				lookbehind: true
			},
			tag: {
				pattern: /(^[\t ]*)(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?:?/m,
				lookbehind: true,
				inside: {
					attributes: [{
						pattern: /&[^(]+\([^)]+\)/,
						inside: Prism$2.languages.javascript
					}, {
						pattern: /\([^)]+\)/,
						inside: {
							"attr-value": {
								pattern: /(=\s*(?!\s))(?:\{[^}]*\}|[^,)\r\n]+)/,
								lookbehind: true,
								inside: Prism$2.languages.javascript
							},
							"attr-name": /[\w-]+(?=\s*!?=|\s*[,)])/,
							punctuation: /[!=(),]+/
						}
					}],
					punctuation: /:/,
					"attr-id": /#[\w\-]+/,
					"attr-class": /\.[\w\-]+/
				}
			},
			code: [{
				pattern: /(^[\t ]*(?:-|!?=)).+/m,
				lookbehind: true,
				inside: Prism$2.languages.javascript
			}],
			punctuation: /[.\-!=|]+/
		};
		var filter_pattern = /(^([\t ]*)):<filter_name>(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/.source;
		var filters = [
			{
				filter: "atpl",
				language: "twig"
			},
			{
				filter: "coffee",
				language: "coffeescript"
			},
			"ejs",
			"handlebars",
			"less",
			"livescript",
			"markdown",
			{
				filter: "sass",
				language: "scss"
			},
			"stylus"
		];
		var all_filters = {};
		for (var i = 0, l$1 = filters.length; i < l$1; i++) {
			var filter$1 = filters[i];
			filter$1 = typeof filter$1 === "string" ? {
				filter: filter$1,
				language: filter$1
			} : filter$1;
			if (Prism$2.languages[filter$1.language]) all_filters["filter-" + filter$1.filter] = {
				pattern: RegExp(filter_pattern.replace("<filter_name>", function() {
					return filter$1.filter;
				}), "m"),
				lookbehind: true,
				inside: {
					"filter-name": {
						pattern: /^:[\w-]+/,
						alias: "variable"
					},
					text: {
						pattern: /\S[\s\S]*/,
						alias: [filter$1.language, "language-" + filter$1.language],
						inside: Prism$2.languages[filter$1.language]
					}
				}
			};
		}
		Prism$2.languages.insertBefore("pug", "filter", all_filters);
	})(Prism$1);
}
puppet.displayName = "puppet";
puppet.aliases = [];
function puppet(Prism$1) {
	(function(Prism$2) {
		Prism$2.languages.puppet = {
			heredoc: [
				{
					pattern: /(@\("([^"\r\n\/):]+)"(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r(?!\n)))*?[ \t]*(?:\|[ \t]*)?(?:-[ \t]*)?\2/,
					lookbehind: true,
					alias: "string",
					inside: { punctuation: /(?=\S).*\S(?= *$)/ }
				},
				{
					pattern: /(@\(([^"\r\n\/):]+)(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r(?!\n)))*?[ \t]*(?:\|[ \t]*)?(?:-[ \t]*)?\2/,
					lookbehind: true,
					greedy: true,
					alias: "string",
					inside: { punctuation: /(?=\S).*\S(?= *$)/ }
				},
				{
					pattern: /@\("?(?:[^"\r\n\/):]+)"?(?:\/[nrts$uL]*)?\)/,
					alias: "string",
					inside: { punctuation: {
						pattern: /(\().+?(?=\))/,
						lookbehind: true
					} }
				}
			],
			"multiline-comment": {
				pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
				lookbehind: true,
				greedy: true,
				alias: "comment"
			},
			regex: {
				pattern: /((?:\bnode\s+|[~=\(\[\{,]\s*|[=+]>\s*|^\s*))\/(?:[^\/\\]|\\[\s\S])+\/(?:[imx]+\b|\B)/,
				lookbehind: true,
				greedy: true,
				inside: { "extended-regex": {
					pattern: /^\/(?:[^\/\\]|\\[\s\S])+\/[im]*x[im]*$/,
					inside: { comment: /#.*/ }
				} }
			},
			comment: {
				pattern: /(^|[^\\])#.*/,
				lookbehind: true,
				greedy: true
			},
			string: {
				pattern: /(["'])(?:\$\{(?:[^'"}]|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}|\$(?!\{)|(?!\1)[^\\$]|\\[\s\S])*\1/,
				greedy: true,
				inside: { "double-quoted": {
					pattern: /^"[\s\S]*"$/,
					inside: {}
				} }
			},
			variable: {
				pattern: /\$(?:::)?\w+(?:::\w+)*/,
				inside: { punctuation: /::/ }
			},
			"attr-name": /(?:\b\w+|\*)(?=\s*=>)/,
			function: [{
				pattern: /(\.)(?!\d)\w+/,
				lookbehind: true
			}, /\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\b|\b(?!\d)\w+(?=\()/],
			number: /\b(?:0x[a-f\d]+|\d+(?:\.\d+)?(?:e-?\d+)?)\b/i,
			boolean: /\b(?:false|true)\b/,
			keyword: /\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\b/,
			datatype: {
				pattern: /\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\b/,
				alias: "symbol"
			},
			operator: /=[=~>]?|![=~]?|<(?:<\|?|[=~|-])?|>[>=]?|->?|~>|\|>?>?|[*\/%+?]|\b(?:and|in|or)\b/,
			punctuation: /[\[\]{}().,;]|:+/
		};
		var interpolation = [{
			pattern: /(^|[^\\])\$\{(?:[^'"{}]|\{[^}]*\}|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}/,
			lookbehind: true,
			inside: {
				"short-variable": {
					pattern: /(^\$\{)(?!\w+\()(?:::)?\w+(?:::\w+)*/,
					lookbehind: true,
					alias: "variable",
					inside: { punctuation: /::/ }
				},
				delimiter: {
					pattern: /^\$/,
					alias: "variable"
				},
				rest: Prism$2.languages.puppet
			}
		}, {
			pattern: /(^|[^\\])\$(?:::)?\w+(?:::\w+)*/,
			lookbehind: true,
			alias: "variable",
			inside: { punctuation: /::/ }
		}];
		Prism$2.languages.puppet["heredoc"][0].inside.interpolation = interpolation;
		Prism$2.languages.puppet["string"].inside["double-quoted"].inside.interpolation = interpolation;
	})(Prism$1);
}
pure.displayName = "pure";
pure.aliases = [];
function pure(Prism$1) {
	(function(Prism$2) {
		Prism$2.languages.pure = {
			comment: [
				{
					pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
					lookbehind: true
				},
				{
					pattern: /(^|[^\\:])\/\/.*/,
					lookbehind: true
				},
				/#!.+/
			],
			"inline-lang": {
				pattern: /%<[\s\S]+?%>/,
				greedy: true,
				inside: {
					lang: {
						pattern: /(^%< *)-\*-.+?-\*-/,
						lookbehind: true,
						alias: "comment"
					},
					delimiter: {
						pattern: /^%<.*|%>$/,
						alias: "punctuation"
					}
				}
			},
			string: {
				pattern: /"(?:\\.|[^"\\\r\n])*"/,
				greedy: true
			},
			number: {
				pattern: /((?:\.\.)?)(?:\b(?:inf|nan)\b|\b0x[\da-f]+|(?:\b(?:0b)?\d+(?:\.\d+)?|\B\.\d+)(?:e[+-]?\d+)?L?)/i,
				lookbehind: true
			},
			keyword: /\b(?:NULL|ans|break|bt|case|catch|cd|clear|const|def|del|dump|else|end|exit|extern|false|force|help|if|infix[lr]?|interface|let|ls|mem|namespace|nonfix|of|otherwise|outfix|override|postfix|prefix|private|public|pwd|quit|run|save|show|stats|then|throw|trace|true|type|underride|using|when|with)\b/,
			function: /\b(?:abs|add_(?:addr|constdef|(?:fundef|interface|macdef|typedef)(?:_at)?|vardef)|all|any|applp?|arity|bigintp?|blob(?:_crc|_size|p)?|boolp?|byte_c?string(?:_pointer)?|byte_(?:matrix|pointer)|calloc|cat|catmap|ceil|char[ps]?|check_ptrtag|chr|clear_sentry|clearsym|closurep?|cmatrixp?|cols?|colcat(?:map)?|colmap|colrev|colvector(?:p|seq)?|complex(?:_float_(?:matrix|pointer)|_matrix(?:_view)?|_pointer|p)?|conj|cookedp?|cst|cstring(?:_(?:dup|list|vector))?|curry3?|cyclen?|del_(?:constdef|fundef|interface|macdef|typedef|vardef)|delete|diag(?:mat)?|dim|dmatrixp?|do|double(?:_matrix(?:_view)?|_pointer|p)?|dowith3?|drop|dropwhile|eval(?:cmd)?|exactp|filter|fix|fixity|flip|float(?:_matrix|_pointer)|floor|fold[lr]1?|frac|free|funp?|functionp?|gcd|get(?:_(?:byte|constdef|double|float|fundef|int(?:64)?|interface(?:_typedef)?|long|macdef|pointer|ptrtag|sentry|short|string|typedef|vardef))?|globsym|hash|head|id|im|imatrixp?|index|inexactp|infp|init|insert|int(?:_matrix(?:_view)?|_pointer|p)?|int64_(?:matrix|pointer)|integerp?|iteraten?|iterwhile|join|keys?|lambdap?|last(?:err(?:pos)?)?|lcd|list[2p]?|listmap|make_ptrtag|malloc|map|matcat|matrixp?|max|member|min|nanp|nargs|nmatrixp?|null|numberp?|ord|pack(?:ed)?|pointer(?:_cast|_tag|_type|p)?|pow|pred|ptrtag|put(?:_(?:byte|double|float|int(?:64)?|long|pointer|short|string))?|rationalp?|re|realp?|realloc|recordp?|redim|reduce(?:_with)?|refp?|repeatn?|reverse|rlistp?|round|rows?|rowcat(?:map)?|rowmap|rowrev|rowvector(?:p|seq)?|same|scan[lr]1?|sentry|sgn|short_(?:matrix|pointer)|slice|smatrixp?|sort|split|str|strcat|stream|stride|string(?:_(?:dup|list|vector)|p)?|subdiag(?:mat)?|submat|subseq2?|substr|succ|supdiag(?:mat)?|symbolp?|tail|take|takewhile|thunkp?|transpose|trunc|tuplep?|typep|ubyte|uint(?:64)?|ulong|uncurry3?|unref|unzip3?|update|ushort|vals?|varp?|vector(?:p|seq)?|void|zip3?|zipwith3?)\b/,
			special: {
				pattern: /\b__[a-z]+__\b/i,
				alias: "builtin"
			},
			operator: /(?:[!"#$%&'*+,\-.\/:<=>?@\\^`|~\u00a1-\u00bf\u00d7-\u00f7\u20d0-\u2bff]|\b_+\b)+|\b(?:and|div|mod|not|or)\b/,
			punctuation: /[(){}\[\];,|]/
		};
		var inlineLanguages = [
			"c",
			{
				lang: "c++",
				alias: "cpp"
			},
			"fortran"
		];
		var inlineLanguageRe = /%< *-\*- *<lang>\d* *-\*-[\s\S]+?%>/.source;
		inlineLanguages.forEach(function(lang$1) {
			var alias$1 = lang$1;
			if (typeof lang$1 !== "string") {
				alias$1 = lang$1.alias;
				lang$1 = lang$1.lang;
			}
			if (Prism$2.languages[alias$1]) {
				var o = {};
				o["inline-lang-" + alias$1] = {
					pattern: RegExp(inlineLanguageRe.replace("<lang>", lang$1.replace(/([.+*?\/\\(){}\[\]])/g, "\\$1")), "i"),
					inside: Prism$2.util.clone(Prism$2.languages.pure["inline-lang"].inside)
				};
				o["inline-lang-" + alias$1].inside.rest = Prism$2.util.clone(Prism$2.languages[alias$1]);
				Prism$2.languages.insertBefore("pure", "inline-lang", o);
			}
		});
		if (Prism$2.languages.c) Prism$2.languages.pure["inline-lang"].inside.rest = Prism$2.util.clone(Prism$2.languages.c);
	})(Prism$1);
}
purebasic.displayName = "purebasic";
purebasic.aliases = ["pbfasm"];
function purebasic(Prism$1) {
	Prism$1.register(clike);
	Prism$1.languages.purebasic = Prism$1.languages.extend("clike", {
		comment: /;.*/,
		keyword: /\b(?:align|and|as|break|calldebugger|case|compilercase|compilerdefault|compilerelse|compilerelseif|compilerendif|compilerendselect|compilererror|compilerif|compilerselect|continue|data|datasection|debug|debuglevel|declare|declarec|declarecdll|declaredll|declaremodule|default|define|dim|disableasm|disabledebugger|disableexplicit|else|elseif|enableasm|enabledebugger|enableexplicit|end|enddatasection|enddeclaremodule|endenumeration|endif|endimport|endinterface|endmacro|endmodule|endprocedure|endselect|endstructure|endstructureunion|endwith|enumeration|extends|fakereturn|for|foreach|forever|global|gosub|goto|if|import|importc|includebinary|includefile|includepath|interface|macro|module|newlist|newmap|next|not|or|procedure|procedurec|procedurecdll|proceduredll|procedurereturn|protected|prototype|prototypec|read|redim|repeat|restore|return|runtime|select|shared|static|step|structure|structureunion|swap|threaded|to|until|wend|while|with|xincludefile|xor)\b/i,
		function: /\b\w+(?:\.\w+)?\s*(?=\()/,
		number: /(?:\$[\da-f]+|\b-?(?:\d+(?:\.\d+)?|\.\d+)(?:e[+-]?\d+)?)\b/i,
		operator: /(?:@\*?|\?|\*)\w+\$?|-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|?\||[~^%?*/@]/
	});
	Prism$1.languages.insertBefore("purebasic", "keyword", {
		tag: /#\w+\$?/,
		asm: {
			pattern: /(^[\t ]*)!.*/m,
			lookbehind: true,
			alias: "tag",
			inside: {
				comment: /;.*/,
				string: {
					pattern: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
					greedy: true
				},
				"label-reference-anonymous": {
					pattern: /(!\s*j[a-z]+\s+)@[fb]/i,
					lookbehind: true,
					alias: "fasm-label"
				},
				"label-reference-addressed": {
					pattern: /(!\s*j[a-z]+\s+)[A-Z._?$@][\w.?$@~#]*/i,
					lookbehind: true,
					alias: "fasm-label"
				},
				keyword: [/\b(?:extern|global)\b[^;\r\n]*/i, /\b(?:CPU|DEFAULT|FLOAT)\b.*/],
				function: {
					pattern: /^([\t ]*!\s*)[\da-z]+(?=\s|$)/im,
					lookbehind: true
				},
				"function-inline": {
					pattern: /(:\s*)[\da-z]+(?=\s)/i,
					lookbehind: true,
					alias: "function"
				},
				label: {
					pattern: /^([\t ]*!\s*)[A-Za-z._?$@][\w.?$@~#]*(?=:)/m,
					lookbehind: true,
					alias: "fasm-label"
				},
				register: /\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|di|si|sp)|[cdefgs]s|mm\d+)\b/i,
				number: /(?:\b|-|(?=\$))(?:0[hx](?:[\da-f]*\.)?[\da-f]+(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|(?:\d+(?:\.\d+)?|\.\d+)(?:\.?e[+-]?\d+)?[dt]?)\b/i,
				operator: /[\[\]*+\-/%<>=&|$!,.:]/
			}
		}
	});
	delete Prism$1.languages.purebasic["class-name"];
	delete Prism$1.languages.purebasic["boolean"];
	Prism$1.languages.pbfasm = Prism$1.languages["purebasic"];
}
purescript.displayName = "purescript";
purescript.aliases = ["purs"];
function purescript(Prism$1) {
	Prism$1.register(haskell);
	Prism$1.languages.purescript = Prism$1.languages.extend("haskell", {
		keyword: /\b(?:ado|case|class|data|derive|do|else|forall|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b|∀/,
		"import-statement": {
			pattern: /(^[\t ]*)import\s+[A-Z][\w']*(?:\.[A-Z][\w']*)*(?:\s+as\s+[A-Z][\w']*(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
			lookbehind: true,
			inside: {
				keyword: /\b(?:as|hiding|import)\b/,
				punctuation: /\./
			}
		},
		builtin: /\b(?:absurd|add|ap|append|apply|between|bind|bottom|clamp|compare|comparing|compose|conj|const|degree|discard|disj|div|eq|flap|flip|gcd|identity|ifM|join|lcm|liftA1|liftM1|map|max|mempty|min|mod|mul|negate|not|notEq|one|otherwise|recip|show|sub|top|unit|unless|unlessM|void|when|whenM|zero)\b/,
		operator: [
			Prism$1.languages.haskell.operator[0],
			Prism$1.languages.haskell.operator[2],
			/[\xa2-\xa6\xa8\xa9\xac\xae-\xb1\xb4\xb8\xd7\xf7\u02c2-\u02c5\u02d2-\u02df\u02e5-\u02eb\u02ed\u02ef-\u02ff\u0375\u0384\u0385\u03f6\u0482\u058d-\u058f\u0606-\u0608\u060b\u060e\u060f\u06de\u06e9\u06fd\u06fe\u07f6\u07fe\u07ff\u09f2\u09f3\u09fa\u09fb\u0af1\u0b70\u0bf3-\u0bfa\u0c7f\u0d4f\u0d79\u0e3f\u0f01-\u0f03\u0f13\u0f15-\u0f17\u0f1a-\u0f1f\u0f34\u0f36\u0f38\u0fbe-\u0fc5\u0fc7-\u0fcc\u0fce\u0fcf\u0fd5-\u0fd8\u109e\u109f\u1390-\u1399\u166d\u17db\u1940\u19de-\u19ff\u1b61-\u1b6a\u1b74-\u1b7c\u1fbd\u1fbf-\u1fc1\u1fcd-\u1fcf\u1fdd-\u1fdf\u1fed-\u1fef\u1ffd\u1ffe\u2044\u2052\u207a-\u207c\u208a-\u208c\u20a0-\u20bf\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211e-\u2123\u2125\u2127\u2129\u212e\u213a\u213b\u2140-\u2144\u214a-\u214d\u214f\u218a\u218b\u2190-\u2307\u230c-\u2328\u232b-\u2426\u2440-\u244a\u249c-\u24e9\u2500-\u2767\u2794-\u27c4\u27c7-\u27e5\u27f0-\u2982\u2999-\u29d7\u29dc-\u29fb\u29fe-\u2b73\u2b76-\u2b95\u2b97-\u2bff\u2ce5-\u2cea\u2e50\u2e51\u2e80-\u2e99\u2e9b-\u2ef3\u2f00-\u2fd5\u2ff0-\u2ffb\u3004\u3012\u3013\u3020\u3036\u3037\u303e\u303f\u309b\u309c\u3190\u3191\u3196-\u319f\u31c0-\u31e3\u3200-\u321e\u322a-\u3247\u3250\u3260-\u327f\u328a-\u32b0\u32c0-\u33ff\u4dc0-\u4dff\ua490-\ua4c6\ua700-\ua716\ua720\ua721\ua789\ua78a\ua828-\ua82b\ua836-\ua839\uaa77-\uaa79\uab5b\uab6a\uab6b\ufb29\ufbb2-\ufbc1\ufdfc\ufdfd\ufe62\ufe64-\ufe66\ufe69\uff04\uff0b\uff1c-\uff1e\uff3e\uff40\uff5c\uff5e\uffe0-\uffe6\uffe8-\uffee\ufffc\ufffd]/
		]
	});
	Prism$1.languages.purs = Prism$1.languages.purescript;
}
qsharp.displayName = "qsharp";
qsharp.aliases = ["qs"];
function qsharp(Prism$1) {
	Prism$1.register(clike);
	(function(Prism$2) {
		function replace$1(pattern, replacements) {
			return pattern.replace(/<<(\d+)>>/g, function(m, index$1) {
				return "(?:" + replacements[+index$1] + ")";
			});
		}
		function re$1(pattern, replacements, flags) {
			return RegExp(replace$1(pattern, replacements), flags || "");
		}
		function nested(pattern, depthLog2) {
			for (var i = 0; i < depthLog2; i++) pattern = pattern.replace(/<<self>>/g, function() {
				return "(?:" + pattern + ")";
			});
			return pattern.replace(/<<self>>/g, "[^\\s\\S]");
		}
		var keywordKinds = {
			type: "Adj BigInt Bool Ctl Double false Int One Pauli PauliI PauliX PauliY PauliZ Qubit Range Result String true Unit Zero",
			other: "Adjoint adjoint apply as auto body borrow borrowing Controlled controlled distribute elif else fail fixup for function if in internal intrinsic invert is let mutable namespace new newtype open operation repeat return self set until use using while within"
		};
		function keywordsToPattern(words) {
			return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
		}
		var keywords = RegExp(keywordsToPattern(keywordKinds.type + " " + keywordKinds.other));
		var identifier = /\b[A-Za-z_]\w*\b/.source;
		var qualifiedName = replace$1(/<<0>>(?:\s*\.\s*<<0>>)*/.source, [identifier]);
		var typeInside = {
			keyword: keywords,
			punctuation: /[<>()?,.:[\]]/
		};
		var regularString = /"(?:\\.|[^\\"])*"/.source;
		Prism$2.languages.qsharp = Prism$2.languages.extend("clike", {
			comment: /\/\/.*/,
			string: [{
				pattern: re$1(/(^|[^$\\])<<0>>/.source, [regularString]),
				lookbehind: true,
				greedy: true
			}],
			"class-name": [{
				pattern: re$1(/(\b(?:as|open)\s+)<<0>>(?=\s*(?:;|as\b))/.source, [qualifiedName]),
				lookbehind: true,
				inside: typeInside
			}, {
				pattern: re$1(/(\bnamespace\s+)<<0>>(?=\s*\{)/.source, [qualifiedName]),
				lookbehind: true,
				inside: typeInside
			}],
			keyword: keywords,
			number: /(?:\b0(?:x[\da-f]+|b[01]+|o[0-7]+)|(?:\B\.\d+|\b\d+(?:\.\d*)?)(?:e[-+]?\d+)?)l?\b/i,
			operator: /\band=|\bor=|\band\b|\bnot\b|\bor\b|<[-=]|[-=]>|>>>=?|<<<=?|\^\^\^=?|\|\|\|=?|&&&=?|w\/=?|~~~|[*\/+\-^=!%]=?/,
			punctuation: /::|[{}[\];(),.:]/
		});
		Prism$2.languages.insertBefore("qsharp", "number", { range: {
			pattern: /\.\./,
			alias: "operator"
		} });
		var interpolationExpr = nested(replace$1(/\{(?:[^"{}]|<<0>>|<<self>>)*\}/.source, [regularString]), 2);
		Prism$2.languages.insertBefore("qsharp", "string", { "interpolation-string": {
			pattern: re$1(/\$"(?:\\.|<<0>>|[^\\"{])*"/.source, [interpolationExpr]),
			greedy: true,
			inside: {
				interpolation: {
					pattern: re$1(/((?:^|[^\\])(?:\\\\)*)<<0>>/.source, [interpolationExpr]),
					lookbehind: true,
					inside: {
						punctuation: /^\{|\}$/,
						expression: {
							pattern: /[\s\S]+/,
							alias: "language-qsharp",
							inside: Prism$2.languages.qsharp
						}
					}
				},
				string: /[\s\S]+/
			}
		} });
	})(Prism$1);
	Prism$1.languages.qs = Prism$1.languages.qsharp;
}
q.displayName = "q";
q.aliases = [];
function q(Prism$1) {
	Prism$1.languages.q = {
		string: /"(?:\\.|[^"\\\r\n])*"/,
		comment: [
			{
				pattern: /([\t )\]}])\/.*/,
				lookbehind: true,
				greedy: true
			},
			{
				pattern: /(^|\r?\n|\r)\/[\t ]*(?:(?:\r?\n|\r)(?:.*(?:\r?\n|\r(?!\n)))*?(?:\\(?=[\t ]*(?:\r?\n|\r))|$)|\S.*)/,
				lookbehind: true,
				greedy: true
			},
			{
				pattern: /^\\[\t ]*(?:\r?\n|\r)[\s\S]+/m,
				greedy: true
			},
			{
				pattern: /^#!.+/m,
				greedy: true
			}
		],
		symbol: /`(?::\S+|[\w.]*)/,
		datetime: {
			pattern: /0N[mdzuvt]|0W[dtz]|\d{4}\.\d\d(?:m|\.\d\d(?:T(?:\d\d(?::\d\d(?::\d\d(?:[.:]\d\d\d)?)?)?)?)?[dz]?)|\d\d:\d\d(?::\d\d(?:[.:]\d\d\d)?)?[uvt]?/,
			alias: "number"
		},
		number: /\b(?![01]:)(?:0N[hje]?|0W[hj]?|0[wn]|0x[\da-fA-F]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?[hjfeb]?)/,
		keyword: /\\\w+\b|\b(?:abs|acos|aj0?|all|and|any|asc|asin|asof|atan|attr|avgs?|binr?|by|ceiling|cols|cor|cos|count|cov|cross|csv|cut|delete|deltas|desc|dev|differ|distinct|div|do|dsave|ej|enlist|eval|except|exec|exit|exp|fby|fills|first|fkeys|flip|floor|from|get|getenv|group|gtime|hclose|hcount|hdel|hopen|hsym|iasc|identity|idesc|if|ij|in|insert|inter|inv|keys?|last|like|list|ljf?|load|log|lower|lsq|ltime|ltrim|mavg|maxs?|mcount|md5|mdev|med|meta|mins?|mmax|mmin|mmu|mod|msum|neg|next|not|null|or|over|parse|peach|pj|plist|prds?|prev|prior|rand|rank|ratios|raze|read0|read1|reciprocal|reval|reverse|rload|rotate|rsave|rtrim|save|scan|scov|sdev|select|set|setenv|show|signum|sin|sqrt|ssr?|string|sublist|sums?|sv|svar|system|tables|tan|til|trim|txf|type|uj|ungroup|union|update|upper|upsert|value|var|views?|vs|wavg|where|while|within|wj1?|wsum|ww|xasc|xbar|xcols?|xdesc|xexp|xgroup|xkey|xlog|xprev|xrank)\b/,
		adverb: {
			pattern: /['\/\\]:?|\beach\b/,
			alias: "function"
		},
		verb: {
			pattern: /(?:\B\.\B|\b[01]:|<[=>]?|>=?|[:+\-*%,!?~=|$&#@^]):?|\b_\b:?/,
			alias: "operator"
		},
		punctuation: /[(){}\[\];.]/
	};
}
qml.displayName = "qml";
qml.aliases = [];
function qml(Prism$1) {
	Prism$1.register(javascript);
	(function(Prism$2) {
		var jsString = /"(?:\\.|[^\\"\r\n])*"|'(?:\\.|[^\\'\r\n])*'/.source;
		var jsComment = /\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))*\*\//.source;
		var jsExpr = /(?:[^\\()[\]{}"'/]|<string>|\/(?![*/])|<comment>|\(<expr>*\)|\[<expr>*\]|\{<expr>*\}|\\[\s\S])/.source.replace(/<string>/g, function() {
			return jsString;
		}).replace(/<comment>/g, function() {
			return jsComment;
		});
		for (var i = 0; i < 2; i++) jsExpr = jsExpr.replace(/<expr>/g, function() {
			return jsExpr;
		});
		jsExpr = jsExpr.replace(/<expr>/g, "[^\\s\\S]");
		Prism$2.languages.qml = {
			comment: {
				pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
				greedy: true
			},
			"javascript-function": {
				pattern: RegExp(/((?:^|;)[ \t]*)function\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*\(<js>*\)\s*\{<js>*\}/.source.replace(/<js>/g, function() {
					return jsExpr;
				}), "m"),
				lookbehind: true,
				greedy: true,
				alias: "language-javascript",
				inside: Prism$2.languages.javascript
			},
			"class-name": {
				pattern: /((?:^|[:;])[ \t]*)(?!\d)\w+(?=[ \t]*\{|[ \t]+on\b)/m,
				lookbehind: true
			},
			property: [{
				pattern: /((?:^|[;{])[ \t]*)(?!\d)\w+(?:\.\w+)*(?=[ \t]*:)/m,
				lookbehind: true
			}, {
				pattern: /((?:^|[;{])[ \t]*)property[ \t]+(?!\d)\w+(?:\.\w+)*[ \t]+(?!\d)\w+(?:\.\w+)*(?=[ \t]*:)/m,
				lookbehind: true,
				inside: {
					keyword: /^property/,
					property: /\w+(?:\.\w+)*/
				}
			}],
			"javascript-expression": {
				pattern: RegExp(/(:[ \t]*)(?![\s;}[])(?:(?!$|[;}])<js>)+/.source.replace(/<js>/g, function() {
					return jsExpr;
				}), "m"),
				lookbehind: true,
				greedy: true,
				alias: "language-javascript",
				inside: Prism$2.languages.javascript
			},
			string: {
				pattern: /"(?:\\.|[^\\"\r\n])*"/,
				greedy: true
			},
			keyword: /\b(?:as|import|on)\b/,
			punctuation: /[{}[\]:;,]/
		};
	})(Prism$1);
}
qore.displayName = "qore";
qore.aliases = [];
function qore(Prism$1) {
	Prism$1.register(clike);
	Prism$1.languages.qore = Prism$1.languages.extend("clike", {
		comment: {
			pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:\/\/|#).*)/,
			lookbehind: true
		},
		string: {
			pattern: /("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,
			greedy: true
		},
		keyword: /\b(?:abstract|any|assert|binary|bool|boolean|break|byte|case|catch|char|class|code|const|continue|data|default|do|double|else|enum|extends|final|finally|float|for|goto|hash|if|implements|import|inherits|instanceof|int|interface|long|my|native|new|nothing|null|object|our|own|private|reference|rethrow|return|short|soft(?:bool|date|float|int|list|number|string)|static|strictfp|string|sub|super|switch|synchronized|this|throw|throws|transient|try|void|volatile|while)\b/,
		boolean: /\b(?:false|true)\b/i,
		function: /\$?\b(?!\d)\w+(?=\()/,
		number: /\b(?:0b[01]+|0x(?:[\da-f]*\.)?[\da-fp\-]+|(?:\d+(?:\.\d+)?|\.\d+)(?:e\d+)?[df]|(?:\d+(?:\.\d+)?|\.\d+))\b/i,
		operator: {
			pattern: /(^|[^.])(?:\+[+=]?|-[-=]?|[!=](?:==?|~)?|>>?=?|<(?:=>?|<=?)?|&[&=]?|\|[|=]?|[*\/%^]=?|[~?])/,
			lookbehind: true
		},
		variable: /\$(?!\d)\w+\b/
	});
}
racket.displayName = "racket";
racket.aliases = ["rkt"];
function racket(Prism$1) {
	Prism$1.register(scheme);
	Prism$1.languages.racket = Prism$1.languages.extend("scheme", { "lambda-parameter": {
		pattern: /([(\[]lambda\s+[(\[])[^()\[\]'\s]+/,
		lookbehind: true
	} });
	Prism$1.languages.insertBefore("racket", "string", { lang: {
		pattern: /^#lang.+/m,
		greedy: true,
		alias: "keyword"
	} });
	Prism$1.languages.rkt = Prism$1.languages.racket;
}
cshtml.displayName = "cshtml";
cshtml.aliases = ["razor"];
function cshtml(Prism$1) {
	Prism$1.register(csharp);
	Prism$1.register(markup);
	(function(Prism$2) {
		var commentLike = /\/(?![/*])|\/\/.*[\r\n]|\/\*[^*]*(?:\*(?!\/)[^*]*)*\*\//.source;
		var stringLike = /@(?!")|"(?:[^\r\n\\"]|\\.)*"|@"(?:[^\\"]|""|\\[\s\S])*"(?!")/.source + "|" + /'(?:(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'|(?=[^\\](?!')))/.source;
		function nested(pattern, depthLog2) {
			for (var i = 0; i < depthLog2; i++) pattern = pattern.replace(/<self>/g, function() {
				return "(?:" + pattern + ")";
			});
			return pattern.replace(/<self>/g, "[^\\s\\S]").replace(/<str>/g, "(?:" + stringLike + ")").replace(/<comment>/g, "(?:" + commentLike + ")");
		}
		var round = nested(/\((?:[^()'"@/]|<str>|<comment>|<self>)*\)/.source, 2);
		var square = nested(/\[(?:[^\[\]'"@/]|<str>|<comment>|<self>)*\]/.source, 1);
		var curly = nested(/\{(?:[^{}'"@/]|<str>|<comment>|<self>)*\}/.source, 2);
		var angle = nested(/<(?:[^<>'"@/]|<comment>|<self>)*>/.source, 1);
		var inlineCs = /@/.source + /(?:await\b\s*)?/.source + "(?:" + /(?!await\b)\w+\b/.source + "|" + round + ")(?:" + /[?!]?\.\w+\b/.source + "|(?:" + angle + ")?" + round + "|" + square + ")*" + /(?![?!\.(\[]|<(?!\/))/.source;
		var tagAttrInlineCs = /@(?![\w()])/.source + "|" + inlineCs;
		var tagAttrValue = "(?:" + /"[^"@]*"|'[^'@]*'|[^\s'"@>=]+(?=[\s>])/.source + "|[\"'][^\"'@]*(?:(?:" + tagAttrInlineCs + ")[^\"'@]*)+[\"'])";
		var tagAttrs = /(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*<tagAttrValue>|(?=[\s/>])))+)?/.source.replace(/<tagAttrValue>/, tagAttrValue);
		var tagContent = /(?!\d)[^\s>\/=$<%]+/.source + tagAttrs + /\s*\/?>/.source;
		var tagRegion = /\B@?/.source + "(?:" + /<([a-zA-Z][\w:]*)/.source + tagAttrs + /\s*>/.source + "(?:" + (/[^<]/.source + "|" + /<\/?(?!\1\b)/.source + tagContent + "|" + nested(/<\1/.source + tagAttrs + /\s*>/.source + "(?:" + (/[^<]/.source + "|" + /<\/?(?!\1\b)/.source + tagContent + "|<self>") + ")*" + /<\/\1\s*>/.source, 2)) + ")*" + /<\/\1\s*>/.source + "|" + /</.source + tagContent + ")";
		Prism$2.languages.cshtml = Prism$2.languages.extend("markup", {});
		var csharpWithHtml = Prism$2.languages.insertBefore("csharp", "string", { html: {
			pattern: RegExp(tagRegion),
			greedy: true,
			inside: Prism$2.languages.cshtml
		} }, { csharp: Prism$2.languages.extend("csharp", {}) });
		var cs = {
			pattern: /\S[\s\S]*/,
			alias: "language-csharp",
			inside: csharpWithHtml
		};
		var inlineValue = {
			pattern: RegExp(/(^|[^@])/.source + inlineCs),
			lookbehind: true,
			greedy: true,
			alias: "variable",
			inside: {
				keyword: /^@/,
				csharp: cs
			}
		};
		Prism$2.languages.cshtml.tag.pattern = RegExp(/<\/?/.source + tagContent);
		Prism$2.languages.cshtml.tag.inside["attr-value"].pattern = RegExp(/=\s*/.source + tagAttrValue);
		Prism$2.languages.insertBefore("inside", "punctuation", { value: inlineValue }, Prism$2.languages.cshtml.tag.inside["attr-value"]);
		Prism$2.languages.insertBefore("cshtml", "prolog", {
			"razor-comment": {
				pattern: /@\*[\s\S]*?\*@/,
				greedy: true,
				alias: "comment"
			},
			block: {
				pattern: RegExp(/(^|[^@])@/.source + "(?:" + [
					curly,
					/(?:code|functions)\s*/.source + curly,
					/(?:for|foreach|lock|switch|using|while)\s*/.source + round + /\s*/.source + curly,
					/do\s*/.source + curly + /\s*while\s*/.source + round + /(?:\s*;)?/.source,
					/try\s*/.source + curly + /\s*catch\s*/.source + round + /\s*/.source + curly + /\s*finally\s*/.source + curly,
					/if\s*/.source + round + /\s*/.source + curly + "(?:" + /\s*else/.source + "(?:" + /\s+if\s*/.source + round + ")?" + /\s*/.source + curly + ")*",
					/helper\s+\w+\s*/.source + round + /\s*/.source + curly
				].join("|") + ")"),
				lookbehind: true,
				greedy: true,
				inside: {
					keyword: /^@\w*/,
					csharp: cs
				}
			},
			directive: {
				pattern: /^([ \t]*)@(?:addTagHelper|attribute|implements|inherits|inject|layout|model|namespace|page|preservewhitespace|removeTagHelper|section|tagHelperPrefix|using)(?=\s).*/m,
				lookbehind: true,
				greedy: true,
				inside: {
					keyword: /^@\w+/,
					csharp: cs
				}
			},
			value: inlineValue,
			"delegate-operator": {
				pattern: /(^|[^@])@(?=<)/,
				lookbehind: true,
				alias: "operator"
			}
		});
		Prism$2.languages.razor = Prism$2.languages.cshtml;
	})(Prism$1);
}
jsx$1.displayName = "jsx";
jsx$1.aliases = [];
function jsx$1(Prism$1) {
	Prism$1.register(javascript);
	Prism$1.register(markup);
	(function(Prism$2) {
		var javascript$1 = Prism$2.util.clone(Prism$2.languages.javascript);
		var space$1 = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
		var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
		var spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
		function re$1(source, flags) {
			source = source.replace(/<S>/g, function() {
				return space$1;
			}).replace(/<BRACES>/g, function() {
				return braces;
			}).replace(/<SPREAD>/g, function() {
				return spread;
			});
			return RegExp(source, flags);
		}
		spread = re$1(spread).source;
		Prism$2.languages.jsx = Prism$2.languages.extend("markup", javascript$1);
		Prism$2.languages.jsx.tag.pattern = re$1(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source);
		Prism$2.languages.jsx.tag.inside["tag"].pattern = /^<\/?[^\s>\/]*/;
		Prism$2.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
		Prism$2.languages.jsx.tag.inside["tag"].inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
		Prism$2.languages.jsx.tag.inside["comment"] = javascript$1["comment"];
		Prism$2.languages.insertBefore("inside", "attr-name", { spread: {
			pattern: re$1(/<SPREAD>/.source),
			inside: Prism$2.languages.jsx
		} }, Prism$2.languages.jsx.tag);
		Prism$2.languages.insertBefore("inside", "special-attr", { script: {
			pattern: re$1(/=<BRACES>/.source),
			alias: "language-javascript",
			inside: {
				"script-punctuation": {
					pattern: /^=(?=\{)/,
					alias: "punctuation"
				},
				rest: Prism$2.languages.jsx
			}
		} }, Prism$2.languages.jsx.tag);
		var stringifyToken = function(token) {
			if (!token) return "";
			if (typeof token === "string") return token;
			if (typeof token.content === "string") return token.content;
			return token.content.map(stringifyToken).join("");
		};
		var walkTokens = function(tokens) {
			var openedTags = [];
			for (var i = 0; i < tokens.length; i++) {
				var token = tokens[i];
				var notTagNorBrace = false;
				if (typeof token !== "string") if (token.type === "tag" && token.content[0] && token.content[0].type === "tag") if (token.content[0].content[0].content === "</") {
					if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) openedTags.pop();
				} else if (token.content[token.content.length - 1].content === "/>") {} else openedTags.push({
					tagName: stringifyToken(token.content[0].content[1]),
					openedBraces: 0
				});
				else if (openedTags.length > 0 && token.type === "punctuation" && token.content === "{") openedTags[openedTags.length - 1].openedBraces++;
				else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === "punctuation" && token.content === "}") openedTags[openedTags.length - 1].openedBraces--;
				else notTagNorBrace = true;
				if (notTagNorBrace || typeof token === "string") {
					if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
						var plainText = stringifyToken(token);
						if (i < tokens.length - 1 && (typeof tokens[i + 1] === "string" || tokens[i + 1].type === "plain-text")) {
							plainText += stringifyToken(tokens[i + 1]);
							tokens.splice(i + 1, 1);
						}
						if (i > 0 && (typeof tokens[i - 1] === "string" || tokens[i - 1].type === "plain-text")) {
							plainText = stringifyToken(tokens[i - 1]) + plainText;
							tokens.splice(i - 1, 1);
							i--;
						}
						tokens[i] = new Prism$2.Token("plain-text", plainText, null, plainText);
					}
				}
				if (token.content && typeof token.content !== "string") walkTokens(token.content);
			}
		};
		Prism$2.hooks.add("after-tokenize", function(env$1) {
			if (env$1.language !== "jsx" && env$1.language !== "tsx") return;
			walkTokens(env$1.tokens);
		});
	})(Prism$1);
}
tsx.displayName = "tsx";
tsx.aliases = [];
function tsx(Prism$1) {
	Prism$1.register(jsx$1);
	Prism$1.register(typescript);
	(function(Prism$2) {
		var typescript$1 = Prism$2.util.clone(Prism$2.languages.typescript);
		Prism$2.languages.tsx = Prism$2.languages.extend("jsx", typescript$1);
		delete Prism$2.languages.tsx["parameter"];
		delete Prism$2.languages.tsx["literal-property"];
		var tag = Prism$2.languages.tsx.tag;
		tag.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + tag.pattern.source + ")", tag.pattern.flags);
		tag.lookbehind = true;
	})(Prism$1);
}
reason.displayName = "reason";
reason.aliases = [];
function reason(Prism$1) {
	Prism$1.register(clike);
	Prism$1.languages.reason = Prism$1.languages.extend("clike", {
		string: {
			pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
			greedy: true
		},
		"class-name": /\b[A-Z]\w*/,
		keyword: /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/,
		operator: /\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/
	});
	Prism$1.languages.insertBefore("reason", "class-name", {
		char: {
			pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/,
			greedy: true
		},
		constructor: /\b[A-Z]\w*\b(?!\s*\.)/,
		label: {
			pattern: /\b[a-z]\w*(?=::)/,
			alias: "symbol"
		}
	});
	delete Prism$1.languages.reason.function;
}
rego.displayName = "rego";
rego.aliases = [];
function rego(Prism$1) {
	Prism$1.languages.rego = {
		comment: /#.*/,
		property: {
			pattern: /(^|[^\\.])(?:"(?:\\.|[^\\"\r\n])*"|`[^`]*`|\b[a-z_]\w*\b)(?=\s*:(?!=))/i,
			lookbehind: true,
			greedy: true
		},
		string: {
			pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"|`[^`]*`/,
			lookbehind: true,
			greedy: true
		},
		keyword: /\b(?:as|default|else|import|not|null|package|set(?=\s*\()|some|with)\b/,
		boolean: /\b(?:false|true)\b/,
		function: {
			pattern: /\b[a-z_]\w*\b(?:\s*\.\s*\b[a-z_]\w*\b)*(?=\s*\()/i,
			inside: {
				namespace: /\b\w+\b(?=\s*\.)/,
				punctuation: /\./
			}
		},
		number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
		operator: /[-+*/%|&]|[<>:=]=?|!=|\b_\b/,
		punctuation: /[,;.\[\]{}()]/
	};
}
renpy.displayName = "renpy";
renpy.aliases = ["rpy"];
function renpy(Prism$1) {
	Prism$1.languages.renpy = {
		comment: {
			pattern: /(^|[^\\])#.+/,
			lookbehind: true
		},
		string: {
			pattern: /("""|''')[\s\S]+?\1|("|')(?:\\.|(?!\2)[^\\])*\2|(?:^#?(?:(?:[0-9a-fA-F]){3}|[0-9a-fA-F]{6})$)/m,
			greedy: true
		},
		function: /\b[a-z_]\w*(?=\()/i,
		property: /\b(?:Update|UpdateVersion|action|activate_sound|adv_nvl_transition|after_load_transition|align|alpha|alt|anchor|antialias|area|auto|background|bar_invert|bar_resizing|bar_vertical|black_color|bold|bottom_bar|bottom_gutter|bottom_margin|bottom_padding|box_reverse|box_wrap|can_update|caret|child|color|crop|default_afm_enable|default_afm_time|default_fullscreen|default_text_cps|developer|directory_name|drag_handle|drag_joined|drag_name|drag_raise|draggable|dragged|drop_shadow|drop_shadow_color|droppable|dropped|easein|easeout|edgescroll|end_game_transition|end_splash_transition|enter_replay_transition|enter_sound|enter_transition|enter_yesno_transition|executable_name|exit_replay_transition|exit_sound|exit_transition|exit_yesno_transition|fadein|fadeout|first_indent|first_spacing|fit_first|focus|focus_mask|font|foreground|game_main_transition|get_installed_packages|google_play_key|google_play_salt|ground|has_music|has_sound|has_voice|height|help|hinting|hover|hover_background|hover_color|hover_sound|hovered|hyperlink_functions|idle|idle_color|image_style|include_update|insensitive|insensitive_background|insensitive_color|inside|intra_transition|italic|justify|kerning|keyboard_focus|language|layer_clipping|layers|layout|left_bar|left_gutter|left_margin|left_padding|length|line_leading|line_overlap_split|line_spacing|linear|main_game_transition|main_menu_music|maximum|min_width|minimum|minwidth|modal|mouse|mousewheel|name|narrator_menu|newline_indent|nvl_adv_transition|offset|order_reverse|outlines|overlay_functions|pos|position|prefix|radius|range|rest_indent|right_bar|right_gutter|right_margin|right_padding|rotate|rotate_pad|ruby_style|sample_sound|save_directory|say_attribute_transition|screen_height|screen_width|scrollbars|selected_hover|selected_hover_color|selected_idle|selected_idle_color|selected_insensitive|show_side_image|show_two_window|side_spacing|side_xpos|side_ypos|size|size_group|slow_cps|slow_cps_multiplier|spacing|strikethrough|subpixel|text_align|text_style|text_xpos|text_y_fudge|text_ypos|thumb|thumb_offset|thumb_shadow|thumbnail_height|thumbnail_width|time|top_bar|top_gutter|top_margin|top_padding|translations|underline|unscrollable|update|value|version|version_name|version_tuple|vertical|width|window_hide_transition|window_icon|window_left_padding|window_show_transition|window_title|windows_icon|xadjustment|xalign|xanchor|xanchoraround|xaround|xcenter|xfill|xinitial|xmargin|xmaximum|xminimum|xoffset|xofsset|xpadding|xpos|xsize|xzoom|yadjustment|yalign|yanchor|yanchoraround|yaround|ycenter|yfill|yinitial|ymargin|ymaximum|yminimum|yoffset|ypadding|ypos|ysize|ysizexysize|yzoom|zoom|zorder)\b/,
		tag: /\b(?:bar|block|button|buttoscreenn|drag|draggroup|fixed|frame|grid|[hv]box|hotbar|hotspot|image|imagebutton|imagemap|input|key|label|menu|mm_menu_frame|mousearea|nvl|parallel|screen|self|side|tag|text|textbutton|timer|vbar|viewport|window)\b|\$/,
		keyword: /\b(?:None|add|adjustment|alignaround|allow|angle|animation|around|as|assert|behind|box_layout|break|build|cache|call|center|changed|child_size|choice|circles|class|clear|clicked|clipping|clockwise|config|contains|continue|corner1|corner2|counterclockwise|def|default|define|del|delay|disabled|disabled_text|dissolve|elif|else|event|except|exclude|exec|expression|fade|finally|for|from|function|global|gm_root|has|hide|id|if|import|in|init|is|jump|knot|lambda|left|less_rounded|mm_root|movie|music|null|on|onlayer|pass|pause|persistent|play|print|python|queue|raise|random|renpy|repeat|return|right|rounded_window|scene|scope|set|show|slow|slow_abortable|slow_done|sound|stop|store|style|style_group|substitute|suffix|theme|transform|transform_anchor|transpose|try|ui|unhovered|updater|use|voice|while|widget|widget_hover|widget_selected|widget_text|yield)\b/,
		boolean: /\b(?:[Ff]alse|[Tt]rue)\b/,
		number: /(?:\b(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?)|\B\.\d+)(?:e[+-]?\d+)?j?/i,
		operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:and|at|not|or|with)\b/,
		punctuation: /[{}[\];(),.:]/
	};
	Prism$1.languages.rpy = Prism$1.languages.renpy;
}
rescript.displayName = "rescript";
rescript.aliases = ["res"];
function rescript(Prism$1) {
	Prism$1.languages.rescript = {
		comment: {
			pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
			greedy: true
		},
		char: {
			pattern: /'(?:[^\r\n\\]|\\(?:.|\w+))'/,
			greedy: true
		},
		string: {
			pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
			greedy: true
		},
		"class-name": /\b[A-Z]\w*|@[a-z.]*|#[A-Za-z]\w*|#\d/,
		function: {
			pattern: /[a-zA-Z]\w*(?=\()|(\.)[a-z]\w*/,
			lookbehind: true
		},
		number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
		boolean: /\b(?:false|true)\b/,
		"attr-value": /[A-Za-z]\w*(?==)/,
		constant: {
			pattern: /(\btype\s+)[a-z]\w*/,
			lookbehind: true
		},
		tag: {
			pattern: /(<)[a-z]\w*|(?:<\/)[a-z]\w*/,
			lookbehind: true,
			inside: { operator: /<|>|\// }
		},
		keyword: /\b(?:and|as|assert|begin|bool|class|constraint|do|done|downto|else|end|exception|external|float|for|fun|function|if|in|include|inherit|initializer|int|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|string|switch|then|to|try|type|when|while|with)\b/,
		operator: /\.{3}|:[:=]?|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/,
		punctuation: /[(){}[\],;.]/
	};
	Prism$1.languages.insertBefore("rescript", "string", { "template-string": {
		pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
		greedy: true,
		inside: {
			"template-punctuation": {
				pattern: /^`|`$/,
				alias: "string"
			},
			interpolation: {
				pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
				lookbehind: true,
				inside: {
					"interpolation-punctuation": {
						pattern: /^\$\{|\}$/,
						alias: "tag"
					},
					rest: Prism$1.languages.rescript
				}
			},
			string: /[\s\S]+/
		}
	} });
	Prism$1.languages.res = Prism$1.languages.rescript;
}
rest.displayName = "rest";
rest.aliases = [];
function rest(Prism$1) {
	Prism$1.languages.rest = {
		table: [{
			pattern: /(^[\t ]*)(?:\+[=-]+)+\+(?:\r?\n|\r)(?:\1[+|].+[+|](?:\r?\n|\r))+\1(?:\+[=-]+)+\+/m,
			lookbehind: true,
			inside: { punctuation: /\||(?:\+[=-]+)+\+/ }
		}, {
			pattern: /(^[\t ]*)=+ [ =]*=(?:(?:\r?\n|\r)\1.+)+(?:\r?\n|\r)\1=+ [ =]*=(?=(?:\r?\n|\r){2}|\s*$)/m,
			lookbehind: true,
			inside: { punctuation: /[=-]+/ }
		}],
		"substitution-def": {
			pattern: /(^[\t ]*\.\. )\|(?:[^|\s](?:[^|]*[^|\s])?)\| [^:]+::/m,
			lookbehind: true,
			inside: {
				substitution: {
					pattern: /^\|(?:[^|\s]|[^|\s][^|]*[^|\s])\|/,
					alias: "attr-value",
					inside: { punctuation: /^\||\|$/ }
				},
				directive: {
					pattern: /( )(?! )[^:]+::/,
					lookbehind: true,
					alias: "function",
					inside: { punctuation: /::$/ }
				}
			}
		},
		"link-target": [{
			pattern: /(^[\t ]*\.\. )\[[^\]]+\]/m,
			lookbehind: true,
			alias: "string",
			inside: { punctuation: /^\[|\]$/ }
		}, {
			pattern: /(^[\t ]*\.\. )_(?:`[^`]+`|(?:[^:\\]|\\.)+):/m,
			lookbehind: true,
			alias: "string",
			inside: { punctuation: /^_|:$/ }
		}],
		directive: {
			pattern: /(^[\t ]*\.\. )[^:]+::/m,
			lookbehind: true,
			alias: "function",
			inside: { punctuation: /::$/ }
		},
		comment: {
			pattern: /(^[\t ]*\.\.)(?:(?: .+)?(?:(?:\r?\n|\r).+)+| .+)(?=(?:\r?\n|\r){2}|$)/m,
			lookbehind: true
		},
		title: [{
			pattern: /^(([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+)(?:\r?\n|\r).+(?:\r?\n|\r)\1$/m,
			inside: {
				punctuation: /^[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+|[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
				important: /.+/
			}
		}, {
			pattern: /(^|(?:\r?\n|\r){2}).+(?:\r?\n|\r)([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+(?=\r?\n|\r|$)/,
			lookbehind: true,
			inside: {
				punctuation: /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
				important: /.+/
			}
		}],
		hr: {
			pattern: /((?:\r?\n|\r){2})([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2{3,}(?=(?:\r?\n|\r){2})/,
			lookbehind: true,
			alias: "punctuation"
		},
		field: {
			pattern: /(^[\t ]*):[^:\r\n]+:(?= )/m,
			lookbehind: true,
			alias: "attr-name"
		},
		"command-line-option": {
			pattern: /(^[\t ]*)(?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?(?:, (?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?)*(?=(?:\r?\n|\r)? {2,}\S)/im,
			lookbehind: true,
			alias: "symbol"
		},
		"literal-block": {
			pattern: /::(?:\r?\n|\r){2}([ \t]+)(?![ \t]).+(?:(?:\r?\n|\r)\1.+)*/,
			inside: { "literal-block-punctuation": {
				pattern: /^::/,
				alias: "punctuation"
			} }
		},
		"quoted-literal-block": {
			pattern: /::(?:\r?\n|\r){2}([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]).*(?:(?:\r?\n|\r)\1.*)*/,
			inside: { "literal-block-punctuation": {
				pattern: /^(?:::|([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\1*)/m,
				alias: "punctuation"
			} }
		},
		"list-bullet": {
			pattern: /(^[\t ]*)(?:[*+\-•‣⁃]|\(?(?:\d+|[a-z]|[ivxdclm]+)\)|(?:\d+|[a-z]|[ivxdclm]+)\.)(?= )/im,
			lookbehind: true,
			alias: "punctuation"
		},
		"doctest-block": {
			pattern: /(^[\t ]*)>>> .+(?:(?:\r?\n|\r).+)*/m,
			lookbehind: true,
			inside: { punctuation: /^>>>/ }
		},
		inline: [{
			pattern: /(^|[\s\-:\/'"<(\[{])(?::[^:]+:`.*?`|`.*?`:[^:]+:|(\*\*?|``?|\|)(?!\s)(?:(?!\2).)*\S\2(?=[\s\-.,:;!?\\\/'")\]}]|$))/m,
			lookbehind: true,
			inside: {
				bold: {
					pattern: /(^\*\*).+(?=\*\*$)/,
					lookbehind: true
				},
				italic: {
					pattern: /(^\*).+(?=\*$)/,
					lookbehind: true
				},
				"inline-literal": {
					pattern: /(^``).+(?=``$)/,
					lookbehind: true,
					alias: "symbol"
				},
				role: {
					pattern: /^:[^:]+:|:[^:]+:$/,
					alias: "function",
					inside: { punctuation: /^:|:$/ }
				},
				"interpreted-text": {
					pattern: /(^`).+(?=`$)/,
					lookbehind: true,
					alias: "attr-value"
				},
				substitution: {
					pattern: /(^\|).+(?=\|$)/,
					lookbehind: true,
					alias: "attr-value"
				},
				punctuation: /\*\*?|``?|\|/
			}
		}],
		link: [{
			pattern: /\[[^\[\]]+\]_(?=[\s\-.,:;!?\\\/'")\]}]|$)/,
			alias: "string",
			inside: { punctuation: /^\[|\]_$/ }
		}, {
			pattern: /(?:\b[a-z\d]+(?:[_.:+][a-z\d]+)*_?_|`[^`]+`_?_|_`[^`]+`)(?=[\s\-.,:;!?\\\/'")\]}]|$)/i,
			alias: "string",
			inside: { punctuation: /^_?`|`$|`?_?_$/ }
		}],
		punctuation: {
			pattern: /(^[\t ]*)(?:\|(?= |$)|(?:---?|—|\.\.|__)(?= )|\.\.$)/m,
			lookbehind: true
		}
	};
}
rip.displayName = "rip";
rip.aliases = [];
function rip(Prism$1) {
	Prism$1.languages.rip = {
		comment: {
			pattern: /#.*/,
			greedy: true
		},
		char: {
			pattern: /\B`[^\s`'",.:;#\/\\()<>\[\]{}]\b/,
			greedy: true
		},
		string: {
			pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
			greedy: true
		},
		regex: {
			pattern: /(^|[^/])\/(?!\/)(?:\[[^\n\r\]]*\]|\\.|[^/\\\r\n\[])+\/(?=\s*(?:$|[\r\n,.;})]))/,
			lookbehind: true,
			greedy: true
		},
		keyword: /(?:=>|->)|\b(?:case|catch|class|else|exit|finally|if|raise|return|switch|try)\b/,
		builtin: /@|\bSystem\b/,
		boolean: /\b(?:false|true)\b/,
		date: /\b\d{4}-\d{2}-\d{2}\b/,
		time: /\b\d{2}:\d{2}:\d{2}\b/,
		datetime: /\b\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\b/,
		symbol: /:[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/,
		number: /[+-]?\b(?:\d+\.\d+|\d+)\b/,
		punctuation: /(?:\.{2,3})|[`,.:;=\/\\()<>\[\]{}]/,
		reference: /[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/
	};
}
roboconf.displayName = "roboconf";
roboconf.aliases = [];
function roboconf(Prism$1) {
	Prism$1.languages.roboconf = {
		comment: /#.*/,
		keyword: {
			pattern: /(^|\s)(?:(?:external|import)\b|(?:facet|instance of)(?=[ \t]+[\w-]+[ \t]*\{))/,
			lookbehind: true
		},
		component: {
			pattern: /[\w-]+(?=[ \t]*\{)/,
			alias: "variable"
		},
		property: /[\w.-]+(?=[ \t]*:)/,
		value: {
			pattern: /(=[ \t]*(?![ \t]))[^,;]+/,
			lookbehind: true,
			alias: "attr-value"
		},
		optional: {
			pattern: /\(optional\)/,
			alias: "builtin"
		},
		wildcard: {
			pattern: /(\.)\*/,
			lookbehind: true,
			alias: "operator"
		},
		punctuation: /[{},.;:=]/
	};
}
robotframework.displayName = "robotframework";
robotframework.aliases = ["robot"];
function robotframework(Prism$1) {
	(function(Prism$2) {
		var comment$2 = {
			pattern: /(^[ \t]*| {2}|\t)#.*/m,
			lookbehind: true,
			greedy: true
		};
		var variable = {
			pattern: /((?:^|[^\\])(?:\\{2})*)[$@&%]\{(?:[^{}\r\n]|\{[^{}\r\n]*\})*\}/,
			lookbehind: true,
			inside: { punctuation: /^[$@&%]\{|\}$/ }
		};
		function createSection(name$2, inside) {
			var extendecInside = {};
			extendecInside["section-header"] = {
				pattern: /^ ?\*{3}.+?\*{3}/,
				alias: "keyword"
			};
			for (var token in inside) extendecInside[token] = inside[token];
			extendecInside["tag"] = {
				pattern: /([\r\n](?: {2}|\t)[ \t]*)\[[-\w]+\]/,
				lookbehind: true,
				inside: { punctuation: /\[|\]/ }
			};
			extendecInside["variable"] = variable;
			extendecInside["comment"] = comment$2;
			return {
				pattern: RegExp(/^ ?\*{3}[ \t]*<name>[ \t]*\*{3}(?:.|[\r\n](?!\*{3}))*/.source.replace(/<name>/g, function() {
					return name$2;
				}), "im"),
				alias: "section",
				inside: extendecInside
			};
		}
		var docTag = {
			pattern: /(\[Documentation\](?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
			lookbehind: true,
			alias: "string"
		};
		var testNameLike = {
			pattern: /([\r\n] ?)(?!#)(?:\S(?:[ \t]\S)*)+/,
			lookbehind: true,
			alias: "function",
			inside: { variable }
		};
		var testPropertyLike = {
			pattern: /([\r\n](?: {2}|\t)[ \t]*)(?!\[|\.{3}|#)(?:\S(?:[ \t]\S)*)+/,
			lookbehind: true,
			inside: { variable }
		};
		Prism$2.languages["robotframework"] = {
			settings: createSection("Settings", {
				documentation: {
					pattern: /([\r\n] ?Documentation(?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
					lookbehind: true,
					alias: "string"
				},
				property: {
					pattern: /([\r\n] ?)(?!\.{3}|#)(?:\S(?:[ \t]\S)*)+/,
					lookbehind: true
				}
			}),
			variables: createSection("Variables"),
			"test-cases": createSection("Test Cases", {
				"test-name": testNameLike,
				documentation: docTag,
				property: testPropertyLike
			}),
			keywords: createSection("Keywords", {
				"keyword-name": testNameLike,
				documentation: docTag,
				property: testPropertyLike
			}),
			tasks: createSection("Tasks", {
				"task-name": testNameLike,
				documentation: docTag,
				property: testPropertyLike
			}),
			comment: comment$2
		};
		Prism$2.languages.robot = Prism$2.languages["robotframework"];
	})(Prism$1);
}
sas.displayName = "sas";
sas.aliases = [];
function sas(Prism$1) {
	(function(Prism$2) {
		var stringPattern = /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))/.source;
		var number$2 = /\b(?:\d[\da-f]*x|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i;
		var numericConstant = {
			pattern: RegExp(stringPattern + "[bx]"),
			alias: "number"
		};
		var macroVariable = { pattern: /&[a-z_]\w*/i };
		var macroKeyword = {
			pattern: /((?:^|\s|=|\())%(?:ABORT|BY|CMS|COPY|DISPLAY|DO|ELSE|END|EVAL|GLOBAL|GO|GOTO|IF|INC|INCLUDE|INDEX|INPUT|KTRIM|LENGTH|LET|LIST|LOCAL|PUT|QKTRIM|QSCAN|QSUBSTR|QSYSFUNC|QUPCASE|RETURN|RUN|SCAN|SUBSTR|SUPERQ|SYMDEL|SYMEXIST|SYMGLOBL|SYMLOCAL|SYSCALL|SYSEVALF|SYSEXEC|SYSFUNC|SYSGET|SYSRPUT|THEN|TO|TSO|UNQUOTE|UNTIL|UPCASE|WHILE|WINDOW)\b/i,
			lookbehind: true,
			alias: "keyword"
		};
		var step = {
			pattern: /(^|\s)(?:proc\s+\w+|data(?!=)|quit|run)\b/i,
			alias: "keyword",
			lookbehind: true
		};
		var comment$2 = [/\/\*[\s\S]*?\*\//, {
			pattern: /(^[ \t]*|;\s*)\*[^;]*;/m,
			lookbehind: true
		}];
		var string$2 = {
			pattern: RegExp(stringPattern),
			greedy: true
		};
		var punctuation = /[$%@.(){}\[\];,\\]/;
		var func = {
			pattern: /%?\b\w+(?=\()/,
			alias: "keyword"
		};
		var args = {
			function: func,
			"arg-value": {
				pattern: /(=\s*)[A-Z\.]+/i,
				lookbehind: true
			},
			operator: /=/,
			"macro-variable": macroVariable,
			arg: {
				pattern: /[A-Z]+/i,
				alias: "keyword"
			},
			number: number$2,
			"numeric-constant": numericConstant,
			punctuation,
			string: string$2
		};
		var format = {
			pattern: /\b(?:format|put)\b=?[\w'$.]+/i,
			inside: {
				keyword: /^(?:format|put)(?==)/i,
				equals: /=/,
				format: {
					pattern: /(?:\w|\$\d)+\.\d?/,
					alias: "number"
				}
			}
		};
		var altformat = {
			pattern: /\b(?:format|put)\s+[\w']+(?:\s+[$.\w]+)+(?=;)/i,
			inside: {
				keyword: /^(?:format|put)/i,
				format: {
					pattern: /[\w$]+\.\d?/,
					alias: "number"
				}
			}
		};
		var globalStatements = {
			pattern: /((?:^|\s)=?)(?:catname|checkpoint execute_always|dm|endsas|filename|footnote|%include|libname|%list|lock|missing|options|page|resetline|%run|sasfile|skip|sysecho|title\d?)\b/i,
			lookbehind: true,
			alias: "keyword"
		};
		var submitStatement = {
			pattern: /(^|\s)(?:submit(?:\s+(?:load|norun|parseonly))?|endsubmit)\b/i,
			lookbehind: true,
			alias: "keyword"
		};
		var actionSets = /aStore|accessControl|aggregation|audio|autotune|bayesianNetClassifier|bioMedImage|boolRule|builtins|cardinality|cdm|clustering|conditionalRandomFields|configuration|copula|countreg|dataDiscovery|dataPreprocess|dataSciencePilot|dataStep|decisionTree|deduplication|deepLearn|deepNeural|deepRnn|ds2|ecm|entityRes|espCluster|explainModel|factmac|fastKnn|fcmpact|fedSql|freqTab|gVarCluster|gam|gleam|graphSemiSupLearn|hiddenMarkovModel|hyperGroup|ica|image|iml|kernalPca|langModel|ldaTopic|loadStreams|mbc|mixed|mlTools|modelPublishing|network|neuralNet|nmf|nonParametricBayes|nonlinear|optNetwork|optimization|panel|pca|percentile|phreg|pls|qkb|qlim|quantreg|recommend|regression|reinforcementLearn|robustPca|ruleMining|sampling|sandwich|sccasl|search(?:Analytics)?|sentimentAnalysis|sequence|session(?:Prop)?|severity|simSystem|simple|smartData|sparkEmbeddedProcess|sparseML|spatialreg|spc|stabilityMonitoring|svDataDescription|svm|table|text(?:Filters|Frequency|Mining|Parse|Rule(?:Develop|Score)|Topic|Util)|timeData|transpose|tsInfo|tsReconcile|uniTimeSeries|varReduce/.source;
		var casActions = {
			pattern: RegExp(/(^|\s)(?:action\s+)?(?:<act>)\.[a-z]+\b[^;]+/.source.replace(/<act>/g, function() {
				return actionSets;
			}), "i"),
			lookbehind: true,
			inside: {
				keyword: RegExp(/(?:<act>)\.[a-z]+\b/.source.replace(/<act>/g, function() {
					return actionSets;
				}), "i"),
				action: {
					pattern: /(?:action)/i,
					alias: "keyword"
				},
				comment: comment$2,
				function: func,
				"arg-value": args["arg-value"],
				operator: args.operator,
				argument: args.arg,
				number: number$2,
				"numeric-constant": numericConstant,
				punctuation,
				string: string$2
			}
		};
		var keywords = {
			pattern: /((?:^|\s)=?)(?:after|analysis|and|array|barchart|barwidth|begingraph|by|call|cas|cbarline|cfill|class(?:lev)?|close|column|computed?|contains|continue|data(?==)|define|delete|describe|document|do\s+over|do|dol|drop|dul|else|end(?:comp|source)?|entryTitle|eval(?:uate)?|exec(?:ute)?|exit|file(?:name)?|fill(?:attrs)?|flist|fnc|function(?:list)?|global|goto|group(?:by)?|headline|headskip|histogram|if|infile|keep|keylabel|keyword|label|layout|leave|legendlabel|length|libname|loadactionset|merge|midpoints|_?null_|name|noobs|nowd|ods|options|or|otherwise|out(?:put)?|over(?:lay)?|plot|print|put|raise|ranexp|rannor|rbreak|retain|return|select|session|sessref|set|source|statgraph|sum|summarize|table|temp|terminate|then\s+do|then|title\d?|to|var|when|where|xaxisopts|y2axisopts|yaxisopts)\b/i,
			lookbehind: true
		};
		Prism$2.languages.sas = {
			datalines: {
				pattern: /^([ \t]*)(?:cards|(?:data)?lines);[\s\S]+?^[ \t]*;/im,
				lookbehind: true,
				alias: "string",
				inside: {
					keyword: { pattern: /^(?:cards|(?:data)?lines)/i },
					punctuation: /;/
				}
			},
			"proc-sql": {
				pattern: /(^proc\s+(?:fed)?sql(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
				lookbehind: true,
				inside: {
					sql: {
						pattern: RegExp(/^[ \t]*(?:select|alter\s+table|(?:create|describe|drop)\s+(?:index|table(?:\s+constraints)?|view)|create\s+unique\s+index|insert\s+into|update)(?:<str>|[^;"'])+;/.source.replace(/<str>/g, function() {
							return stringPattern;
						}), "im"),
						alias: "language-sql",
						inside: Prism$2.languages.sql
					},
					"global-statements": globalStatements,
					"sql-statements": {
						pattern: /(^|\s)(?:disconnect\s+from|begin|commit|exec(?:ute)?|reset|rollback|validate)\b/i,
						lookbehind: true,
						alias: "keyword"
					},
					number: number$2,
					"numeric-constant": numericConstant,
					punctuation,
					string: string$2
				}
			},
			"proc-groovy": {
				pattern: /(^proc\s+groovy(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
				lookbehind: true,
				inside: {
					comment: comment$2,
					groovy: {
						pattern: RegExp(/(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(/<str>/g, function() {
							return stringPattern;
						}), "im"),
						lookbehind: true,
						alias: "language-groovy",
						inside: Prism$2.languages.groovy
					},
					keyword: keywords,
					"submit-statement": submitStatement,
					"global-statements": globalStatements,
					number: number$2,
					"numeric-constant": numericConstant,
					punctuation,
					string: string$2
				}
			},
			"proc-lua": {
				pattern: /(^proc\s+lua(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
				lookbehind: true,
				inside: {
					comment: comment$2,
					lua: {
						pattern: RegExp(/(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(/<str>/g, function() {
							return stringPattern;
						}), "im"),
						lookbehind: true,
						alias: "language-lua",
						inside: Prism$2.languages.lua
					},
					keyword: keywords,
					"submit-statement": submitStatement,
					"global-statements": globalStatements,
					number: number$2,
					"numeric-constant": numericConstant,
					punctuation,
					string: string$2
				}
			},
			"proc-cas": {
				pattern: /(^proc\s+cas(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|quit|data);|(?![\s\S]))/im,
				lookbehind: true,
				inside: {
					comment: comment$2,
					"statement-var": {
						pattern: /((?:^|\s)=?)saveresult\s[^;]+/im,
						lookbehind: true,
						inside: {
							statement: {
								pattern: /^saveresult\s+\S+/i,
								inside: { keyword: /^(?:saveresult)/i }
							},
							rest: args
						}
					},
					"cas-actions": casActions,
					statement: {
						pattern: /((?:^|\s)=?)(?:default|(?:un)?set|on|output|upload)[^;]+/im,
						lookbehind: true,
						inside: args
					},
					step,
					keyword: keywords,
					function: func,
					format,
					altformat,
					"global-statements": globalStatements,
					number: number$2,
					"numeric-constant": numericConstant,
					punctuation,
					string: string$2
				}
			},
			"proc-args": {
				pattern: RegExp(/(^proc\s+\w+\s+)(?!\s)(?:[^;"']|<str>)+;/.source.replace(/<str>/g, function() {
					return stringPattern;
				}), "im"),
				lookbehind: true,
				inside: args
			},
			"macro-keyword": macroKeyword,
			"macro-variable": macroVariable,
			"macro-string-functions": {
				pattern: /((?:^|\s|=))%(?:BQUOTE|NRBQUOTE|NRQUOTE|NRSTR|QUOTE|STR)\(.*?(?:[^%]\))/i,
				lookbehind: true,
				inside: {
					function: {
						pattern: /%(?:BQUOTE|NRBQUOTE|NRQUOTE|NRSTR|QUOTE|STR)/i,
						alias: "keyword"
					},
					"macro-keyword": macroKeyword,
					"macro-variable": macroVariable,
					"escaped-char": { pattern: /%['"()<>=¬^~;,#]/ },
					punctuation
				}
			},
			"macro-declaration": {
				pattern: /^%macro[^;]+(?=;)/im,
				inside: { keyword: /%macro/i }
			},
			"macro-end": {
				pattern: /^%mend[^;]+(?=;)/im,
				inside: { keyword: /%mend/i }
			},
			macro: {
				pattern: /%_\w+(?=\()/,
				alias: "keyword"
			},
			input: {
				pattern: /\binput\s[-\w\s/*.$&]+;/i,
				inside: {
					input: {
						alias: "keyword",
						pattern: /^input/i
					},
					comment: comment$2,
					number: number$2,
					"numeric-constant": numericConstant
				}
			},
			"options-args": {
				pattern: /(^options)[-'"|/\\<>*+=:()\w\s]*(?=;)/im,
				lookbehind: true,
				inside: args
			},
			"cas-actions": casActions,
			comment: comment$2,
			function: func,
			format,
			altformat,
			"numeric-constant": numericConstant,
			datetime: {
				pattern: RegExp(stringPattern + "(?:dt?|t)"),
				alias: "number"
			},
			string: string$2,
			step,
			keyword: keywords,
			"operator-keyword": {
				pattern: /\b(?:eq|ge|gt|in|le|lt|ne|not)\b/i,
				alias: "operator"
			},
			number: number$2,
			operator: /\*\*?|\|\|?|!!?|¦¦?|<[>=]?|>[<=]?|[-+\/=&]|[~¬^]=?/,
			punctuation
		};
	})(Prism$1);
}
shellSession.displayName = "shell-session";
shellSession.aliases = ["sh-session", "shellsession"];
function shellSession(Prism$1) {
	Prism$1.register(bash);
	(function(Prism$2) {
		var strings = [
			/"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/.source,
			/'[^']*'/.source,
			/\$'(?:[^'\\]|\\[\s\S])*'/.source,
			/<<-?\s*(["']?)(\w+)\1\s[\s\S]*?[\r\n]\2/.source
		].join("|");
		Prism$2.languages["shell-session"] = {
			command: {
				pattern: RegExp(/^/.source + "(?:" + (/[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+(?::[^\0-\x1F$#%*?"<>:;|]+)?/.source + "|" + /[/~.][^\0-\x1F$#%*?"<>@:;|]*/.source) + ")?" + /[$#%](?=\s)/.source + /(?:[^\\\r\n \t'"<$]|[ \t](?:(?!#)|#.*$)|\\(?:[^\r]|\r\n?)|\$(?!')|<(?!<)|<<str>>)+/.source.replace(/<<str>>/g, function() {
					return strings;
				}), "m"),
				greedy: true,
				inside: {
					info: {
						pattern: /^[^#$%]+/,
						alias: "punctuation",
						inside: {
							user: /^[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+/,
							punctuation: /:/,
							path: /[\s\S]+/
						}
					},
					bash: {
						pattern: /(^[$#%]\s*)\S[\s\S]*/,
						lookbehind: true,
						alias: "language-bash",
						inside: Prism$2.languages.bash
					},
					"shell-symbol": {
						pattern: /^[$#%]/,
						alias: "important"
					}
				}
			},
			output: /.(?:.*(?:[\r\n]|.$))*/
		};
		Prism$2.languages["sh-session"] = Prism$2.languages["shellsession"] = Prism$2.languages["shell-session"];
	})(Prism$1);
}
smali.displayName = "smali";
smali.aliases = [];
function smali(Prism$1) {
	Prism$1.languages.smali = {
		comment: /#.*/,
		string: {
			pattern: /"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\(?:.|u[\da-fA-F]{4}))'/,
			greedy: true
		},
		"class-name": {
			pattern: /(^|[^L])L(?:(?:\w+|`[^`\r\n]*`)\/)*(?:[\w$]+|`[^`\r\n]*`)(?=\s*;)/,
			lookbehind: true,
			inside: {
				"class-name": {
					pattern: /(^L|\/)(?:[\w$]+|`[^`\r\n]*`)$/,
					lookbehind: true
				},
				namespace: {
					pattern: /^(L)(?:(?:\w+|`[^`\r\n]*`)\/)+/,
					lookbehind: true,
					inside: { punctuation: /\// }
				},
				builtin: /^L/
			}
		},
		builtin: [{
			pattern: /([();\[])[BCDFIJSVZ]+/,
			lookbehind: true
		}, {
			pattern: /([\w$>]:)[BCDFIJSVZ]/,
			lookbehind: true
		}],
		keyword: [
			{
				pattern: /(\.end\s+)[\w-]+/,
				lookbehind: true
			},
			{
				pattern: /(^|[^\w.-])\.(?!\d)[\w-]+/,
				lookbehind: true
			},
			{
				pattern: /(^|[^\w.-])(?:abstract|annotation|bridge|constructor|enum|final|interface|private|protected|public|runtime|static|synthetic|system|transient)(?![\w.-])/,
				lookbehind: true
			}
		],
		function: {
			pattern: /(^|[^\w.-])(?:\w+|<[\w$-]+>)(?=\()/,
			lookbehind: true
		},
		field: {
			pattern: /[\w$]+(?=:)/,
			alias: "variable"
		},
		register: {
			pattern: /(^|[^\w.-])[vp]\d(?![\w.-])/,
			lookbehind: true,
			alias: "variable"
		},
		boolean: {
			pattern: /(^|[^\w.-])(?:false|true)(?![\w.-])/,
			lookbehind: true
		},
		number: {
			pattern: /(^|[^/\w.-])-?(?:NAN|INFINITY|0x(?:[\dA-F]+(?:\.[\dA-F]*)?|\.[\dA-F]+)(?:p[+-]?[\dA-F]+)?|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)[dflst]?(?![\w.-])/i,
			lookbehind: true
		},
		label: {
			pattern: /(:)\w+/,
			lookbehind: true,
			alias: "property"
		},
		operator: /->|\.\.|[\[=]/,
		punctuation: /[{}(),;:]/
	};
}
smalltalk.displayName = "smalltalk";
smalltalk.aliases = [];
function smalltalk(Prism$1) {
	Prism$1.languages.smalltalk = {
		comment: {
			pattern: /"(?:""|[^"])*"/,
			greedy: true
		},
		char: {
			pattern: /\$./,
			greedy: true
		},
		string: {
			pattern: /'(?:''|[^'])*'/,
			greedy: true
		},
		symbol: /#[\da-z]+|#(?:-|([+\/\\*~<>=@%|&?!])\1?)|#(?=\()/i,
		"block-arguments": {
			pattern: /(\[\s*):[^\[|]*\|/,
			lookbehind: true,
			inside: {
				variable: /:[\da-z]+/i,
				punctuation: /\|/
			}
		},
		"temporary-variables": {
			pattern: /\|[^|]+\|/,
			inside: {
				variable: /[\da-z]+/i,
				punctuation: /\|/
			}
		},
		keyword: /\b(?:new|nil|self|super)\b/,
		boolean: /\b(?:false|true)\b/,
		number: [/\d+r-?[\dA-Z]+(?:\.[\dA-Z]+)?(?:e-?\d+)?/, /\b\d+(?:\.\d+)?(?:e-?\d+)?/],
		operator: /[<=]=?|:=|~[~=]|\/\/?|\\\\|>[>=]?|[!^+\-*&|,@]/,
		punctuation: /[.;:?\[\](){}]/
	};
}
smarty.displayName = "smarty";
smarty.aliases = [];
function smarty(Prism$1) {
	Prism$1.register(markupTemplating);
	(function(Prism$2) {
		Prism$2.languages.smarty = {
			comment: {
				pattern: /^\{\*[\s\S]*?\*\}/,
				greedy: true
			},
			"embedded-php": {
				pattern: /^\{php\}[\s\S]*?\{\/php\}/,
				greedy: true,
				inside: {
					smarty: {
						pattern: /^\{php\}|\{\/php\}$/,
						inside: null
					},
					php: {
						pattern: /[\s\S]+/,
						alias: "language-php",
						inside: Prism$2.languages.php
					}
				}
			},
			string: [{
				pattern: /"(?:\\.|[^"\\\r\n])*"/,
				greedy: true,
				inside: {
					interpolation: {
						pattern: /\{[^{}]*\}|`[^`]*`/,
						inside: {
							"interpolation-punctuation": {
								pattern: /^[{`]|[`}]$/,
								alias: "punctuation"
							},
							expression: {
								pattern: /[\s\S]+/,
								inside: null
							}
						}
					},
					variable: /\$\w+/
				}
			}, {
				pattern: /'(?:\\.|[^'\\\r\n])*'/,
				greedy: true
			}],
			keyword: {
				pattern: /(^\{\/?)[a-z_]\w*\b(?!\()/i,
				lookbehind: true,
				greedy: true
			},
			delimiter: {
				pattern: /^\{\/?|\}$/,
				greedy: true,
				alias: "punctuation"
			},
			number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
			variable: [
				/\$(?!\d)\w+/,
				/#(?!\d)\w+#/,
				{
					pattern: /(\.|->|\w\s*=)(?!\d)\w+\b(?!\()/,
					lookbehind: true
				},
				{
					pattern: /(\[)(?!\d)\w+(?=\])/,
					lookbehind: true
				}
			],
			function: {
				pattern: /(\|\s*)@?[a-z_]\w*|\b[a-z_]\w*(?=\()/i,
				lookbehind: true
			},
			"attr-name": /\b[a-z_]\w*(?=\s*=)/i,
			boolean: /\b(?:false|no|off|on|true|yes)\b/,
			punctuation: /[\[\](){}.,:`]|->/,
			operator: [
				/[+\-*\/%]|==?=?|[!<>]=?|&&|\|\|?/,
				/\bis\s+(?:not\s+)?(?:div|even|odd)(?:\s+by)?\b/,
				/\b(?:and|eq|gt?e|gt|lt?e|lt|mod|neq?|not|or)\b/
			]
		};
		Prism$2.languages.smarty["embedded-php"].inside.smarty.inside = Prism$2.languages.smarty;
		Prism$2.languages.smarty.string[0].inside.interpolation.inside.expression.inside = Prism$2.languages.smarty;
		var string$2 = /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/;
		var smartyPattern = RegExp(/\{\*[\s\S]*?\*\}/.source + "|" + /\{php\}[\s\S]*?\{\/php\}/.source + "|" + /\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>)*\})*\})*\}/.source.replace(/<str>/g, function() {
			return string$2.source;
		}), "g");
		Prism$2.hooks.add("before-tokenize", function(env$1) {
			var smartyLiteralStart = "{literal}";
			var smartyLiteralEnd = "{/literal}";
			var smartyLiteralMode = false;
			Prism$2.languages["markup-templating"].buildPlaceholders(env$1, "smarty", smartyPattern, function(match) {
				if (match === smartyLiteralEnd) smartyLiteralMode = false;
				if (!smartyLiteralMode) {
					if (match === smartyLiteralStart) smartyLiteralMode = true;
					return true;
				}
				return false;
			});
		});
		Prism$2.hooks.add("after-tokenize", function(env$1) {
			Prism$2.languages["markup-templating"].tokenizePlaceholders(env$1, "smarty");
		});
	})(Prism$1);
}
sml.displayName = "sml";
sml.aliases = ["smlnj"];
function sml(Prism$1) {
	(function(Prism$2) {
		var keywords = /\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\b/i;
		Prism$2.languages.sml = {
			comment: /\(\*(?:[^*(]|\*(?!\))|\((?!\*)|\(\*(?:[^*(]|\*(?!\))|\((?!\*))*\*\))*\*\)/,
			string: {
				pattern: /#?"(?:[^"\\]|\\.)*"/,
				greedy: true
			},
			"class-name": [{
				pattern: RegExp(/((?:^|[^:]):\s*)<TERMINAL>(?:\s*(?:(?:\*|->)\s*<TERMINAL>|,\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\s+<LONG-ID>)))*/.source.replace(/<NOT-LAST>/g, function() {
					return /\s*(?:[*,]|->)/.source;
				}).replace(/<TERMINAL>/g, function() {
					return /(?:'[\w']*|<LONG-ID>|\((?:[^()]|\([^()]*\))*\)|\{(?:[^{}]|\{[^{}]*\})*\})(?:\s+<LONG-ID>)*/.source;
				}).replace(/<LONG-ID>/g, function() {
					return /(?!<KEYWORD>)[a-z\d_][\w'.]*/.source;
				}).replace(/<KEYWORD>/g, function() {
					return keywords.source;
				}), "i"),
				lookbehind: true,
				greedy: true,
				inside: null
			}, {
				pattern: /((?:^|[^\w'])(?:datatype|exception|functor|signature|structure|type)\s+)[a-z_][\w'.]*/i,
				lookbehind: true
			}],
			function: {
				pattern: /((?:^|[^\w'])fun\s+)[a-z_][\w'.]*/i,
				lookbehind: true
			},
			keyword: keywords,
			variable: {
				pattern: /(^|[^\w'])'[\w']*/,
				lookbehind: true
			},
			number: /~?\b(?:\d+(?:\.\d+)?(?:e~?\d+)?|0x[\da-f]+)\b/i,
			word: {
				pattern: /\b0w(?:\d+|x[\da-f]+)\b/i,
				alias: "constant"
			},
			boolean: /\b(?:false|true)\b/i,
			operator: /\.\.\.|:[>=:]|=>?|->|[<>]=?|[!+\-*/^#|@~]/,
			punctuation: /[(){}\[\].:,;]/
		};
		Prism$2.languages.sml["class-name"][0].inside = Prism$2.languages.sml;
		Prism$2.languages.smlnj = Prism$2.languages.sml;
	})(Prism$1);
}
solidity.displayName = "solidity";
solidity.aliases = ["sol"];
function solidity(Prism$1) {
	Prism$1.register(clike);
	Prism$1.languages.solidity = Prism$1.languages.extend("clike", {
		"class-name": {
			pattern: /(\b(?:contract|enum|interface|library|new|struct|using)\s+)(?!\d)[\w$]+/,
			lookbehind: true
		},
		keyword: /\b(?:_|anonymous|as|assembly|assert|break|calldata|case|constant|constructor|continue|contract|default|delete|do|else|emit|enum|event|external|for|from|function|if|import|indexed|inherited|interface|internal|is|let|library|mapping|memory|modifier|new|payable|pragma|private|public|pure|require|returns?|revert|selfdestruct|solidity|storage|struct|suicide|switch|this|throw|using|var|view|while)\b/,
		operator: /=>|->|:=|=:|\*\*|\+\+|--|\|\||&&|<<=?|>>=?|[-+*/%^&|<>!=]=?|[~?]/
	});
	Prism$1.languages.insertBefore("solidity", "keyword", { builtin: /\b(?:address|bool|byte|u?int(?:8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?|string|bytes(?:[1-9]|[12]\d|3[0-2])?)\b/ });
	Prism$1.languages.insertBefore("solidity", "number", { version: {
		pattern: /([<>]=?|\^)\d+\.\d+\.\d+\b/,
		lookbehind: true,
		alias: "number"
	} });
	Prism$1.languages.sol = Prism$1.languages.solidity;
}
solutionFile.displayName = "solution-file";
solutionFile.aliases = ["sln"];
function solutionFile(Prism$1) {
	(function(Prism$2) {
		var guid = {
			pattern: /\{[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}\}/i,
			alias: "constant",
			inside: { punctuation: /[{}]/ }
		};
		Prism$2.languages["solution-file"] = {
			comment: {
				pattern: /#.*/,
				greedy: true
			},
			string: {
				pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
				greedy: true,
				inside: { guid }
			},
			object: {
				pattern: /^([ \t]*)(?:([A-Z]\w*)\b(?=.*(?:\r\n?|\n)(?:\1[ \t].*(?:\r\n?|\n))*\1End\2(?=[ \t]*$))|End[A-Z]\w*(?=[ \t]*$))/m,
				lookbehind: true,
				greedy: true,
				alias: "keyword"
			},
			property: {
				pattern: /^([ \t]*)(?!\s)[^\r\n"#=()]*[^\s"#=()](?=\s*=)/m,
				lookbehind: true,
				inside: { guid }
			},
			guid,
			number: /\b\d+(?:\.\d+)*\b/,
			boolean: /\b(?:FALSE|TRUE)\b/,
			operator: /=/,
			punctuation: /[(),]/
		};
		Prism$2.languages["sln"] = Prism$2.languages["solution-file"];
	})(Prism$1);
}
soy.displayName = "soy";
soy.aliases = [];
function soy(Prism$1) {
	Prism$1.register(markupTemplating);
	(function(Prism$2) {
		var stringPattern = /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
		var numberPattern = /\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b0x[\dA-F]+\b/;
		Prism$2.languages.soy = {
			comment: [/\/\*[\s\S]*?\*\//, {
				pattern: /(\s)\/\/.*/,
				lookbehind: true,
				greedy: true
			}],
			"command-arg": {
				pattern: /(\{+\/?\s*(?:alias|call|delcall|delpackage|deltemplate|namespace|template)\s+)\.?[\w.]+/,
				lookbehind: true,
				alias: "string",
				inside: { punctuation: /\./ }
			},
			parameter: {
				pattern: /(\{+\/?\s*@?param\??\s+)\.?[\w.]+/,
				lookbehind: true,
				alias: "variable"
			},
			keyword: [{
				pattern: /(\{+\/?[^\S\r\n]*)(?:\\[nrt]|alias|call|case|css|default|delcall|delpackage|deltemplate|else(?:if)?|fallbackmsg|for(?:each)?|if(?:empty)?|lb|let|literal|msg|namespace|nil|@?param\??|rb|sp|switch|template|xid)/,
				lookbehind: true
			}, /\b(?:any|as|attributes|bool|css|float|html|in|int|js|list|map|null|number|string|uri)\b/],
			delimiter: {
				pattern: /^\{+\/?|\/?\}+$/,
				alias: "punctuation"
			},
			property: /\w+(?==)/,
			variable: {
				pattern: /\$[^\W\d]\w*(?:\??(?:\.\w+|\[[^\]]+\]))*/,
				inside: {
					string: {
						pattern: stringPattern,
						greedy: true
					},
					number: numberPattern,
					punctuation: /[\[\].?]/
				}
			},
			string: {
				pattern: stringPattern,
				greedy: true
			},
			function: [/\w+(?=\()/, {
				pattern: /(\|[^\S\r\n]*)\w+/,
				lookbehind: true
			}],
			boolean: /\b(?:false|true)\b/,
			number: numberPattern,
			operator: /\?:?|<=?|>=?|==?|!=|[+*/%-]|\b(?:and|not|or)\b/,
			punctuation: /[{}()\[\]|.,:]/
		};
		Prism$2.hooks.add("before-tokenize", function(env$1) {
			var soyPattern = /\{\{.+?\}\}|\{.+?\}|\s\/\/.*|\/\*[\s\S]*?\*\//g;
			var soyLitteralStart = "{literal}";
			var soyLitteralEnd = "{/literal}";
			var soyLitteralMode = false;
			Prism$2.languages["markup-templating"].buildPlaceholders(env$1, "soy", soyPattern, function(match) {
				if (match === soyLitteralEnd) soyLitteralMode = false;
				if (!soyLitteralMode) {
					if (match === soyLitteralStart) soyLitteralMode = true;
					return true;
				}
				return false;
			});
		});
		Prism$2.hooks.add("after-tokenize", function(env$1) {
			Prism$2.languages["markup-templating"].tokenizePlaceholders(env$1, "soy");
		});
	})(Prism$1);
}
turtle.displayName = "turtle";
turtle.aliases = ["trig"];
function turtle(Prism$1) {
	Prism$1.languages.turtle = {
		comment: {
			pattern: /#.*/,
			greedy: true
		},
		"multiline-string": {
			pattern: /"""(?:(?:""?)?(?:[^"\\]|\\.))*"""|'''(?:(?:''?)?(?:[^'\\]|\\.))*'''/,
			greedy: true,
			alias: "string",
			inside: { comment: /#.*/ }
		},
		string: {
			pattern: /"(?:[^\\"\r\n]|\\.)*"|'(?:[^\\'\r\n]|\\.)*'/,
			greedy: true
		},
		url: {
			pattern: /<(?:[^\x00-\x20<>"{}|^`\\]|\\(?:u[\da-fA-F]{4}|U[\da-fA-F]{8}))*>/,
			greedy: true,
			inside: { punctuation: /[<>]/ }
		},
		function: {
			pattern: /(?:(?![-.\d\xB7])[-.\w\xB7\xC0-\uFFFD]+)?:(?:(?![-.])(?:[-.:\w\xC0-\uFFFD]|%[\da-f]{2}|\\.)+)?/i,
			inside: {
				"local-name": {
					pattern: /([^:]*:)[\s\S]+/,
					lookbehind: true
				},
				prefix: {
					pattern: /[\s\S]+/,
					inside: { punctuation: /:/ }
				}
			}
		},
		number: /[+-]?\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
		punctuation: /[{}.,;()[\]]|\^\^/,
		boolean: /\b(?:false|true)\b/,
		keyword: [/(?:\ba|@prefix|@base)\b|=/, /\b(?:base|graph|prefix)\b/i],
		tag: {
			pattern: /@[a-z]+(?:-[a-z\d]+)*/i,
			inside: { punctuation: /@/ }
		}
	};
	Prism$1.languages.trig = Prism$1.languages["turtle"];
}
sparql.displayName = "sparql";
sparql.aliases = ["rq"];
function sparql(Prism$1) {
	Prism$1.register(turtle);
	Prism$1.languages.sparql = Prism$1.languages.extend("turtle", {
		boolean: /\b(?:false|true)\b/i,
		variable: {
			pattern: /[?$]\w+/,
			greedy: true
		}
	});
	Prism$1.languages.insertBefore("sparql", "punctuation", { keyword: [
		/\b(?:A|ADD|ALL|AS|ASC|ASK|BNODE|BY|CLEAR|CONSTRUCT|COPY|CREATE|DATA|DEFAULT|DELETE|DESC|DESCRIBE|DISTINCT|DROP|EXISTS|FILTER|FROM|GROUP|HAVING|INSERT|INTO|LIMIT|LOAD|MINUS|MOVE|NAMED|NOT|NOW|OFFSET|OPTIONAL|ORDER|RAND|REDUCED|SELECT|SEPARATOR|SERVICE|SILENT|STRUUID|UNION|USING|UUID|VALUES|WHERE)\b/i,
		/\b(?:ABS|AVG|BIND|BOUND|CEIL|COALESCE|CONCAT|CONTAINS|COUNT|DATATYPE|DAY|ENCODE_FOR_URI|FLOOR|GROUP_CONCAT|HOURS|IF|IRI|isBLANK|isIRI|isLITERAL|isNUMERIC|isURI|LANG|LANGMATCHES|LCASE|MAX|MD5|MIN|MINUTES|MONTH|REGEX|REPLACE|ROUND|sameTerm|SAMPLE|SECONDS|SHA1|SHA256|SHA384|SHA512|STR|STRAFTER|STRBEFORE|STRDT|STRENDS|STRLANG|STRLEN|STRSTARTS|SUBSTR|SUM|TIMEZONE|TZ|UCASE|URI|YEAR)\b(?=\s*\()/i,
		/\b(?:BASE|GRAPH|PREFIX)\b/i
	] });
	Prism$1.languages.rq = Prism$1.languages.sparql;
}
splunkSpl.displayName = "splunk-spl";
splunkSpl.aliases = [];
function splunkSpl(Prism$1) {
	Prism$1.languages["splunk-spl"] = {
		comment: /`comment\("(?:\\.|[^\\"])*"\)`/,
		string: {
			pattern: /"(?:\\.|[^\\"])*"/,
			greedy: true
		},
		keyword: /\b(?:abstract|accum|addcoltotals|addinfo|addtotals|analyzefields|anomalies|anomalousvalue|anomalydetection|append|appendcols|appendcsv|appendlookup|appendpipe|arules|associate|audit|autoregress|bin|bucket|bucketdir|chart|cluster|cofilter|collect|concurrency|contingency|convert|correlate|datamodel|dbinspect|dedup|delete|delta|diff|erex|eval|eventcount|eventstats|extract|fieldformat|fields|fieldsummary|filldown|fillnull|findtypes|folderize|foreach|format|from|gauge|gentimes|geom|geomfilter|geostats|head|highlight|history|iconify|input|inputcsv|inputlookup|iplocation|join|kmeans|kv|kvform|loadjob|localize|localop|lookup|makecontinuous|makemv|makeresults|map|mcollect|metadata|metasearch|meventcollect|mstats|multikv|multisearch|mvcombine|mvexpand|nomv|outlier|outputcsv|outputlookup|outputtext|overlap|pivot|predict|rangemap|rare|regex|relevancy|reltime|rename|replace|rest|return|reverse|rex|rtorder|run|savedsearch|script|scrub|search|searchtxn|selfjoin|sendemail|set|setfields|sichart|sirare|sistats|sitimechart|sitop|sort|spath|stats|strcat|streamstats|table|tags|tail|timechart|timewrap|top|transaction|transpose|trendline|tscollect|tstats|typeahead|typelearner|typer|union|uniq|untable|where|x11|xmlkv|xmlunescape|xpath|xyseries)\b/i,
		"operator-word": {
			pattern: /\b(?:and|as|by|not|or|xor)\b/i,
			alias: "operator"
		},
		function: /\b\w+(?=\s*\()/,
		property: /\b\w+(?=\s*=(?!=))/,
		date: {
			pattern: /\b\d{1,2}\/\d{1,2}\/\d{1,4}(?:(?::\d{1,2}){3})?\b/,
			alias: "number"
		},
		number: /\b\d+(?:\.\d+)?\b/,
		boolean: /\b(?:f|false|t|true)\b/i,
		operator: /[<>=]=?|[-+*/%|]/,
		punctuation: /[()[\],]/
	};
}
sqf.displayName = "sqf";
sqf.aliases = [];
function sqf(Prism$1) {
	Prism$1.register(clike);
	Prism$1.languages.sqf = Prism$1.languages.extend("clike", {
		string: {
			pattern: /"(?:(?:"")?[^"])*"(?!")|'(?:[^'])*'/,
			greedy: true
		},
		keyword: /\b(?:breakOut|breakTo|call|case|catch|default|do|echo|else|execFSM|execVM|exitWith|for|forEach|forEachMember|forEachMemberAgent|forEachMemberTeam|from|goto|if|nil|preprocessFile|preprocessFileLineNumbers|private|scopeName|spawn|step|switch|then|throw|to|try|while|with)\b/i,
		boolean: /\b(?:false|true)\b/i,
		function: /\b(?:abs|accTime|acos|action|actionIDs|actionKeys|actionKeysImages|actionKeysNames|actionKeysNamesArray|actionName|actionParams|activateAddons|activatedAddons|activateKey|add3DENConnection|add3DENEventHandler|add3DENLayer|addAction|addBackpack|addBackpackCargo|addBackpackCargoGlobal|addBackpackGlobal|addCamShake|addCuratorAddons|addCuratorCameraArea|addCuratorEditableObjects|addCuratorEditingArea|addCuratorPoints|addEditorObject|addEventHandler|addForce|addForceGeneratorRTD|addGoggles|addGroupIcon|addHandgunItem|addHeadgear|addItem|addItemCargo|addItemCargoGlobal|addItemPool|addItemToBackpack|addItemToUniform|addItemToVest|addLiveStats|addMagazine|addMagazineAmmoCargo|addMagazineCargo|addMagazineCargoGlobal|addMagazineGlobal|addMagazinePool|addMagazines|addMagazineTurret|addMenu|addMenuItem|addMissionEventHandler|addMPEventHandler|addMusicEventHandler|addOwnedMine|addPlayerScores|addPrimaryWeaponItem|addPublicVariableEventHandler|addRating|addResources|addScore|addScoreSide|addSecondaryWeaponItem|addSwitchableUnit|addTeamMember|addToRemainsCollector|addTorque|addUniform|addVehicle|addVest|addWaypoint|addWeapon|addWeaponCargo|addWeaponCargoGlobal|addWeaponGlobal|addWeaponItem|addWeaponPool|addWeaponTurret|admin|agent|agents|AGLToASL|aimedAtTarget|aimPos|airDensityCurveRTD|airDensityRTD|airplaneThrottle|airportSide|AISFinishHeal|alive|all3DENEntities|allAirports|allControls|allCurators|allCutLayers|allDead|allDeadMen|allDisplays|allGroups|allMapMarkers|allMines|allMissionObjects|allow3DMode|allowCrewInImmobile|allowCuratorLogicIgnoreAreas|allowDamage|allowDammage|allowFileOperations|allowFleeing|allowGetIn|allowSprint|allPlayers|allSimpleObjects|allSites|allTurrets|allUnits|allUnitsUAV|allVariables|ammo|ammoOnPylon|animate|animateBay|animateDoor|animatePylon|animateSource|animationNames|animationPhase|animationSourcePhase|animationState|append|apply|armoryPoints|arrayIntersect|asin|ASLToAGL|ASLToATL|assert|assignAsCargo|assignAsCargoIndex|assignAsCommander|assignAsDriver|assignAsGunner|assignAsTurret|assignCurator|assignedCargo|assignedCommander|assignedDriver|assignedGunner|assignedItems|assignedTarget|assignedTeam|assignedVehicle|assignedVehicleRole|assignItem|assignTeam|assignToAirport|atan|atan2|atg|ATLToASL|attachedObject|attachedObjects|attachedTo|attachObject|attachTo|attackEnabled|backpack|backpackCargo|backpackContainer|backpackItems|backpackMagazines|backpackSpaceFor|behaviour|benchmark|binocular|blufor|boundingBox|boundingBoxReal|boundingCenter|briefingName|buildingExit|buildingPos|buldozer_EnableRoadDiag|buldozer_IsEnabledRoadDiag|buldozer_LoadNewRoads|buldozer_reloadOperMap|buttonAction|buttonSetAction|cadetMode|callExtension|camCommand|camCommit|camCommitPrepared|camCommitted|camConstuctionSetParams|camCreate|camDestroy|cameraEffect|cameraEffectEnableHUD|cameraInterest|cameraOn|cameraView|campaignConfigFile|camPreload|camPreloaded|camPrepareBank|camPrepareDir|camPrepareDive|camPrepareFocus|camPrepareFov|camPrepareFovRange|camPreparePos|camPrepareRelPos|camPrepareTarget|camSetBank|camSetDir|camSetDive|camSetFocus|camSetFov|camSetFovRange|camSetPos|camSetRelPos|camSetTarget|camTarget|camUseNVG|canAdd|canAddItemToBackpack|canAddItemToUniform|canAddItemToVest|cancelSimpleTaskDestination|canFire|canMove|canSlingLoad|canStand|canSuspend|canTriggerDynamicSimulation|canUnloadInCombat|canVehicleCargo|captive|captiveNum|cbChecked|cbSetChecked|ceil|channelEnabled|cheatsEnabled|checkAIFeature|checkVisibility|civilian|className|clear3DENAttribute|clear3DENInventory|clearAllItemsFromBackpack|clearBackpackCargo|clearBackpackCargoGlobal|clearForcesRTD|clearGroupIcons|clearItemCargo|clearItemCargoGlobal|clearItemPool|clearMagazineCargo|clearMagazineCargoGlobal|clearMagazinePool|clearOverlay|clearRadio|clearVehicleInit|clearWeaponCargo|clearWeaponCargoGlobal|clearWeaponPool|clientOwner|closeDialog|closeDisplay|closeOverlay|collapseObjectTree|collect3DENHistory|collectiveRTD|combatMode|commandArtilleryFire|commandChat|commander|commandFire|commandFollow|commandFSM|commandGetOut|commandingMenu|commandMove|commandRadio|commandStop|commandSuppressiveFire|commandTarget|commandWatch|comment|commitOverlay|compile|compileFinal|completedFSM|composeText|configClasses|configFile|configHierarchy|configName|configNull|configProperties|configSourceAddonList|configSourceMod|configSourceModList|confirmSensorTarget|connectTerminalToUAV|controlNull|controlsGroupCtrl|copyFromClipboard|copyToClipboard|copyWaypoints|cos|count|countEnemy|countFriendly|countSide|countType|countUnknown|create3DENComposition|create3DENEntity|createAgent|createCenter|createDialog|createDiaryLink|createDiaryRecord|createDiarySubject|createDisplay|createGearDialog|createGroup|createGuardedPoint|createLocation|createMarker|createMarkerLocal|createMenu|createMine|createMissionDisplay|createMPCampaignDisplay|createSimpleObject|createSimpleTask|createSite|createSoundSource|createTask|createTeam|createTrigger|createUnit|createVehicle|createVehicleCrew|createVehicleLocal|crew|ctAddHeader|ctAddRow|ctClear|ctCurSel|ctData|ctFindHeaderRows|ctFindRowHeader|ctHeaderControls|ctHeaderCount|ctRemoveHeaders|ctRemoveRows|ctrlActivate|ctrlAddEventHandler|ctrlAngle|ctrlAutoScrollDelay|ctrlAutoScrollRewind|ctrlAutoScrollSpeed|ctrlChecked|ctrlClassName|ctrlCommit|ctrlCommitted|ctrlCreate|ctrlDelete|ctrlEnable|ctrlEnabled|ctrlFade|ctrlHTMLLoaded|ctrlIDC|ctrlIDD|ctrlMapAnimAdd|ctrlMapAnimClear|ctrlMapAnimCommit|ctrlMapAnimDone|ctrlMapCursor|ctrlMapMouseOver|ctrlMapScale|ctrlMapScreenToWorld|ctrlMapWorldToScreen|ctrlModel|ctrlModelDirAndUp|ctrlModelScale|ctrlParent|ctrlParentControlsGroup|ctrlPosition|ctrlRemoveAllEventHandlers|ctrlRemoveEventHandler|ctrlScale|ctrlSetActiveColor|ctrlSetAngle|ctrlSetAutoScrollDelay|ctrlSetAutoScrollRewind|ctrlSetAutoScrollSpeed|ctrlSetBackgroundColor|ctrlSetChecked|ctrlSetDisabledColor|ctrlSetEventHandler|ctrlSetFade|ctrlSetFocus|ctrlSetFont|ctrlSetFontH1|ctrlSetFontH1B|ctrlSetFontH2|ctrlSetFontH2B|ctrlSetFontH3|ctrlSetFontH3B|ctrlSetFontH4|ctrlSetFontH4B|ctrlSetFontH5|ctrlSetFontH5B|ctrlSetFontH6|ctrlSetFontH6B|ctrlSetFontHeight|ctrlSetFontHeightH1|ctrlSetFontHeightH2|ctrlSetFontHeightH3|ctrlSetFontHeightH4|ctrlSetFontHeightH5|ctrlSetFontHeightH6|ctrlSetFontHeightSecondary|ctrlSetFontP|ctrlSetFontPB|ctrlSetFontSecondary|ctrlSetForegroundColor|ctrlSetModel|ctrlSetModelDirAndUp|ctrlSetModelScale|ctrlSetPixelPrecision|ctrlSetPosition|ctrlSetScale|ctrlSetStructuredText|ctrlSetText|ctrlSetTextColor|ctrlSetTextColorSecondary|ctrlSetTextSecondary|ctrlSetTooltip|ctrlSetTooltipColorBox|ctrlSetTooltipColorShade|ctrlSetTooltipColorText|ctrlShow|ctrlShown|ctrlText|ctrlTextHeight|ctrlTextSecondary|ctrlTextWidth|ctrlType|ctrlVisible|ctRowControls|ctRowCount|ctSetCurSel|ctSetData|ctSetHeaderTemplate|ctSetRowTemplate|ctSetValue|ctValue|curatorAddons|curatorCamera|curatorCameraArea|curatorCameraAreaCeiling|curatorCoef|curatorEditableObjects|curatorEditingArea|curatorEditingAreaType|curatorMouseOver|curatorPoints|curatorRegisteredObjects|curatorSelected|curatorWaypointCost|current3DENOperation|currentChannel|currentCommand|currentMagazine|currentMagazineDetail|currentMagazineDetailTurret|currentMagazineTurret|currentMuzzle|currentNamespace|currentTask|currentTasks|currentThrowable|currentVisionMode|currentWaypoint|currentWeapon|currentWeaponMode|currentWeaponTurret|currentZeroing|cursorObject|cursorTarget|customChat|customRadio|cutFadeOut|cutObj|cutRsc|cutText|damage|date|dateToNumber|daytime|deActivateKey|debriefingText|debugFSM|debugLog|deg|delete3DENEntities|deleteAt|deleteCenter|deleteCollection|deleteEditorObject|deleteGroup|deleteGroupWhenEmpty|deleteIdentity|deleteLocation|deleteMarker|deleteMarkerLocal|deleteRange|deleteResources|deleteSite|deleteStatus|deleteTeam|deleteVehicle|deleteVehicleCrew|deleteWaypoint|detach|detectedMines|diag_activeMissionFSMs|diag_activeScripts|diag_activeSQFScripts|diag_activeSQSScripts|diag_captureFrame|diag_captureFrameToFile|diag_captureSlowFrame|diag_codePerformance|diag_drawMode|diag_dynamicSimulationEnd|diag_enable|diag_enabled|diag_fps|diag_fpsMin|diag_frameNo|diag_lightNewLoad|diag_list|diag_log|diag_logSlowFrame|diag_mergeConfigFile|diag_recordTurretLimits|diag_setLightNew|diag_tickTime|diag_toggle|dialog|diarySubjectExists|didJIP|didJIPOwner|difficulty|difficultyEnabled|difficultyEnabledRTD|difficultyOption|direction|directSay|disableAI|disableCollisionWith|disableConversation|disableDebriefingStats|disableMapIndicators|disableNVGEquipment|disableRemoteSensors|disableSerialization|disableTIEquipment|disableUAVConnectability|disableUserInput|displayAddEventHandler|displayCtrl|displayNull|displayParent|displayRemoveAllEventHandlers|displayRemoveEventHandler|displaySetEventHandler|dissolveTeam|distance|distance2D|distanceSqr|distributionRegion|do3DENAction|doArtilleryFire|doFire|doFollow|doFSM|doGetOut|doMove|doorPhase|doStop|doSuppressiveFire|doTarget|doWatch|drawArrow|drawEllipse|drawIcon|drawIcon3D|drawLine|drawLine3D|drawLink|drawLocation|drawPolygon|drawRectangle|drawTriangle|driver|drop|dynamicSimulationDistance|dynamicSimulationDistanceCoef|dynamicSimulationEnabled|dynamicSimulationSystemEnabled|east|edit3DENMissionAttributes|editObject|editorSetEventHandler|effectiveCommander|emptyPositions|enableAI|enableAIFeature|enableAimPrecision|enableAttack|enableAudioFeature|enableAutoStartUpRTD|enableAutoTrimRTD|enableCamShake|enableCaustics|enableChannel|enableCollisionWith|enableCopilot|enableDebriefingStats|enableDiagLegend|enableDynamicSimulation|enableDynamicSimulationSystem|enableEndDialog|enableEngineArtillery|enableEnvironment|enableFatigue|enableGunLights|enableInfoPanelComponent|enableIRLasers|enableMimics|enablePersonTurret|enableRadio|enableReload|enableRopeAttach|enableSatNormalOnDetail|enableSaving|enableSentences|enableSimulation|enableSimulationGlobal|enableStamina|enableStressDamage|enableTeamSwitch|enableTraffic|enableUAVConnectability|enableUAVWaypoints|enableVehicleCargo|enableVehicleSensor|enableWeaponDisassembly|endl|endLoadingScreen|endMission|engineOn|enginesIsOnRTD|enginesPowerRTD|enginesRpmRTD|enginesTorqueRTD|entities|environmentEnabled|estimatedEndServerTime|estimatedTimeLeft|evalObjectArgument|everyBackpack|everyContainer|exec|execEditorScript|exp|expectedDestination|exportJIPMessages|eyeDirection|eyePos|face|faction|fadeMusic|fadeRadio|fadeSound|fadeSpeech|failMission|fillWeaponsFromPool|find|findCover|findDisplay|findEditorObject|findEmptyPosition|findEmptyPositionReady|findIf|findNearestEnemy|finishMissionInit|finite|fire|fireAtTarget|firstBackpack|flag|flagAnimationPhase|flagOwner|flagSide|flagTexture|fleeing|floor|flyInHeight|flyInHeightASL|fog|fogForecast|fogParams|forceAddUniform|forceAtPositionRTD|forcedMap|forceEnd|forceFlagTexture|forceFollowRoad|forceGeneratorRTD|forceMap|forceRespawn|forceSpeed|forceWalk|forceWeaponFire|forceWeatherChange|forgetTarget|format|formation|formationDirection|formationLeader|formationMembers|formationPosition|formationTask|formatText|formLeader|freeLook|fromEditor|fuel|fullCrew|gearIDCAmmoCount|gearSlotAmmoCount|gearSlotData|get3DENActionState|get3DENAttribute|get3DENCamera|get3DENConnections|get3DENEntity|get3DENEntityID|get3DENGrid|get3DENIconsVisible|get3DENLayerEntities|get3DENLinesVisible|get3DENMissionAttribute|get3DENMouseOver|get3DENSelected|getAimingCoef|getAllEnvSoundControllers|getAllHitPointsDamage|getAllOwnedMines|getAllSoundControllers|getAmmoCargo|getAnimAimPrecision|getAnimSpeedCoef|getArray|getArtilleryAmmo|getArtilleryComputerSettings|getArtilleryETA|getAssignedCuratorLogic|getAssignedCuratorUnit|getBackpackCargo|getBleedingRemaining|getBurningValue|getCameraViewDirection|getCargoIndex|getCenterOfMass|getClientState|getClientStateNumber|getCompatiblePylonMagazines|getConnectedUAV|getContainerMaxLoad|getCursorObjectParams|getCustomAimCoef|getDammage|getDescription|getDir|getDirVisual|getDLCAssetsUsage|getDLCAssetsUsageByName|getDLCs|getDLCUsageTime|getEditorCamera|getEditorMode|getEditorObjectScope|getElevationOffset|getEngineTargetRpmRTD|getEnvSoundController|getFatigue|getFieldManualStartPage|getForcedFlagTexture|getFriend|getFSMVariable|getFuelCargo|getGroupIcon|getGroupIconParams|getGroupIcons|getHideFrom|getHit|getHitIndex|getHitPointDamage|getItemCargo|getMagazineCargo|getMarkerColor|getMarkerPos|getMarkerSize|getMarkerType|getMass|getMissionConfig|getMissionConfigValue|getMissionDLCs|getMissionLayerEntities|getMissionLayers|getModelInfo|getMousePosition|getMusicPlayedTime|getNumber|getObjectArgument|getObjectChildren|getObjectDLC|getObjectMaterials|getObjectProxy|getObjectTextures|getObjectType|getObjectViewDistance|getOxygenRemaining|getPersonUsedDLCs|getPilotCameraDirection|getPilotCameraPosition|getPilotCameraRotation|getPilotCameraTarget|getPlateNumber|getPlayerChannel|getPlayerScores|getPlayerUID|getPlayerUIDOld|getPos|getPosASL|getPosASLVisual|getPosASLW|getPosATL|getPosATLVisual|getPosVisual|getPosWorld|getPylonMagazines|getRelDir|getRelPos|getRemoteSensorsDisabled|getRepairCargo|getResolution|getRotorBrakeRTD|getShadowDistance|getShotParents|getSlingLoad|getSoundController|getSoundControllerResult|getSpeed|getStamina|getStatValue|getSuppression|getTerrainGrid|getTerrainHeightASL|getText|getTotalDLCUsageTime|getTrimOffsetRTD|getUnitLoadout|getUnitTrait|getUserMFDText|getUserMFDValue|getVariable|getVehicleCargo|getWeaponCargo|getWeaponSway|getWingsOrientationRTD|getWingsPositionRTD|getWPPos|glanceAt|globalChat|globalRadio|goggles|group|groupChat|groupFromNetId|groupIconSelectable|groupIconsVisible|groupId|groupOwner|groupRadio|groupSelectedUnits|groupSelectUnit|grpNull|gunner|gusts|halt|handgunItems|handgunMagazine|handgunWeapon|handsHit|hasInterface|hasPilotCamera|hasWeapon|hcAllGroups|hcGroupParams|hcLeader|hcRemoveAllGroups|hcRemoveGroup|hcSelected|hcSelectGroup|hcSetGroup|hcShowBar|hcShownBar|headgear|hideBody|hideObject|hideObjectGlobal|hideSelection|hint|hintC|hintCadet|hintSilent|hmd|hostMission|htmlLoad|HUDMovementLevels|humidity|image|importAllGroups|importance|in|inArea|inAreaArray|incapacitatedState|independent|inflame|inflamed|infoPanel|infoPanelComponentEnabled|infoPanelComponents|infoPanels|inGameUISetEventHandler|inheritsFrom|initAmbientLife|inPolygon|inputAction|inRangeOfArtillery|insertEditorObject|intersect|is3DEN|is3DENMultiplayer|isAbleToBreathe|isAgent|isAimPrecisionEnabled|isArray|isAutoHoverOn|isAutonomous|isAutoStartUpEnabledRTD|isAutotest|isAutoTrimOnRTD|isBleeding|isBurning|isClass|isCollisionLightOn|isCopilotEnabled|isDamageAllowed|isDedicated|isDLCAvailable|isEngineOn|isEqualTo|isEqualType|isEqualTypeAll|isEqualTypeAny|isEqualTypeArray|isEqualTypeParams|isFilePatchingEnabled|isFlashlightOn|isFlatEmpty|isForcedWalk|isFormationLeader|isGroupDeletedWhenEmpty|isHidden|isInRemainsCollector|isInstructorFigureEnabled|isIRLaserOn|isKeyActive|isKindOf|isLaserOn|isLightOn|isLocalized|isManualFire|isMarkedForCollection|isMultiplayer|isMultiplayerSolo|isNil|isNull|isNumber|isObjectHidden|isObjectRTD|isOnRoad|isPipEnabled|isPlayer|isRealTime|isRemoteExecuted|isRemoteExecutedJIP|isServer|isShowing3DIcons|isSimpleObject|isSprintAllowed|isStaminaEnabled|isSteamMission|isStreamFriendlyUIEnabled|isStressDamageEnabled|isText|isTouchingGround|isTurnedOut|isTutHintsEnabled|isUAVConnectable|isUAVConnected|isUIContext|isUniformAllowed|isVehicleCargo|isVehicleRadarOn|isVehicleSensorEnabled|isWalking|isWeaponDeployed|isWeaponRested|itemCargo|items|itemsWithMagazines|join|joinAs|joinAsSilent|joinSilent|joinString|kbAddDatabase|kbAddDatabaseTargets|kbAddTopic|kbHasTopic|kbReact|kbRemoveTopic|kbTell|kbWasSaid|keyImage|keyName|knowsAbout|land|landAt|landResult|language|laserTarget|lbAdd|lbClear|lbColor|lbColorRight|lbCurSel|lbData|lbDelete|lbIsSelected|lbPicture|lbPictureRight|lbSelection|lbSetColor|lbSetColorRight|lbSetCurSel|lbSetData|lbSetPicture|lbSetPictureColor|lbSetPictureColorDisabled|lbSetPictureColorSelected|lbSetPictureRight|lbSetPictureRightColor|lbSetPictureRightColorDisabled|lbSetPictureRightColorSelected|lbSetSelectColor|lbSetSelectColorRight|lbSetSelected|lbSetText|lbSetTextRight|lbSetTooltip|lbSetValue|lbSize|lbSort|lbSortByValue|lbText|lbTextRight|lbValue|leader|leaderboardDeInit|leaderboardGetRows|leaderboardInit|leaderboardRequestRowsFriends|leaderboardRequestRowsGlobal|leaderboardRequestRowsGlobalAroundUser|leaderboardsRequestUploadScore|leaderboardsRequestUploadScoreKeepBest|leaderboardState|leaveVehicle|libraryCredits|libraryDisclaimers|lifeState|lightAttachObject|lightDetachObject|lightIsOn|lightnings|limitSpeed|linearConversion|lineBreak|lineIntersects|lineIntersectsObjs|lineIntersectsSurfaces|lineIntersectsWith|linkItem|list|listObjects|listRemoteTargets|listVehicleSensors|ln|lnbAddArray|lnbAddColumn|lnbAddRow|lnbClear|lnbColor|lnbColorRight|lnbCurSelRow|lnbData|lnbDeleteColumn|lnbDeleteRow|lnbGetColumnsPosition|lnbPicture|lnbPictureRight|lnbSetColor|lnbSetColorRight|lnbSetColumnsPos|lnbSetCurSelRow|lnbSetData|lnbSetPicture|lnbSetPictureColor|lnbSetPictureColorRight|lnbSetPictureColorSelected|lnbSetPictureColorSelectedRight|lnbSetPictureRight|lnbSetText|lnbSetTextRight|lnbSetValue|lnbSize|lnbSort|lnbSortByValue|lnbText|lnbTextRight|lnbValue|load|loadAbs|loadBackpack|loadFile|loadGame|loadIdentity|loadMagazine|loadOverlay|loadStatus|loadUniform|loadVest|local|localize|locationNull|locationPosition|lock|lockCameraTo|lockCargo|lockDriver|locked|lockedCargo|lockedDriver|lockedTurret|lockIdentity|lockTurret|lockWP|log|logEntities|logNetwork|logNetworkTerminate|lookAt|lookAtPos|magazineCargo|magazines|magazinesAllTurrets|magazinesAmmo|magazinesAmmoCargo|magazinesAmmoFull|magazinesDetail|magazinesDetailBackpack|magazinesDetailUniform|magazinesDetailVest|magazinesTurret|magazineTurretAmmo|mapAnimAdd|mapAnimClear|mapAnimCommit|mapAnimDone|mapCenterOnCamera|mapGridPosition|markAsFinishedOnSteam|markerAlpha|markerBrush|markerColor|markerDir|markerPos|markerShape|markerSize|markerText|markerType|max|members|menuAction|menuAdd|menuChecked|menuClear|menuCollapse|menuData|menuDelete|menuEnable|menuEnabled|menuExpand|menuHover|menuPicture|menuSetAction|menuSetCheck|menuSetData|menuSetPicture|menuSetValue|menuShortcut|menuShortcutText|menuSize|menuSort|menuText|menuURL|menuValue|min|mineActive|mineDetectedBy|missionConfigFile|missionDifficulty|missionName|missionNamespace|missionStart|missionVersion|modelToWorld|modelToWorldVisual|modelToWorldVisualWorld|modelToWorldWorld|modParams|moonIntensity|moonPhase|morale|move|move3DENCamera|moveInAny|moveInCargo|moveInCommander|moveInDriver|moveInGunner|moveInTurret|moveObjectToEnd|moveOut|moveTime|moveTo|moveToCompleted|moveToFailed|musicVolume|name|nameSound|nearEntities|nearestBuilding|nearestLocation|nearestLocations|nearestLocationWithDubbing|nearestObject|nearestObjects|nearestTerrainObjects|nearObjects|nearObjectsReady|nearRoads|nearSupplies|nearTargets|needReload|netId|netObjNull|newOverlay|nextMenuItemIndex|nextWeatherChange|nMenuItems|numberOfEnginesRTD|numberToDate|objectCurators|objectFromNetId|objectParent|objNull|objStatus|onBriefingGear|onBriefingGroup|onBriefingNotes|onBriefingPlan|onBriefingTeamSwitch|onCommandModeChanged|onDoubleClick|onEachFrame|onGroupIconClick|onGroupIconOverEnter|onGroupIconOverLeave|onHCGroupSelectionChanged|onMapSingleClick|onPlayerConnected|onPlayerDisconnected|onPreloadFinished|onPreloadStarted|onShowNewObject|onTeamSwitch|openCuratorInterface|openDLCPage|openDSInterface|openMap|openSteamApp|openYoutubeVideo|opfor|orderGetIn|overcast|overcastForecast|owner|param|params|parseNumber|parseSimpleArray|parseText|parsingNamespace|particlesQuality|pi|pickWeaponPool|pitch|pixelGrid|pixelGridBase|pixelGridNoUIScale|pixelH|pixelW|playableSlotsNumber|playableUnits|playAction|playActionNow|player|playerRespawnTime|playerSide|playersNumber|playGesture|playMission|playMove|playMoveNow|playMusic|playScriptedMission|playSound|playSound3D|position|positionCameraToWorld|posScreenToWorld|posWorldToScreen|ppEffectAdjust|ppEffectCommit|ppEffectCommitted|ppEffectCreate|ppEffectDestroy|ppEffectEnable|ppEffectEnabled|ppEffectForceInNVG|precision|preloadCamera|preloadObject|preloadSound|preloadTitleObj|preloadTitleRsc|primaryWeapon|primaryWeaponItems|primaryWeaponMagazine|priority|processDiaryLink|processInitCommands|productVersion|profileName|profileNamespace|profileNameSteam|progressLoadingScreen|progressPosition|progressSetPosition|publicVariable|publicVariableClient|publicVariableServer|pushBack|pushBackUnique|putWeaponPool|queryItemsPool|queryMagazinePool|queryWeaponPool|rad|radioChannelAdd|radioChannelCreate|radioChannelRemove|radioChannelSetCallSign|radioChannelSetLabel|radioVolume|rain|rainbow|random|rank|rankId|rating|rectangular|registeredTasks|registerTask|reload|reloadEnabled|remoteControl|remoteExec|remoteExecCall|remoteExecutedOwner|remove3DENConnection|remove3DENEventHandler|remove3DENLayer|removeAction|removeAll3DENEventHandlers|removeAllActions|removeAllAssignedItems|removeAllContainers|removeAllCuratorAddons|removeAllCuratorCameraAreas|removeAllCuratorEditingAreas|removeAllEventHandlers|removeAllHandgunItems|removeAllItems|removeAllItemsWithMagazines|removeAllMissionEventHandlers|removeAllMPEventHandlers|removeAllMusicEventHandlers|removeAllOwnedMines|removeAllPrimaryWeaponItems|removeAllWeapons|removeBackpack|removeBackpackGlobal|removeCuratorAddons|removeCuratorCameraArea|removeCuratorEditableObjects|removeCuratorEditingArea|removeDrawIcon|removeDrawLinks|removeEventHandler|removeFromRemainsCollector|removeGoggles|removeGroupIcon|removeHandgunItem|removeHeadgear|removeItem|removeItemFromBackpack|removeItemFromUniform|removeItemFromVest|removeItems|removeMagazine|removeMagazineGlobal|removeMagazines|removeMagazinesTurret|removeMagazineTurret|removeMenuItem|removeMissionEventHandler|removeMPEventHandler|removeMusicEventHandler|removeOwnedMine|removePrimaryWeaponItem|removeSecondaryWeaponItem|removeSimpleTask|removeSwitchableUnit|removeTeamMember|removeUniform|removeVest|removeWeapon|removeWeaponAttachmentCargo|removeWeaponCargo|removeWeaponGlobal|removeWeaponTurret|reportRemoteTarget|requiredVersion|resetCamShake|resetSubgroupDirection|resistance|resize|resources|respawnVehicle|restartEditorCamera|reveal|revealMine|reverse|reversedMouseY|roadAt|roadsConnectedTo|roleDescription|ropeAttachedObjects|ropeAttachedTo|ropeAttachEnabled|ropeAttachTo|ropeCreate|ropeCut|ropeDestroy|ropeDetach|ropeEndPosition|ropeLength|ropes|ropeUnwind|ropeUnwound|rotorsForcesRTD|rotorsRpmRTD|round|runInitScript|safeZoneH|safeZoneW|safeZoneWAbs|safeZoneX|safeZoneXAbs|safeZoneY|save3DENInventory|saveGame|saveIdentity|saveJoysticks|saveOverlay|saveProfileNamespace|saveStatus|saveVar|savingEnabled|say|say2D|say3D|score|scoreSide|screenshot|screenToWorld|scriptDone|scriptName|scriptNull|scudState|secondaryWeapon|secondaryWeaponItems|secondaryWeaponMagazine|select|selectBestPlaces|selectDiarySubject|selectedEditorObjects|selectEditorObject|selectionNames|selectionPosition|selectLeader|selectMax|selectMin|selectNoPlayer|selectPlayer|selectRandom|selectRandomWeighted|selectWeapon|selectWeaponTurret|sendAUMessage|sendSimpleCommand|sendTask|sendTaskResult|sendUDPMessage|serverCommand|serverCommandAvailable|serverCommandExecutable|serverName|serverTime|set|set3DENAttribute|set3DENAttributes|set3DENGrid|set3DENIconsVisible|set3DENLayer|set3DENLinesVisible|set3DENLogicType|set3DENMissionAttribute|set3DENMissionAttributes|set3DENModelsVisible|set3DENObjectType|set3DENSelected|setAccTime|setActualCollectiveRTD|setAirplaneThrottle|setAirportSide|setAmmo|setAmmoCargo|setAmmoOnPylon|setAnimSpeedCoef|setAperture|setApertureNew|setArmoryPoints|setAttributes|setAutonomous|setBehaviour|setBleedingRemaining|setBrakesRTD|setCameraInterest|setCamShakeDefParams|setCamShakeParams|setCamUseTI|setCaptive|setCenterOfMass|setCollisionLight|setCombatMode|setCompassOscillation|setConvoySeparation|setCuratorCameraAreaCeiling|setCuratorCoef|setCuratorEditingAreaType|setCuratorWaypointCost|setCurrentChannel|setCurrentTask|setCurrentWaypoint|setCustomAimCoef|setCustomWeightRTD|setDamage|setDammage|setDate|setDebriefingText|setDefaultCamera|setDestination|setDetailMapBlendPars|setDir|setDirection|setDrawIcon|setDriveOnPath|setDropInterval|setDynamicSimulationDistance|setDynamicSimulationDistanceCoef|setEditorMode|setEditorObjectScope|setEffectCondition|setEngineRpmRTD|setFace|setFaceAnimation|setFatigue|setFeatureType|setFlagAnimationPhase|setFlagOwner|setFlagSide|setFlagTexture|setFog|setForceGeneratorRTD|setFormation|setFormationTask|setFormDir|setFriend|setFromEditor|setFSMVariable|setFuel|setFuelCargo|setGroupIcon|setGroupIconParams|setGroupIconsSelectable|setGroupIconsVisible|setGroupId|setGroupIdGlobal|setGroupOwner|setGusts|setHideBehind|setHit|setHitIndex|setHitPointDamage|setHorizonParallaxCoef|setHUDMovementLevels|setIdentity|setImportance|setInfoPanel|setLeader|setLightAmbient|setLightAttenuation|setLightBrightness|setLightColor|setLightDayLight|setLightFlareMaxDistance|setLightFlareSize|setLightIntensity|setLightnings|setLightUseFlare|setLocalWindParams|setMagazineTurretAmmo|setMarkerAlpha|setMarkerAlphaLocal|setMarkerBrush|setMarkerBrushLocal|setMarkerColor|setMarkerColorLocal|setMarkerDir|setMarkerDirLocal|setMarkerPos|setMarkerPosLocal|setMarkerShape|setMarkerShapeLocal|setMarkerSize|setMarkerSizeLocal|setMarkerText|setMarkerTextLocal|setMarkerType|setMarkerTypeLocal|setMass|setMimic|setMousePosition|setMusicEffect|setMusicEventHandler|setName|setNameSound|setObjectArguments|setObjectMaterial|setObjectMaterialGlobal|setObjectProxy|setObjectTexture|setObjectTextureGlobal|setObjectViewDistance|setOvercast|setOwner|setOxygenRemaining|setParticleCircle|setParticleClass|setParticleFire|setParticleParams|setParticleRandom|setPilotCameraDirection|setPilotCameraRotation|setPilotCameraTarget|setPilotLight|setPiPEffect|setPitch|setPlateNumber|setPlayable|setPlayerRespawnTime|setPos|setPosASL|setPosASL2|setPosASLW|setPosATL|setPosition|setPosWorld|setPylonLoadOut|setPylonsPriority|setRadioMsg|setRain|setRainbow|setRandomLip|setRank|setRectangular|setRepairCargo|setRotorBrakeRTD|setShadowDistance|setShotParents|setSide|setSimpleTaskAlwaysVisible|setSimpleTaskCustomData|setSimpleTaskDescription|setSimpleTaskDestination|setSimpleTaskTarget|setSimpleTaskType|setSimulWeatherLayers|setSize|setSkill|setSlingLoad|setSoundEffect|setSpeaker|setSpeech|setSpeedMode|setStamina|setStaminaScheme|setStatValue|setSuppression|setSystemOfUnits|setTargetAge|setTaskMarkerOffset|setTaskResult|setTaskState|setTerrainGrid|setText|setTimeMultiplier|setTitleEffect|setToneMapping|setToneMappingParams|setTrafficDensity|setTrafficDistance|setTrafficGap|setTrafficSpeed|setTriggerActivation|setTriggerArea|setTriggerStatements|setTriggerText|setTriggerTimeout|setTriggerType|setType|setUnconscious|setUnitAbility|setUnitLoadout|setUnitPos|setUnitPosWeak|setUnitRank|setUnitRecoilCoefficient|setUnitTrait|setUnloadInCombat|setUserActionText|setUserMFDText|setUserMFDValue|setVariable|setVectorDir|setVectorDirAndUp|setVectorUp|setVehicleAmmo|setVehicleAmmoDef|setVehicleArmor|setVehicleCargo|setVehicleId|setVehicleInit|setVehicleLock|setVehiclePosition|setVehicleRadar|setVehicleReceiveRemoteTargets|setVehicleReportOwnPosition|setVehicleReportRemoteTargets|setVehicleTIPars|setVehicleVarName|setVelocity|setVelocityModelSpace|setVelocityTransformation|setViewDistance|setVisibleIfTreeCollapsed|setWantedRpmRTD|setWaves|setWaypointBehaviour|setWaypointCombatMode|setWaypointCompletionRadius|setWaypointDescription|setWaypointForceBehaviour|setWaypointFormation|setWaypointHousePosition|setWaypointLoiterRadius|setWaypointLoiterType|setWaypointName|setWaypointPosition|setWaypointScript|setWaypointSpeed|setWaypointStatements|setWaypointTimeout|setWaypointType|setWaypointVisible|setWeaponReloadingTime|setWind|setWindDir|setWindForce|setWindStr|setWingForceScaleRTD|setWPPos|show3DIcons|showChat|showCinemaBorder|showCommandingMenu|showCompass|showCuratorCompass|showGPS|showHUD|showLegend|showMap|shownArtilleryComputer|shownChat|shownCompass|shownCuratorCompass|showNewEditorObject|shownGPS|shownHUD|shownMap|shownPad|shownRadio|shownScoretable|shownUAVFeed|shownWarrant|shownWatch|showPad|showRadio|showScoretable|showSubtitles|showUAVFeed|showWarrant|showWatch|showWaypoint|showWaypoints|side|sideAmbientLife|sideChat|sideEmpty|sideEnemy|sideFriendly|sideLogic|sideRadio|sideUnknown|simpleTasks|simulationEnabled|simulCloudDensity|simulCloudOcclusion|simulInClouds|simulWeatherSync|sin|size|sizeOf|skill|skillFinal|skipTime|sleep|sliderPosition|sliderRange|sliderSetPosition|sliderSetRange|sliderSetSpeed|sliderSpeed|slingLoadAssistantShown|soldierMagazines|someAmmo|sort|soundVolume|speaker|speed|speedMode|splitString|sqrt|squadParams|stance|startLoadingScreen|stop|stopEngineRTD|stopped|str|sunOrMoon|supportInfo|suppressFor|surfaceIsWater|surfaceNormal|surfaceType|swimInDepth|switchableUnits|switchAction|switchCamera|switchGesture|switchLight|switchMove|synchronizedObjects|synchronizedTriggers|synchronizedWaypoints|synchronizeObjectsAdd|synchronizeObjectsRemove|synchronizeTrigger|synchronizeWaypoint|systemChat|systemOfUnits|tan|targetKnowledge|targets|targetsAggregate|targetsQuery|taskAlwaysVisible|taskChildren|taskCompleted|taskCustomData|taskDescription|taskDestination|taskHint|taskMarkerOffset|taskNull|taskParent|taskResult|taskState|taskType|teamMember|teamMemberNull|teamName|teams|teamSwitch|teamSwitchEnabled|teamType|terminate|terrainIntersect|terrainIntersectASL|terrainIntersectAtASL|text|textLog|textLogFormat|tg|time|timeMultiplier|titleCut|titleFadeOut|titleObj|titleRsc|titleText|toArray|toFixed|toLower|toString|toUpper|triggerActivated|triggerActivation|triggerArea|triggerAttachedVehicle|triggerAttachObject|triggerAttachVehicle|triggerDynamicSimulation|triggerStatements|triggerText|triggerTimeout|triggerTimeoutCurrent|triggerType|turretLocal|turretOwner|turretUnit|tvAdd|tvClear|tvCollapse|tvCollapseAll|tvCount|tvCurSel|tvData|tvDelete|tvExpand|tvExpandAll|tvPicture|tvPictureRight|tvSetColor|tvSetCurSel|tvSetData|tvSetPicture|tvSetPictureColor|tvSetPictureColorDisabled|tvSetPictureColorSelected|tvSetPictureRight|tvSetPictureRightColor|tvSetPictureRightColorDisabled|tvSetPictureRightColorSelected|tvSetSelectColor|tvSetText|tvSetTooltip|tvSetValue|tvSort|tvSortByValue|tvText|tvTooltip|tvValue|type|typeName|typeOf|UAVControl|uiNamespace|uiSleep|unassignCurator|unassignItem|unassignTeam|unassignVehicle|underwater|uniform|uniformContainer|uniformItems|uniformMagazines|unitAddons|unitAimPosition|unitAimPositionVisual|unitBackpack|unitIsUAV|unitPos|unitReady|unitRecoilCoefficient|units|unitsBelowHeight|unlinkItem|unlockAchievement|unregisterTask|updateDrawIcon|updateMenuItem|updateObjectTree|useAIOperMapObstructionTest|useAISteeringComponent|useAudioTimeForMoves|userInputDisabled|vectorAdd|vectorCos|vectorCrossProduct|vectorDiff|vectorDir|vectorDirVisual|vectorDistance|vectorDistanceSqr|vectorDotProduct|vectorFromTo|vectorMagnitude|vectorMagnitudeSqr|vectorModelToWorld|vectorModelToWorldVisual|vectorMultiply|vectorNormalized|vectorUp|vectorUpVisual|vectorWorldToModel|vectorWorldToModelVisual|vehicle|vehicleCargoEnabled|vehicleChat|vehicleRadio|vehicleReceiveRemoteTargets|vehicleReportOwnPosition|vehicleReportRemoteTargets|vehicles|vehicleVarName|velocity|velocityModelSpace|verifySignature|vest|vestContainer|vestItems|vestMagazines|viewDistance|visibleCompass|visibleGPS|visibleMap|visiblePosition|visiblePositionASL|visibleScoretable|visibleWatch|waitUntil|waves|waypointAttachedObject|waypointAttachedVehicle|waypointAttachObject|waypointAttachVehicle|waypointBehaviour|waypointCombatMode|waypointCompletionRadius|waypointDescription|waypointForceBehaviour|waypointFormation|waypointHousePosition|waypointLoiterRadius|waypointLoiterType|waypointName|waypointPosition|waypoints|waypointScript|waypointsEnabledUAV|waypointShow|waypointSpeed|waypointStatements|waypointTimeout|waypointTimeoutCurrent|waypointType|waypointVisible|weaponAccessories|weaponAccessoriesCargo|weaponCargo|weaponDirection|weaponInertia|weaponLowered|weapons|weaponsItems|weaponsItemsCargo|weaponState|weaponsTurret|weightRTD|west|WFSideText|wind|windDir|windRTD|windStr|wingsForcesRTD|worldName|worldSize|worldToModel|worldToModelVisual|worldToScreen)\b/i,
		number: /(?:\$|\b0x)[\da-f]+\b|(?:\B\.\d+|\b\d+(?:\.\d+)?)(?:e[+-]?\d+)?\b/i,
		operator: /##|>>|&&|\|\||[!=<>]=?|[-+*/%#^]|\b(?:and|mod|not|or)\b/i,
		"magic-variable": {
			pattern: /\b(?:this|thisList|thisTrigger|_exception|_fnc_scriptName|_fnc_scriptNameParent|_forEachIndex|_this|_thisEventHandler|_thisFSM|_thisScript|_x)\b/i,
			alias: "keyword"
		},
		constant: /\bDIK(?:_[a-z\d]+)+\b/i
	});
	Prism$1.languages.insertBefore("sqf", "string", { macro: {
		pattern: /(^[ \t]*)#[a-z](?:[^\r\n\\]|\\(?:\r\n|[\s\S]))*/im,
		lookbehind: true,
		greedy: true,
		alias: "property",
		inside: {
			directive: {
				pattern: /#[a-z]+\b/i,
				alias: "keyword"
			},
			comment: Prism$1.languages.sqf.comment
		}
	} });
	delete Prism$1.languages.sqf["class-name"];
}
squirrel.displayName = "squirrel";
squirrel.aliases = [];
function squirrel(Prism$1) {
	Prism$1.register(clike);
	Prism$1.languages.squirrel = Prism$1.languages.extend("clike", {
		comment: [Prism$1.languages.clike["comment"][0], {
			pattern: /(^|[^\\:])(?:\/\/|#).*/,
			lookbehind: true,
			greedy: true
		}],
		string: {
			pattern: /(^|[^\\"'@])(?:@"(?:[^"]|"")*"(?!")|"(?:[^\\\r\n"]|\\.)*")/,
			lookbehind: true,
			greedy: true
		},
		"class-name": {
			pattern: /(\b(?:class|enum|extends|instanceof)\s+)\w+(?:\.\w+)*/,
			lookbehind: true,
			inside: { punctuation: /\./ }
		},
		keyword: /\b(?:__FILE__|__LINE__|base|break|case|catch|class|clone|const|constructor|continue|default|delete|else|enum|extends|for|foreach|function|if|in|instanceof|local|null|resume|return|static|switch|this|throw|try|typeof|while|yield)\b/,
		number: /\b(?:0x[0-9a-fA-F]+|\d+(?:\.(?:\d+|[eE][+-]?\d+))?)\b/,
		operator: /\+\+|--|<=>|<[-<]|>>>?|&&?|\|\|?|[-+*/%!=<>]=?|[~^]|::?/,
		punctuation: /[(){}\[\],;.]/
	});
	Prism$1.languages.insertBefore("squirrel", "string", { char: {
		pattern: /(^|[^\\"'])'(?:[^\\']|\\(?:[xuU][0-9a-fA-F]{0,8}|[\s\S]))'/,
		lookbehind: true,
		greedy: true
	} });
	Prism$1.languages.insertBefore("squirrel", "operator", {
		"attribute-punctuation": {
			pattern: /<\/|\/>/,
			alias: "important"
		},
		lambda: {
			pattern: /@(?=\()/,
			alias: "operator"
		}
	});
}
stan.displayName = "stan";
stan.aliases = [];
function stan(Prism$1) {
	(function(Prism$2) {
		var higherOrderFunctions = /\b(?:algebra_solver|algebra_solver_newton|integrate_1d|integrate_ode|integrate_ode_bdf|integrate_ode_rk45|map_rect|ode_(?:adams|bdf|ckrk|rk45)(?:_tol)?|ode_adjoint_tol_ctl|reduce_sum|reduce_sum_static)\b/;
		Prism$2.languages.stan = {
			comment: /\/\/.*|\/\*[\s\S]*?\*\/|#(?!include).*/,
			string: {
				pattern: /"[\x20\x21\x23-\x5B\x5D-\x7E]*"/,
				greedy: true
			},
			directive: {
				pattern: /^([ \t]*)#include\b.*/m,
				lookbehind: true,
				alias: "property"
			},
			"function-arg": {
				pattern: RegExp("(" + higherOrderFunctions.source + /\s*\(\s*/.source + ")" + /[a-zA-Z]\w*/.source),
				lookbehind: true,
				alias: "function"
			},
			constraint: {
				pattern: /(\b(?:int|matrix|real|row_vector|vector)\s*)<[^<>]*>/,
				lookbehind: true,
				inside: {
					expression: {
						pattern: /(=\s*)\S(?:\S|\s+(?!\s))*?(?=\s*(?:>$|,\s*\w+\s*=))/,
						lookbehind: true,
						inside: null
					},
					property: /\b[a-z]\w*(?=\s*=)/i,
					operator: /=/,
					punctuation: /^<|>$|,/
				}
			},
			keyword: [
				{
					pattern: /\bdata(?=\s*\{)|\b(?:functions|generated|model|parameters|quantities|transformed)\b/,
					alias: "program-block"
				},
				/\b(?:array|break|cholesky_factor_corr|cholesky_factor_cov|complex|continue|corr_matrix|cov_matrix|data|else|for|if|in|increment_log_prob|int|matrix|ordered|positive_ordered|print|real|reject|return|row_vector|simplex|target|unit_vector|vector|void|while)\b/,
				higherOrderFunctions
			],
			function: /\b[a-z]\w*(?=\s*\()/i,
			number: /(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:E[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
			boolean: /\b(?:false|true)\b/,
			operator: /<-|\.[*/]=?|\|\|?|&&|[!=<>+\-*/]=?|['^%~?:]/,
			punctuation: /[()\[\]{},;]/
		};
		Prism$2.languages.stan.constraint.inside.expression.inside = Prism$2.languages.stan;
	})(Prism$1);
}
stata.displayName = "stata";
stata.aliases = [];
function stata(Prism$1) {
	Prism$1.register(java);
	Prism$1.register(mata);
	Prism$1.register(python);
	Prism$1.languages.stata = {
		comment: [{
			pattern: /(^[ \t]*)\*.*/m,
			lookbehind: true,
			greedy: true
		}, {
			pattern: /(^|\s)\/\/.*|\/\*[\s\S]*?\*\//,
			lookbehind: true,
			greedy: true
		}],
		"string-literal": {
			pattern: /"[^"\r\n]*"|[‘`']".*?"[’`']/,
			greedy: true,
			inside: {
				interpolation: {
					pattern: /\$\{[^{}]*\}|[‘`']\w[^’`'\r\n]*[’`']/,
					inside: {
						punctuation: /^\$\{|\}$/,
						expression: {
							pattern: /[\s\S]+/,
							inside: null
						}
					}
				},
				string: /[\s\S]+/
			}
		},
		mata: {
			pattern: /(^[ \t]*mata[ \t]*:)[\s\S]+?(?=^end\b)/m,
			lookbehind: true,
			greedy: true,
			alias: "language-mata",
			inside: Prism$1.languages.mata
		},
		java: {
			pattern: /(^[ \t]*java[ \t]*:)[\s\S]+?(?=^end\b)/m,
			lookbehind: true,
			greedy: true,
			alias: "language-java",
			inside: Prism$1.languages.java
		},
		python: {
			pattern: /(^[ \t]*python[ \t]*:)[\s\S]+?(?=^end\b)/m,
			lookbehind: true,
			greedy: true,
			alias: "language-python",
			inside: Prism$1.languages.python
		},
		command: {
			pattern: /(^[ \t]*(?:\.[ \t]+)?(?:(?:bayes|bootstrap|by|bysort|capture|collect|fmm|fp|frame|jackknife|mfp|mi|nestreg|noisily|permute|quietly|rolling|simulate|statsby|stepwise|svy|version|xi)\b[^:\r\n]*:[ \t]*|(?:capture|noisily|quietly|version)[ \t]+)?)[a-zA-Z]\w*/m,
			lookbehind: true,
			greedy: true,
			alias: "keyword"
		},
		variable: /\$\w+|[‘`']\w[^’`'\r\n]*[’`']/,
		keyword: /\b(?:bayes|bootstrap|by|bysort|capture|clear|collect|fmm|fp|frame|if|in|jackknife|mi[ \t]+estimate|mfp|nestreg|noisily|of|permute|quietly|rolling|simulate|sort|statsby|stepwise|svy|varlist|version|xi)\b/,
		boolean: /\b(?:off|on)\b/,
		number: /\b\d+(?:\.\d+)?\b|\B\.\d+/,
		function: /\b[a-z_]\w*(?=\()/i,
		operator: /\+\+|--|##?|[<>!=~]=?|[+\-*^&|/]/,
		punctuation: /[(){}[\],:]/
	};
	Prism$1.languages.stata["string-literal"].inside.interpolation.inside.expression.inside = Prism$1.languages.stata;
}
iecst.displayName = "iecst";
iecst.aliases = [];
function iecst(Prism$1) {
	Prism$1.languages.iecst = {
		comment: [{
			pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\(\*[\s\S]*?(?:\*\)|$)|\{[\s\S]*?(?:\}|$))/,
			lookbehind: true,
			greedy: true
		}, {
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true,
			greedy: true
		}],
		string: {
			pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
			greedy: true
		},
		keyword: [/\b(?:END_)?(?:PROGRAM|CONFIGURATION|INTERFACE|FUNCTION_BLOCK|FUNCTION|ACTION|TRANSITION|TYPE|STRUCT|(?:INITIAL_)?STEP|NAMESPACE|LIBRARY|CHANNEL|FOLDER|RESOURCE|VAR_(?:ACCESS|CONFIG|EXTERNAL|GLOBAL|INPUT|IN_OUT|OUTPUT|TEMP)|VAR|METHOD|PROPERTY)\b/i, /\b(?:AT|BY|(?:END_)?(?:CASE|FOR|IF|REPEAT|WHILE)|CONSTANT|CONTINUE|DO|ELSE|ELSIF|EXIT|EXTENDS|FROM|GET|GOTO|IMPLEMENTS|JMP|NON_RETAIN|OF|PRIVATE|PROTECTED|PUBLIC|RETAIN|RETURN|SET|TASK|THEN|TO|UNTIL|USING|WITH|__CATCH|__ENDTRY|__FINALLY|__TRY)\b/],
		"class-name": /\b(?:ANY|ARRAY|BOOL|BYTE|U?(?:D|L|S)?INT|(?:D|L)?WORD|DATE(?:_AND_TIME)?|DT|L?REAL|POINTER|STRING|TIME(?:_OF_DAY)?|TOD)\b/,
		address: {
			pattern: /%[IQM][XBWDL][\d.]*|%[IQ][\d.]*/,
			alias: "symbol"
		},
		number: /\b(?:16#[\da-f]+|2#[01_]+|0x[\da-f]+)\b|\b(?:D|DT|T|TOD)#[\d_shmd:]*|\b[A-Z]*#[\d.,_]*|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
		boolean: /\b(?:FALSE|NULL|TRUE)\b/,
		operator: /S?R?:?=>?|&&?|\*\*?|<[=>]?|>=?|[-:^/+#]|\b(?:AND|EQ|EXPT|GE|GT|LE|LT|MOD|NE|NOT|OR|XOR)\b/,
		function: /\b[a-z_]\w*(?=\s*\()/i,
		punctuation: /[()[\].,;]/
	};
}
supercollider.displayName = "supercollider";
supercollider.aliases = ["sclang"];
function supercollider(Prism$1) {
	Prism$1.languages.supercollider = {
		comment: {
			pattern: /\/\/.*|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\//,
			greedy: true
		},
		string: {
			pattern: /(^|[^\\])"(?:[^"\\]|\\[\s\S])*"/,
			lookbehind: true,
			greedy: true
		},
		char: {
			pattern: /\$(?:[^\\\r\n]|\\.)/,
			greedy: true
		},
		symbol: {
			pattern: /(^|[^\\])'(?:[^'\\]|\\[\s\S])*'|\\\w+/,
			lookbehind: true,
			greedy: true
		},
		keyword: /\b(?:_|arg|classvar|const|nil|var|while)\b/,
		boolean: /\b(?:false|true)\b/,
		label: {
			pattern: /\b[a-z_]\w*(?=\s*:)/,
			alias: "property"
		},
		number: /\b(?:inf|pi|0x[0-9a-fA-F]+|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(?:pi)?|\d+r[0-9a-zA-Z]+(?:\.[0-9a-zA-Z]+)?|\d+[sb]{1,4}\d*)\b/,
		"class-name": /\b[A-Z]\w*\b/,
		operator: /\.{2,3}|#(?![[{])|&&|[!=]==?|\+>>|\+{1,3}|-[->]|=>|>>|\?\?|@\|?@|\|(?:@|[!=]=)?\||!\?|<[!=>]|\*{1,2}|<{2,3}\*?|[-!%&/<>?@|=`]/,
		punctuation: /[{}()[\].:,;]|#[[{]/
	};
	Prism$1.languages.sclang = Prism$1.languages.supercollider;
}
systemd.displayName = "systemd";
systemd.aliases = [];
function systemd(Prism$1) {
	(function(Prism$2) {
		var comment$2 = {
			pattern: /^[;#].*/m,
			greedy: true
		};
		var quotesSource = /"(?:[^\r\n"\\]|\\(?:[^\r]|\r\n?))*"(?!\S)/.source;
		Prism$2.languages.systemd = {
			comment: comment$2,
			section: {
				pattern: /^\[[^\n\r\[\]]*\](?=[ \t]*$)/m,
				greedy: true,
				inside: {
					punctuation: /^\[|\]$/,
					"section-name": {
						pattern: /[\s\S]+/,
						alias: "selector"
					}
				}
			},
			key: {
				pattern: /^[^\s=]+(?=[ \t]*=)/m,
				greedy: true,
				alias: "attr-name"
			},
			value: {
				pattern: RegExp(/(=[ \t]*(?!\s))/.source + "(?:" + quotesSource + "|(?=[^\"\r\n]))(?:" + (/[^\s\\]/.source + "|[ 	]+(?:(?![ 	\"])|" + quotesSource + ")|" + /\\[\r\n]+(?:[#;].*[\r\n]+)*(?![#;])/.source) + ")*"),
				lookbehind: true,
				greedy: true,
				alias: "attr-value",
				inside: {
					comment: comment$2,
					quoted: {
						pattern: RegExp(/(^|\s)/.source + quotesSource),
						lookbehind: true,
						greedy: true
					},
					punctuation: /\\$/m,
					boolean: {
						pattern: /^(?:false|no|off|on|true|yes)$/,
						greedy: true
					}
				}
			},
			punctuation: /=/
		};
	})(Prism$1);
}
t4Templating.displayName = "t4-templating";
t4Templating.aliases = [];
function t4Templating(Prism$1) {
	(function(Prism$2) {
		function createBlock(prefix, inside, contentAlias) {
			return {
				pattern: RegExp("<#" + prefix + "[\\s\\S]*?#>"),
				alias: "block",
				inside: {
					delimiter: {
						pattern: RegExp("^<#" + prefix + "|#>$"),
						alias: "important"
					},
					content: {
						pattern: /[\s\S]+/,
						inside,
						alias: contentAlias
					}
				}
			};
		}
		function createT4(insideLang) {
			var grammar = Prism$2.languages[insideLang];
			var className$1 = "language-" + insideLang;
			return { block: {
				pattern: /<#[\s\S]+?#>/,
				inside: {
					directive: createBlock("@", {
						"attr-value": {
							pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/,
							inside: { punctuation: /^=|^["']|["']$/ }
						},
						keyword: /\b\w+(?=\s)/,
						"attr-name": /\b\w+/
					}),
					expression: createBlock("=", grammar, className$1),
					"class-feature": createBlock("\\+", grammar, className$1),
					standard: createBlock("", grammar, className$1)
				}
			} };
		}
		Prism$2.languages["t4-templating"] = Object.defineProperty({}, "createT4", { value: createT4 });
	})(Prism$1);
}
t4Cs.displayName = "t4-cs";
t4Cs.aliases = ["t4"];
function t4Cs(Prism$1) {
	Prism$1.register(csharp);
	Prism$1.register(t4Templating);
	Prism$1.languages.t4 = Prism$1.languages["t4-cs"] = Prism$1.languages["t4-templating"].createT4("csharp");
}
t4Vb.displayName = "t4-vb";
t4Vb.aliases = [];
function t4Vb(Prism$1) {
	Prism$1.register(t4Templating);
	Prism$1.register(vbnet);
	Prism$1.languages["t4-vb"] = Prism$1.languages["t4-templating"].createT4("vbnet");
}
tap.displayName = "tap";
tap.aliases = [];
function tap(Prism$1) {
	Prism$1.register(yaml);
	Prism$1.languages.tap = {
		fail: /not ok[^#{\n\r]*/,
		pass: /ok[^#{\n\r]*/,
		pragma: /pragma [+-][a-z]+/,
		bailout: /bail out!.*/i,
		version: /TAP version \d+/i,
		plan: /\b\d+\.\.\d+(?: +#.*)?/,
		subtest: {
			pattern: /# Subtest(?:: .*)?/,
			greedy: true
		},
		punctuation: /[{}]/,
		directive: /#.*/,
		yamlish: {
			pattern: /(^[ \t]*)---[\s\S]*?[\r\n][ \t]*\.\.\.$/m,
			lookbehind: true,
			inside: Prism$1.languages.yaml,
			alias: "language-yaml"
		}
	};
}
tcl.displayName = "tcl";
tcl.aliases = [];
function tcl(Prism$1) {
	Prism$1.languages.tcl = {
		comment: {
			pattern: /(^|[^\\])#.*/,
			lookbehind: true
		},
		string: {
			pattern: /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"/,
			greedy: true
		},
		variable: [
			{
				pattern: /(\$)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/,
				lookbehind: true
			},
			{
				pattern: /(\$)\{[^}]+\}/,
				lookbehind: true
			},
			{
				pattern: /(^[\t ]*set[ \t]+)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/m,
				lookbehind: true
			}
		],
		function: {
			pattern: /(^[\t ]*proc[ \t]+)\S+/m,
			lookbehind: true
		},
		builtin: [{
			pattern: /(^[\t ]*)(?:break|class|continue|error|eval|exit|for|foreach|if|proc|return|switch|while)\b/m,
			lookbehind: true
		}, /\b(?:else|elseif)\b/],
		scope: {
			pattern: /(^[\t ]*)(?:global|upvar|variable)\b/m,
			lookbehind: true,
			alias: "constant"
		},
		keyword: {
			pattern: /(^[\t ]*|\[)(?:Safe_Base|Tcl|after|append|apply|array|auto_(?:execok|import|load|mkindex|qualify|reset)|automkindex_old|bgerror|binary|catch|cd|chan|clock|close|concat|dde|dict|encoding|eof|exec|expr|fblocked|fconfigure|fcopy|file(?:event|name)?|flush|gets|glob|history|http|incr|info|interp|join|lappend|lassign|lindex|linsert|list|llength|load|lrange|lrepeat|lreplace|lreverse|lsearch|lset|lsort|math(?:func|op)|memory|msgcat|namespace|open|package|parray|pid|pkg_mkIndex|platform|puts|pwd|re_syntax|read|refchan|regexp|registry|regsub|rename|scan|seek|set|socket|source|split|string|subst|tcl(?:_endOfWord|_findLibrary|startOf(?:Next|Previous)Word|test|vars|wordBreak(?:After|Before))|tell|time|tm|trace|unknown|unload|unset|update|uplevel|vwait)\b/m,
			lookbehind: true
		},
		operator: /!=?|\*\*?|==|&&?|\|\|?|<[=<]?|>[=>]?|[-+~\/%?^]|\b(?:eq|in|ne|ni)\b/,
		punctuation: /[{}()\[\]]/
	};
}
tt2.displayName = "tt2";
tt2.aliases = [];
function tt2(Prism$1) {
	Prism$1.register(clike);
	Prism$1.register(markupTemplating);
	(function(Prism$2) {
		Prism$2.languages.tt2 = Prism$2.languages.extend("clike", {
			comment: /#.*|\[%#[\s\S]*?%\]/,
			keyword: /\b(?:BLOCK|CALL|CASE|CATCH|CLEAR|DEBUG|DEFAULT|ELSE|ELSIF|END|FILTER|FINAL|FOREACH|GET|IF|IN|INCLUDE|INSERT|LAST|MACRO|META|NEXT|PERL|PROCESS|RAWPERL|RETURN|SET|STOP|SWITCH|TAGS|THROW|TRY|UNLESS|USE|WHILE|WRAPPER)\b/,
			punctuation: /[[\]{},()]/
		});
		Prism$2.languages.insertBefore("tt2", "number", {
			operator: /=[>=]?|!=?|<=?|>=?|&&|\|\|?|\b(?:and|not|or)\b/,
			variable: { pattern: /\b[a-z]\w*(?:\s*\.\s*(?:\d+|\$?[a-z]\w*))*\b/i }
		});
		Prism$2.languages.insertBefore("tt2", "keyword", { delimiter: {
			pattern: /^(?:\[%|%%)-?|-?%\]$/,
			alias: "punctuation"
		} });
		Prism$2.languages.insertBefore("tt2", "string", {
			"single-quoted-string": {
				pattern: /'[^\\']*(?:\\[\s\S][^\\']*)*'/,
				greedy: true,
				alias: "string"
			},
			"double-quoted-string": {
				pattern: /"[^\\"]*(?:\\[\s\S][^\\"]*)*"/,
				greedy: true,
				alias: "string",
				inside: { variable: { pattern: /\$(?:[a-z]\w*(?:\.(?:\d+|\$?[a-z]\w*))*)/i } }
			}
		});
		delete Prism$2.languages.tt2.string;
		Prism$2.hooks.add("before-tokenize", function(env$1) {
			var tt2Pattern = /\[%[\s\S]+?%\]/g;
			Prism$2.languages["markup-templating"].buildPlaceholders(env$1, "tt2", tt2Pattern);
		});
		Prism$2.hooks.add("after-tokenize", function(env$1) {
			Prism$2.languages["markup-templating"].tokenizePlaceholders(env$1, "tt2");
		});
	})(Prism$1);
}
toml.displayName = "toml";
toml.aliases = [];
function toml(Prism$1) {
	(function(Prism$2) {
		var key = /(?:[\w-]+|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*")/.source;
		function insertKey(pattern) {
			return pattern.replace(/__/g, function() {
				return key;
			});
		}
		Prism$2.languages.toml = {
			comment: {
				pattern: /#.*/,
				greedy: true
			},
			table: {
				pattern: RegExp(insertKey(/(^[\t ]*\[\s*(?:\[\s*)?)__(?:\s*\.\s*__)*(?=\s*\])/.source), "m"),
				lookbehind: true,
				greedy: true,
				alias: "class-name"
			},
			key: {
				pattern: RegExp(insertKey(/(^[\t ]*|[{,]\s*)__(?:\s*\.\s*__)*(?=\s*=)/.source), "m"),
				lookbehind: true,
				greedy: true,
				alias: "property"
			},
			string: {
				pattern: /"""(?:\\[\s\S]|[^\\])*?"""|'''[\s\S]*?'''|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*"/,
				greedy: true
			},
			date: [{
				pattern: /\b\d{4}-\d{2}-\d{2}(?:[T\s]\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})?)?\b/i,
				alias: "number"
			}, {
				pattern: /\b\d{2}:\d{2}:\d{2}(?:\.\d+)?\b/,
				alias: "number"
			}],
			number: /(?:\b0(?:x[\da-zA-Z]+(?:_[\da-zA-Z]+)*|o[0-7]+(?:_[0-7]+)*|b[10]+(?:_[10]+)*))\b|[-+]?\b\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?\b|[-+]?\b(?:inf|nan)\b/,
			boolean: /\b(?:false|true)\b/,
			punctuation: /[.,=[\]{}]/
		};
	})(Prism$1);
}
tremor.displayName = "tremor";
tremor.aliases = ["trickle", "troy"];
function tremor(Prism$1) {
	(function(Prism$2) {
		Prism$2.languages.tremor = {
			comment: {
				pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
				lookbehind: true
			},
			"interpolated-string": null,
			extractor: {
				pattern: /\b[a-z_]\w*\|(?:[^\r\n\\|]|\\(?:\r\n|[\s\S]))*\|/i,
				greedy: true,
				inside: {
					regex: {
						pattern: /(^re)\|[\s\S]+/,
						lookbehind: true
					},
					function: /^\w+/,
					value: /\|[\s\S]+/
				}
			},
			identifier: {
				pattern: /`[^`]*`/,
				greedy: true
			},
			function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())\b/,
			keyword: /\b(?:args|as|by|case|config|connect|connector|const|copy|create|default|define|deploy|drop|each|emit|end|erase|event|flow|fn|for|from|group|having|insert|into|intrinsic|let|links|match|merge|mod|move|of|operator|patch|pipeline|recur|script|select|set|sliding|state|stream|to|tumbling|update|use|when|where|window|with)\b/,
			boolean: /\b(?:false|null|true)\b/i,
			number: /\b(?:0b[01_]*|0x[0-9a-fA-F_]*|\d[\d_]*(?:\.\d[\d_]*)?(?:[Ee][+-]?[\d_]+)?)\b/,
			"pattern-punctuation": {
				pattern: /%(?=[({[])/,
				alias: "punctuation"
			},
			operator: /[-+*\/%~!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?>?=?|(?:absent|and|not|or|present|xor)\b/,
			punctuation: /::|[;\[\]()\{\},.:]/
		};
		var interpolationPattern = /#\{(?:[^"{}]|\{[^{}]*\}|"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*")*\}/.source;
		Prism$2.languages.tremor["interpolated-string"] = {
			pattern: RegExp(/(^|[^\\])/.source + "(?:\"\"\"(?:" + /[^"\\#]|\\[\s\S]|"(?!"")|#(?!\{)/.source + "|" + interpolationPattern + ")*\"\"\"|\"(?:" + /[^"\\\r\n#]|\\(?:\r\n|[\s\S])|#(?!\{)/.source + "|" + interpolationPattern + ")*\")"),
			lookbehind: true,
			greedy: true,
			inside: {
				interpolation: {
					pattern: RegExp(interpolationPattern),
					inside: {
						punctuation: /^#\{|\}$/,
						expression: {
							pattern: /[\s\S]+/,
							inside: Prism$2.languages.tremor
						}
					}
				},
				string: /[\s\S]+/
			}
		};
		Prism$2.languages.troy = Prism$2.languages["tremor"];
		Prism$2.languages.trickle = Prism$2.languages["tremor"];
	})(Prism$1);
}
typoscript.displayName = "typoscript";
typoscript.aliases = ["tsconfig"];
function typoscript(Prism$1) {
	(function(Prism$2) {
		var keywords = /\b(?:ACT|ACTIFSUB|CARRAY|CASE|CLEARGIF|COA|COA_INT|CONSTANTS|CONTENT|CUR|EDITPANEL|EFFECT|EXT|FILE|FLUIDTEMPLATE|FORM|FRAME|FRAMESET|GIFBUILDER|GMENU|GMENU_FOLDOUT|GMENU_LAYERS|GP|HMENU|HRULER|HTML|IENV|IFSUB|IMAGE|IMGMENU|IMGMENUITEM|IMGTEXT|IMG_RESOURCE|INCLUDE_TYPOSCRIPT|JSMENU|JSMENUITEM|LLL|LOAD_REGISTER|NO|PAGE|RECORDS|RESTORE_REGISTER|TEMPLATE|TEXT|TMENU|TMENUITEM|TMENU_LAYERS|USER|USER_INT|_GIFBUILDER|global|globalString|globalVar)\b/;
		Prism$2.languages.typoscript = {
			comment: [
				{
					pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
					lookbehind: true
				},
				{
					pattern: /(^|[^\\:= \t]|(?:^|[^= \t])[ \t]+)\/\/.*/,
					lookbehind: true,
					greedy: true
				},
				{
					pattern: /(^|[^"'])#.*/,
					lookbehind: true,
					greedy: true
				}
			],
			function: [{
				pattern: /<INCLUDE_TYPOSCRIPT:\s*source\s*=\s*(?:"[^"\r\n]*"|'[^'\r\n]*')\s*>/,
				inside: {
					string: {
						pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
						inside: { keyword: keywords }
					},
					keyword: { pattern: /INCLUDE_TYPOSCRIPT/ }
				}
			}, {
				pattern: /@import\s*(?:"[^"\r\n]*"|'[^'\r\n]*')/,
				inside: { string: /"[^"\r\n]*"|'[^'\r\n]*'/ }
			}],
			string: {
				pattern: /^([^=]*=[< ]?)(?:(?!\]\n).)*/,
				lookbehind: true,
				inside: {
					function: /\{\$.*\}/,
					keyword: keywords,
					number: /^\d+$/,
					punctuation: /[,|:]/
				}
			},
			keyword: keywords,
			number: {
				pattern: /\b\d+\s*[.{=]/,
				inside: { operator: /[.{=]/ }
			},
			tag: {
				pattern: /\.?[-\w\\]+\.?/,
				inside: { punctuation: /\./ }
			},
			punctuation: /[{}[\];(),.:|]/,
			operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/
		};
		Prism$2.languages.tsconfig = Prism$2.languages.typoscript;
	})(Prism$1);
}
unrealscript.displayName = "unrealscript";
unrealscript.aliases = ["uc", "uscript"];
function unrealscript(Prism$1) {
	Prism$1.languages.unrealscript = {
		comment: /\/\/.*|\/\*[\s\S]*?\*\//,
		string: {
			pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
			greedy: true
		},
		category: {
			pattern: /(\b(?:(?:autoexpand|hide|show)categories|var)\s*\()[^()]+(?=\))/,
			lookbehind: true,
			greedy: true,
			alias: "property"
		},
		metadata: {
			pattern: /(\w\s*)<\s*\w+\s*=[^<>|=\r\n]+(?:\|\s*\w+\s*=[^<>|=\r\n]+)*>/,
			lookbehind: true,
			greedy: true,
			inside: {
				property: /\b\w+(?=\s*=)/,
				operator: /=/,
				punctuation: /[<>|]/
			}
		},
		macro: {
			pattern: /`\w+/,
			alias: "property"
		},
		"class-name": {
			pattern: /(\b(?:class|enum|extends|interface|state(?:\(\))?|struct|within)\s+)\w+/,
			lookbehind: true
		},
		keyword: /\b(?:abstract|actor|array|auto|autoexpandcategories|bool|break|byte|case|class|classgroup|client|coerce|collapsecategories|config|const|continue|default|defaultproperties|delegate|dependson|deprecated|do|dontcollapsecategories|editconst|editinlinenew|else|enum|event|exec|export|extends|final|float|for|forcescriptorder|foreach|function|goto|guid|hidecategories|hidedropdown|if|ignores|implements|inherits|input|int|interface|iterator|latent|local|material|name|native|nativereplication|noexport|nontransient|noteditinlinenew|notplaceable|operator|optional|out|pawn|perobjectconfig|perobjectlocalized|placeable|postoperator|preoperator|private|protected|reliable|replication|return|server|showcategories|simulated|singular|state|static|string|struct|structdefault|structdefaultproperties|switch|texture|transient|travel|unreliable|until|var|vector|while|within)\b/,
		function: /\b[a-z_]\w*(?=\s*\()/i,
		boolean: /\b(?:false|true)\b/,
		number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
		operator: />>|<<|--|\+\+|\*\*|[-+*/~!=<>$@]=?|&&?|\|\|?|\^\^?|[?:%]|\b(?:ClockwiseFrom|Cross|Dot)\b/,
		punctuation: /[()[\]{};,.]/
	};
	Prism$1.languages.uc = Prism$1.languages.uscript = Prism$1.languages.unrealscript;
}
uorazor.displayName = "uorazor";
uorazor.aliases = [];
function uorazor(Prism$1) {
	Prism$1.languages.uorazor = {
		"comment-hash": {
			pattern: /#.*/,
			alias: "comment",
			greedy: true
		},
		"comment-slash": {
			pattern: /\/\/.*/,
			alias: "comment",
			greedy: true
		},
		string: {
			pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
			inside: { punctuation: /^['"]|['"]$/ },
			greedy: true
		},
		"source-layers": {
			pattern: /\b(?:arms|backpack|blue|bracelet|cancel|clear|cloak|criminal|earrings|enemy|facialhair|friend|friendly|gloves|gray|grey|ground|hair|head|innerlegs|innertorso|innocent|lefthand|middletorso|murderer|neck|nonfriendly|onehandedsecondary|outerlegs|outertorso|pants|red|righthand|ring|self|shirt|shoes|talisman|waist)\b/i,
			alias: "function"
		},
		"source-commands": {
			pattern: /\b(?:alliance|attack|cast|clearall|clearignore|clearjournal|clearlist|clearsysmsg|createlist|createtimer|dclick|dclicktype|dclickvar|dress|dressconfig|drop|droprelloc|emote|getlabel|guild|gumpclose|gumpresponse|hotkey|ignore|lasttarget|lift|lifttype|menu|menuresponse|msg|org|organize|organizer|overhead|pause|poplist|potion|promptresponse|pushlist|removelist|removetimer|rename|restock|say|scav|scavenger|script|setability|setlasttarget|setskill|settimer|setvar|sysmsg|target|targetloc|targetrelloc|targettype|undress|unignore|unsetvar|useobject|useonce|useskill|usetype|virtue|wait|waitforgump|waitformenu|waitforprompt|waitforstat|waitforsysmsg|waitfortarget|walk|wfsysmsg|wft|whisper|yell)\b/,
			alias: "function"
		},
		"tag-name": {
			pattern: /(^\{%-?\s*)\w+/,
			lookbehind: true,
			alias: "keyword"
		},
		delimiter: {
			pattern: /^\{[{%]-?|-?[%}]\}$/,
			alias: "punctuation"
		},
		function: /\b(?:atlist|close|closest|count|counter|counttype|dead|dex|diffhits|diffmana|diffstam|diffweight|find|findbuff|finddebuff|findlayer|findtype|findtypelist|followers|gumpexists|hidden|hits|hp|hue|human|humanoid|ingump|inlist|insysmessage|insysmsg|int|invul|lhandempty|list|listexists|mana|maxhits|maxhp|maxmana|maxstam|maxweight|monster|mounted|name|next|noto|paralyzed|poisoned|position|prev|previous|queued|rand|random|rhandempty|skill|stam|str|targetexists|timer|timerexists|varexist|warmode|weight)\b/,
		keyword: /\b(?:and|as|break|continue|else|elseif|endfor|endif|endwhile|for|if|loop|not|or|replay|stop|while)\b/,
		boolean: /\b(?:false|null|true)\b/,
		number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
		operator: [{
			pattern: /(\s)(?:and|b-and|b-or|b-xor|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
			lookbehind: true
		}, /[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/],
		punctuation: /[()\[\]{}:.,]/
	};
}
v.displayName = "v";
v.aliases = [];
function v(Prism$1) {
	Prism$1.register(clike);
	(function(Prism$2) {
		var interpolationExpr = {
			pattern: /[\s\S]+/,
			inside: null
		};
		Prism$2.languages.v = Prism$2.languages.extend("clike", {
			string: {
				pattern: /r?(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
				alias: "quoted-string",
				greedy: true,
				inside: { interpolation: {
					pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\{[^{}]*\}|\w+(?:\.\w+(?:\([^\(\)]*\))?|\[[^\[\]]+\])*)/,
					lookbehind: true,
					inside: {
						"interpolation-variable": {
							pattern: /^\$\w[\s\S]*$/,
							alias: "variable"
						},
						"interpolation-punctuation": {
							pattern: /^\$\{|\}$/,
							alias: "punctuation"
						},
						"interpolation-expression": interpolationExpr
					}
				} }
			},
			"class-name": {
				pattern: /(\b(?:enum|interface|struct|type)\s+)(?:C\.)?\w+/,
				lookbehind: true
			},
			keyword: /(?:\b(?:__global|as|asm|assert|atomic|break|chan|const|continue|defer|else|embed|enum|fn|for|go(?:to)?|if|import|in|interface|is|lock|match|module|mut|none|or|pub|return|rlock|select|shared|sizeof|static|struct|type(?:of)?|union|unsafe)|\$(?:else|for|if)|#(?:flag|include))\b/,
			number: /\b(?:0x[a-f\d]+(?:_[a-f\d]+)*|0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?)\b/i,
			operator: /~|\?|[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\.?/,
			builtin: /\b(?:any(?:_float|_int)?|bool|byte(?:ptr)?|charptr|f(?:32|64)|i(?:8|16|64|128|nt)|rune|size_t|string|u(?:16|32|64|128)|voidptr)\b/
		});
		interpolationExpr.inside = Prism$2.languages.v;
		Prism$2.languages.insertBefore("v", "string", { char: {
			pattern: /`(?:\\`|\\?[^`]{1,2})`/,
			alias: "rune"
		} });
		Prism$2.languages.insertBefore("v", "operator", {
			attribute: {
				pattern: /(^[\t ]*)\[(?:deprecated|direct_array_access|flag|inline|live|ref_only|typedef|unsafe_fn|windows_stdcall)\]/m,
				lookbehind: true,
				alias: "annotation",
				inside: {
					punctuation: /[\[\]]/,
					keyword: /\w+/
				}
			},
			generic: {
				pattern: /<\w+>(?=\s*[\)\{])/,
				inside: {
					punctuation: /[<>]/,
					"class-name": /\w+/
				}
			}
		});
		Prism$2.languages.insertBefore("v", "function", { "generic-function": {
			pattern: /\b\w+\s*<\w+>(?=\()/,
			inside: {
				function: /^\w+/,
				generic: {
					pattern: /<\w+>/,
					inside: Prism$2.languages.v.generic.inside
				}
			}
		} });
	})(Prism$1);
}
vala.displayName = "vala";
vala.aliases = [];
function vala(Prism$1) {
	Prism$1.register(clike);
	Prism$1.languages.vala = Prism$1.languages.extend("clike", {
		"class-name": [
			{
				pattern: /\b[A-Z]\w*(?:\.\w+)*\b(?=(?:\?\s+|\*?\s+\*?)\w)/,
				inside: { punctuation: /\./ }
			},
			{
				pattern: /(\[)[A-Z]\w*(?:\.\w+)*\b/,
				lookbehind: true,
				inside: { punctuation: /\./ }
			},
			{
				pattern: /(\b(?:class|interface)\s+[A-Z]\w*(?:\.\w+)*\s*:\s*)[A-Z]\w*(?:\.\w+)*\b/,
				lookbehind: true,
				inside: { punctuation: /\./ }
			},
			{
				pattern: /((?:\b(?:class|enum|interface|new|struct)\s+)|(?:catch\s+\())[A-Z]\w*(?:\.\w+)*\b/,
				lookbehind: true,
				inside: { punctuation: /\./ }
			}
		],
		keyword: /\b(?:abstract|as|assert|async|base|bool|break|case|catch|char|class|const|construct|continue|default|delegate|delete|do|double|dynamic|else|ensures|enum|errordomain|extern|finally|float|for|foreach|get|if|in|inline|int|int16|int32|int64|int8|interface|internal|is|lock|long|namespace|new|null|out|override|owned|params|private|protected|public|ref|requires|return|set|short|signal|sizeof|size_t|ssize_t|static|string|struct|switch|this|throw|throws|try|typeof|uchar|uint|uint16|uint32|uint64|uint8|ulong|unichar|unowned|ushort|using|value|var|virtual|void|volatile|weak|while|yield)\b/i,
		function: /\b\w+(?=\s*\()/,
		number: /(?:\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?:f|u?l?)?/i,
		operator: /\+\+|--|&&|\|\||<<=?|>>=?|=>|->|~|[+\-*\/%&^|=!<>]=?|\?\??|\.\.\./,
		punctuation: /[{}[\];(),.:]/,
		constant: /\b[A-Z0-9_]+\b/
	});
	Prism$1.languages.insertBefore("vala", "string", {
		"raw-string": {
			pattern: /"""[\s\S]*?"""/,
			greedy: true,
			alias: "string"
		},
		"template-string": {
			pattern: /@"[\s\S]*?"/,
			greedy: true,
			inside: {
				interpolation: {
					pattern: /\$(?:\([^)]*\)|[a-zA-Z]\w*)/,
					inside: {
						delimiter: {
							pattern: /^\$\(?|\)$/,
							alias: "punctuation"
						},
						rest: Prism$1.languages.vala
					}
				},
				string: /[\s\S]+/
			}
		}
	});
	Prism$1.languages.insertBefore("vala", "keyword", { regex: {
		pattern: /\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[imsx]{0,4}(?=\s*(?:$|[\r\n,.;})\]]))/,
		greedy: true,
		inside: {
			"regex-source": {
				pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
				lookbehind: true,
				alias: "language-regex",
				inside: Prism$1.languages.regex
			},
			"regex-delimiter": /^\//,
			"regex-flags": /^[a-z]+$/
		}
	} });
}
velocity.displayName = "velocity";
velocity.aliases = [];
function velocity(Prism$1) {
	Prism$1.register(markup);
	(function(Prism$2) {
		Prism$2.languages.velocity = Prism$2.languages.extend("markup", {});
		var velocity$1 = {
			variable: {
				pattern: /(^|[^\\](?:\\\\)*)\$!?(?:[a-z][\w-]*(?:\([^)]*\))?(?:\.[a-z][\w-]*(?:\([^)]*\))?|\[[^\]]+\])*|\{[^}]+\})/i,
				lookbehind: true,
				inside: {}
			},
			string: {
				pattern: /"[^"]*"|'[^']*'/,
				greedy: true
			},
			number: /\b\d+\b/,
			boolean: /\b(?:false|true)\b/,
			operator: /[=!<>]=?|[+*/%-]|&&|\|\||\.\.|\b(?:eq|g[et]|l[et]|n(?:e|ot))\b/,
			punctuation: /[(){}[\]:,.]/
		};
		velocity$1.variable.inside = {
			string: velocity$1["string"],
			function: {
				pattern: /([^\w-])[a-z][\w-]*(?=\()/,
				lookbehind: true
			},
			number: velocity$1["number"],
			boolean: velocity$1["boolean"],
			punctuation: velocity$1["punctuation"]
		};
		Prism$2.languages.insertBefore("velocity", "comment", {
			unparsed: {
				pattern: /(^|[^\\])#\[\[[\s\S]*?\]\]#/,
				lookbehind: true,
				greedy: true,
				inside: { punctuation: /^#\[\[|\]\]#$/ }
			},
			"velocity-comment": [{
				pattern: /(^|[^\\])#\*[\s\S]*?\*#/,
				lookbehind: true,
				greedy: true,
				alias: "comment"
			}, {
				pattern: /(^|[^\\])##.*/,
				lookbehind: true,
				greedy: true,
				alias: "comment"
			}],
			directive: {
				pattern: /(^|[^\\](?:\\\\)*)#@?(?:[a-z][\w-]*|\{[a-z][\w-]*\})(?:\s*\((?:[^()]|\([^()]*\))*\))?/i,
				lookbehind: true,
				inside: {
					keyword: {
						pattern: /^#@?(?:[a-z][\w-]*|\{[a-z][\w-]*\})|\bin\b/,
						inside: { punctuation: /[{}]/ }
					},
					rest: velocity$1
				}
			},
			variable: velocity$1["variable"]
		});
		Prism$2.languages.velocity["tag"].inside["attr-value"].inside.rest = Prism$2.languages.velocity;
	})(Prism$1);
}
verilog.displayName = "verilog";
verilog.aliases = [];
function verilog(Prism$1) {
	Prism$1.languages.verilog = {
		comment: {
			pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
			greedy: true
		},
		string: {
			pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
			greedy: true
		},
		"kernel-function": {
			pattern: /\B\$\w+\b/,
			alias: "property"
		},
		constant: /\B`\w+\b/,
		function: /\b\w+(?=\()/,
		keyword: /\b(?:alias|and|assert|assign|assume|automatic|before|begin|bind|bins|binsof|bit|break|buf|bufif0|bufif1|byte|case|casex|casez|cell|chandle|class|clocking|cmos|config|const|constraint|context|continue|cover|covergroup|coverpoint|cross|deassign|default|defparam|design|disable|dist|do|edge|else|end|endcase|endclass|endclocking|endconfig|endfunction|endgenerate|endgroup|endinterface|endmodule|endpackage|endprimitive|endprogram|endproperty|endsequence|endspecify|endtable|endtask|enum|event|expect|export|extends|extern|final|first_match|for|force|foreach|forever|fork|forkjoin|function|generate|genvar|highz0|highz1|if|iff|ifnone|ignore_bins|illegal_bins|import|incdir|include|initial|inout|input|inside|instance|int|integer|interface|intersect|join|join_any|join_none|large|liblist|library|local|localparam|logic|longint|macromodule|matches|medium|modport|module|nand|negedge|new|nmos|nor|noshowcancelled|not|notif0|notif1|null|or|output|package|packed|parameter|pmos|posedge|primitive|priority|program|property|protected|pull0|pull1|pulldown|pullup|pulsestyle_ondetect|pulsestyle_onevent|pure|rand|randc|randcase|randsequence|rcmos|real|realtime|ref|reg|release|repeat|return|rnmos|rpmos|rtran|rtranif0|rtranif1|scalared|sequence|shortint|shortreal|showcancelled|signed|small|solve|specify|specparam|static|string|strong0|strong1|struct|super|supply0|supply1|table|tagged|task|this|throughout|time|timeprecision|timeunit|tran|tranif0|tranif1|tri|tri0|tri1|triand|trior|trireg|type|typedef|union|unique|unsigned|use|uwire|var|vectored|virtual|void|wait|wait_order|wand|weak0|weak1|while|wildcard|wire|with|within|wor|xnor|xor)\b/,
		important: /\b(?:always|always_comb|always_ff|always_latch)\b(?: *@)?/,
		number: /\B##?\d+|(?:\b\d+)?'[odbh] ?[\da-fzx_?]+|\b(?:\d*[._])?\d+(?:e[-+]?\d+)?/i,
		operator: /[-+{}^~%*\/?=!<>&|]+/,
		punctuation: /[[\];(),.:]/
	};
}
vhdl.displayName = "vhdl";
vhdl.aliases = [];
function vhdl(Prism$1) {
	Prism$1.languages.vhdl = {
		comment: /--.+/,
		"vhdl-vectors": {
			pattern: /\b[oxb]"[\da-f_]+"|"[01uxzwlh-]+"/i,
			alias: "number"
		},
		"quoted-function": {
			pattern: /"\S+?"(?=\()/,
			alias: "function"
		},
		string: /"(?:[^\\"\r\n]|\\(?:\r\n|[\s\S]))*"/,
		attribute: {
			pattern: /\b'\w+/,
			alias: "attr-name"
		},
		keyword: /\b(?:access|after|alias|all|architecture|array|assert|attribute|begin|block|body|buffer|bus|case|component|configuration|constant|disconnect|downto|else|elsif|end|entity|exit|file|for|function|generate|generic|group|guarded|if|impure|in|inertial|inout|is|label|library|linkage|literal|loop|map|new|next|null|of|on|open|others|out|package|port|postponed|private|procedure|process|pure|range|record|register|reject|report|return|select|severity|shared|signal|subtype|then|to|transport|type|unaffected|units|until|use|variable|view|wait|when|while|with)\b/i,
		boolean: /\b(?:false|true)\b/i,
		function: /\w+(?=\()/,
		number: /'[01uxzwlh-]'|\b(?:\d+#[\da-f_.]+#|\d[\d_.]*)(?:e[-+]?\d+)?/i,
		operator: /[<>]=?|:=|[-+*/&=]|\b(?:abs|and|mod|nand|nor|not|or|rem|rol|ror|sla|sll|sra|srl|xnor|xor)\b/i,
		punctuation: /[{}[\];(),.:]/
	};
}
vim.displayName = "vim";
vim.aliases = [];
function vim(Prism$1) {
	Prism$1.languages.vim = {
		string: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\r\n]|'')*'/,
		comment: /".*/,
		function: /\b\w+(?=\()/,
		keyword: /\b(?:N|Next|P|Print|X|XMLent|XMLns|ab|abbreviate|abc|abclear|abo|aboveleft|al|all|ar|arga|argadd|argd|argdelete|argdo|arge|argedit|argg|argglobal|argl|arglocal|args|argu|argument|as|ascii|b|bN|bNext|ba|bad|badd|ball|bd|bdelete|be|bel|belowright|bf|bfirst|bl|blast|bm|bmodified|bn|bnext|bo|botright|bp|bprevious|br|brea|break|breaka|breakadd|breakd|breakdel|breakl|breaklist|brewind|bro|browse|bufdo|buffer|buffers|bun|bunload|bw|bwipeout|c|cN|cNext|cNfcNfile|ca|cabbrev|cabc|cabclear|cad|caddb|caddbuffer|caddexpr|caddf|caddfile|cal|call|cat|catch|cb|cbuffer|cc|ccl|cclose|cd|ce|center|cex|cexpr|cf|cfile|cfir|cfirst|cg|cgetb|cgetbuffer|cgete|cgetexpr|cgetfile|change|changes|chd|chdir|che|checkpath|checkt|checktime|cl|cla|clast|clist|clo|close|cmapc|cmapclear|cn|cnew|cnewer|cnext|cnf|cnfile|cnorea|cnoreabbrev|co|col|colder|colo|colorscheme|comc|comclear|comp|compiler|con|conf|confirm|continue|cope|copen|copy|cp|cpf|cpfile|cprevious|cq|cquit|cr|crewind|cu|cuna|cunabbrev|cunmap|cw|cwindow|d|debugg|debuggreedy|delc|delcommand|delete|delf|delfunction|delm|delmarks|di|diffg|diffget|diffoff|diffpatch|diffpu|diffput|diffsplit|diffthis|diffu|diffupdate|dig|digraphs|display|dj|djump|dl|dlist|dr|drop|ds|dsearch|dsp|dsplit|e|earlier|echoe|echoerr|echom|echomsg|echon|edit|el|else|elsei|elseif|em|emenu|en|endf|endfo|endfor|endfun|endfunction|endif|endt|endtry|endw|endwhile|ene|enew|ex|exi|exit|exu|exusage|f|file|files|filetype|fin|fina|finally|find|fini|finish|fir|first|fix|fixdel|fo|fold|foldc|foldclose|foldd|folddoc|folddoclosed|folddoopen|foldo|foldopen|for|fu|fun|function|go|goto|gr|grep|grepa|grepadd|h|ha|hardcopy|help|helpf|helpfind|helpg|helpgrep|helpt|helptags|hid|hide|his|history|ia|iabbrev|iabc|iabclear|if|ij|ijump|il|ilist|imapc|imapclear|in|inorea|inoreabbrev|isearch|isp|isplit|iu|iuna|iunabbrev|iunmap|j|join|ju|jumps|k|kee|keepalt|keepj|keepjumps|keepmarks|l|lN|lNext|lNf|lNfile|la|lad|laddb|laddbuffer|laddexpr|laddf|laddfile|lan|language|last|later|lb|lbuffer|lc|lcd|lch|lchdir|lcl|lclose|left|lefta|leftabove|let|lex|lexpr|lf|lfile|lfir|lfirst|lg|lgetb|lgetbuffer|lgete|lgetexpr|lgetfile|lgr|lgrep|lgrepa|lgrepadd|lh|lhelpgrep|list|ll|lla|llast|lli|llist|lm|lmak|lmake|lmap|lmapc|lmapclear|ln|lne|lnew|lnewer|lnext|lnf|lnfile|lnoremap|lo|loadview|loc|lockmarks|lockv|lockvar|lol|lolder|lop|lopen|lp|lpf|lpfile|lprevious|lr|lrewind|ls|lt|ltag|lu|lunmap|lv|lvimgrep|lvimgrepa|lvimgrepadd|lw|lwindow|m|ma|mak|make|mark|marks|mat|match|menut|menutranslate|mk|mkexrc|mks|mksession|mksp|mkspell|mkv|mkvie|mkview|mkvimrc|mod|mode|move|mz|mzf|mzfile|mzscheme|n|nbkey|new|next|nmapc|nmapclear|noh|nohlsearch|norea|noreabbrev|nu|number|nun|nunmap|o|omapc|omapclear|on|only|open|opt|options|ou|ounmap|p|pc|pclose|pe|ped|pedit|perl|perld|perldo|po|pop|popu|popup|pp|ppop|pre|preserve|prev|previous|print|prof|profd|profdel|profile|promptf|promptfind|promptr|promptrepl|ps|psearch|ptN|ptNext|pta|ptag|ptf|ptfirst|ptj|ptjump|ptl|ptlast|ptn|ptnext|ptp|ptprevious|ptr|ptrewind|pts|ptselect|pu|put|pw|pwd|py|pyf|pyfile|python|q|qa|qall|quit|quita|quitall|r|read|rec|recover|red|redi|redir|redo|redr|redraw|redraws|redrawstatus|reg|registers|res|resize|ret|retab|retu|return|rew|rewind|ri|right|rightb|rightbelow|ru|rub|ruby|rubyd|rubydo|rubyf|rubyfile|runtime|rv|rviminfo|sN|sNext|sa|sal|sall|san|sandbox|sargument|sav|saveas|sb|sbN|sbNext|sba|sball|sbf|sbfirst|sbl|sblast|sbm|sbmodified|sbn|sbnext|sbp|sbprevious|sbr|sbrewind|sbuffer|scrip|scripte|scriptencoding|scriptnames|se|set|setf|setfiletype|setg|setglobal|setl|setlocal|sf|sfind|sfir|sfirst|sh|shell|sign|sil|silent|sim|simalt|sl|sla|slast|sleep|sm|smagic|smap|smapc|smapclear|sme|smenu|sn|snext|sni|sniff|sno|snomagic|snor|snoremap|snoreme|snoremenu|so|sor|sort|source|sp|spe|spelld|spelldump|spellgood|spelli|spellinfo|spellr|spellrepall|spellu|spellundo|spellw|spellwrong|split|spr|sprevious|sre|srewind|st|sta|stag|star|startg|startgreplace|startinsert|startr|startreplace|stj|stjump|stop|stopi|stopinsert|sts|stselect|sun|sunhide|sunm|sunmap|sus|suspend|sv|sview|syncbind|t|tN|tNext|ta|tab|tabN|tabNext|tabc|tabclose|tabd|tabdo|tabe|tabedit|tabf|tabfind|tabfir|tabfirst|tabl|tablast|tabm|tabmove|tabn|tabnew|tabnext|tabo|tabonly|tabp|tabprevious|tabr|tabrewind|tabs|tag|tags|tc|tcl|tcld|tcldo|tclf|tclfile|te|tearoff|tf|tfirst|th|throw|tj|tjump|tl|tlast|tm|tmenu|tn|tnext|to|topleft|tp|tprevious|tr|trewind|try|ts|tselect|tu|tunmenu|u|una|unabbreviate|undo|undoj|undojoin|undol|undolist|unh|unhide|unlet|unlo|unlockvar|unm|unmap|up|update|ve|verb|verbose|version|vert|vertical|vi|vie|view|vim|vimgrep|vimgrepa|vimgrepadd|visual|viu|viusage|vmapc|vmapclear|vne|vnew|vs|vsplit|vu|vunmap|w|wN|wNext|wa|wall|wh|while|win|winc|wincmd|windo|winp|winpos|winsize|wn|wnext|wp|wprevious|wq|wqa|wqall|write|ws|wsverb|wv|wviminfo|x|xa|xall|xit|xm|xmap|xmapc|xmapclear|xme|xmenu|xn|xnoremap|xnoreme|xnoremenu|xu|xunmap|y|yank)\b/,
		builtin: /\b(?:acd|ai|akm|aleph|allowrevins|altkeymap|ambiwidth|ambw|anti|antialias|arab|arabic|arabicshape|ari|arshape|autochdir|autocmd|autoindent|autoread|autowrite|autowriteall|aw|awa|background|backspace|backup|backupcopy|backupdir|backupext|backupskip|balloondelay|ballooneval|balloonexpr|bdir|bdlay|beval|bex|bexpr|bg|bh|bin|binary|biosk|bioskey|bk|bkc|bomb|breakat|brk|browsedir|bs|bsdir|bsk|bt|bufhidden|buflisted|buftype|casemap|ccv|cdpath|cedit|cfu|ch|charconvert|ci|cin|cindent|cink|cinkeys|cino|cinoptions|cinw|cinwords|clipboard|cmdheight|cmdwinheight|cmp|cms|columns|com|comments|commentstring|compatible|complete|completefunc|completeopt|consk|conskey|copyindent|cot|cpo|cpoptions|cpt|cscopepathcomp|cscopeprg|cscopequickfix|cscopetag|cscopetagorder|cscopeverbose|cspc|csprg|csqf|cst|csto|csverb|cuc|cul|cursorcolumn|cursorline|cwh|debug|deco|def|define|delcombine|dex|dg|dict|dictionary|diff|diffexpr|diffopt|digraph|dip|dir|directory|dy|ea|ead|eadirection|eb|ed|edcompatible|ef|efm|ei|ek|enc|encoding|endofline|eol|ep|equalalways|equalprg|errorbells|errorfile|errorformat|esckeys|et|eventignore|expandtab|exrc|fcl|fcs|fdc|fde|fdi|fdl|fdls|fdm|fdn|fdo|fdt|fen|fenc|fencs|fex|ff|ffs|fileencoding|fileencodings|fileformat|fileformats|fillchars|fk|fkmap|flp|fml|fmr|foldcolumn|foldenable|foldexpr|foldignore|foldlevel|foldlevelstart|foldmarker|foldmethod|foldminlines|foldnestmax|foldtext|formatexpr|formatlistpat|formatoptions|formatprg|fp|fs|fsync|ft|gcr|gd|gdefault|gfm|gfn|gfs|gfw|ghr|gp|grepformat|grepprg|gtl|gtt|guicursor|guifont|guifontset|guifontwide|guiheadroom|guioptions|guipty|guitablabel|guitabtooltip|helpfile|helpheight|helplang|hf|hh|hi|hidden|highlight|hk|hkmap|hkmapp|hkp|hl|hlg|hls|hlsearch|ic|icon|iconstring|ignorecase|im|imactivatekey|imak|imc|imcmdline|imd|imdisable|imi|iminsert|ims|imsearch|inc|include|includeexpr|incsearch|inde|indentexpr|indentkeys|indk|inex|inf|infercase|insertmode|invacd|invai|invakm|invallowrevins|invaltkeymap|invanti|invantialias|invar|invarab|invarabic|invarabicshape|invari|invarshape|invautochdir|invautoindent|invautoread|invautowrite|invautowriteall|invaw|invawa|invbackup|invballooneval|invbeval|invbin|invbinary|invbiosk|invbioskey|invbk|invbl|invbomb|invbuflisted|invcf|invci|invcin|invcindent|invcompatible|invconfirm|invconsk|invconskey|invcopyindent|invcp|invcscopetag|invcscopeverbose|invcst|invcsverb|invcuc|invcul|invcursorcolumn|invcursorline|invdeco|invdelcombine|invdg|invdiff|invdigraph|invdisable|invea|inveb|inved|invedcompatible|invek|invendofline|inveol|invequalalways|inverrorbells|invesckeys|invet|invex|invexpandtab|invexrc|invfen|invfk|invfkmap|invfoldenable|invgd|invgdefault|invguipty|invhid|invhidden|invhk|invhkmap|invhkmapp|invhkp|invhls|invhlsearch|invic|invicon|invignorecase|invim|invimc|invimcmdline|invimd|invincsearch|invinf|invinfercase|invinsertmode|invis|invjoinspaces|invjs|invlazyredraw|invlbr|invlinebreak|invlisp|invlist|invloadplugins|invlpl|invlz|invma|invmacatsui|invmagic|invmh|invml|invmod|invmodeline|invmodifiable|invmodified|invmore|invmousef|invmousefocus|invmousehide|invnu|invnumber|invodev|invopendevice|invpaste|invpi|invpreserveindent|invpreviewwindow|invprompt|invpvw|invreadonly|invremap|invrestorescreen|invrevins|invri|invrightleft|invrightleftcmd|invrl|invrlc|invro|invrs|invru|invruler|invsb|invsc|invscb|invscrollbind|invscs|invsecure|invsft|invshellslash|invshelltemp|invshiftround|invshortname|invshowcmd|invshowfulltag|invshowmatch|invshowmode|invsi|invsm|invsmartcase|invsmartindent|invsmarttab|invsmd|invsn|invsol|invspell|invsplitbelow|invsplitright|invspr|invsr|invssl|invsta|invstartofline|invstmp|invswapfile|invswf|invta|invtagbsearch|invtagrelative|invtagstack|invtbi|invtbidi|invtbs|invtermbidi|invterse|invtextauto|invtextmode|invtf|invtgst|invtildeop|invtimeout|invtitle|invto|invtop|invtr|invttimeout|invttybuiltin|invttyfast|invtx|invvb|invvisualbell|invwa|invwarn|invwb|invweirdinvert|invwfh|invwfw|invwildmenu|invwinfixheight|invwinfixwidth|invwiv|invwmnu|invwrap|invwrapscan|invwrite|invwriteany|invwritebackup|invws|isf|isfname|isi|isident|isk|iskeyword|isprint|joinspaces|js|key|keymap|keymodel|keywordprg|km|kmp|kp|langmap|langmenu|laststatus|lazyredraw|lbr|lcs|linebreak|lines|linespace|lisp|lispwords|listchars|loadplugins|lpl|lsp|lz|macatsui|magic|makeef|makeprg|matchpairs|matchtime|maxcombine|maxfuncdepth|maxmapdepth|maxmem|maxmempattern|maxmemtot|mco|mef|menuitems|mfd|mh|mis|mkspellmem|ml|mls|mm|mmd|mmp|mmt|modeline|modelines|modifiable|modified|more|mouse|mousef|mousefocus|mousehide|mousem|mousemodel|mouses|mouseshape|mouset|mousetime|mp|mps|msm|mzq|mzquantum|nf|noacd|noai|noakm|noallowrevins|noaltkeymap|noanti|noantialias|noar|noarab|noarabic|noarabicshape|noari|noarshape|noautochdir|noautoindent|noautoread|noautowrite|noautowriteall|noaw|noawa|nobackup|noballooneval|nobeval|nobin|nobinary|nobiosk|nobioskey|nobk|nobl|nobomb|nobuflisted|nocf|noci|nocin|nocindent|nocompatible|noconfirm|noconsk|noconskey|nocopyindent|nocp|nocscopetag|nocscopeverbose|nocst|nocsverb|nocuc|nocul|nocursorcolumn|nocursorline|nodeco|nodelcombine|nodg|nodiff|nodigraph|nodisable|noea|noeb|noed|noedcompatible|noek|noendofline|noeol|noequalalways|noerrorbells|noesckeys|noet|noex|noexpandtab|noexrc|nofen|nofk|nofkmap|nofoldenable|nogd|nogdefault|noguipty|nohid|nohidden|nohk|nohkmap|nohkmapp|nohkp|nohls|noic|noicon|noignorecase|noim|noimc|noimcmdline|noimd|noincsearch|noinf|noinfercase|noinsertmode|nois|nojoinspaces|nojs|nolazyredraw|nolbr|nolinebreak|nolisp|nolist|noloadplugins|nolpl|nolz|noma|nomacatsui|nomagic|nomh|noml|nomod|nomodeline|nomodifiable|nomodified|nomore|nomousef|nomousefocus|nomousehide|nonu|nonumber|noodev|noopendevice|nopaste|nopi|nopreserveindent|nopreviewwindow|noprompt|nopvw|noreadonly|noremap|norestorescreen|norevins|nori|norightleft|norightleftcmd|norl|norlc|noro|nors|noru|noruler|nosb|nosc|noscb|noscrollbind|noscs|nosecure|nosft|noshellslash|noshelltemp|noshiftround|noshortname|noshowcmd|noshowfulltag|noshowmatch|noshowmode|nosi|nosm|nosmartcase|nosmartindent|nosmarttab|nosmd|nosn|nosol|nospell|nosplitbelow|nosplitright|nospr|nosr|nossl|nosta|nostartofline|nostmp|noswapfile|noswf|nota|notagbsearch|notagrelative|notagstack|notbi|notbidi|notbs|notermbidi|noterse|notextauto|notextmode|notf|notgst|notildeop|notimeout|notitle|noto|notop|notr|nottimeout|nottybuiltin|nottyfast|notx|novb|novisualbell|nowa|nowarn|nowb|noweirdinvert|nowfh|nowfw|nowildmenu|nowinfixheight|nowinfixwidth|nowiv|nowmnu|nowrap|nowrapscan|nowrite|nowriteany|nowritebackup|nows|nrformats|numberwidth|nuw|odev|oft|ofu|omnifunc|opendevice|operatorfunc|opfunc|osfiletype|pa|para|paragraphs|paste|pastetoggle|patchexpr|patchmode|path|pdev|penc|pex|pexpr|pfn|ph|pheader|pi|pm|pmbcs|pmbfn|popt|preserveindent|previewheight|previewwindow|printdevice|printencoding|printexpr|printfont|printheader|printmbcharset|printmbfont|printoptions|prompt|pt|pumheight|pvh|pvw|qe|quoteescape|readonly|remap|report|restorescreen|revins|rightleft|rightleftcmd|rl|rlc|ro|rs|rtp|ruf|ruler|rulerformat|runtimepath|sbo|sc|scb|scr|scroll|scrollbind|scrolljump|scrolloff|scrollopt|scs|sect|sections|secure|sel|selection|selectmode|sessionoptions|sft|shcf|shellcmdflag|shellpipe|shellquote|shellredir|shellslash|shelltemp|shelltype|shellxquote|shiftround|shiftwidth|shm|shortmess|shortname|showbreak|showcmd|showfulltag|showmatch|showmode|showtabline|shq|si|sidescroll|sidescrolloff|siso|sj|slm|smartcase|smartindent|smarttab|smc|smd|softtabstop|sol|spc|spell|spellcapcheck|spellfile|spelllang|spellsuggest|spf|spl|splitbelow|splitright|sps|sr|srr|ss|ssl|ssop|stal|startofline|statusline|stl|stmp|su|sua|suffixes|suffixesadd|sw|swapfile|swapsync|swb|swf|switchbuf|sws|sxq|syn|synmaxcol|syntax|t_AB|t_AF|t_AL|t_CS|t_CV|t_Ce|t_Co|t_Cs|t_DL|t_EI|t_F1|t_F2|t_F3|t_F4|t_F5|t_F6|t_F7|t_F8|t_F9|t_IE|t_IS|t_K1|t_K3|t_K4|t_K5|t_K6|t_K7|t_K8|t_K9|t_KA|t_KB|t_KC|t_KD|t_KE|t_KF|t_KG|t_KH|t_KI|t_KJ|t_KK|t_KL|t_RI|t_RV|t_SI|t_Sb|t_Sf|t_WP|t_WS|t_ZH|t_ZR|t_al|t_bc|t_cd|t_ce|t_cl|t_cm|t_cs|t_da|t_db|t_dl|t_fs|t_k1|t_k2|t_k3|t_k4|t_k5|t_k6|t_k7|t_k8|t_k9|t_kB|t_kD|t_kI|t_kN|t_kP|t_kb|t_kd|t_ke|t_kh|t_kl|t_kr|t_ks|t_ku|t_le|t_mb|t_md|t_me|t_mr|t_ms|t_nd|t_op|t_se|t_so|t_sr|t_te|t_ti|t_ts|t_ue|t_us|t_ut|t_vb|t_ve|t_vi|t_vs|t_xs|tabline|tabpagemax|tabstop|tagbsearch|taglength|tagrelative|tagstack|tal|tb|tbi|tbidi|tbis|tbs|tenc|term|termbidi|termencoding|terse|textauto|textmode|textwidth|tgst|thesaurus|tildeop|timeout|timeoutlen|title|titlelen|titleold|titlestring|toolbar|toolbariconsize|top|tpm|tsl|tsr|ttimeout|ttimeoutlen|ttm|tty|ttybuiltin|ttyfast|ttym|ttymouse|ttyscroll|ttytype|tw|tx|uc|ul|undolevels|updatecount|updatetime|ut|vb|vbs|vdir|verbosefile|vfile|viewdir|viewoptions|viminfo|virtualedit|visualbell|vop|wak|warn|wb|wc|wcm|wd|weirdinvert|wfh|wfw|whichwrap|wi|wig|wildchar|wildcharm|wildignore|wildmenu|wildmode|wildoptions|wim|winaltkeys|window|winfixheight|winfixwidth|winheight|winminheight|winminwidth|winwidth|wiv|wiw|wm|wmh|wmnu|wmw|wop|wrap|wrapmargin|wrapscan|writeany|writebackup|writedelay|ww)\b/,
		number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?)\b/i,
		operator: /\|\||&&|[-+.]=?|[=!](?:[=~][#?]?)?|[<>]=?[#?]?|[*\/%?]|\b(?:is(?:not)?)\b/,
		punctuation: /[{}[\](),;:]/
	};
}
visualBasic.displayName = "visual-basic";
visualBasic.aliases = ["vb", "vba"];
function visualBasic(Prism$1) {
	Prism$1.languages["visual-basic"] = {
		comment: {
			pattern: /(?:['‘’]|REM\b)(?:[^\r\n_]|_(?:\r\n?|\n)?)*/i,
			inside: { keyword: /^REM/i }
		},
		directive: {
			pattern: /#(?:Const|Else|ElseIf|End|ExternalChecksum|ExternalSource|If|Region)(?:\b_[ \t]*(?:\r\n?|\n)|.)+/i,
			alias: "property",
			greedy: true
		},
		string: {
			pattern: /\$?["“”](?:["“”]{2}|[^"“”])*["“”]C?/i,
			greedy: true
		},
		date: {
			pattern: /#[ \t]*(?:\d+([/-])\d+\1\d+(?:[ \t]+(?:\d+[ \t]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[ \t]*(?:AM|PM))?))?|\d+[ \t]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[ \t]*(?:AM|PM))?)[ \t]*#/i,
			alias: "number"
		},
		number: /(?:(?:\b\d+(?:\.\d+)?|\.\d+)(?:E[+-]?\d+)?|&[HO][\dA-F]+)(?:[FRD]|U?[ILS])?/i,
		boolean: /\b(?:False|Nothing|True)\b/i,
		keyword: /\b(?:AddHandler|AddressOf|Alias|And(?:Also)?|As|Boolean|ByRef|Byte|ByVal|Call|Case|Catch|C(?:Bool|Byte|Char|Date|Dbl|Dec|Int|Lng|Obj|SByte|Short|Sng|Str|Type|UInt|ULng|UShort)|Char|Class|Const|Continue|Currency|Date|Decimal|Declare|Default|Delegate|Dim|DirectCast|Do|Double|Each|Else(?:If)?|End(?:If)?|Enum|Erase|Error|Event|Exit|Finally|For|Friend|Function|Get(?:Type|XMLNamespace)?|Global|GoSub|GoTo|Handles|If|Implements|Imports|In|Inherits|Integer|Interface|Is|IsNot|Let|Lib|Like|Long|Loop|Me|Mod|Module|Must(?:Inherit|Override)|My(?:Base|Class)|Namespace|Narrowing|New|Next|Not(?:Inheritable|Overridable)?|Object|Of|On|Operator|Option(?:al)?|Or(?:Else)?|Out|Overloads|Overridable|Overrides|ParamArray|Partial|Private|Property|Protected|Public|RaiseEvent|ReadOnly|ReDim|RemoveHandler|Resume|Return|SByte|Select|Set|Shadows|Shared|short|Single|Static|Step|Stop|String|Structure|Sub|SyncLock|Then|Throw|To|Try|TryCast|Type|TypeOf|U(?:Integer|Long|Short)|Until|Using|Variant|Wend|When|While|Widening|With(?:Events)?|WriteOnly|Xor)\b/i,
		operator: /[+\-*/\\^<=>&#@$%!]|\b_(?=[ \t]*[\r\n])/,
		punctuation: /[{}().,:?]/
	};
	Prism$1.languages.vb = Prism$1.languages["visual-basic"];
	Prism$1.languages.vba = Prism$1.languages["visual-basic"];
}
warpscript.displayName = "warpscript";
warpscript.aliases = [];
function warpscript(Prism$1) {
	Prism$1.languages.warpscript = {
		comment: /#.*|\/\/.*|\/\*[\s\S]*?\*\//,
		string: {
			pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'|<'(?:[^\\']|'(?!>)|\\.)*'>/,
			greedy: true
		},
		variable: /\$\S+/,
		macro: {
			pattern: /@\S+/,
			alias: "property"
		},
		keyword: /\b(?:BREAK|CHECKMACRO|CONTINUE|CUDF|DEFINED|DEFINEDMACRO|EVAL|FAIL|FOR|FOREACH|FORSTEP|IFT|IFTE|MSGFAIL|NRETURN|RETHROW|RETURN|SWITCH|TRY|UDF|UNTIL|WHILE)\b/,
		number: /[+-]?\b(?:NaN|Infinity|\d+(?:\.\d*)?(?:[Ee][+-]?\d+)?|0x[\da-fA-F]+|0b[01]+)\b/,
		boolean: /\b(?:F|T|false|true)\b/,
		punctuation: /<%|%>|[{}[\]()]/,
		operator: /==|&&?|\|\|?|\*\*?|>>>?|<<|[<>!~]=?|[-/%^]|\+!?|\b(?:AND|NOT|OR)\b/
	};
}
wasm.displayName = "wasm";
wasm.aliases = [];
function wasm(Prism$1) {
	Prism$1.languages.wasm = {
		comment: [/\(;[\s\S]*?;\)/, {
			pattern: /;;.*/,
			greedy: true
		}],
		string: {
			pattern: /"(?:\\[\s\S]|[^"\\])*"/,
			greedy: true
		},
		keyword: [
			{
				pattern: /\b(?:align|offset)=/,
				inside: { operator: /=/ }
			},
			{
				pattern: /\b(?:(?:f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|neg?|nearest|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|sqrt|store(?:8|16|32)?|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))?|memory\.(?:grow|size))\b/,
				inside: { punctuation: /\./ }
			},
			/\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\b/
		],
		variable: /\$[\w!#$%&'*+\-./:<=>?@\\^`|~]+/,
		number: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/,
		punctuation: /[()]/
	};
}
webIdl.displayName = "web-idl";
webIdl.aliases = ["webidl"];
function webIdl(Prism$1) {
	(function(Prism$2) {
		var id$1 = /(?:\B-|\b_|\b)[A-Za-z][\w-]*(?![\w-])/.source;
		var type = "(?:" + /\b(?:unsigned\s+)?long\s+long(?![\w-])/.source + "|" + /\b(?:unrestricted|unsigned)\s+[a-z]+(?![\w-])/.source + "|" + /(?!(?:unrestricted|unsigned)\b)/.source + id$1 + /(?:\s*<(?:[^<>]|<[^<>]*>)*>)?/.source + ")" + /(?:\s*\?)?/.source;
		var typeInside = {};
		Prism$2.languages["web-idl"] = {
			comment: {
				pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
				greedy: true
			},
			string: {
				pattern: /"[^"]*"/,
				greedy: true
			},
			namespace: {
				pattern: RegExp(/(\bnamespace\s+)/.source + id$1),
				lookbehind: true
			},
			"class-name": [
				{
					pattern: /(^|[^\w-])(?:iterable|maplike|setlike)\s*<(?:[^<>]|<[^<>]*>)*>/,
					lookbehind: true,
					inside: typeInside
				},
				{
					pattern: RegExp(/(\b(?:attribute|const|deleter|getter|optional|setter)\s+)/.source + type),
					lookbehind: true,
					inside: typeInside
				},
				{
					pattern: RegExp("(" + /\bcallback\s+/.source + id$1 + /\s*=\s*/.source + ")" + type),
					lookbehind: true,
					inside: typeInside
				},
				{
					pattern: RegExp(/(\btypedef\b\s*)/.source + type),
					lookbehind: true,
					inside: typeInside
				},
				{
					pattern: RegExp(/(\b(?:callback|dictionary|enum|interface(?:\s+mixin)?)\s+)(?!(?:interface|mixin)\b)/.source + id$1),
					lookbehind: true
				},
				{
					pattern: RegExp(/(:\s*)/.source + id$1),
					lookbehind: true
				},
				RegExp(id$1 + /(?=\s+(?:implements|includes)\b)/.source),
				{
					pattern: RegExp(/(\b(?:implements|includes)\s+)/.source + id$1),
					lookbehind: true
				},
				{
					pattern: RegExp(type + "(?=" + /\s*(?:\.{3}\s*)?/.source + id$1 + /\s*[(),;=]/.source + ")"),
					inside: typeInside
				}
			],
			builtin: /\b(?:ArrayBuffer|BigInt64Array|BigUint64Array|ByteString|DOMString|DataView|Float32Array|Float64Array|FrozenArray|Int16Array|Int32Array|Int8Array|ObservableArray|Promise|USVString|Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray)\b/,
			keyword: [/\b(?:async|attribute|callback|const|constructor|deleter|dictionary|enum|getter|implements|includes|inherit|interface|mixin|namespace|null|optional|or|partial|readonly|required|setter|static|stringifier|typedef|unrestricted)\b/, /\b(?:any|bigint|boolean|byte|double|float|iterable|long|maplike|object|octet|record|sequence|setlike|short|symbol|undefined|unsigned|void)\b/],
			boolean: /\b(?:false|true)\b/,
			number: {
				pattern: /(^|[^\w-])-?(?:0x[0-9a-f]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|NaN|Infinity)(?![\w-])/i,
				lookbehind: true
			},
			operator: /\.{3}|[=:?<>-]/,
			punctuation: /[(){}[\].,;]/
		};
		for (var key in Prism$2.languages["web-idl"]) if (key !== "class-name") typeInside[key] = Prism$2.languages["web-idl"][key];
		Prism$2.languages["webidl"] = Prism$2.languages["web-idl"];
	})(Prism$1);
}
wgsl.displayName = "wgsl";
wgsl.aliases = [];
function wgsl(Prism$1) {
	Prism$1.languages.wgsl = {
		comment: {
			pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
			greedy: true
		},
		"builtin-attribute": {
			pattern: /(@)builtin\(.*?\)/,
			lookbehind: true,
			inside: {
				attribute: {
					pattern: /^builtin/,
					alias: "attr-name"
				},
				punctuation: /[(),]/,
				"built-in-values": {
					pattern: /\b(?:frag_depth|front_facing|global_invocation_id|instance_index|local_invocation_id|local_invocation_index|num_workgroups|position|sample_index|sample_mask|vertex_index|workgroup_id)\b/,
					alias: "attr-value"
				}
			}
		},
		attributes: {
			pattern: /(@)(?:align|binding|compute|const|fragment|group|id|interpolate|invariant|location|size|vertex|workgroup_size)/i,
			lookbehind: true,
			alias: "attr-name"
		},
		functions: {
			pattern: /\b(fn\s+)[_a-zA-Z]\w*(?=[(<])/,
			lookbehind: true,
			alias: "function"
		},
		keyword: /\b(?:bitcast|break|case|const|continue|continuing|default|discard|else|enable|fallthrough|fn|for|function|if|let|loop|private|return|storage|struct|switch|type|uniform|var|while|workgroup)\b/,
		builtin: /\b(?:abs|acos|acosh|all|any|array|asin|asinh|atan|atan2|atanh|atomic|atomicAdd|atomicAnd|atomicCompareExchangeWeak|atomicExchange|atomicLoad|atomicMax|atomicMin|atomicOr|atomicStore|atomicSub|atomicXor|bool|ceil|clamp|cos|cosh|countLeadingZeros|countOneBits|countTrailingZeros|cross|degrees|determinant|distance|dot|dpdx|dpdxCoarse|dpdxFine|dpdy|dpdyCoarse|dpdyFine|exp|exp2|extractBits|f32|f64|faceForward|firstLeadingBit|floor|fma|fract|frexp|fwidth|fwidthCoarse|fwidthFine|i32|i64|insertBits|inverseSqrt|ldexp|length|log|log2|mat[2-4]x[2-4]|max|min|mix|modf|normalize|override|pack2x16float|pack2x16snorm|pack2x16unorm|pack4x8snorm|pack4x8unorm|pow|ptr|quantizeToF16|radians|reflect|refract|reverseBits|round|sampler|sampler_comparison|select|shiftLeft|shiftRight|sign|sin|sinh|smoothstep|sqrt|staticAssert|step|storageBarrier|tan|tanh|textureDimensions|textureGather|textureGatherCompare|textureLoad|textureNumLayers|textureNumLevels|textureNumSamples|textureSample|textureSampleBias|textureSampleCompare|textureSampleCompareLevel|textureSampleGrad|textureSampleLevel|textureStore|texture_1d|texture_2d|texture_2d_array|texture_3d|texture_cube|texture_cube_array|texture_depth_2d|texture_depth_2d_array|texture_depth_cube|texture_depth_cube_array|texture_depth_multisampled_2d|texture_multisampled_2d|texture_storage_1d|texture_storage_2d|texture_storage_2d_array|texture_storage_3d|transpose|trunc|u32|u64|unpack2x16float|unpack2x16snorm|unpack2x16unorm|unpack4x8snorm|unpack4x8unorm|vec[2-4]|workgroupBarrier)\b/,
		"function-calls": {
			pattern: /\b[_a-z]\w*(?=\()/i,
			alias: "function"
		},
		"class-name": /\b(?:[A-Z][A-Za-z0-9]*)\b/,
		"bool-literal": {
			pattern: /\b(?:false|true)\b/,
			alias: "boolean"
		},
		"hex-int-literal": {
			pattern: /\b0[xX][0-9a-fA-F]+[iu]?\b(?![.pP])/,
			alias: "number"
		},
		"hex-float-literal": {
			pattern: /\b0[xX][0-9a-fA-F]*(?:\.[0-9a-fA-F]*)?(?:[pP][+-]?\d+[fh]?)?/,
			alias: "number"
		},
		"decimal-float-literal": [
			{
				pattern: /\d*\.\d+(?:[eE](?:\+|-)?\d+)?[fh]?/,
				alias: "number"
			},
			{
				pattern: /\d+\.\d*(?:[eE](?:\+|-)?\d+)?[fh]?/,
				alias: "number"
			},
			{
				pattern: /\d+[eE](?:\+|-)?\d+[fh]?/,
				alias: "number"
			},
			{
				pattern: /\b\d+[fh]\b/,
				alias: "number"
			}
		],
		"int-literal": {
			pattern: /\b\d+[iu]?\b/,
			alias: "number"
		},
		operator: [
			{ pattern: /(?:\^|~|\|(?!\|)|\|\||&&|<<|>>|!)(?!=)/ },
			{ pattern: /&(?![&=])/ },
			{ pattern: /(?:\+=|-=|\*=|\/=|%=|\^=|&=|\|=|<<=|>>=)/ },
			{
				pattern: /(^|[^<>=!])=(?![=>])/,
				lookbehind: true
			},
			{
				pattern: /(?:==|!=|<=|\+\+|--|(^|[^=])>=)/,
				lookbehind: true
			},
			{ pattern: /(?:(?:[+%]|(?:\*(?!\w)))(?!=))|(?:-(?!>))|(?:\/(?!\/))/ },
			{ pattern: /->/ }
		],
		punctuation: /[@(){}[\],;<>:.]/
	};
}
wiki.displayName = "wiki";
wiki.aliases = [];
function wiki(Prism$1) {
	Prism$1.register(markup);
	Prism$1.languages.wiki = Prism$1.languages.extend("markup", {
		"block-comment": {
			pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
			lookbehind: true,
			alias: "comment"
		},
		heading: {
			pattern: /^(=+)[^=\r\n].*?\1/m,
			inside: {
				punctuation: /^=+|=+$/,
				important: /.+/
			}
		},
		emphasis: {
			pattern: /('{2,5}).+?\1/,
			inside: {
				"bold-italic": {
					pattern: /(''''').+?(?=\1)/,
					lookbehind: true,
					alias: ["bold", "italic"]
				},
				bold: {
					pattern: /(''')[^'](?:.*?[^'])?(?=\1)/,
					lookbehind: true
				},
				italic: {
					pattern: /('')[^'](?:.*?[^'])?(?=\1)/,
					lookbehind: true
				},
				punctuation: /^''+|''+$/
			}
		},
		hr: {
			pattern: /^-{4,}/m,
			alias: "punctuation"
		},
		url: [/ISBN +(?:97[89][ -]?)?(?:\d[ -]?){9}[\dx]\b|(?:PMID|RFC) +\d+/i, /\[\[.+?\]\]|\[.+?\]/],
		variable: [
			/__[A-Z]+__/,
			/\{{3}.+?\}{3}/,
			/\{\{.+?\}\}/
		],
		symbol: [/^#redirect/im, /~{3,5}/],
		"table-tag": {
			pattern: /((?:^|[|!])[|!])[^|\r\n]+\|(?!\|)/m,
			lookbehind: true,
			inside: {
				"table-bar": {
					pattern: /\|$/,
					alias: "punctuation"
				},
				rest: Prism$1.languages.markup["tag"].inside
			}
		},
		punctuation: /^(?:\{\||\|\}|\|-|[*#:;!|])|\|\||!!/m
	});
	Prism$1.languages.insertBefore("wiki", "tag", { nowiki: {
		pattern: /<(nowiki|pre|source)\b[^>]*>[\s\S]*?<\/\1>/i,
		inside: { tag: {
			pattern: /<(?:nowiki|pre|source)\b[^>]*>|<\/(?:nowiki|pre|source)>/i,
			inside: Prism$1.languages.markup["tag"].inside
		} }
	} });
}
wolfram.displayName = "wolfram";
wolfram.aliases = [
	"mathematica",
	"nb",
	"wl"
];
function wolfram(Prism$1) {
	Prism$1.languages.wolfram = {
		comment: /\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/,
		string: {
			pattern: /"(?:\\.|[^"\\\r\n])*"/,
			greedy: true
		},
		keyword: /\b(?:Abs|AbsArg|Accuracy|Block|Do|For|Function|If|Manipulate|Module|Nest|NestList|None|Return|Switch|Table|Which|While)\b/,
		context: {
			pattern: /\b\w+`+\w*/,
			alias: "class-name"
		},
		blank: {
			pattern: /\b\w+_\b/,
			alias: "regex"
		},
		"global-variable": {
			pattern: /\$\w+/,
			alias: "variable"
		},
		boolean: /\b(?:False|True)\b/,
		number: /(?:\b(?=\d)|\B(?=\.))(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?j?\b/i,
		operator: /\/\.|;|=\.|\^=|\^:=|:=|<<|>>|<\||\|>|:>|\|->|->|<-|@@@|@@|@|\/@|=!=|===|==|=|\+|-|\[\/-+%=\]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
		punctuation: /[{}[\];(),.:]/
	};
	Prism$1.languages.mathematica = Prism$1.languages.wolfram;
	Prism$1.languages.wl = Prism$1.languages.wolfram;
	Prism$1.languages.nb = Prism$1.languages.wolfram;
}
wren.displayName = "wren";
wren.aliases = [];
function wren(Prism$1) {
	Prism$1.languages.wren = {
		comment: [{
			pattern: /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*))*\*\/)*\*\/)*\*\//,
			greedy: true
		}, {
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true,
			greedy: true
		}],
		"triple-quoted-string": {
			pattern: /"""[\s\S]*?"""/,
			greedy: true,
			alias: "string"
		},
		"string-literal": null,
		hashbang: {
			pattern: /^#!\/.+/,
			greedy: true,
			alias: "comment"
		},
		attribute: {
			pattern: /#!?[ \t\u3000]*\w+/,
			alias: "keyword"
		},
		"class-name": [{
			pattern: /(\bclass\s+)\w+/,
			lookbehind: true
		}, /\b[A-Z][a-z\d_]*\b/],
		constant: /\b[A-Z][A-Z\d_]*\b/,
		null: {
			pattern: /\bnull\b/,
			alias: "keyword"
		},
		keyword: /\b(?:as|break|class|construct|continue|else|for|foreign|if|import|in|is|return|static|super|this|var|while)\b/,
		boolean: /\b(?:false|true)\b/,
		number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
		function: /\b[a-z_]\w*(?=\s*[({])/i,
		operator: /<<|>>|[=!<>]=?|&&|\|\||[-+*/%~^&|?:]|\.{2,3}/,
		punctuation: /[\[\](){}.,;]/
	};
	Prism$1.languages.wren["string-literal"] = {
		pattern: /(^|[^\\"])"(?:[^\\"%]|\\[\s\S]|%(?!\()|%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\))*"/,
		lookbehind: true,
		greedy: true,
		inside: {
			interpolation: {
				pattern: /((?:^|[^\\])(?:\\{2})*)%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\)/,
				lookbehind: true,
				inside: {
					expression: {
						pattern: /^(%\()[\s\S]+(?=\)$)/,
						lookbehind: true,
						inside: Prism$1.languages.wren
					},
					"interpolation-punctuation": {
						pattern: /^%\(|\)$/,
						alias: "punctuation"
					}
				}
			},
			string: /[\s\S]+/
		}
	};
}
xeora.displayName = "xeora";
xeora.aliases = ["xeoracube"];
function xeora(Prism$1) {
	Prism$1.register(markup);
	(function(Prism$2) {
		Prism$2.languages.xeora = Prism$2.languages.extend("markup", {
			constant: {
				pattern: /\$(?:DomainContents|PageRenderDuration)\$/,
				inside: { punctuation: { pattern: /\$/ } }
			},
			variable: {
				pattern: /\$@?(?:#+|[-+*~=^])?[\w.]+\$/,
				inside: {
					punctuation: { pattern: /[$.]/ },
					operator: { pattern: /#+|[-+*~=^@]/ }
				}
			},
			"function-inline": {
				pattern: /\$F:[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\$/,
				inside: {
					variable: {
						pattern: /(?:[,|])@?(?:#+|[-+*~=^])?[\w.]+/,
						inside: {
							punctuation: { pattern: /[,.|]/ },
							operator: { pattern: /#+|[-+*~=^@]/ }
						}
					},
					punctuation: { pattern: /\$\w:|[$:?.,|]/ }
				},
				alias: "function"
			},
			"function-block": {
				pattern: /\$XF:\{[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\}:XF\$/,
				inside: { punctuation: { pattern: /[$:{}?.,|]/ } },
				alias: "function"
			},
			"directive-inline": {
				pattern: /\$\w(?:#\d+\+?)?(?:\[[-\w.]+\])?:[-\/\w.]+\$/,
				inside: { punctuation: {
					pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
					inside: { tag: { pattern: /#\d/ } }
				} },
				alias: "function"
			},
			"directive-block-open": {
				pattern: /\$\w+:\{|\$\w(?:#\d+\+?)?(?:\[[-\w.]+\])?:[-\w.]+:\{(?:![A-Z]+)?/,
				inside: {
					punctuation: {
						pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
						inside: { tag: { pattern: /#\d/ } }
					},
					attribute: {
						pattern: /![A-Z]+$/,
						inside: { punctuation: { pattern: /!/ } },
						alias: "keyword"
					}
				},
				alias: "function"
			},
			"directive-block-separator": {
				pattern: /\}:[-\w.]+:\{/,
				inside: { punctuation: { pattern: /[:{}]/ } },
				alias: "function"
			},
			"directive-block-close": {
				pattern: /\}:[-\w.]+\$/,
				inside: { punctuation: { pattern: /[:{}$]/ } },
				alias: "function"
			}
		});
		Prism$2.languages.insertBefore("inside", "punctuation", { variable: Prism$2.languages.xeora["function-inline"].inside["variable"] }, Prism$2.languages.xeora["function-block"]);
		Prism$2.languages.xeoracube = Prism$2.languages.xeora;
	})(Prism$1);
}
xmlDoc.displayName = "xml-doc";
xmlDoc.aliases = [];
function xmlDoc(Prism$1) {
	Prism$1.register(markup);
	(function(Prism$2) {
		function insertDocComment(lang$1, docComment) {
			if (Prism$2.languages[lang$1]) Prism$2.languages.insertBefore(lang$1, "comment", { "doc-comment": docComment });
		}
		var tag = Prism$2.languages.markup.tag;
		var slashDocComment = {
			pattern: /\/\/\/.*/,
			greedy: true,
			alias: "comment",
			inside: { tag }
		};
		var tickDocComment = {
			pattern: /'''.*/,
			greedy: true,
			alias: "comment",
			inside: { tag }
		};
		insertDocComment("csharp", slashDocComment);
		insertDocComment("fsharp", slashDocComment);
		insertDocComment("vbnet", tickDocComment);
	})(Prism$1);
}
xojo.displayName = "xojo";
xojo.aliases = [];
function xojo(Prism$1) {
	Prism$1.languages.xojo = {
		comment: {
			pattern: /(?:'|\/\/|Rem\b).+/i,
			greedy: true
		},
		string: {
			pattern: /"(?:""|[^"])*"/,
			greedy: true
		},
		number: [/(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i, /&[bchou][a-z\d]+/i],
		directive: {
			pattern: /#(?:Else|ElseIf|Endif|If|Pragma)\b/i,
			alias: "property"
		},
		keyword: /\b(?:AddHandler|App|Array|As(?:signs)?|Auto|Boolean|Break|By(?:Ref|Val)|Byte|Call|Case|Catch|CFStringRef|CGFloat|Class|Color|Const|Continue|CString|Currency|CurrentMethodName|Declare|Delegate|Dim|Do(?:uble|wnTo)?|Each|Else(?:If)?|End|Enumeration|Event|Exception|Exit|Extends|False|Finally|For|Function|Get|GetTypeInfo|Global|GOTO|If|Implements|In|Inherits|Int(?:8|16|32|64|eger|erface)?|Lib|Loop|Me|Module|Next|Nil|Object|Optional|OSType|ParamArray|Private|Property|Protected|PString|Ptr|Raise(?:Event)?|ReDim|RemoveHandler|Return|Select(?:or)?|Self|Set|Shared|Short|Single|Soft|Static|Step|String|Sub|Super|Text|Then|To|True|Try|Ubound|UInt(?:8|16|32|64|eger)?|Until|Using|Var(?:iant)?|Wend|While|WindowPtr|WString)\b/i,
		operator: /<[=>]?|>=?|[+\-*\/\\^=]|\b(?:AddressOf|And|Ctype|IsA?|Mod|New|Not|Or|WeakAddressOf|Xor)\b/i,
		punctuation: /[.,;:()]/
	};
}
xquery.displayName = "xquery";
xquery.aliases = [];
function xquery(Prism$1) {
	Prism$1.register(markup);
	(function(Prism$2) {
		Prism$2.languages.xquery = Prism$2.languages.extend("markup", {
			"xquery-comment": {
				pattern: /\(:[\s\S]*?:\)/,
				greedy: true,
				alias: "comment"
			},
			string: {
				pattern: /(["'])(?:\1\1|(?!\1)[\s\S])*\1/,
				greedy: true
			},
			extension: {
				pattern: /\(#.+?#\)/,
				alias: "symbol"
			},
			variable: /\$[-\w:]+/,
			axis: {
				pattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,
				lookbehind: true,
				alias: "operator"
			},
			"keyword-operator": {
				pattern: /(^|[^:-])\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\b(?=$|[^:-])/,
				lookbehind: true,
				alias: "operator"
			},
			keyword: {
				pattern: /(^|[^:-])\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\b(?=$|[^:-])/,
				lookbehind: true
			},
			function: /[\w-]+(?::[\w-]+)*(?=\s*\()/,
			"xquery-element": {
				pattern: /(element\s+)[\w-]+(?::[\w-]+)*/,
				lookbehind: true,
				alias: "tag"
			},
			"xquery-attribute": {
				pattern: /(attribute\s+)[\w-]+(?::[\w-]+)*/,
				lookbehind: true,
				alias: "attr-name"
			},
			builtin: {
				pattern: /(^|[^:-])\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\b(?=$|[^:-])/,
				lookbehind: true
			},
			number: /\b\d+(?:\.\d+)?(?:E[+-]?\d+)?/,
			operator: [/[+*=?|@]|\.\.?|:=|!=|<[=<]?|>[=>]?/, {
				pattern: /(\s)-(?=\s)/,
				lookbehind: true
			}],
			punctuation: /[[\](){},;:/]/
		});
		Prism$2.languages.xquery.tag.pattern = /<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/;
		Prism$2.languages.xquery["tag"].inside["attr-value"].pattern = /=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+)/;
		Prism$2.languages.xquery["tag"].inside["attr-value"].inside["punctuation"] = /^="|"$/;
		Prism$2.languages.xquery["tag"].inside["attr-value"].inside["expression"] = {
			pattern: /\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}/,
			inside: Prism$2.languages.xquery,
			alias: "language-xquery"
		};
		var stringifyToken = function(token) {
			if (typeof token === "string") return token;
			if (typeof token.content === "string") return token.content;
			return token.content.map(stringifyToken).join("");
		};
		var walkTokens = function(tokens) {
			var openedTags = [];
			for (var i = 0; i < tokens.length; i++) {
				var token = tokens[i];
				var notTagNorBrace = false;
				if (typeof token !== "string") {
					if (token.type === "tag" && token.content[0] && token.content[0].type === "tag") if (token.content[0].content[0].content === "</") {
						if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) openedTags.pop();
					} else if (token.content[token.content.length - 1].content === "/>") {} else openedTags.push({
						tagName: stringifyToken(token.content[0].content[1]),
						openedBraces: 0
					});
					else if (openedTags.length > 0 && token.type === "punctuation" && token.content === "{" && (!tokens[i + 1] || tokens[i + 1].type !== "punctuation" || tokens[i + 1].content !== "{") && (!tokens[i - 1] || tokens[i - 1].type !== "plain-text" || tokens[i - 1].content !== "{")) openedTags[openedTags.length - 1].openedBraces++;
					else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === "punctuation" && token.content === "}") openedTags[openedTags.length - 1].openedBraces--;
					else if (token.type !== "comment") notTagNorBrace = true;
				}
				if (notTagNorBrace || typeof token === "string") {
					if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
						var plainText = stringifyToken(token);
						if (i < tokens.length - 1 && (typeof tokens[i + 1] === "string" || tokens[i + 1].type === "plain-text")) {
							plainText += stringifyToken(tokens[i + 1]);
							tokens.splice(i + 1, 1);
						}
						if (i > 0 && (typeof tokens[i - 1] === "string" || tokens[i - 1].type === "plain-text")) {
							plainText = stringifyToken(tokens[i - 1]) + plainText;
							tokens.splice(i - 1, 1);
							i--;
						}
						if (/^\s+$/.test(plainText)) tokens[i] = plainText;
						else tokens[i] = new Prism$2.Token("plain-text", plainText, null, plainText);
					}
				}
				if (token.content && typeof token.content !== "string") walkTokens(token.content);
			}
		};
		Prism$2.hooks.add("after-tokenize", function(env$1) {
			if (env$1.language !== "xquery") return;
			walkTokens(env$1.tokens);
		});
	})(Prism$1);
}
yang.displayName = "yang";
yang.aliases = [];
function yang(Prism$1) {
	Prism$1.languages.yang = {
		comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
		string: {
			pattern: /"(?:[^\\"]|\\.)*"|'[^']*'/,
			greedy: true
		},
		keyword: {
			pattern: /(^|[{};\r\n][ \t]*)[a-z_][\w.-]*/i,
			lookbehind: true
		},
		namespace: {
			pattern: /(\s)[a-z_][\w.-]*(?=:)/i,
			lookbehind: true
		},
		boolean: /\b(?:false|true)\b/,
		operator: /\+/,
		punctuation: /[{};:]/
	};
}
zig.displayName = "zig";
zig.aliases = [];
function zig(Prism$1) {
	(function(Prism$2) {
		function literal(str) {
			return function() {
				return str;
			};
		}
		var keyword = /\b(?:align|allowzero|and|anyframe|anytype|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|nosuspend|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\b/;
		var IDENTIFIER = "\\b(?!" + keyword.source + ")(?!\\d)\\w+\\b";
		var ALIGN = /align\s*\((?:[^()]|\([^()]*\))*\)/.source;
		var PREFIX_TYPE_OP = /(?:\?|\bpromise->|(?:\[[^[\]]*\]|\*(?!\*)|\*\*)(?:\s*<ALIGN>|\s*const\b|\s*volatile\b|\s*allowzero\b)*)/.source.replace(/<ALIGN>/g, literal(ALIGN));
		var SUFFIX_EXPR = /(?:\bpromise\b|(?:\berror\.)?<ID>(?:\.<ID>)*(?!\s+<ID>))/.source.replace(/<ID>/g, literal(IDENTIFIER));
		var TYPE = "(?!\\s)(?:!?\\s*(?:" + PREFIX_TYPE_OP + "\\s*)*" + SUFFIX_EXPR + ")+";
		Prism$2.languages.zig = {
			comment: [{
				pattern: /\/\/[/!].*/,
				alias: "doc-comment"
			}, /\/{2}.*/],
			string: [{
				pattern: /(^|[^\\@])c?"(?:[^"\\\r\n]|\\.)*"/,
				lookbehind: true,
				greedy: true
			}, {
				pattern: /([\r\n])([ \t]+c?\\{2}).*(?:(?:\r\n?|\n)\2.*)*/,
				lookbehind: true,
				greedy: true
			}],
			char: {
				pattern: /(^|[^\\])'(?:[^'\\\r\n]|[\uD800-\uDFFF]{2}|\\(?:.|x[a-fA-F\d]{2}|u\{[a-fA-F\d]{1,6}\}))'/,
				lookbehind: true,
				greedy: true
			},
			builtin: /\B@(?!\d)\w+(?=\s*\()/,
			label: {
				pattern: /(\b(?:break|continue)\s*:\s*)\w+\b|\b(?!\d)\w+\b(?=\s*:\s*(?:\{|while\b))/,
				lookbehind: true
			},
			"class-name": [
				/\b(?!\d)\w+(?=\s*=\s*(?:(?:extern|packed)\s+)?(?:enum|struct|union)\s*[({])/,
				{
					pattern: RegExp(/(:\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?[=;,)])|<TYPE>(?=\s*(?:<ALIGN>\s*)?\{)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),
					lookbehind: true,
					inside: null
				},
				{
					pattern: RegExp(/(\)\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?;)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),
					lookbehind: true,
					inside: null
				}
			],
			"builtin-type": {
				pattern: /\b(?:anyerror|bool|c_u?(?:int|long|longlong|short)|c_longdouble|c_void|comptime_(?:float|int)|f(?:16|32|64|128)|[iu](?:8|16|32|64|128|size)|noreturn|type|void)\b/,
				alias: "keyword"
			},
			keyword,
			function: /\b(?!\d)\w+(?=\s*\()/,
			number: /\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\d]+(?:\.[a-fA-F\d]*)?(?:[pP][+-]?[a-fA-F\d]+)?|\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)\b/,
			boolean: /\b(?:false|true)\b/,
			operator: /\.[*?]|\.{2,3}|[-=]>|\*\*|\+\+|\|\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,
			punctuation: /[.:,;(){}[\]]/
		};
		Prism$2.languages.zig["class-name"].forEach(function(obj) {
			if (obj.inside === null) obj.inside = Prism$2.languages.zig;
		});
	})(Prism$1);
}
refractor.register(markup);
refractor.register(css);
refractor.register(clike);
refractor.register(regex$1);
refractor.register(javascript);
refractor.register(abap);
refractor.register(abnf);
refractor.register(actionscript);
refractor.register(ada);
refractor.register(agda);
refractor.register(al);
refractor.register(antlr4);
refractor.register(apacheconf);
refractor.register(sql);
refractor.register(apex);
refractor.register(apl);
refractor.register(applescript);
refractor.register(aql);
refractor.register(c$1);
refractor.register(cpp);
refractor.register(arduino);
refractor.register(arff);
refractor.register(armasm);
refractor.register(bash);
refractor.register(yaml);
refractor.register(markdown);
refractor.register(arturo);
refractor.register(asciidoc);
refractor.register(csharp);
refractor.register(aspnet);
refractor.register(asm6502);
refractor.register(asmatmel);
refractor.register(autohotkey);
refractor.register(autoit);
refractor.register(avisynth);
refractor.register(avroIdl);
refractor.register(awk);
refractor.register(basic);
refractor.register(batch);
refractor.register(bbcode);
refractor.register(bbj);
refractor.register(bicep);
refractor.register(birb);
refractor.register(bison);
refractor.register(bnf);
refractor.register(bqn);
refractor.register(brainfuck);
refractor.register(brightscript);
refractor.register(bro);
refractor.register(bsl);
refractor.register(cfscript);
refractor.register(chaiscript);
refractor.register(cil);
refractor.register(cilkc);
refractor.register(cilkcpp);
refractor.register(clojure);
refractor.register(cmake);
refractor.register(cobol);
refractor.register(coffeescript);
refractor.register(concurnas);
refractor.register(csp);
refractor.register(cooklang);
refractor.register(coq);
refractor.register(ruby);
refractor.register(crystal);
refractor.register(cssExtras);
refractor.register(csv);
refractor.register(cue);
refractor.register(cypher);
refractor.register(d);
refractor.register(dart);
refractor.register(dataweave);
refractor.register(dax);
refractor.register(dhall);
refractor.register(diff);
refractor.register(markupTemplating);
refractor.register(django);
refractor.register(dnsZoneFile);
refractor.register(docker);
refractor.register(dot);
refractor.register(ebnf);
refractor.register(editorconfig);
refractor.register(eiffel);
refractor.register(ejs);
refractor.register(elixir);
refractor.register(elm);
refractor.register(lua);
refractor.register(etlua);
refractor.register(erb);
refractor.register(erlang);
refractor.register(excelFormula);
refractor.register(fsharp);
refractor.register(factor);
refractor.register($false);
refractor.register(firestoreSecurityRules);
refractor.register(flow$2);
refractor.register(fortran);
refractor.register(ftl);
refractor.register(gml);
refractor.register(gap);
refractor.register(gcode);
refractor.register(gdscript);
refractor.register(gedcom);
refractor.register(gettext);
refractor.register(gherkin);
refractor.register(git);
refractor.register(glsl);
refractor.register(gn);
refractor.register(linkerScript);
refractor.register(go);
refractor.register(goModule);
refractor.register(gradle);
refractor.register(graphql);
refractor.register(groovy);
refractor.register(less);
refractor.register(scss);
refractor.register(textile);
refractor.register(haml);
refractor.register(handlebars);
refractor.register(haskell);
refractor.register(haxe);
refractor.register(hcl);
refractor.register(hlsl);
refractor.register(hoon);
refractor.register(hpkp);
refractor.register(hsts);
refractor.register(json);
refractor.register(uri);
refractor.register(http);
refractor.register(ichigojam);
refractor.register(icon);
refractor.register(icuMessageFormat);
refractor.register(idris);
refractor.register(ignore$1);
refractor.register(inform7);
refractor.register(ini);
refractor.register(io);
refractor.register(j);
refractor.register(java);
refractor.register(php);
refractor.register(javadoclike);
refractor.register(scala);
refractor.register(javadoc);
refractor.register(javastacktrace);
refractor.register(jexl);
refractor.register(jolie);
refractor.register(jq);
refractor.register(jsTemplates);
refractor.register(typescript);
refractor.register(jsdoc);
refractor.register(n4js);
refractor.register(jsExtras);
refractor.register(json5);
refractor.register(jsonp);
refractor.register(jsstacktrace);
refractor.register(julia);
refractor.register(keepalived);
refractor.register(keyman);
refractor.register(kotlin);
refractor.register(kumir);
refractor.register(kusto);
refractor.register(latex);
refractor.register(latte);
refractor.register(scheme);
refractor.register(lilypond);
refractor.register(liquid);
refractor.register(lisp);
refractor.register(livescript);
refractor.register(llvm);
refractor.register(log);
refractor.register(lolcode);
refractor.register(magma);
refractor.register(makefile);
refractor.register(mata);
refractor.register(matlab);
refractor.register(maxscript);
refractor.register(mel);
refractor.register(mermaid);
refractor.register(metafont);
refractor.register(mizar);
refractor.register(mongodb);
refractor.register(monkey);
refractor.register(moonscript);
refractor.register(n1ql);
refractor.register(nand2tetrisHdl);
refractor.register(naniscript);
refractor.register(nasm);
refractor.register(neon);
refractor.register(nevod);
refractor.register(nginx);
refractor.register(nim);
refractor.register(nix);
refractor.register(nsis);
refractor.register(objectivec);
refractor.register(ocaml);
refractor.register(odin);
refractor.register(opencl);
refractor.register(openqasm);
refractor.register(oz);
refractor.register(parigp);
refractor.register(parser);
refractor.register(pascal);
refractor.register(pascaligo);
refractor.register(psl);
refractor.register(pcaxis);
refractor.register(peoplecode);
refractor.register(perl);
refractor.register(phpdoc);
refractor.register(phpExtras);
refractor.register(plantUml);
refractor.register(plsql);
refractor.register(powerquery);
refractor.register(powershell);
refractor.register(processing);
refractor.register(prolog);
refractor.register(promql);
refractor.register(properties);
refractor.register(protobuf);
refractor.register(stylus);
refractor.register(twig);
refractor.register(pug);
refractor.register(puppet);
refractor.register(pure);
refractor.register(purebasic);
refractor.register(purescript);
refractor.register(python);
refractor.register(qsharp);
refractor.register(q);
refractor.register(qml);
refractor.register(qore);
refractor.register(r);
refractor.register(racket);
refractor.register(cshtml);
refractor.register(jsx$1);
refractor.register(tsx);
refractor.register(reason);
refractor.register(rego);
refractor.register(renpy);
refractor.register(rescript);
refractor.register(rest);
refractor.register(rip);
refractor.register(roboconf);
refractor.register(robotframework);
refractor.register(rust);
refractor.register(sas);
refractor.register(sass);
refractor.register(shellSession);
refractor.register(smali);
refractor.register(smalltalk);
refractor.register(smarty);
refractor.register(sml);
refractor.register(solidity);
refractor.register(solutionFile);
refractor.register(soy);
refractor.register(turtle);
refractor.register(sparql);
refractor.register(splunkSpl);
refractor.register(sqf);
refractor.register(squirrel);
refractor.register(stan);
refractor.register(stata);
refractor.register(iecst);
refractor.register(supercollider);
refractor.register(swift);
refractor.register(systemd);
refractor.register(t4Templating);
refractor.register(t4Cs);
refractor.register(vbnet);
refractor.register(t4Vb);
refractor.register(tap);
refractor.register(tcl);
refractor.register(tt2);
refractor.register(toml);
refractor.register(tremor);
refractor.register(typoscript);
refractor.register(unrealscript);
refractor.register(uorazor);
refractor.register(v);
refractor.register(vala);
refractor.register(velocity);
refractor.register(verilog);
refractor.register(vhdl);
refractor.register(vim);
refractor.register(visualBasic);
refractor.register(warpscript);
refractor.register(wasm);
refractor.register(webIdl);
refractor.register(wgsl);
refractor.register(wiki);
refractor.register(wolfram);
refractor.register(wren);
refractor.register(xeora);
refractor.register(xmlDoc);
refractor.register(xojo);
refractor.register(xquery);
refractor.register(yang);
refractor.register(zig);
var import_parse_numeric_range = __toESM(require_parse_numeric_range());
function a() {
	a = function(e$1, r$2) {
		return new t(e$1, void 0, r$2);
	};
	var e = RegExp.prototype, r$1 = new WeakMap();
	function t(e$1, n$2, i) {
		var o = new RegExp(e$1, n$2);
		return r$1.set(o, i || r$1.get(e$1)), l(o, t.prototype);
	}
	function n$1(e$1, t$1) {
		var n$2 = r$1.get(t$1);
		return Object.keys(n$2).reduce(function(r$2, t$2) {
			var i = n$2[t$2];
			if ("number" == typeof i) r$2[t$2] = e$1[i];
			else {
				for (var o = 0; void 0 === e$1[i[o]] && o + 1 < i.length;) o++;
				r$2[t$2] = e$1[i[o]];
			}
			return r$2;
		}, Object.create(null));
	}
	return function(e$1, r$2) {
		if ("function" != typeof r$2 && null !== r$2) throw new TypeError("Super expression must either be null or a function");
		e$1.prototype = Object.create(r$2 && r$2.prototype, { constructor: {
			value: e$1,
			writable: !0,
			configurable: !0
		} }), Object.defineProperty(e$1, "prototype", { writable: !1 }), r$2 && l(e$1, r$2);
	}(t, RegExp), t.prototype.exec = function(r$2) {
		var t$1 = e.exec.call(this, r$2);
		if (t$1) {
			t$1.groups = n$1(t$1, this);
			var i = t$1.indices;
			i && (i.groups = n$1(i, this));
		}
		return t$1;
	}, t.prototype[Symbol.replace] = function(t$1, i) {
		if ("string" == typeof i) {
			var o = r$1.get(this);
			return e[Symbol.replace].call(this, t$1, i.replace(/\$<([^>]+)>/g, function(e$1, r$2) {
				var t$2 = o[r$2];
				return "$" + (Array.isArray(t$2) ? t$2.join("$") : t$2);
			}));
		}
		if ("function" == typeof i) {
			var a$1 = this;
			return e[Symbol.replace].call(this, t$1, function() {
				var e$1 = arguments;
				return "object" != typeof e$1[e$1.length - 1] && (e$1 = [].slice.call(e$1)).push(n$1(e$1, a$1)), i.apply(this, e$1);
			});
		}
		return e[Symbol.replace].call(this, t$1, i);
	}, a.apply(this, arguments);
}
function l(e, r$1) {
	return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e$1, r$2) {
		return e$1.__proto__ = r$2, e$1;
	}, l(e, r$1);
}
function s$1(e, r$1) {
	(null == r$1 || r$1 > e.length) && (r$1 = e.length);
	for (var t = 0, n$1 = new Array(r$1); t < r$1; t++) n$1[t] = e[t];
	return n$1;
}
function u(e, r$1) {
	var t = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
	if (t) return (t = t.call(e)).next.bind(t);
	if (Array.isArray(e) || (t = function(e$1, r$2) {
		if (e$1) {
			if ("string" == typeof e$1) return s$1(e$1, r$2);
			var t$1 = Object.prototype.toString.call(e$1).slice(8, -1);
			return "Object" === t$1 && e$1.constructor && (t$1 = e$1.constructor.name), "Map" === t$1 || "Set" === t$1 ? Array.from(e$1) : "Arguments" === t$1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t$1) ? s$1(e$1, r$2) : void 0;
		}
	}(e)) || r$1 && e && "number" == typeof e.length) {
		t && (e = t);
		var n$1 = 0;
		return function() {
			return n$1 >= e.length ? { done: !0 } : {
				done: !1,
				value: e[n$1++]
			};
		};
	}
	throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var c = function(i) {
	return function(o) {
		return void 0 === o && (o = {}), function(e, r$1) {
			if (r$1 && !e.registered(r$1)) throw new Error("The default language \"" + r$1 + "\" is not registered with refractor.");
		}(i, o.defaultLanguage), function(r$1) {
			visit(r$1, "element", l$1);
		};
		function l$1(e, l$2, s$2) {
			var c$2, p$1;
			if (s$2 && "pre" === s$2.tagName && "code" === e.tagName) {
				var f$1 = (null == e || null == (c$2 = e.data) ? void 0 : c$2.meta) || (null == e || null == (p$1 = e.properties) ? void 0 : p$1.metastring) || "";
				e.properties.className ? "boolean" == typeof e.properties.className ? e.properties.className = [] : Array.isArray(e.properties.className) || (e.properties.className = [e.properties.className]) : e.properties.className = [];
				var m, h$2, d$1 = function(e$1) {
					for (var r$1, t = u(e$1.properties.className); !(r$1 = t()).done;) {
						var n$1 = r$1.value;
						if ("language-" === n$1.slice(0, 9)) return n$1.slice(9).toLowerCase();
					}
					return null;
				}(e);
				if (!d$1 && o.defaultLanguage && e.properties.className.push("language-" + (d$1 = o.defaultLanguage)), e.properties.className.push("code-highlight"), d$1) try {
					var g, v$1;
					v$1 = null != (g = d$1) && g.includes("diff-") ? d$1.split("-")[1] : d$1, m = i.highlight(toString(e), v$1), s$2.properties.className = (s$2.properties.className || []).concat("language-" + v$1);
				} catch (r$1) {
					if (!o.ignoreMissing || !/Unknown language/.test(r$1.message)) throw r$1;
					m = e;
				}
				else m = e;
				m.children = (h$2 = 1, function e$1(r$1) {
					return r$1.reduce(function(r$2, t) {
						if ("text" === t.type) {
							var n$1 = t.value, i$1 = (n$1.match(/\n/g) || "").length;
							if (0 === i$1) t.position = {
								start: {
									line: h$2,
									column: 1
								},
								end: {
									line: h$2,
									column: 1
								}
							}, r$2.push(t);
							else for (var o$1, a$1 = n$1.split("\n"), l$3 = u(a$1.entries()); !(o$1 = l$3()).done;) {
								var s$3 = o$1.value, c$3 = s$3[0], p$2 = s$3[1];
								r$2.push({
									type: "text",
									value: c$3 === a$1.length - 1 ? p$2 : p$2 + "\n",
									position: {
										start: {
											line: h$2 + c$3,
											column: 1
										},
										end: {
											line: h$2 + c$3,
											column: 1
										}
									}
								});
							}
							return h$2 += i$1, r$2;
						}
						if (Object.prototype.hasOwnProperty.call(t, "children")) {
							var f$2 = h$2;
							return t.children = e$1(t.children), r$2.push(t), t.position = {
								start: {
									line: f$2,
									column: 1
								},
								end: {
									line: h$2,
									column: 1
								}
							}, r$2;
						}
						return r$2.push(t), r$2;
					}, []);
				})(m.children), m.position = m.children.length > 0 ? {
					start: {
						line: m.children[0].position.start.line,
						column: 0
					},
					end: {
						line: m.children[m.children.length - 1].position.end.line,
						column: 0
					}
				} : {
					start: {
						line: 0,
						column: 0
					},
					end: {
						line: 0,
						column: 0
					}
				};
				for (var y, b = function(e$1) {
					var r$1 = /{([\d,-]+)}/, t = e$1.split(",").map(function(e$2) {
						return e$2.trim();
					}).join();
					if (r$1.test(t)) {
						var i$1 = r$1.exec(t)[1], o$1 = (0, import_parse_numeric_range.default)(i$1);
						return function(e$2) {
							return o$1.includes(e$2 + 1);
						};
					}
					return function() {
						return !1;
					};
				}(f$1), w = function(e$1) {
					var r$1 = a(/showLineNumbers=(\d+)/i, { lines: 1 });
					if (r$1.test(e$1)) {
						var t = r$1.exec(e$1);
						return Number(t.groups.lines);
					}
					return 1;
				}(f$1), N = function(e$1) {
					for (var r$1 = new Array(e$1), t = 0; t < e$1; t++) r$1[t] = {
						type: "element",
						tagName: "span",
						properties: { className: [] },
						children: []
					};
					return r$1;
				}(m.position.end.line), j$1 = [
					"showlinenumbers=false",
					"showlinenumbers=\"false\"",
					"showlinenumbers={false}"
				], x = function() {
					var e$1, n$1, i$1 = y.value, a$1 = i$1[0], l$3 = i$1[1];
					l$3.properties.className = ["code-line"];
					var s$3 = filter(m, function(e$2) {
						return e$2.position.start.line <= a$1 + 1 && e$2.position.end.line >= a$1 + 1;
					});
					l$3.children = s$3.children, !f$1.toLowerCase().includes("showLineNumbers".toLowerCase()) && !o.showLineNumbers || j$1.some(function(e$2) {
						return f$1.toLowerCase().includes(e$2);
					}) || (l$3.properties.line = [(a$1 + w).toString()], l$3.properties.className.push("line-number")), b(a$1) && l$3.properties.className.push("highlight-line"), ("diff" === d$1 || null != (e$1 = d$1) && e$1.includes("diff-")) && "-" === toString(l$3).substring(0, 1) ? l$3.properties.className.push("deleted") : ("diff" === d$1 || null != (n$1 = d$1) && n$1.includes("diff-")) && "+" === toString(l$3).substring(0, 1) && l$3.properties.className.push("inserted");
				}, O = u(N.entries()); !(y = O()).done;) x();
				N.length > 0 && "" === toString(N[N.length - 1]).trim() && N.pop(), e.children = N;
			}
		}
	};
}, p = c(refractor), f = c(refractor);
var Schema = class {
	constructor(property, normal, space$1) {
		this.normal = normal;
		this.property = property;
		if (space$1) this.space = space$1;
	}
};
Schema.prototype.normal = {};
Schema.prototype.property = {};
Schema.prototype.space = void 0;
function merge(definitions, space$1) {
	const property = {};
	const normal = {};
	for (const definition$2 of definitions) {
		Object.assign(property, definition$2.property);
		Object.assign(normal, definition$2.normal);
	}
	return new Schema(property, normal, space$1);
}
function normalize(value) {
	return value.toLowerCase();
}
var Info = class {
	constructor(property, attribute$1) {
		this.attribute = attribute$1;
		this.property = property;
	}
};
Info.prototype.attribute = "";
Info.prototype.booleanish = false;
Info.prototype.boolean = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.commaSeparated = false;
Info.prototype.defined = false;
Info.prototype.mustUseProperty = false;
Info.prototype.number = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.property = "";
Info.prototype.spaceSeparated = false;
Info.prototype.space = void 0;
var types_exports = {};
__export(types_exports, {
	boolean: () => boolean,
	booleanish: () => booleanish,
	commaOrSpaceSeparated: () => commaOrSpaceSeparated,
	commaSeparated: () => commaSeparated,
	number: () => number,
	overloadedBoolean: () => overloadedBoolean,
	spaceSeparated: () => spaceSeparated
});
let powers = 0;
const boolean = increment();
const booleanish = increment();
const overloadedBoolean = increment();
const number = increment();
const spaceSeparated = increment();
const commaSeparated = increment();
const commaOrSpaceSeparated = increment();
function increment() {
	return 2 ** ++powers;
}
const checks = Object.keys(types_exports);
var DefinedInfo = class extends Info {
	constructor(property, attribute$1, mask, space$1) {
		let index$1 = -1;
		super(property, attribute$1);
		mark(this, "space", space$1);
		if (typeof mask === "number") while (++index$1 < checks.length) {
			const check = checks[index$1];
			mark(this, checks[index$1], (mask & types_exports[check]) === types_exports[check]);
		}
	}
};
DefinedInfo.prototype.defined = true;
function mark(values, key, value) {
	if (value) values[key] = value;
}
function create$1(definition$2) {
	const properties$1 = {};
	const normals = {};
	for (const [property, value] of Object.entries(definition$2.properties)) {
		const info = new DefinedInfo(property, definition$2.transform(definition$2.attributes || {}, property), value, definition$2.space);
		if (definition$2.mustUseProperty && definition$2.mustUseProperty.includes(property)) info.mustUseProperty = true;
		properties$1[property] = info;
		normals[normalize(property)] = property;
		normals[normalize(info.attribute)] = property;
	}
	return new Schema(properties$1, normals, definition$2.space);
}
const aria = create$1({
	properties: {
		ariaActiveDescendant: null,
		ariaAtomic: booleanish,
		ariaAutoComplete: null,
		ariaBusy: booleanish,
		ariaChecked: booleanish,
		ariaColCount: number,
		ariaColIndex: number,
		ariaColSpan: number,
		ariaControls: spaceSeparated,
		ariaCurrent: null,
		ariaDescribedBy: spaceSeparated,
		ariaDetails: null,
		ariaDisabled: booleanish,
		ariaDropEffect: spaceSeparated,
		ariaErrorMessage: null,
		ariaExpanded: booleanish,
		ariaFlowTo: spaceSeparated,
		ariaGrabbed: booleanish,
		ariaHasPopup: null,
		ariaHidden: booleanish,
		ariaInvalid: null,
		ariaKeyShortcuts: null,
		ariaLabel: null,
		ariaLabelledBy: spaceSeparated,
		ariaLevel: number,
		ariaLive: null,
		ariaModal: booleanish,
		ariaMultiLine: booleanish,
		ariaMultiSelectable: booleanish,
		ariaOrientation: null,
		ariaOwns: spaceSeparated,
		ariaPlaceholder: null,
		ariaPosInSet: number,
		ariaPressed: booleanish,
		ariaReadOnly: booleanish,
		ariaRelevant: null,
		ariaRequired: booleanish,
		ariaRoleDescription: spaceSeparated,
		ariaRowCount: number,
		ariaRowIndex: number,
		ariaRowSpan: number,
		ariaSelected: booleanish,
		ariaSetSize: number,
		ariaSort: null,
		ariaValueMax: number,
		ariaValueMin: number,
		ariaValueNow: number,
		ariaValueText: null,
		role: null
	},
	transform(_$1, property) {
		return property === "role" ? property : "aria-" + property.slice(4).toLowerCase();
	}
});
function caseSensitiveTransform(attributes$1, attribute$1) {
	return attribute$1 in attributes$1 ? attributes$1[attribute$1] : attribute$1;
}
function caseInsensitiveTransform(attributes$1, property) {
	return caseSensitiveTransform(attributes$1, property.toLowerCase());
}
const html$4 = create$1({
	attributes: {
		acceptcharset: "accept-charset",
		classname: "class",
		htmlfor: "for",
		httpequiv: "http-equiv"
	},
	mustUseProperty: [
		"checked",
		"multiple",
		"muted",
		"selected"
	],
	properties: {
		abbr: null,
		accept: commaSeparated,
		acceptCharset: spaceSeparated,
		accessKey: spaceSeparated,
		action: null,
		allow: null,
		allowFullScreen: boolean,
		allowPaymentRequest: boolean,
		allowUserMedia: boolean,
		alt: null,
		as: null,
		async: boolean,
		autoCapitalize: null,
		autoComplete: spaceSeparated,
		autoFocus: boolean,
		autoPlay: boolean,
		blocking: spaceSeparated,
		capture: null,
		charSet: null,
		checked: boolean,
		cite: null,
		className: spaceSeparated,
		cols: number,
		colSpan: null,
		content: null,
		contentEditable: booleanish,
		controls: boolean,
		controlsList: spaceSeparated,
		coords: number | commaSeparated,
		crossOrigin: null,
		data: null,
		dateTime: null,
		decoding: null,
		default: boolean,
		defer: boolean,
		dir: null,
		dirName: null,
		disabled: boolean,
		download: overloadedBoolean,
		draggable: booleanish,
		encType: null,
		enterKeyHint: null,
		fetchPriority: null,
		form: null,
		formAction: null,
		formEncType: null,
		formMethod: null,
		formNoValidate: boolean,
		formTarget: null,
		headers: spaceSeparated,
		height: number,
		hidden: overloadedBoolean,
		high: number,
		href: null,
		hrefLang: null,
		htmlFor: spaceSeparated,
		httpEquiv: spaceSeparated,
		id: null,
		imageSizes: null,
		imageSrcSet: null,
		inert: boolean,
		inputMode: null,
		integrity: null,
		is: null,
		isMap: boolean,
		itemId: null,
		itemProp: spaceSeparated,
		itemRef: spaceSeparated,
		itemScope: boolean,
		itemType: spaceSeparated,
		kind: null,
		label: null,
		lang: null,
		language: null,
		list: null,
		loading: null,
		loop: boolean,
		low: number,
		manifest: null,
		max: null,
		maxLength: number,
		media: null,
		method: null,
		min: null,
		minLength: number,
		multiple: boolean,
		muted: boolean,
		name: null,
		nonce: null,
		noModule: boolean,
		noValidate: boolean,
		onAbort: null,
		onAfterPrint: null,
		onAuxClick: null,
		onBeforeMatch: null,
		onBeforePrint: null,
		onBeforeToggle: null,
		onBeforeUnload: null,
		onBlur: null,
		onCancel: null,
		onCanPlay: null,
		onCanPlayThrough: null,
		onChange: null,
		onClick: null,
		onClose: null,
		onContextLost: null,
		onContextMenu: null,
		onContextRestored: null,
		onCopy: null,
		onCueChange: null,
		onCut: null,
		onDblClick: null,
		onDrag: null,
		onDragEnd: null,
		onDragEnter: null,
		onDragExit: null,
		onDragLeave: null,
		onDragOver: null,
		onDragStart: null,
		onDrop: null,
		onDurationChange: null,
		onEmptied: null,
		onEnded: null,
		onError: null,
		onFocus: null,
		onFormData: null,
		onHashChange: null,
		onInput: null,
		onInvalid: null,
		onKeyDown: null,
		onKeyPress: null,
		onKeyUp: null,
		onLanguageChange: null,
		onLoad: null,
		onLoadedData: null,
		onLoadedMetadata: null,
		onLoadEnd: null,
		onLoadStart: null,
		onMessage: null,
		onMessageError: null,
		onMouseDown: null,
		onMouseEnter: null,
		onMouseLeave: null,
		onMouseMove: null,
		onMouseOut: null,
		onMouseOver: null,
		onMouseUp: null,
		onOffline: null,
		onOnline: null,
		onPageHide: null,
		onPageShow: null,
		onPaste: null,
		onPause: null,
		onPlay: null,
		onPlaying: null,
		onPopState: null,
		onProgress: null,
		onRateChange: null,
		onRejectionHandled: null,
		onReset: null,
		onResize: null,
		onScroll: null,
		onScrollEnd: null,
		onSecurityPolicyViolation: null,
		onSeeked: null,
		onSeeking: null,
		onSelect: null,
		onSlotChange: null,
		onStalled: null,
		onStorage: null,
		onSubmit: null,
		onSuspend: null,
		onTimeUpdate: null,
		onToggle: null,
		onUnhandledRejection: null,
		onUnload: null,
		onVolumeChange: null,
		onWaiting: null,
		onWheel: null,
		open: boolean,
		optimum: number,
		pattern: null,
		ping: spaceSeparated,
		placeholder: null,
		playsInline: boolean,
		popover: null,
		popoverTarget: null,
		popoverTargetAction: null,
		poster: null,
		preload: null,
		readOnly: boolean,
		referrerPolicy: null,
		rel: spaceSeparated,
		required: boolean,
		reversed: boolean,
		rows: number,
		rowSpan: number,
		sandbox: spaceSeparated,
		scope: null,
		scoped: boolean,
		seamless: boolean,
		selected: boolean,
		shadowRootClonable: boolean,
		shadowRootDelegatesFocus: boolean,
		shadowRootMode: null,
		shape: null,
		size: number,
		sizes: null,
		slot: null,
		span: number,
		spellCheck: booleanish,
		src: null,
		srcDoc: null,
		srcLang: null,
		srcSet: null,
		start: number,
		step: null,
		style: null,
		tabIndex: number,
		target: null,
		title: null,
		translate: null,
		type: null,
		typeMustMatch: boolean,
		useMap: null,
		value: booleanish,
		width: number,
		wrap: null,
		writingSuggestions: null,
		align: null,
		aLink: null,
		archive: spaceSeparated,
		axis: null,
		background: null,
		bgColor: null,
		border: number,
		borderColor: null,
		bottomMargin: number,
		cellPadding: null,
		cellSpacing: null,
		char: null,
		charOff: null,
		classId: null,
		clear: null,
		code: null,
		codeBase: null,
		codeType: null,
		color: null,
		compact: boolean,
		declare: boolean,
		event: null,
		face: null,
		frame: null,
		frameBorder: null,
		hSpace: number,
		leftMargin: number,
		link: null,
		longDesc: null,
		lowSrc: null,
		marginHeight: number,
		marginWidth: number,
		noResize: boolean,
		noHref: boolean,
		noShade: boolean,
		noWrap: boolean,
		object: null,
		profile: null,
		prompt: null,
		rev: null,
		rightMargin: number,
		rules: null,
		scheme: null,
		scrolling: booleanish,
		standby: null,
		summary: null,
		text: null,
		topMargin: number,
		valueType: null,
		version: null,
		vAlign: null,
		vLink: null,
		vSpace: number,
		allowTransparency: null,
		autoCorrect: null,
		autoSave: null,
		disablePictureInPicture: boolean,
		disableRemotePlayback: boolean,
		prefix: null,
		property: null,
		results: number,
		security: null,
		unselectable: null
	},
	space: "html",
	transform: caseInsensitiveTransform
});
const svg$2 = create$1({
	attributes: {
		accentHeight: "accent-height",
		alignmentBaseline: "alignment-baseline",
		arabicForm: "arabic-form",
		baselineShift: "baseline-shift",
		capHeight: "cap-height",
		className: "class",
		clipPath: "clip-path",
		clipRule: "clip-rule",
		colorInterpolation: "color-interpolation",
		colorInterpolationFilters: "color-interpolation-filters",
		colorProfile: "color-profile",
		colorRendering: "color-rendering",
		crossOrigin: "crossorigin",
		dataType: "datatype",
		dominantBaseline: "dominant-baseline",
		enableBackground: "enable-background",
		fillOpacity: "fill-opacity",
		fillRule: "fill-rule",
		floodColor: "flood-color",
		floodOpacity: "flood-opacity",
		fontFamily: "font-family",
		fontSize: "font-size",
		fontSizeAdjust: "font-size-adjust",
		fontStretch: "font-stretch",
		fontStyle: "font-style",
		fontVariant: "font-variant",
		fontWeight: "font-weight",
		glyphName: "glyph-name",
		glyphOrientationHorizontal: "glyph-orientation-horizontal",
		glyphOrientationVertical: "glyph-orientation-vertical",
		hrefLang: "hreflang",
		horizAdvX: "horiz-adv-x",
		horizOriginX: "horiz-origin-x",
		horizOriginY: "horiz-origin-y",
		imageRendering: "image-rendering",
		letterSpacing: "letter-spacing",
		lightingColor: "lighting-color",
		markerEnd: "marker-end",
		markerMid: "marker-mid",
		markerStart: "marker-start",
		navDown: "nav-down",
		navDownLeft: "nav-down-left",
		navDownRight: "nav-down-right",
		navLeft: "nav-left",
		navNext: "nav-next",
		navPrev: "nav-prev",
		navRight: "nav-right",
		navUp: "nav-up",
		navUpLeft: "nav-up-left",
		navUpRight: "nav-up-right",
		onAbort: "onabort",
		onActivate: "onactivate",
		onAfterPrint: "onafterprint",
		onBeforePrint: "onbeforeprint",
		onBegin: "onbegin",
		onCancel: "oncancel",
		onCanPlay: "oncanplay",
		onCanPlayThrough: "oncanplaythrough",
		onChange: "onchange",
		onClick: "onclick",
		onClose: "onclose",
		onCopy: "oncopy",
		onCueChange: "oncuechange",
		onCut: "oncut",
		onDblClick: "ondblclick",
		onDrag: "ondrag",
		onDragEnd: "ondragend",
		onDragEnter: "ondragenter",
		onDragExit: "ondragexit",
		onDragLeave: "ondragleave",
		onDragOver: "ondragover",
		onDragStart: "ondragstart",
		onDrop: "ondrop",
		onDurationChange: "ondurationchange",
		onEmptied: "onemptied",
		onEnd: "onend",
		onEnded: "onended",
		onError: "onerror",
		onFocus: "onfocus",
		onFocusIn: "onfocusin",
		onFocusOut: "onfocusout",
		onHashChange: "onhashchange",
		onInput: "oninput",
		onInvalid: "oninvalid",
		onKeyDown: "onkeydown",
		onKeyPress: "onkeypress",
		onKeyUp: "onkeyup",
		onLoad: "onload",
		onLoadedData: "onloadeddata",
		onLoadedMetadata: "onloadedmetadata",
		onLoadStart: "onloadstart",
		onMessage: "onmessage",
		onMouseDown: "onmousedown",
		onMouseEnter: "onmouseenter",
		onMouseLeave: "onmouseleave",
		onMouseMove: "onmousemove",
		onMouseOut: "onmouseout",
		onMouseOver: "onmouseover",
		onMouseUp: "onmouseup",
		onMouseWheel: "onmousewheel",
		onOffline: "onoffline",
		onOnline: "ononline",
		onPageHide: "onpagehide",
		onPageShow: "onpageshow",
		onPaste: "onpaste",
		onPause: "onpause",
		onPlay: "onplay",
		onPlaying: "onplaying",
		onPopState: "onpopstate",
		onProgress: "onprogress",
		onRateChange: "onratechange",
		onRepeat: "onrepeat",
		onReset: "onreset",
		onResize: "onresize",
		onScroll: "onscroll",
		onSeeked: "onseeked",
		onSeeking: "onseeking",
		onSelect: "onselect",
		onShow: "onshow",
		onStalled: "onstalled",
		onStorage: "onstorage",
		onSubmit: "onsubmit",
		onSuspend: "onsuspend",
		onTimeUpdate: "ontimeupdate",
		onToggle: "ontoggle",
		onUnload: "onunload",
		onVolumeChange: "onvolumechange",
		onWaiting: "onwaiting",
		onZoom: "onzoom",
		overlinePosition: "overline-position",
		overlineThickness: "overline-thickness",
		paintOrder: "paint-order",
		panose1: "panose-1",
		pointerEvents: "pointer-events",
		referrerPolicy: "referrerpolicy",
		renderingIntent: "rendering-intent",
		shapeRendering: "shape-rendering",
		stopColor: "stop-color",
		stopOpacity: "stop-opacity",
		strikethroughPosition: "strikethrough-position",
		strikethroughThickness: "strikethrough-thickness",
		strokeDashArray: "stroke-dasharray",
		strokeDashOffset: "stroke-dashoffset",
		strokeLineCap: "stroke-linecap",
		strokeLineJoin: "stroke-linejoin",
		strokeMiterLimit: "stroke-miterlimit",
		strokeOpacity: "stroke-opacity",
		strokeWidth: "stroke-width",
		tabIndex: "tabindex",
		textAnchor: "text-anchor",
		textDecoration: "text-decoration",
		textRendering: "text-rendering",
		transformOrigin: "transform-origin",
		typeOf: "typeof",
		underlinePosition: "underline-position",
		underlineThickness: "underline-thickness",
		unicodeBidi: "unicode-bidi",
		unicodeRange: "unicode-range",
		unitsPerEm: "units-per-em",
		vAlphabetic: "v-alphabetic",
		vHanging: "v-hanging",
		vIdeographic: "v-ideographic",
		vMathematical: "v-mathematical",
		vectorEffect: "vector-effect",
		vertAdvY: "vert-adv-y",
		vertOriginX: "vert-origin-x",
		vertOriginY: "vert-origin-y",
		wordSpacing: "word-spacing",
		writingMode: "writing-mode",
		xHeight: "x-height",
		playbackOrder: "playbackorder",
		timelineBegin: "timelinebegin"
	},
	properties: {
		about: commaOrSpaceSeparated,
		accentHeight: number,
		accumulate: null,
		additive: null,
		alignmentBaseline: null,
		alphabetic: number,
		amplitude: number,
		arabicForm: null,
		ascent: number,
		attributeName: null,
		attributeType: null,
		azimuth: number,
		bandwidth: null,
		baselineShift: null,
		baseFrequency: null,
		baseProfile: null,
		bbox: null,
		begin: null,
		bias: number,
		by: null,
		calcMode: null,
		capHeight: number,
		className: spaceSeparated,
		clip: null,
		clipPath: null,
		clipPathUnits: null,
		clipRule: null,
		color: null,
		colorInterpolation: null,
		colorInterpolationFilters: null,
		colorProfile: null,
		colorRendering: null,
		content: null,
		contentScriptType: null,
		contentStyleType: null,
		crossOrigin: null,
		cursor: null,
		cx: null,
		cy: null,
		d: null,
		dataType: null,
		defaultAction: null,
		descent: number,
		diffuseConstant: number,
		direction: null,
		display: null,
		dur: null,
		divisor: number,
		dominantBaseline: null,
		download: boolean,
		dx: null,
		dy: null,
		edgeMode: null,
		editable: null,
		elevation: number,
		enableBackground: null,
		end: null,
		event: null,
		exponent: number,
		externalResourcesRequired: null,
		fill: null,
		fillOpacity: number,
		fillRule: null,
		filter: null,
		filterRes: null,
		filterUnits: null,
		floodColor: null,
		floodOpacity: null,
		focusable: null,
		focusHighlight: null,
		fontFamily: null,
		fontSize: null,
		fontSizeAdjust: null,
		fontStretch: null,
		fontStyle: null,
		fontVariant: null,
		fontWeight: null,
		format: null,
		fr: null,
		from: null,
		fx: null,
		fy: null,
		g1: commaSeparated,
		g2: commaSeparated,
		glyphName: commaSeparated,
		glyphOrientationHorizontal: null,
		glyphOrientationVertical: null,
		glyphRef: null,
		gradientTransform: null,
		gradientUnits: null,
		handler: null,
		hanging: number,
		hatchContentUnits: null,
		hatchUnits: null,
		height: null,
		href: null,
		hrefLang: null,
		horizAdvX: number,
		horizOriginX: number,
		horizOriginY: number,
		id: null,
		ideographic: number,
		imageRendering: null,
		initialVisibility: null,
		in: null,
		in2: null,
		intercept: number,
		k: number,
		k1: number,
		k2: number,
		k3: number,
		k4: number,
		kernelMatrix: commaOrSpaceSeparated,
		kernelUnitLength: null,
		keyPoints: null,
		keySplines: null,
		keyTimes: null,
		kerning: null,
		lang: null,
		lengthAdjust: null,
		letterSpacing: null,
		lightingColor: null,
		limitingConeAngle: number,
		local: null,
		markerEnd: null,
		markerMid: null,
		markerStart: null,
		markerHeight: null,
		markerUnits: null,
		markerWidth: null,
		mask: null,
		maskContentUnits: null,
		maskUnits: null,
		mathematical: null,
		max: null,
		media: null,
		mediaCharacterEncoding: null,
		mediaContentEncodings: null,
		mediaSize: number,
		mediaTime: null,
		method: null,
		min: null,
		mode: null,
		name: null,
		navDown: null,
		navDownLeft: null,
		navDownRight: null,
		navLeft: null,
		navNext: null,
		navPrev: null,
		navRight: null,
		navUp: null,
		navUpLeft: null,
		navUpRight: null,
		numOctaves: null,
		observer: null,
		offset: null,
		onAbort: null,
		onActivate: null,
		onAfterPrint: null,
		onBeforePrint: null,
		onBegin: null,
		onCancel: null,
		onCanPlay: null,
		onCanPlayThrough: null,
		onChange: null,
		onClick: null,
		onClose: null,
		onCopy: null,
		onCueChange: null,
		onCut: null,
		onDblClick: null,
		onDrag: null,
		onDragEnd: null,
		onDragEnter: null,
		onDragExit: null,
		onDragLeave: null,
		onDragOver: null,
		onDragStart: null,
		onDrop: null,
		onDurationChange: null,
		onEmptied: null,
		onEnd: null,
		onEnded: null,
		onError: null,
		onFocus: null,
		onFocusIn: null,
		onFocusOut: null,
		onHashChange: null,
		onInput: null,
		onInvalid: null,
		onKeyDown: null,
		onKeyPress: null,
		onKeyUp: null,
		onLoad: null,
		onLoadedData: null,
		onLoadedMetadata: null,
		onLoadStart: null,
		onMessage: null,
		onMouseDown: null,
		onMouseEnter: null,
		onMouseLeave: null,
		onMouseMove: null,
		onMouseOut: null,
		onMouseOver: null,
		onMouseUp: null,
		onMouseWheel: null,
		onOffline: null,
		onOnline: null,
		onPageHide: null,
		onPageShow: null,
		onPaste: null,
		onPause: null,
		onPlay: null,
		onPlaying: null,
		onPopState: null,
		onProgress: null,
		onRateChange: null,
		onRepeat: null,
		onReset: null,
		onResize: null,
		onScroll: null,
		onSeeked: null,
		onSeeking: null,
		onSelect: null,
		onShow: null,
		onStalled: null,
		onStorage: null,
		onSubmit: null,
		onSuspend: null,
		onTimeUpdate: null,
		onToggle: null,
		onUnload: null,
		onVolumeChange: null,
		onWaiting: null,
		onZoom: null,
		opacity: null,
		operator: null,
		order: null,
		orient: null,
		orientation: null,
		origin: null,
		overflow: null,
		overlay: null,
		overlinePosition: number,
		overlineThickness: number,
		paintOrder: null,
		panose1: null,
		path: null,
		pathLength: number,
		patternContentUnits: null,
		patternTransform: null,
		patternUnits: null,
		phase: null,
		ping: spaceSeparated,
		pitch: null,
		playbackOrder: null,
		pointerEvents: null,
		points: null,
		pointsAtX: number,
		pointsAtY: number,
		pointsAtZ: number,
		preserveAlpha: null,
		preserveAspectRatio: null,
		primitiveUnits: null,
		propagate: null,
		property: commaOrSpaceSeparated,
		r: null,
		radius: null,
		referrerPolicy: null,
		refX: null,
		refY: null,
		rel: commaOrSpaceSeparated,
		rev: commaOrSpaceSeparated,
		renderingIntent: null,
		repeatCount: null,
		repeatDur: null,
		requiredExtensions: commaOrSpaceSeparated,
		requiredFeatures: commaOrSpaceSeparated,
		requiredFonts: commaOrSpaceSeparated,
		requiredFormats: commaOrSpaceSeparated,
		resource: null,
		restart: null,
		result: null,
		rotate: null,
		rx: null,
		ry: null,
		scale: null,
		seed: null,
		shapeRendering: null,
		side: null,
		slope: null,
		snapshotTime: null,
		specularConstant: number,
		specularExponent: number,
		spreadMethod: null,
		spacing: null,
		startOffset: null,
		stdDeviation: null,
		stemh: null,
		stemv: null,
		stitchTiles: null,
		stopColor: null,
		stopOpacity: null,
		strikethroughPosition: number,
		strikethroughThickness: number,
		string: null,
		stroke: null,
		strokeDashArray: commaOrSpaceSeparated,
		strokeDashOffset: null,
		strokeLineCap: null,
		strokeLineJoin: null,
		strokeMiterLimit: number,
		strokeOpacity: number,
		strokeWidth: null,
		style: null,
		surfaceScale: number,
		syncBehavior: null,
		syncBehaviorDefault: null,
		syncMaster: null,
		syncTolerance: null,
		syncToleranceDefault: null,
		systemLanguage: commaOrSpaceSeparated,
		tabIndex: number,
		tableValues: null,
		target: null,
		targetX: number,
		targetY: number,
		textAnchor: null,
		textDecoration: null,
		textRendering: null,
		textLength: null,
		timelineBegin: null,
		title: null,
		transformBehavior: null,
		type: null,
		typeOf: commaOrSpaceSeparated,
		to: null,
		transform: null,
		transformOrigin: null,
		u1: null,
		u2: null,
		underlinePosition: number,
		underlineThickness: number,
		unicode: null,
		unicodeBidi: null,
		unicodeRange: null,
		unitsPerEm: number,
		values: null,
		vAlphabetic: number,
		vMathematical: number,
		vectorEffect: null,
		vHanging: number,
		vIdeographic: number,
		version: null,
		vertAdvY: number,
		vertOriginX: number,
		vertOriginY: number,
		viewBox: null,
		viewTarget: null,
		visibility: null,
		width: null,
		widths: null,
		wordSpacing: null,
		writingMode: null,
		x: null,
		x1: null,
		x2: null,
		xChannelSelector: null,
		xHeight: number,
		y: null,
		y1: null,
		y2: null,
		yChannelSelector: null,
		z: null,
		zoomAndPan: null
	},
	space: "svg",
	transform: caseSensitiveTransform
});
const xlink = create$1({
	properties: {
		xLinkActuate: null,
		xLinkArcRole: null,
		xLinkHref: null,
		xLinkRole: null,
		xLinkShow: null,
		xLinkTitle: null,
		xLinkType: null
	},
	space: "xlink",
	transform(_$1, property) {
		return "xlink:" + property.slice(5).toLowerCase();
	}
});
const xmlns = create$1({
	attributes: { xmlnsxlink: "xmlns:xlink" },
	properties: {
		xmlnsXLink: null,
		xmlns: null
	},
	space: "xmlns",
	transform: caseInsensitiveTransform
});
const xml = create$1({
	properties: {
		xmlBase: null,
		xmlLang: null,
		xmlSpace: null
	},
	space: "xml",
	transform(_$1, property) {
		return "xml:" + property.slice(3).toLowerCase();
	}
});
const hastToReact = {
	classId: "classID",
	dataType: "datatype",
	itemId: "itemID",
	strokeDashArray: "strokeDasharray",
	strokeDashOffset: "strokeDashoffset",
	strokeLineCap: "strokeLinecap",
	strokeLineJoin: "strokeLinejoin",
	strokeMiterLimit: "strokeMiterlimit",
	typeOf: "typeof",
	xLinkActuate: "xlinkActuate",
	xLinkArcRole: "xlinkArcrole",
	xLinkHref: "xlinkHref",
	xLinkRole: "xlinkRole",
	xLinkShow: "xlinkShow",
	xLinkTitle: "xlinkTitle",
	xLinkType: "xlinkType",
	xmlnsXLink: "xmlnsXlink"
};
const cap$1 = /[A-Z]/g;
const dash = /-[a-z]/g;
const valid = /^data[-\w.:]+$/i;
function find(schema, value) {
	const normal = normalize(value);
	let property = value;
	let Type = Info;
	if (normal in schema.normal) return schema.property[schema.normal[normal]];
	if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
		if (value.charAt(4) === "-") {
			const rest$1 = value.slice(5).replace(dash, camelcase);
			property = "data" + rest$1.charAt(0).toUpperCase() + rest$1.slice(1);
		} else {
			const rest$1 = value.slice(4);
			if (!dash.test(rest$1)) {
				let dashes = rest$1.replace(cap$1, kebab);
				if (dashes.charAt(0) !== "-") dashes = "-" + dashes;
				value = "data" + dashes;
			}
		}
		Type = DefinedInfo;
	}
	return new Type(property, value);
}
function kebab($0) {
	return "-" + $0.toLowerCase();
}
function camelcase($0) {
	return $0.charAt(1).toUpperCase();
}
const html$2 = merge([
	aria,
	html$4,
	xlink,
	xmlns,
	xml
], "html");
const svg = merge([
	aria,
	svg$2,
	xlink,
	xmlns,
	xml
], "svg");
var emptyMulticharIndex = {};
var emptyRegularIndex = {};
function extendIndex(item, index$1) {
	var currentIndex = index$1;
	for (var pos = 0; pos < item.length; pos++) {
		var isLast = pos === item.length - 1;
		var char = item.charAt(pos);
		var charIndex = currentIndex[char] || (currentIndex[char] = { chars: {} });
		if (isLast) charIndex.self = item;
		currentIndex = charIndex.chars;
	}
}
function createMulticharIndex(items) {
	if (items.length === 0) return emptyMulticharIndex;
	var index$1 = {};
	for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
		var item = items_1[_i];
		extendIndex(item, index$1);
	}
	return index$1;
}
function createRegularIndex(items) {
	if (items.length === 0) return emptyRegularIndex;
	var result = {};
	for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {
		var item = items_2[_i];
		result[item] = true;
	}
	return result;
}
var emptyPseudoSignatures = {};
var defaultPseudoSignature = {
	type: "String",
	optional: true
};
function calculatePseudoSignature(types) {
	var result = {
		type: "NoArgument",
		optional: false
	};
	function setResultType(type$1) {
		if (result.type && result.type !== type$1 && result.type !== "NoArgument") throw new Error("Conflicting pseudo-class argument type: \"".concat(result.type, "\" vs \"").concat(type$1, "\"."));
		result.type = type$1;
	}
	for (var _i = 0, types_1 = types; _i < types_1.length; _i++) {
		var type = types_1[_i];
		if (type === "NoArgument") result.optional = true;
		if (type === "Formula") setResultType("Formula");
		if (type === "FormulaOfSelector") {
			setResultType("Formula");
			result.ofSelector = true;
		}
		if (type === "String") setResultType("String");
		if (type === "Selector") setResultType("Selector");
	}
	return result;
}
function inverseCategories(obj) {
	var result = {};
	for (var _i = 0, _a$1 = Object.keys(obj); _i < _a$1.length; _i++) {
		var category = _a$1[_i];
		var items = obj[category];
		if (items) for (var _b = 0, _c = items; _b < _c.length; _b++) {
			var item = _c[_b];
			(result[item] || (result[item] = [])).push(category);
		}
	}
	return result;
}
function calculatePseudoSignatures(definitions) {
	var pseudoClassesToArgumentTypes = inverseCategories(definitions);
	var result = {};
	for (var _i = 0, _a$1 = Object.keys(pseudoClassesToArgumentTypes); _i < _a$1.length; _i++) {
		var pseudoClass = _a$1[_i];
		var argumentTypes = pseudoClassesToArgumentTypes[pseudoClass];
		if (argumentTypes) result[pseudoClass] = calculatePseudoSignature(argumentTypes);
	}
	return result;
}
var __assign = function() {
	__assign = Object.assign || function(t) {
		for (var s$2, i = 1, n$1 = arguments.length; i < n$1; i++) {
			s$2 = arguments[i];
			for (var p$1 in s$2) if (Object.prototype.hasOwnProperty.call(s$2, p$1)) t[p$1] = s$2[p$1];
		}
		return t;
	};
	return __assign.apply(this, arguments);
};
var emptyXmlOptions = {};
var defaultXmlOptions = { wildcard: true };
function getXmlOptions(param) {
	if (param) if (typeof param === "boolean") return defaultXmlOptions;
	else return param;
	else return emptyXmlOptions;
}
function withMigration(migration, merge$2) {
	return function(base, extension$1) {
		return merge$2(migration(base), migration(extension$1));
	};
}
function withNoNegative(merge$2) {
	return function(base, extension$1) {
		var result = merge$2(base, extension$1);
		if (!result) throw new Error("Syntax definition cannot be null or undefined.");
		return result;
	};
}
function withPositive(positive, merge$2) {
	return function(base, extension$1) {
		if (extension$1 === true) return positive;
		return merge$2(base === true ? positive : base, extension$1);
	};
}
function mergeSection(values) {
	return function(base, extension$1) {
		if (!extension$1 || !base) return extension$1;
		if (typeof extension$1 !== "object" || extension$1 === null) throw new Error("Unexpected syntax definition extension type: ".concat(extension$1, "."));
		var result = __assign({}, base);
		for (var _i = 0, _a$1 = Object.entries(extension$1); _i < _a$1.length; _i++) {
			var _b = _a$1[_i], key = _b[0], value = _b[1];
			if (key === "latest") continue;
			var mergeSchema = values[key];
			result[key] = mergeSchema(base[key], value);
		}
		return result;
	};
}
function replaceValueIfSpecified(base, extension$1) {
	if (extension$1 !== void 0) return extension$1;
	return base;
}
function concatArray(base, extension$1) {
	if (!extension$1) return base;
	if (!base) return extension$1;
	return base.concat(extension$1);
}
function mergeDefinitions(base, extension$1) {
	if (!extension$1) return base;
	if (!base) return extension$1;
	var result = __assign({}, base);
	for (var _i = 0, _a$1 = Object.entries(extension$1); _i < _a$1.length; _i++) {
		var _b = _a$1[_i], key = _b[0], value = _b[1];
		if (!value) {
			delete result[key];
			continue;
		}
		var baseValue = base[key];
		if (!baseValue) {
			result[key] = value;
			continue;
		}
		result[key] = baseValue.concat(value);
	}
	return result;
}
var extendSyntaxDefinition = withNoNegative(mergeSection({
	baseSyntax: replaceValueIfSpecified,
	modules: concatArray,
	tag: withPositive(defaultXmlOptions, mergeSection({ wildcard: replaceValueIfSpecified })),
	ids: replaceValueIfSpecified,
	classNames: replaceValueIfSpecified,
	namespace: withPositive(defaultXmlOptions, mergeSection({ wildcard: replaceValueIfSpecified })),
	combinators: concatArray,
	attributes: mergeSection({
		operators: concatArray,
		caseSensitivityModifiers: concatArray,
		unknownCaseSensitivityModifiers: replaceValueIfSpecified
	}),
	pseudoClasses: mergeSection({
		unknown: replaceValueIfSpecified,
		definitions: mergeDefinitions
	}),
	pseudoElements: mergeSection({
		unknown: replaceValueIfSpecified,
		notation: replaceValueIfSpecified,
		definitions: withMigration(function(definitions) {
			return Array.isArray(definitions) ? { NoArgument: definitions } : definitions;
		}, mergeDefinitions)
	})
}));
var css1SyntaxDefinition = {
	tag: {},
	ids: true,
	classNames: true,
	combinators: [],
	pseudoElements: {
		unknown: "reject",
		notation: "singleColon",
		definitions: ["first-letter", "first-line"]
	},
	pseudoClasses: {
		unknown: "reject",
		definitions: { NoArgument: [
			"link",
			"visited",
			"active"
		] }
	}
};
var css2SyntaxDefinition = extendSyntaxDefinition(css1SyntaxDefinition, {
	tag: { wildcard: true },
	combinators: [">", "+"],
	attributes: {
		unknownCaseSensitivityModifiers: "reject",
		operators: [
			"=",
			"~=",
			"|="
		]
	},
	pseudoElements: { definitions: ["before", "after"] },
	pseudoClasses: {
		unknown: "reject",
		definitions: {
			NoArgument: [
				"hover",
				"focus",
				"first-child"
			],
			String: ["lang"]
		}
	}
});
var selectors3SyntaxDefinition = extendSyntaxDefinition(css2SyntaxDefinition, {
	namespace: { wildcard: true },
	combinators: ["~"],
	attributes: { operators: [
		"^=",
		"$=",
		"*="
	] },
	pseudoElements: { notation: "both" },
	pseudoClasses: { definitions: {
		NoArgument: [
			"root",
			"last-child",
			"first-of-type",
			"last-of-type",
			"only-child",
			"only-of-type",
			"empty",
			"target",
			"enabled",
			"disabled",
			"checked",
			"indeterminate"
		],
		Formula: [
			"nth-child",
			"nth-last-child",
			"nth-of-type",
			"nth-last-of-type"
		],
		Selector: ["not"]
	} }
});
var selectors4SyntaxDefinition = extendSyntaxDefinition(selectors3SyntaxDefinition, {
	combinators: ["||"],
	attributes: { caseSensitivityModifiers: [
		"i",
		"I",
		"s",
		"S"
	] },
	pseudoClasses: { definitions: {
		NoArgument: [
			"any-link",
			"local-link",
			"target-within",
			"scope",
			"current",
			"past",
			"future",
			"focus-within",
			"focus-visible",
			"read-write",
			"read-only",
			"placeholder-shown",
			"default",
			"valid",
			"invalid",
			"in-range",
			"out-of-range",
			"required",
			"optional",
			"blank",
			"user-invalid",
			"playing",
			"paused",
			"autofill",
			"modal",
			"fullscreen",
			"picture-in-picture",
			"defined",
			"loading",
			"popover-open"
		],
		Formula: ["nth-col", "nth-last-col"],
		String: ["dir"],
		FormulaOfSelector: ["nth-child", "nth-last-child"],
		Selector: [
			"current",
			"is",
			"where",
			"has",
			"state"
		]
	} },
	pseudoElements: { definitions: { NoArgument: ["marker"] } }
});
var cssModules = {
	"css-position-1": {
		latest: false,
		pseudoClasses: { definitions: { NoArgument: [
			"static",
			"relative",
			"absolute"
		] } }
	},
	"css-position-2": {
		latest: false,
		pseudoClasses: { definitions: { NoArgument: [
			"static",
			"relative",
			"absolute",
			"fixed"
		] } }
	},
	"css-position-3": {
		latest: false,
		pseudoClasses: { definitions: { NoArgument: [
			"sticky",
			"fixed",
			"absolute",
			"relative",
			"static"
		] } }
	},
	"css-position-4": {
		latest: true,
		pseudoClasses: { definitions: { NoArgument: [
			"sticky",
			"fixed",
			"absolute",
			"relative",
			"static",
			"initial"
		] } }
	},
	"css-scoping-1": {
		latest: true,
		pseudoClasses: { definitions: {
			NoArgument: ["host", "host-context"],
			Selector: ["host", "host-context"]
		} },
		pseudoElements: { definitions: { Selector: ["slotted"] } }
	},
	"css-pseudo-4": {
		latest: true,
		pseudoElements: { definitions: {
			NoArgument: [
				"marker",
				"selection",
				"target-text",
				"search-text",
				"spelling-error",
				"grammar-error",
				"backdrop",
				"file-selector-button",
				"prefix",
				"postfix",
				"placeholder",
				"details-content"
			],
			String: ["highlight"]
		} }
	},
	"css-shadow-parts-1": {
		latest: true,
		pseudoElements: { definitions: { String: ["part"] } }
	}
};
var latestSyntaxDefinition = __assign(__assign({}, selectors4SyntaxDefinition), { modules: Object.entries(cssModules).filter(function(_a$1) {
	var latest = _a$1[1].latest;
	return latest;
}).map(function(_a$1) {
	var name$2 = _a$1[0];
	return name$2;
}) });
var progressiveSyntaxDefinition = extendSyntaxDefinition(latestSyntaxDefinition, {
	pseudoElements: { unknown: "accept" },
	pseudoClasses: { unknown: "accept" },
	attributes: { unknownCaseSensitivityModifiers: "accept" }
});
var cssSyntaxDefinitions = {
	css1: css1SyntaxDefinition,
	css2: css2SyntaxDefinition,
	css3: selectors3SyntaxDefinition,
	"selectors-3": selectors3SyntaxDefinition,
	"selectors-4": selectors4SyntaxDefinition,
	latest: latestSyntaxDefinition,
	progressive: progressiveSyntaxDefinition
};
function buildPseudoLocationIndex() {
	var index$1 = {
		pseudoClasses: {},
		pseudoElements: {}
	};
	var cssLevels = [
		"css1",
		"css2",
		"css3",
		"selectors-3",
		"selectors-4"
	];
	for (var _i = 0, cssLevels_1 = cssLevels; _i < cssLevels_1.length; _i++) {
		var level = cssLevels_1[_i];
		var syntax = cssSyntaxDefinitions[level];
		if (syntax.pseudoClasses && typeof syntax.pseudoClasses === "object") {
			var definitions = syntax.pseudoClasses.definitions;
			if (definitions) for (var _a$1 = 0, _b = Object.entries(definitions); _a$1 < _b.length; _a$1++) {
				var _c = _b[_a$1], names = _c[1];
				for (var _d = 0, names_1 = names; _d < names_1.length; _d++) {
					var name_1 = names_1[_d];
					if (!index$1.pseudoClasses[name_1]) index$1.pseudoClasses[name_1] = [];
					if (!index$1.pseudoClasses[name_1].includes(level)) index$1.pseudoClasses[name_1].push(level);
				}
			}
		}
		if (syntax.pseudoElements && typeof syntax.pseudoElements === "object") {
			var definitions = syntax.pseudoElements.definitions;
			if (definitions) if (Array.isArray(definitions)) for (var _e = 0, definitions_1 = definitions; _e < definitions_1.length; _e++) {
				var name_2 = definitions_1[_e];
				if (!index$1.pseudoElements[name_2]) index$1.pseudoElements[name_2] = [];
				if (!index$1.pseudoElements[name_2].includes(level)) index$1.pseudoElements[name_2].push(level);
			}
			else for (var _f = 0, _g = Object.values(definitions); _f < _g.length; _f++) {
				var names = _g[_f];
				for (var _h = 0, names_2 = names; _h < names_2.length; _h++) {
					var name_3 = names_2[_h];
					if (!index$1.pseudoElements[name_3]) index$1.pseudoElements[name_3] = [];
					if (!index$1.pseudoElements[name_3].includes(level)) index$1.pseudoElements[name_3].push(level);
				}
			}
		}
	}
	for (var _j = 0, _k = Object.entries(cssModules); _j < _k.length; _j++) {
		var _l = _k[_j], moduleName = _l[0], moduleSyntax = _l[1];
		if (moduleSyntax.pseudoClasses && typeof moduleSyntax.pseudoClasses === "object") {
			var definitions = moduleSyntax.pseudoClasses.definitions;
			if (definitions) for (var _m = 0, _o = Object.values(definitions); _m < _o.length; _m++) {
				var names = _o[_m];
				for (var _p = 0, names_3 = names; _p < names_3.length; _p++) {
					var name_4 = names_3[_p];
					if (!index$1.pseudoClasses[name_4]) index$1.pseudoClasses[name_4] = [];
					if (!index$1.pseudoClasses[name_4].includes(moduleName)) index$1.pseudoClasses[name_4].push(moduleName);
				}
			}
		}
		if (moduleSyntax.pseudoElements && typeof moduleSyntax.pseudoElements === "object") {
			var definitions = moduleSyntax.pseudoElements.definitions;
			if (definitions) if (Array.isArray(definitions)) for (var _q = 0, definitions_2 = definitions; _q < definitions_2.length; _q++) {
				var name_5 = definitions_2[_q];
				if (!index$1.pseudoElements[name_5]) index$1.pseudoElements[name_5] = [];
				if (!index$1.pseudoElements[name_5].includes(moduleName)) index$1.pseudoElements[name_5].push(moduleName);
			}
			else for (var _r = 0, _s = Object.values(definitions); _r < _s.length; _r++) {
				var names = _s[_r];
				for (var _t = 0, names_4 = names; _t < names_4.length; _t++) {
					var name_6 = names_4[_t];
					if (!index$1.pseudoElements[name_6]) index$1.pseudoElements[name_6] = [];
					if (!index$1.pseudoElements[name_6].includes(moduleName)) index$1.pseudoElements[name_6].push(moduleName);
				}
			}
		}
	}
	return index$1;
}
var pseudoLocationIndex = buildPseudoLocationIndex();
function isIdentStart(c$2) {
	return c$2 >= "a" && c$2 <= "z" || c$2 >= "A" && c$2 <= "Z" || c$2 === "-" || c$2 === "_" || c$2 === "\\" || c$2 >= "\xA0";
}
function isIdent(c$2) {
	return c$2 >= "a" && c$2 <= "z" || c$2 >= "A" && c$2 <= "Z" || c$2 >= "0" && c$2 <= "9" || c$2 === "-" || c$2 === "_" || c$2 >= "\xA0";
}
function isHex(c$2) {
	return c$2 >= "a" && c$2 <= "f" || c$2 >= "A" && c$2 <= "F" || c$2 >= "0" && c$2 <= "9";
}
var whitespaceChars = {
	" ": true,
	"	": true,
	"\n": true,
	"\r": true,
	"\f": true
};
var quoteChars = {
	"\"": true,
	"'": true
};
var digitsChars = {
	0: true,
	1: true,
	2: true,
	3: true,
	4: true,
	5: true,
	6: true,
	7: true,
	8: true,
	9: true
};
var maxHexLength = 6;
var errorPrefix = "css-selector-parser parse error: ";
function createParser(options) {
	if (options === void 0) options = {};
	var _a$1 = options.syntax, syntax = _a$1 === void 0 ? "latest" : _a$1, substitutes = options.substitutes, _b = options.strict, strict = _b === void 0 ? true : _b, modules = options.modules;
	var syntaxDefinition = typeof syntax === "object" ? syntax : cssSyntaxDefinitions[syntax];
	if (syntaxDefinition.baseSyntax) syntaxDefinition = extendSyntaxDefinition(cssSyntaxDefinitions[syntaxDefinition.baseSyntax], syntaxDefinition);
	if (syntaxDefinition.modules && syntaxDefinition.modules.length > 0) for (var _i = 0, _c = syntaxDefinition.modules; _i < _c.length; _i++) {
		var module_1 = _c[_i];
		var moduleSyntax = cssModules[module_1];
		if (moduleSyntax) syntaxDefinition = extendSyntaxDefinition(moduleSyntax, syntaxDefinition);
	}
	if (modules && modules.length > 0) for (var _d = 0, modules_1 = modules; _d < modules_1.length; _d++) {
		var module_2 = modules_1[_d];
		var moduleSyntax = cssModules[module_2];
		if (moduleSyntax) syntaxDefinition = extendSyntaxDefinition(moduleSyntax, syntaxDefinition);
	}
	var _e = syntaxDefinition.tag ? [true, Boolean(getXmlOptions(syntaxDefinition.tag).wildcard)] : [false, false], tagNameEnabled = _e[0], tagNameWildcardEnabled = _e[1];
	var idEnabled = Boolean(syntaxDefinition.ids);
	var classNamesEnabled = Boolean(syntaxDefinition.classNames);
	var namespaceEnabled = Boolean(syntaxDefinition.namespace);
	var namespaceWildcardEnabled = syntaxDefinition.namespace && (syntaxDefinition.namespace === true || syntaxDefinition.namespace.wildcard === true);
	if (namespaceEnabled && !tagNameEnabled) throw new Error("".concat(errorPrefix, "Namespaces cannot be enabled while tags are disabled."));
	var substitutesEnabled = Boolean(substitutes);
	var combinatorsIndex = syntaxDefinition.combinators ? createMulticharIndex(syntaxDefinition.combinators) : emptyMulticharIndex;
	var _f = syntaxDefinition.attributes ? [
		true,
		syntaxDefinition.attributes.operators ? createMulticharIndex(syntaxDefinition.attributes.operators) : emptyMulticharIndex,
		syntaxDefinition.attributes.caseSensitivityModifiers ? createRegularIndex(syntaxDefinition.attributes.caseSensitivityModifiers) : emptyRegularIndex,
		syntaxDefinition.attributes.unknownCaseSensitivityModifiers === "accept"
	] : [
		false,
		emptyMulticharIndex,
		emptyRegularIndex,
		false
	], attributesEnabled = _f[0], attributesOperatorsIndex = _f[1], attributesCaseSensitivityModifiers = _f[2], attributesAcceptUnknownCaseSensitivityModifiers = _f[3];
	var attributesCaseSensitivityModifiersEnabled = attributesAcceptUnknownCaseSensitivityModifiers || Object.keys(attributesCaseSensitivityModifiers).length > 0;
	var _g = syntaxDefinition.pseudoClasses ? [
		true,
		syntaxDefinition.pseudoClasses.definitions ? calculatePseudoSignatures(syntaxDefinition.pseudoClasses.definitions) : emptyPseudoSignatures,
		syntaxDefinition.pseudoClasses.unknown === "accept"
	] : [
		false,
		emptyPseudoSignatures,
		false
	], pseudoClassesEnabled = _g[0], pseudoClassesDefinitions = _g[1], pseudoClassesAcceptUnknown = _g[2];
	var _h = syntaxDefinition.pseudoElements ? [
		true,
		syntaxDefinition.pseudoElements.notation === "singleColon" || syntaxDefinition.pseudoElements.notation === "both",
		!syntaxDefinition.pseudoElements.notation || syntaxDefinition.pseudoElements.notation === "doubleColon" || syntaxDefinition.pseudoElements.notation === "both",
		syntaxDefinition.pseudoElements.definitions ? calculatePseudoSignatures(Array.isArray(syntaxDefinition.pseudoElements.definitions) ? { NoArgument: syntaxDefinition.pseudoElements.definitions } : syntaxDefinition.pseudoElements.definitions) : emptyPseudoSignatures,
		syntaxDefinition.pseudoElements.unknown === "accept"
	] : [
		false,
		false,
		false,
		emptyPseudoSignatures,
		false
	], pseudoElementsEnabled = _h[0], pseudoElementsSingleColonNotationEnabled = _h[1], pseudoElementsDoubleColonNotationEnabled = _h[2], pseudoElementsDefinitions = _h[3], pseudoElementsAcceptUnknown = _h[4];
	var str = "";
	var l$1 = str.length;
	var pos = 0;
	var chr = "";
	var is$1 = function(comparison) {
		return chr === comparison;
	};
	var isTagStart = function() {
		return is$1("*") || isIdentStart(chr);
	};
	var rewind = function(newPos) {
		pos = newPos;
		chr = str.charAt(pos);
	};
	var next$1 = function() {
		pos++;
		chr = str.charAt(pos);
	};
	var readAndNext = function() {
		var current = chr;
		pos++;
		chr = str.charAt(pos);
		return current;
	};
	function fail(errorMessage) {
		var position$3 = Math.min(l$1 - 1, pos);
		var error = new Error("".concat(errorPrefix).concat(errorMessage, " Pos: ").concat(position$3, "."));
		error.position = position$3;
		error.name = "ParserError";
		throw error;
	}
	function assert(condition, errorMessage) {
		if (!condition) return fail(errorMessage);
	}
	var assertNonEof = function() {
		assert(pos < l$1, "Unexpected end of input.");
	};
	var isEof = function() {
		return pos >= l$1;
	};
	var pass = function(character) {
		assert(pos < l$1, "Expected \"".concat(character, "\" but end of input reached."));
		assert(chr === character, "Expected \"".concat(character, "\" but \"").concat(chr, "\" found."));
		pos++;
		chr = str.charAt(pos);
	};
	function matchMulticharIndex(index$1) {
		var match = matchMulticharIndexPos(index$1, pos);
		if (match) {
			pos += match.length;
			chr = str.charAt(pos);
			return match;
		}
	}
	function matchMulticharIndexPos(index$1, subPos) {
		var char = str.charAt(subPos);
		var charIndex = index$1[char];
		if (charIndex) {
			var subMatch = matchMulticharIndexPos(charIndex.chars, subPos + 1);
			if (subMatch) return subMatch;
			if (charIndex.self) return charIndex.self;
		}
	}
	function parseHex() {
		var hex = readAndNext();
		var count$1 = 1;
		while (isHex(chr) && count$1 < maxHexLength) {
			hex += readAndNext();
			count$1++;
		}
		skipSingleWhitespace();
		return String.fromCharCode(parseInt(hex, 16));
	}
	function parseString(quote) {
		var result = "";
		pass(quote);
		while (pos < l$1) if (is$1(quote)) {
			next$1();
			return result;
		} else if (is$1("\\")) {
			next$1();
			if (is$1(quote)) {
				result += quote;
				next$1();
			} else if (chr === "\n" || chr === "\f") next$1();
			else if (chr === "\r") {
				next$1();
				if (is$1("\n")) next$1();
			} else if (isHex(chr)) result += parseHex();
			else {
				result += chr;
				next$1();
			}
		} else {
			result += chr;
			next$1();
		}
		return result;
	}
	function parseIdentifier() {
		if (!isIdentStart(chr)) return null;
		var result = "";
		while (is$1("-")) {
			result += chr;
			next$1();
		}
		if (result === "-" && !isIdent(chr) && !is$1("\\")) fail("Identifiers cannot consist of a single hyphen.");
		if (strict && result.length >= 2) fail("Identifiers cannot start with two hyphens with strict mode on.");
		if (digitsChars[chr]) fail("Identifiers cannot start with hyphens followed by digits.");
		while (pos < l$1) if (isIdent(chr)) result += readAndNext();
		else if (is$1("\\")) {
			next$1();
			assertNonEof();
			if (isHex(chr)) result += parseHex();
			else result += readAndNext();
		} else break;
		return result;
	}
	function parsePseudoClassString() {
		var result = "";
		while (pos < l$1) if (is$1(")")) break;
		else if (is$1("\\")) {
			next$1();
			if (isEof() && !strict) return (result + "\\").trim();
			assertNonEof();
			if (isHex(chr)) result += parseHex();
			else result += readAndNext();
		} else result += readAndNext();
		return result.trim();
	}
	function skipSingleWhitespace() {
		if (chr === " " || chr === "	" || chr === "\f" || chr === "\n") {
			next$1();
			return;
		}
		if (chr === "\r") next$1();
		if (chr === "\n") next$1();
	}
	function skipWhitespace() {
		while (whitespaceChars[chr]) next$1();
	}
	function parseSelector$2(relative) {
		if (relative === void 0) relative = false;
		skipWhitespace();
		var rules = [parseRule(relative)];
		while (is$1(",")) {
			next$1();
			skipWhitespace();
			rules.push(parseRule(relative));
		}
		return {
			type: "Selector",
			rules
		};
	}
	function parseAttribute() {
		pass("[");
		skipWhitespace();
		var attr;
		if (is$1("|")) {
			assert(namespaceEnabled, "Namespaces are not enabled.");
			next$1();
			var name_1 = parseIdentifier();
			assert(name_1, "Expected attribute name.");
			attr = {
				type: "Attribute",
				name: name_1,
				namespace: { type: "NoNamespace" }
			};
		} else if (is$1("*")) {
			assert(namespaceEnabled, "Namespaces are not enabled.");
			assert(namespaceWildcardEnabled, "Wildcard namespace is not enabled.");
			next$1();
			pass("|");
			var name_2 = parseIdentifier();
			assert(name_2, "Expected attribute name.");
			attr = {
				type: "Attribute",
				name: name_2,
				namespace: { type: "WildcardNamespace" }
			};
		} else {
			var identifier = parseIdentifier();
			assert(identifier, "Expected attribute name.");
			attr = {
				type: "Attribute",
				name: identifier
			};
			if (is$1("|")) {
				var savedPos = pos;
				next$1();
				if (isIdentStart(chr)) {
					assert(namespaceEnabled, "Namespaces are not enabled.");
					var name_3 = parseIdentifier();
					assert(name_3, "Expected attribute name.");
					attr = {
						type: "Attribute",
						name: name_3,
						namespace: {
							type: "NamespaceName",
							name: identifier
						}
					};
				} else rewind(savedPos);
			}
		}
		assert(attr.name, "Expected attribute name.");
		skipWhitespace();
		if (isEof() && !strict) return attr;
		if (is$1("]")) next$1();
		else {
			attr.operator = matchMulticharIndex(attributesOperatorsIndex);
			assert(attr.operator, "Expected a valid attribute selector operator.");
			skipWhitespace();
			assertNonEof();
			if (quoteChars[chr]) attr.value = {
				type: "String",
				value: parseString(chr)
			};
			else if (substitutesEnabled && is$1("$")) {
				next$1();
				var name_4 = parseIdentifier();
				assert(name_4, "Expected substitute name.");
				attr.value = {
					type: "Substitution",
					name: name_4
				};
			} else {
				var value = parseIdentifier();
				assert(value, "Expected attribute value.");
				attr.value = {
					type: "String",
					value
				};
			}
			skipWhitespace();
			if (isEof() && !strict) return attr;
			if (!is$1("]")) {
				var caseSensitivityModifier = parseIdentifier();
				assert(caseSensitivityModifier, "Expected end of attribute selector.");
				attr.caseSensitivityModifier = caseSensitivityModifier;
				assert(attributesCaseSensitivityModifiersEnabled, "Attribute case sensitivity modifiers are not enabled.");
				assert(attributesAcceptUnknownCaseSensitivityModifiers || attributesCaseSensitivityModifiers[attr.caseSensitivityModifier], "Unknown attribute case sensitivity modifier.");
				skipWhitespace();
				if (isEof() && !strict) return attr;
			}
			pass("]");
		}
		return attr;
	}
	function parseNumber() {
		var result = "";
		while (digitsChars[chr]) result += readAndNext();
		assert(result !== "", "Formula parse error.");
		return parseInt(result);
	}
	var isNumberStart = function() {
		return is$1("-") || is$1("+") || digitsChars[chr];
	};
	function parseFormula() {
		if (is$1("e") || is$1("o")) {
			var ident = parseIdentifier();
			if (ident === "even") {
				skipWhitespace();
				return [2, 0];
			}
			if (ident === "odd") {
				skipWhitespace();
				return [2, 1];
			}
		}
		var firstNumber = null;
		var firstNumberMultiplier = 1;
		if (is$1("-")) {
			next$1();
			firstNumberMultiplier = -1;
		}
		if (isNumberStart()) {
			if (is$1("+")) next$1();
			firstNumber = parseNumber();
			if (!is$1("\\") && !is$1("n")) return [0, firstNumber * firstNumberMultiplier];
		}
		if (firstNumber === null) firstNumber = 1;
		firstNumber *= firstNumberMultiplier;
		var identifier;
		if (is$1("\\")) {
			next$1();
			if (isHex(chr)) identifier = parseHex();
			else identifier = readAndNext();
		} else identifier = readAndNext();
		assert(identifier === "n", "Formula parse error: expected \"n\".");
		skipWhitespace();
		if (is$1("+") || is$1("-")) {
			var sign = is$1("+") ? 1 : -1;
			next$1();
			skipWhitespace();
			return [firstNumber, sign * parseNumber()];
		} else return [firstNumber, 0];
	}
	function parsePseudoArgument(pseudoName, type, signature) {
		var argument;
		if (is$1("(")) {
			next$1();
			skipWhitespace();
			if (substitutesEnabled && is$1("$")) {
				next$1();
				var name_5 = parseIdentifier();
				assert(name_5, "Expected substitute name.");
				argument = {
					type: "Substitution",
					name: name_5
				};
			} else if (signature.type === "String") {
				argument = {
					type: "String",
					value: parsePseudoClassString()
				};
				assert(argument.value, "Expected ".concat(type, " argument value."));
			} else if (signature.type === "Selector") argument = parseSelector$2(true);
			else if (signature.type === "Formula") {
				var _a$2 = parseFormula(), a$1 = _a$2[0], b = _a$2[1];
				argument = {
					type: "Formula",
					a: a$1,
					b
				};
				if (signature.ofSelector) {
					skipWhitespace();
					if (is$1("o") || is$1("\\")) {
						var ident = parseIdentifier();
						assert(ident === "of", "Formula of selector parse error.");
						skipWhitespace();
						argument = {
							type: "FormulaOfSelector",
							a: a$1,
							b,
							selector: parseRule()
						};
					}
				}
			} else return fail("Invalid ".concat(type, " signature."));
			skipWhitespace();
			if (isEof() && !strict) return argument;
			pass(")");
		} else assert(signature.optional, "Argument is required for ".concat(type, " \"").concat(pseudoName, "\"."));
		return argument;
	}
	function parseTagName() {
		if (is$1("*")) {
			assert(tagNameWildcardEnabled, "Wildcard tag name is not enabled.");
			next$1();
			return { type: "WildcardTag" };
		} else if (isIdentStart(chr)) {
			assert(tagNameEnabled, "Tag names are not enabled.");
			var name_6 = parseIdentifier();
			assert(name_6, "Expected tag name.");
			return {
				type: "TagName",
				name: name_6
			};
		} else return fail("Expected tag name.");
	}
	function parseTagNameWithNamespace() {
		if (is$1("*")) {
			var savedPos = pos;
			next$1();
			if (!is$1("|")) {
				rewind(savedPos);
				return parseTagName();
			}
			next$1();
			if (!isTagStart()) {
				rewind(savedPos);
				return parseTagName();
			}
			assert(namespaceEnabled, "Namespaces are not enabled.");
			assert(namespaceWildcardEnabled, "Wildcard namespace is not enabled.");
			var tagName = parseTagName();
			tagName.namespace = { type: "WildcardNamespace" };
			return tagName;
		} else if (is$1("|")) {
			assert(namespaceEnabled, "Namespaces are not enabled.");
			next$1();
			var tagName = parseTagName();
			tagName.namespace = { type: "NoNamespace" };
			return tagName;
		} else if (isIdentStart(chr)) {
			var identifier = parseIdentifier();
			assert(identifier, "Expected tag name.");
			if (!is$1("|")) {
				assert(tagNameEnabled, "Tag names are not enabled.");
				return {
					type: "TagName",
					name: identifier
				};
			}
			var savedPos = pos;
			next$1();
			if (!isTagStart()) {
				rewind(savedPos);
				return {
					type: "TagName",
					name: identifier
				};
			}
			assert(namespaceEnabled, "Namespaces are not enabled.");
			var tagName = parseTagName();
			tagName.namespace = {
				type: "NamespaceName",
				name: identifier
			};
			return tagName;
		} else return fail("Expected tag name.");
	}
	function parseRule(relative) {
		var _a$2, _b$1;
		if (relative === void 0) relative = false;
		var rule = {
			type: "Rule",
			items: []
		};
		if (relative) {
			var combinator = matchMulticharIndex(combinatorsIndex);
			if (combinator) {
				rule.combinator = combinator;
				skipWhitespace();
			}
		}
		while (pos < l$1) if (isTagStart()) {
			assert(rule.items.length === 0, "Unexpected tag/namespace start.");
			rule.items.push(parseTagNameWithNamespace());
		} else if (is$1("|")) {
			var savedPos = pos;
			next$1();
			if (isTagStart()) {
				assert(rule.items.length === 0, "Unexpected tag/namespace start.");
				rewind(savedPos);
				rule.items.push(parseTagNameWithNamespace());
			} else {
				rewind(savedPos);
				break;
			}
		} else if (is$1(".")) {
			assert(classNamesEnabled, "Class names are not enabled.");
			next$1();
			var className$1 = parseIdentifier();
			assert(className$1, "Expected class name.");
			rule.items.push({
				type: "ClassName",
				name: className$1
			});
		} else if (is$1("#")) {
			assert(idEnabled, "IDs are not enabled.");
			next$1();
			var idName = parseIdentifier();
			assert(idName, "Expected ID name.");
			rule.items.push({
				type: "Id",
				name: idName
			});
		} else if (is$1("[")) {
			assert(attributesEnabled, "Attributes are not enabled.");
			rule.items.push(parseAttribute());
		} else if (is$1(":")) {
			var isDoubleColon = false;
			var isPseudoElement = false;
			next$1();
			if (is$1(":")) {
				assert(pseudoElementsEnabled, "Pseudo elements are not enabled.");
				assert(pseudoElementsDoubleColonNotationEnabled, "Pseudo elements double colon notation is not enabled.");
				isDoubleColon = true;
				next$1();
			}
			var pseudoName = parseIdentifier();
			assert(isDoubleColon || pseudoName, "Expected pseudo-class name.");
			assert(!isDoubleColon || pseudoName, "Expected pseudo-element name.");
			assert(pseudoName, "Expected pseudo-class name.");
			if (!isDoubleColon || pseudoElementsAcceptUnknown || Object.prototype.hasOwnProperty.call(pseudoElementsDefinitions, pseudoName)) {} else {
				var locations = pseudoLocationIndex.pseudoElements[pseudoName];
				var errorMessage = "Unknown pseudo-element \"".concat(pseudoName, "\"");
				if (locations && locations.length > 0) errorMessage += ". It is defined in: ".concat(locations.join(", "));
				fail(errorMessage + ".");
			}
			isPseudoElement = pseudoElementsEnabled && (isDoubleColon || !isDoubleColon && pseudoElementsSingleColonNotationEnabled && Object.prototype.hasOwnProperty.call(pseudoElementsDefinitions, pseudoName));
			if (isPseudoElement) {
				var signature = (_a$2 = pseudoElementsDefinitions[pseudoName]) !== null && _a$2 !== void 0 ? _a$2 : pseudoElementsAcceptUnknown && defaultPseudoSignature;
				var pseudoElement = {
					type: "PseudoElement",
					name: pseudoName
				};
				var argument = parsePseudoArgument(pseudoName, "pseudo-element", signature);
				if (argument) {
					assert(argument.type !== "Formula" && argument.type !== "FormulaOfSelector", "Pseudo-elements cannot have formula argument.");
					pseudoElement.argument = argument;
				}
				rule.items.push(pseudoElement);
			} else {
				assert(pseudoClassesEnabled, "Pseudo-classes are not enabled.");
				var signature = (_b$1 = pseudoClassesDefinitions[pseudoName]) !== null && _b$1 !== void 0 ? _b$1 : pseudoClassesAcceptUnknown && defaultPseudoSignature;
				if (signature) {} else {
					var locations = pseudoLocationIndex.pseudoClasses[pseudoName];
					var errorMessage = "Unknown pseudo-class: \"".concat(pseudoName, "\"");
					if (locations && locations.length > 0) errorMessage += ". It is defined in: ".concat(locations.join(", "));
					fail(errorMessage + ".");
				}
				var argument = parsePseudoArgument(pseudoName, "pseudo-class", signature);
				var pseudoClass = {
					type: "PseudoClass",
					name: pseudoName
				};
				if (argument) pseudoClass.argument = argument;
				rule.items.push(pseudoClass);
			}
		} else break;
		if (rule.items.length === 0) if (isEof()) return fail("Expected rule but end of input reached.");
		else return fail("Expected rule but \"".concat(chr, "\" found."));
		skipWhitespace();
		if (!isEof() && !is$1(",") && !is$1(")")) {
			var combinator = matchMulticharIndex(combinatorsIndex);
			skipWhitespace();
			rule.nestedRule = parseRule();
			rule.nestedRule.combinator = combinator;
		}
		return rule;
	}
	return function(input) {
		if (typeof input !== "string") throw new Error("".concat(errorPrefix, "Expected string input."));
		str = input;
		l$1 = str.length;
		pos = 0;
		chr = str.charAt(0);
		return parseSelector$2();
	};
}
const cssSelectorParse = createParser({ syntax: "selectors-4" });
function parse$3(selector) {
	if (typeof selector !== "string") throw new TypeError("Expected `string` as selector, not `" + selector + "`");
	return cssSelectorParse(selector);
}
const rtlRange = "֑-߿יִ-﷽ﹰ-ﻼ";
const ltrRange = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿";
const rtl = new RegExp("^[^" + ltrRange + "]*[֑-߿יִ-﷽ﹰ-ﻼ]");
const ltr = new RegExp("^[^" + rtlRange + "]*[A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿]");
function direction(value) {
	const source = String(value || "");
	return rtl.test(source) ? "rtl" : ltr.test(source) ? "ltr" : "neutral";
}
function enterState(state, node$1) {
	const schema = state.schema;
	const language = state.language;
	const currentDirection = state.direction;
	const editableOrEditingHost = state.editableOrEditingHost;
	let directionInferred;
	if (node$1.type === "element") {
		const lang$1 = node$1.properties.xmlLang || node$1.properties.lang;
		const type = node$1.properties.type || "text";
		const direction$1 = directionProperty(node$1);
		if (lang$1 !== null && lang$1 !== void 0) state.language = String(lang$1);
		if (schema && schema.space === "html") {
			if (node$1.properties.contentEditable === "true") state.editableOrEditingHost = true;
			if (node$1.tagName === "svg") state.schema = svg;
			if (direction$1 === "rtl") directionInferred = direction$1;
			else if (direction$1 === "ltr" || direction$1 !== "auto" && node$1.tagName === "html" || direction$1 !== "auto" && node$1.tagName === "input" && type === "tel") directionInferred = "ltr";
			else if (direction$1 === "auto" || node$1.tagName === "bdi") if (node$1.tagName === "textarea") directionInferred = directionBidi(toString(node$1));
			else if (node$1.tagName === "input" && (type === "email" || type === "search" || type === "tel" || type === "text")) directionInferred = node$1.properties.value ? directionBidi(String(node$1.properties.value)) : "ltr";
			else visit(node$1, inferDirectionality);
			if (directionInferred) state.direction = directionInferred;
		} else if (state.editableOrEditingHost) state.editableOrEditingHost = false;
	}
	return reset;
	function reset() {
		state.schema = schema;
		state.language = language;
		state.direction = currentDirection;
		state.editableOrEditingHost = editableOrEditingHost;
	}
	function inferDirectionality(child) {
		if (child.type === "text") {
			directionInferred = directionBidi(child.value);
			return directionInferred ? EXIT : void 0;
		}
		if (child !== node$1 && child.type === "element" && (child.tagName === "bdi" || child.tagName === "script" || child.tagName === "style" || child.tagName === "textare" || directionProperty(child))) return SKIP;
	}
}
function directionBidi(value) {
	const result = direction(value);
	return result === "neutral" ? void 0 : result;
}
function directionProperty(node$1) {
	const value = node$1.type === "element" && typeof node$1.properties.dir === "string" ? node$1.properties.dir.toLowerCase() : void 0;
	return value === "auto" || value === "ltr" || value === "rtl" ? value : void 0;
}
function ok() {}
function unreachable() {}
function attribute(query, element$5, schema) {
	const info = find(schema, query.name);
	const propertyValue = element$5.properties[info.property];
	let value = normalizeValue(propertyValue, info);
	if (!query.value) return value !== void 0;
	ok(query.value.type === "String", "expected plain string");
	let key = query.value.value;
	if (query.caseSensitivityModifier === "i") {
		key = key.toLowerCase();
		if (value) value = value.toLowerCase();
	}
	if (value !== void 0) switch (query.operator) {
		case "=": return key === value;
		case "$=": return key === value.slice(-key.length);
		case "*=": return value.includes(key);
		case "^=": return key === value.slice(0, key.length);
		case "|=": return key === value || key === value.slice(0, key.length) && value.charAt(key.length) === "-";
		case "~=": return key === value || parse$2(value).includes(key);
	}
	return false;
}
function normalizeValue(value, info) {
	if (value === null || value === void 0) {} else if (typeof value === "boolean") {
		if (value) return info.attribute;
	} else if (Array.isArray(value)) {
		if (value.length > 0) return (info.commaSeparated ? stringify : stringify$1)(value);
	} else return String(value);
}
const emptyClassNames = [];
function className(query, element$5) {
	const value = element$5.properties.className || emptyClassNames;
	return value.includes(query.name);
}
function id(query, element$5) {
	return element$5.properties.id === query.name;
}
function name$1(query, element$5) {
	return query.name === element$5.tagName;
}
function factory(check, filter$1) {
	return function(tags, ranges) {
		let left = cast(tags, "tag");
		const right = cast(ranges === null || ranges === void 0 ? "*" : ranges, "range");
		const matches = [];
		let rightIndex = -1;
		while (++rightIndex < right.length) {
			const range = right[rightIndex].toLowerCase();
			if (!filter$1 && range === "*") continue;
			let leftIndex = -1;
			const next$1 = [];
			while (++leftIndex < left.length) if (check(left[leftIndex].toLowerCase(), range)) {
				if (!filter$1) return left[leftIndex];
				matches.push(left[leftIndex]);
			} else next$1.push(left[leftIndex]);
			left = next$1;
		}
		return filter$1 ? matches : void 0;
	};
}
const basicFilter = factory(function(tag, range) {
	return range === "*" || tag === range || tag.includes(range + "-");
}, true);
const extendedFilter = factory(function(tag, range) {
	const left = tag.split("-");
	const right = range.split("-");
	let leftIndex = 0;
	let rightIndex = 0;
	if (right[rightIndex] !== "*" && left[leftIndex] !== right[rightIndex]) return false;
	leftIndex++;
	rightIndex++;
	while (rightIndex < right.length) {
		if (right[rightIndex] === "*") {
			rightIndex++;
			continue;
		}
		if (!left[leftIndex]) return false;
		if (left[leftIndex] === right[rightIndex]) {
			leftIndex++;
			rightIndex++;
			continue;
		}
		if (left[leftIndex].length === 1) return false;
		leftIndex++;
	}
	return true;
}, true);
const lookup = factory(function(tag, range) {
	let right = range;
	while (true) {
		if (right === "*" || tag === right) return true;
		let index$1 = right.lastIndexOf("-");
		if (index$1 < 0) return false;
		if (right.charAt(index$1 - 2) === "-") index$1 -= 2;
		right = right.slice(0, index$1);
	}
}, false);
function cast(values, name$2) {
	const value = values && typeof values === "string" ? [values] : values;
	if (!value || typeof value !== "object" || !("length" in value)) throw new Error("Invalid " + name$2 + " `" + value + "`, expected non-empty string");
	return value;
}
const own$8 = {}.hasOwnProperty;
function hasProperty(node$1, name$2) {
	const value = node$1.type === "element" && own$8.call(node$1.properties, name$2) && node$1.properties[name$2];
	return value !== null && value !== void 0 && value !== false;
}
const re = /[ \t\n\f\r]/g;
function whitespace(thing) {
	return typeof thing === "object" ? thing.type === "text" ? empty$2(thing.value) : false : empty$2(thing);
}
function empty$2(value) {
	return value.replace(re, "") === "";
}
const whitespace$1 = new Set([
	9,
	10,
	12,
	13,
	32
]);
const ZERO = "0".charCodeAt(0);
const NINE = "9".charCodeAt(0);
function parse$4(formula) {
	formula = formula.trim().toLowerCase();
	if (formula === "even") return [2, 0];
	else if (formula === "odd") return [2, 1];
	let idx = 0;
	let a$1 = 0;
	let sign = readSign();
	let number$2 = readNumber();
	if (idx < formula.length && formula.charAt(idx) === "n") {
		idx++;
		a$1 = sign * (number$2 !== null && number$2 !== void 0 ? number$2 : 1);
		skipWhitespace();
		if (idx < formula.length) {
			sign = readSign();
			skipWhitespace();
			number$2 = readNumber();
		} else sign = number$2 = 0;
	}
	if (number$2 === null || idx < formula.length) throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
	return [a$1, sign * number$2];
	function readSign() {
		if (formula.charAt(idx) === "-") {
			idx++;
			return -1;
		}
		if (formula.charAt(idx) === "+") idx++;
		return 1;
	}
	function readNumber() {
		const start = idx;
		let value = 0;
		while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
			value = value * 10 + (formula.charCodeAt(idx) - ZERO);
			idx++;
		}
		return idx === start ? null : value;
	}
	function skipWhitespace() {
		while (idx < formula.length && whitespace$1.has(formula.charCodeAt(idx))) idx++;
	}
}
var require_boolbase = __commonJSMin((exports, module) => {
	module.exports = {
		trueFunc: function trueFunc() {
			return true;
		},
		falseFunc: function falseFunc() {
			return false;
		}
	};
});
var import_boolbase = __toESM(require_boolbase());
function compile(parsed) {
	const a$1 = parsed[0];
	const b = parsed[1] - 1;
	if (b < 0 && a$1 <= 0) return import_boolbase.default.falseFunc;
	if (a$1 === -1) return (index$1) => index$1 <= b;
	if (a$1 === 0) return (index$1) => index$1 === b;
	if (a$1 === 1) return b < 0 ? import_boolbase.default.trueFunc : (index$1) => index$1 >= b;
	const absA = Math.abs(a$1);
	const bMod = (b % absA + absA) % absA;
	return a$1 > 1 ? (index$1) => index$1 >= b && index$1 % absA === bMod : (index$1) => index$1 <= b && index$1 % absA === bMod;
}
function nthCheck(formula) {
	return compile(parse$4(formula));
}
const own$7 = {}.hasOwnProperty;
function zwitch(key, options) {
	const settings = options || {};
	function one$6(value, ...parameters) {
		let fn = one$6.invalid;
		const handlers$1 = one$6.handlers;
		if (value && own$7.call(value, key)) {
			const id$1 = String(value[key]);
			fn = own$7.call(handlers$1, id$1) ? handlers$1[id$1] : one$6.unknown;
		}
		if (fn) return fn.call(this, value, ...parameters);
	}
	one$6.handlers = settings.handlers || {};
	one$6.invalid = settings.invalid;
	one$6.unknown = settings.unknown;
	return one$6;
}
const nthCheck$1 = nthCheck.default || nthCheck;
const pseudo = zwitch("name", {
	handlers: {
		"any-link": anyLink,
		blank,
		checked,
		dir,
		disabled,
		empty: empty$1,
		enabled,
		"first-child": firstChild,
		"first-of-type": firstOfType,
		has,
		is,
		lang,
		"last-child": lastChild,
		"last-of-type": lastOfType,
		not,
		"nth-child": nthChild,
		"nth-last-child": nthLastChild,
		"nth-last-of-type": nthLastOfType,
		"nth-of-type": nthOfType,
		"only-child": onlyChild,
		"only-of-type": onlyOfType,
		optional,
		"read-only": readOnly,
		"read-write": readWrite,
		required,
		root: root$5,
		scope
	},
	invalid: invalidPseudo,
	unknown: unknownPseudo
});
function anyLink(_$1, element$5) {
	return (element$5.tagName === "a" || element$5.tagName === "area" || element$5.tagName === "link") && hasProperty(element$5, "href");
}
function assertDeep(state, query) {
	if (state.shallow) throw new Error("Cannot use `:" + query.name + "` without parent");
}
function blank(_$1, element$5) {
	return !someChildren(element$5, check);
	function check(child) {
		return child.type === "element" || child.type === "text" && !whitespace(child);
	}
}
function checked(_$1, element$5) {
	if (element$5.tagName === "input" || element$5.tagName === "menuitem") return Boolean((element$5.properties.type === "checkbox" || element$5.properties.type === "radio") && hasProperty(element$5, "checked"));
	if (element$5.tagName === "option") return hasProperty(element$5, "selected");
	return false;
}
function dir(query, _1, _2, _3, state) {
	ok(query.argument, "expected `argument`");
	ok(query.argument.type === "String", "expected plain text");
	return state.direction === query.argument.value;
}
function disabled(_$1, element$5) {
	return (element$5.tagName === "button" || element$5.tagName === "input" || element$5.tagName === "select" || element$5.tagName === "textarea" || element$5.tagName === "optgroup" || element$5.tagName === "option" || element$5.tagName === "menuitem" || element$5.tagName === "fieldset") && hasProperty(element$5, "disabled");
}
function empty$1(_$1, element$5) {
	return !someChildren(element$5, check);
	function check(child) {
		return child.type === "element" || child.type === "text";
	}
}
function enabled(query, element$5) {
	return !disabled(query, element$5);
}
function firstChild(query, _1, _2, _3, state) {
	assertDeep(state, query);
	return state.elementIndex === 0;
}
function firstOfType(query, _1, _2, _3, state) {
	assertDeep(state, query);
	return state.typeIndex === 0;
}
function getCachedNthCheck(query) {
	let cachedFunction = query._cachedFn;
	if (!cachedFunction) {
		const value = query.argument;
		ok(value, "expected `argument`");
		if (value.type !== "Formula") throw new Error("Expected `nth` formula, such as `even` or `2n+1` (`of` is not yet supported)");
		cachedFunction = nthCheck$1(value.a + "n+" + value.b);
		query._cachedFn = cachedFunction;
	}
	return cachedFunction;
}
function has(query, element$5, _1, _2, state) {
	ok(query.argument, "expected `argument`");
	ok(query.argument.type === "Selector", "expected selector");
	const childState = {
		...state,
		found: false,
		one: true,
		results: [],
		rootQuery: query.argument,
		scopeElements: [element$5],
		shallow: false
	};
	walk(childState, {
		type: "root",
		children: element$5.children
	});
	return childState.results.length > 0;
}
function invalidPseudo() {
	unreachable("Invalid pseudo-selector");
}
function is(query, element$5, _1, _2, state) {
	ok(query.argument, "expected `argument`");
	ok(query.argument.type === "Selector", "expected selector");
	const childState = {
		...state,
		found: false,
		one: true,
		results: [],
		rootQuery: query.argument,
		scopeElements: [element$5],
		shallow: false
	};
	walk(childState, element$5);
	return childState.results[0] === element$5;
}
function lang(query, _1, _2, _3, state) {
	ok(query.argument, "expected `argument`");
	ok(query.argument.type === "String", "expected string");
	return state.language !== "" && state.language !== void 0 && extendedFilter(state.language, parse$1(query.argument.value)).length > 0;
}
function lastChild(query, _1, _2, _3, state) {
	assertDeep(state, query);
	return Boolean(state.elementCount && state.elementIndex === state.elementCount - 1);
}
function lastOfType(query, _1, _2, _3, state) {
	assertDeep(state, query);
	return typeof state.typeIndex === "number" && typeof state.typeCount === "number" && state.typeIndex === state.typeCount - 1;
}
function not(query, element$5, index$1, parent$1, state) {
	return !is(query, element$5, index$1, parent$1, state);
}
function nthChild(query, _1, _2, _3, state) {
	const cachedFunction = getCachedNthCheck(query);
	assertDeep(state, query);
	return typeof state.elementIndex === "number" && cachedFunction(state.elementIndex);
}
function nthLastChild(query, _1, _2, _3, state) {
	const cachedFunction = getCachedNthCheck(query);
	assertDeep(state, query);
	return Boolean(typeof state.elementCount === "number" && typeof state.elementIndex === "number" && cachedFunction(state.elementCount - state.elementIndex - 1));
}
function nthLastOfType(query, _1, _2, _3, state) {
	const cachedFunction = getCachedNthCheck(query);
	assertDeep(state, query);
	return typeof state.typeCount === "number" && typeof state.typeIndex === "number" && cachedFunction(state.typeCount - 1 - state.typeIndex);
}
function nthOfType(query, _1, _2, _3, state) {
	const cachedFunction = getCachedNthCheck(query);
	assertDeep(state, query);
	return typeof state.typeIndex === "number" && cachedFunction(state.typeIndex);
}
function onlyChild(query, _1, _2, _3, state) {
	assertDeep(state, query);
	return state.elementCount === 1;
}
function onlyOfType(query, _1, _2, _3, state) {
	assertDeep(state, query);
	return state.typeCount === 1;
}
function optional(query, element$5) {
	return !required(query, element$5);
}
function readOnly(query, element$5, index$1, parent$1, state) {
	return !readWrite(query, element$5, index$1, parent$1, state);
}
function readWrite(_$1, element$5, _1, _2, state) {
	return element$5.tagName === "input" || element$5.tagName === "textarea" ? !hasProperty(element$5, "readOnly") && !hasProperty(element$5, "disabled") : Boolean(state.editableOrEditingHost);
}
function required(_$1, element$5) {
	return (element$5.tagName === "input" || element$5.tagName === "textarea" || element$5.tagName === "select") && hasProperty(element$5, "required");
}
function root$5(_1, element$5, _2, parent$1, state) {
	return Boolean((!parent$1 || parent$1.type === "root") && state.schema && (state.schema.space === "html" || state.schema.space === "svg") && (element$5.tagName === "html" || element$5.tagName === "svg"));
}
function scope(_1, element$5, _2, _3, state) {
	return state.scopeElements.includes(element$5);
}
function someChildren(element$5, check) {
	const children = element$5.children;
	let index$1 = -1;
	while (++index$1 < children.length) if (check(children[index$1])) return true;
	return false;
}
function unknownPseudo(query_) {
	const query = query_;
	throw new Error("Unknown pseudo-selector `" + query.name + "`");
}
function test(query, element$5, index$1, parent$1, state) {
	for (const item of query.items) if (item.type === "Attribute") {
		if (!attribute(item, element$5, state.schema)) return false;
	} else if (item.type === "Id") {
		if (!id(item, element$5)) return false;
	} else if (item.type === "ClassName") {
		if (!className(item, element$5)) return false;
	} else if (item.type === "PseudoClass") {
		if (!pseudo(item, element$5, index$1, parent$1, state)) return false;
	} else if (item.type === "PseudoElement") throw new Error("Invalid selector: `::" + item.name + "`");
	else if (item.type === "TagName") {
		if (!name$1(item, element$5)) return false;
	}
	return true;
}
const empty = [];
function walk(state, tree) {
	if (tree) one$4(state, [], tree, void 0, void 0, tree);
}
function add(nest, field, rule) {
	const list$3 = nest[field];
	if (list$3) list$3.push(rule);
	else nest[field] = [rule];
}
function all$4(state, nest, node$1, tree) {
	const fromParent = combine(nest.descendant, nest.directChild);
	let fromSibling;
	let index$1 = -1;
	const total = {
		count: 0,
		types: new Map()
	};
	const before = {
		count: 0,
		types: new Map()
	};
	while (++index$1 < node$1.children.length) count(total, node$1.children[index$1]);
	index$1 = -1;
	while (++index$1 < node$1.children.length) {
		const child = node$1.children[index$1];
		const name$2 = child.type === "element" ? child.tagName.toUpperCase() : void 0;
		state.elementIndex = before.count;
		state.typeIndex = name$2 ? before.types.get(name$2) || 0 : 0;
		state.elementCount = total.count;
		state.typeCount = name$2 ? total.types.get(name$2) : 0;
		if ("children" in child) {
			const forSibling = combine(fromParent, fromSibling);
			const nest$1 = one$4(state, forSibling, node$1.children[index$1], index$1, node$1, tree);
			fromSibling = combine(nest$1.generalSibling, nest$1.adjacentSibling);
		}
		if (state.one && state.found) break;
		count(before, node$1.children[index$1]);
	}
}
function applySelectors(state, rules, node$1, index$1, parent$1) {
	const nestResult = {
		adjacentSibling: void 0,
		descendant: void 0,
		directChild: void 0,
		generalSibling: void 0
	};
	let selectorIndex = -1;
	while (++selectorIndex < rules.length) {
		const rule = rules[selectorIndex];
		if (state.one && state.found) break;
		if (state.shallow && rule.nestedRule) throw new Error("Expected selector without nesting");
		if (test(rule, node$1, index$1, parent$1, state)) {
			const nest = rule.nestedRule;
			if (nest) {
				const label = nest.combinator === "+" ? "adjacentSibling" : nest.combinator === "~" ? "generalSibling" : nest.combinator === ">" ? "directChild" : "descendant";
				add(nestResult, label, nest);
			} else {
				state.found = true;
				if (!state.results.includes(node$1)) state.results.push(node$1);
			}
		}
		if (rule.combinator === void 0) add(nestResult, "descendant", rule);
		else if (rule.combinator === "~") add(nestResult, "generalSibling", rule);
	}
	return nestResult;
}
function combine(left, right) {
	return left && right && left.length > 0 && right.length > 0 ? [...left, ...right] : left && left.length > 0 ? left : right && right.length > 0 ? right : empty;
}
function count(counts, node$1) {
	if (node$1.type === "element") {
		const name$2 = node$1.tagName.toUpperCase();
		const count$1 = (counts.types.get(name$2) || 0) + 1;
		counts.count++;
		counts.types.set(name$2, count$1);
	}
}
function one$4(state, currentRules, node$1, index$1, parent$1, tree) {
	let nestResult = {
		adjacentSibling: void 0,
		descendant: void 0,
		directChild: void 0,
		generalSibling: void 0
	};
	const exit$2 = enterState(state, node$1);
	if (node$1.type === "element") {
		let rootRules = state.rootQuery.rules;
		if (parent$1 && parent$1 !== tree) rootRules = state.rootQuery.rules.filter((d$1) => d$1.combinator === void 0 || d$1.combinator === ">" && parent$1 === tree);
		nestResult = applySelectors(state, combine(currentRules, rootRules), node$1, index$1, parent$1);
	}
	if ("children" in node$1 && !state.shallow && !(state.one && state.found)) all$4(state, nestResult, node$1, tree);
	exit$2();
	return nestResult;
}
function selectAll(selector, tree, space$1) {
	const state = createState$1(selector, tree, space$1);
	walk(state, tree || void 0);
	return state.results;
}
function createState$1(selector, tree, space$1) {
	return {
		direction: "ltr",
		editableOrEditingHost: false,
		elementCount: void 0,
		elementIndex: void 0,
		found: false,
		language: void 0,
		one: false,
		results: [],
		rootQuery: parse$3(selector),
		schema: space$1 === "svg" ? svg : html$2,
		scopeElements: tree ? tree.type === "root" ? tree.children : [tree] : [],
		shallow: false,
		typeIndex: void 0,
		typeCount: void 0
	};
}
const getCodeString = (data = [], code$3 = "") => {
	data.forEach((node$1) => {
		if (node$1.type === "text") code$3 += node$1.value;
		else if (node$1.type === "element" && node$1.children && Array.isArray(node$1.children)) code$3 += getCodeString(node$1.children);
	});
	return code$3;
};
const remarkRewrite = (options) => {
	const { selector, rewrite } = options || {};
	return (tree) => {
		if (!rewrite || typeof rewrite !== "function") return;
		if (selector && typeof selector === "string") {
			const selected = selectAll(selector, tree);
			if (selected && selected.length > 0) visit(tree, selected, (node$1, index$1, parent$1) => {
				rewrite(node$1, index$1, parent$1);
			});
			return;
		}
		visit(tree, (node$1, index$1, parent$1) => {
			rewrite(node$1, index$1, parent$1);
		});
	};
};
var lib_default = remarkRewrite;
const getURLParameters = (url = "") => (url.match(/([^?=&]+)(=([^&]*))/g) || []).reduce((a$1, v$1) => (a$1[v$1.slice(0, v$1.indexOf("="))] = v$1.slice(v$1.indexOf("=") + 1), a$1), {});
const prevChild = (data = [], index$1) => {
	let i = index$1;
	while (i > -1) {
		i--;
		if (!data[i]) return;
		if (data[i] && data[i].value && data[i].value.replace(/(\n|\s)/g, "") !== "" || data[i].type !== "text") {
			if (!/^rehype:/.test(data[i].value) || data[i].type !== "comment") return;
			return data[i];
		}
	}
	return;
};
const nextChild = (data = [], index$1, tagName, codeBlockParames) => {
	let i = index$1;
	while (i < data.length) {
		i++;
		if (tagName) {
			const element$5 = data[i];
			if (element$5 && element$5.value && element$5.value.replace(/(\n|\s)/g, "") !== "" || data[i] && data[i].type === "element") return element$5.tagName === tagName ? element$5 : void 0;
		} else {
			const element$5 = data[i];
			if (!element$5 || element$5.type === "element") return;
			if (element$5.type === "text" && element$5.value.replace(/(\n|\s)/g, "") !== "") return;
			if (element$5.type && /^(comment|raw)$/gi.test(element$5.type)) {
				if (element$5.value && !/^rehype:/.test(element$5.value.replace(/^(\s+)?<!--(.*?)-->/, "$2") || "")) return;
				if (codeBlockParames) {
					const nextNode = nextChild(data, i, "pre", codeBlockParames);
					if (nextNode) return;
					element$5.value = (element$5.value || "").replace(/^(\n|\s)+/, "");
					return element$5;
				} else {
					element$5.value = (element$5.value || "").replace(/^(\n|\s)+/, "");
					return element$5;
				}
			}
		}
	}
	return;
};
const getCommentObject = ({ value = "" }) => {
	const param = getURLParameters(value.replace(/^<!--(.*?)-->/, "$1").replace(/^rehype:/, ""));
	Object.keys(param).forEach((keyName) => {
		if (param[keyName] === "true") param[keyName] = true;
		if (param[keyName] === "false") param[keyName] = false;
		if (typeof param[keyName] === "string" && !/^0/.test(param[keyName]) && !isNaN(+param[keyName])) param[keyName] = +param[keyName];
	});
	return param;
};
const propertiesHandle = (defaultAttrs, attrs, type) => {
	if (type === "string") return {
		...defaultAttrs,
		"data-config": JSON.stringify({
			...attrs,
			rehyp: true
		})
	};
	else if (type === "attr") return {
		...defaultAttrs,
		...attrs
	};
	return {
		...defaultAttrs,
		"data-config": {
			...attrs,
			rehyp: true
		}
	};
};
const rehypeAttrs = (options = {}) => {
	const { properties: properties$1 = "data", codeBlockParames = true } = options;
	return (tree) => {
		visit(tree, "element", (node$1, index$1, parent$1) => {
			if (codeBlockParames && node$1.tagName === "pre" && node$1 && Array.isArray(node$1.children) && parent$1 && Array.isArray(parent$1.children) && parent$1.children.length > 1) {
				const firstChild$1 = node$1.children[0];
				if (firstChild$1 && firstChild$1.tagName === "code" && typeof index$1 === "number") {
					const child = prevChild(parent$1.children, index$1);
					if (child) {
						const attr = getCommentObject(child);
						if (Object.keys(attr).length > 0) {
							node$1.properties = {
								...node$1.properties,
								"data-type": "rehyp"
							};
							firstChild$1.properties = propertiesHandle(firstChild$1.properties, attr, properties$1);
						}
					}
				}
			}
			if (/^(em|strong|b|a|i|p|pre|kbd|blockquote|h(1|2|3|4|5|6)|code|table|img|del|ul|ol)$/.test(node$1.tagName) && parent$1 && Array.isArray(parent$1.children) && typeof index$1 === "number") {
				const child = nextChild(parent$1.children, index$1, "", codeBlockParames);
				if (child) {
					const attr = getCommentObject(child);
					if (Object.keys(attr).length > 0) node$1.properties = propertiesHandle(node$1.properties, attr, properties$1);
				}
			}
		});
	};
};
var lib_default$1 = rehypeAttrs;
const VOID = -1;
const PRIMITIVE = 0;
const ARRAY = 1;
const OBJECT = 2;
const DATE = 3;
const REGEXP = 4;
const MAP = 5;
const SET = 6;
const ERROR = 7;
const BIGINT = 8;
const env = typeof self === "object" ? self : globalThis;
const deserializer = ($$1, _$1) => {
	const as = (out, index$1) => {
		$$1.set(index$1, out);
		return out;
	};
	const unpair = (index$1) => {
		if ($$1.has(index$1)) return $$1.get(index$1);
		const [type, value] = _$1[index$1];
		switch (type) {
			case PRIMITIVE:
			case VOID: return as(value, index$1);
			case ARRAY: {
				const arr = as([], index$1);
				for (const index$2 of value) arr.push(unpair(index$2));
				return arr;
			}
			case OBJECT: {
				const object = as({}, index$1);
				for (const [key, index$2] of value) object[unpair(key)] = unpair(index$2);
				return object;
			}
			case DATE: return as(new Date(value), index$1);
			case REGEXP: {
				const { source, flags } = value;
				return as(new RegExp(source, flags), index$1);
			}
			case MAP: {
				const map$2 = as(new Map(), index$1);
				for (const [key, index$2] of value) map$2.set(unpair(key), unpair(index$2));
				return map$2;
			}
			case SET: {
				const set = as(new Set(), index$1);
				for (const index$2 of value) set.add(unpair(index$2));
				return set;
			}
			case ERROR: {
				const { name: name$2, message } = value;
				return as(new env[name$2](message), index$1);
			}
			case BIGINT: return as(BigInt(value), index$1);
			case "BigInt": return as(Object(BigInt(value)), index$1);
			case "ArrayBuffer": return as(new Uint8Array(value).buffer, value);
			case "DataView": {
				const { buffer } = new Uint8Array(value);
				return as(new DataView(buffer), value);
			}
		}
		return as(new env[type](value), index$1);
	};
	return unpair;
};
const deserialize = (serialized) => deserializer(new Map(), serialized)(0);
const EMPTY = "";
const { toString: toString$2 } = {};
const { keys } = Object;
const typeOf = (value) => {
	const type = typeof value;
	if (type !== "object" || !value) return [PRIMITIVE, type];
	const asString = toString$2.call(value).slice(8, -1);
	switch (asString) {
		case "Array": return [ARRAY, EMPTY];
		case "Object": return [OBJECT, EMPTY];
		case "Date": return [DATE, EMPTY];
		case "RegExp": return [REGEXP, EMPTY];
		case "Map": return [MAP, EMPTY];
		case "Set": return [SET, EMPTY];
		case "DataView": return [ARRAY, asString];
	}
	if (asString.includes("Array")) return [ARRAY, asString];
	if (asString.includes("Error")) return [ERROR, asString];
	return [OBJECT, asString];
};
const shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
const serializer = (strict, json$1, $$1, _$1) => {
	const as = (out, value) => {
		const index$1 = _$1.push(out) - 1;
		$$1.set(value, index$1);
		return index$1;
	};
	const pair = (value) => {
		if ($$1.has(value)) return $$1.get(value);
		let [TYPE, type] = typeOf(value);
		switch (TYPE) {
			case PRIMITIVE: {
				let entry = value;
				switch (type) {
					case "bigint":
						TYPE = BIGINT;
						entry = value.toString();
						break;
					case "function":
					case "symbol":
						if (strict) throw new TypeError("unable to serialize " + type);
						entry = null;
						break;
					case "undefined": return as([VOID], value);
				}
				return as([TYPE, entry], value);
			}
			case ARRAY: {
				if (type) {
					let spread = value;
					if (type === "DataView") spread = new Uint8Array(value.buffer);
					else if (type === "ArrayBuffer") spread = new Uint8Array(value);
					return as([type, [...spread]], value);
				}
				const arr = [];
				const index$1 = as([TYPE, arr], value);
				for (const entry of value) arr.push(pair(entry));
				return index$1;
			}
			case OBJECT: {
				if (type) switch (type) {
					case "BigInt": return as([type, value.toString()], value);
					case "Boolean":
					case "Number":
					case "String": return as([type, value.valueOf()], value);
				}
				if (json$1 && "toJSON" in value) return pair(value.toJSON());
				const entries = [];
				const index$1 = as([TYPE, entries], value);
				for (const key of keys(value)) if (strict || !shouldSkip(typeOf(value[key]))) entries.push([pair(key), pair(value[key])]);
				return index$1;
			}
			case DATE: return as([TYPE, value.toISOString()], value);
			case REGEXP: {
				const { source, flags } = value;
				return as([TYPE, {
					source,
					flags
				}], value);
			}
			case MAP: {
				const entries = [];
				const index$1 = as([TYPE, entries], value);
				for (const [key, entry] of value) if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry)))) entries.push([pair(key), pair(entry)]);
				return index$1;
			}
			case SET: {
				const entries = [];
				const index$1 = as([TYPE, entries], value);
				for (const entry of value) if (strict || !shouldSkip(typeOf(entry))) entries.push(pair(entry));
				return index$1;
			}
		}
		const { message } = value;
		return as([TYPE, {
			name: type,
			message
		}], value);
	};
	return pair;
};
const serialize$1 = (value, { json: json$1, lossy } = {}) => {
	const _$1 = [];
	return serializer(!(json$1 || lossy), !!json$1, new Map(), _$1)(value), _$1;
};
var esm_default$1 = typeof structuredClone === "function" ? (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize$1(any, options)) : structuredClone(any) : (any, options) => deserialize(serialize$1(any, options));
const search$1 = /[#.]/g;
function parseSelector(selector, defaultTagName) {
	const value = selector || "";
	const props = {};
	let start = 0;
	let previous$2;
	let tagName;
	while (start < value.length) {
		search$1.lastIndex = start;
		const match = search$1.exec(value);
		const subvalue = value.slice(start, match ? match.index : value.length);
		if (subvalue) {
			if (!previous$2) tagName = subvalue;
			else if (previous$2 === "#") props.id = subvalue;
			else if (Array.isArray(props.className)) props.className.push(subvalue);
			else props.className = [subvalue];
			start += subvalue.length;
		}
		if (match) {
			previous$2 = match[0];
			start++;
		}
	}
	return {
		type: "element",
		tagName: tagName || defaultTagName || "div",
		properties: props,
		children: []
	};
}
function createH(schema, defaultTagName, caseSensitive) {
	const adjust = caseSensitive ? createAdjustMap(caseSensitive) : void 0;
	function h$2(selector, properties$1, ...children) {
		let node$1;
		if (selector === null || selector === void 0) {
			node$1 = {
				type: "root",
				children: []
			};
			const child = properties$1;
			children.unshift(child);
		} else {
			node$1 = parseSelector(selector, defaultTagName);
			const lower = node$1.tagName.toLowerCase();
			const adjusted = adjust ? adjust.get(lower) : void 0;
			node$1.tagName = adjusted || lower;
			if (isChild(properties$1)) children.unshift(properties$1);
			else for (const [key, value] of Object.entries(properties$1)) addProperty(schema, node$1.properties, key, value);
		}
		for (const child of children) addChild(node$1.children, child);
		if (node$1.type === "element" && node$1.tagName === "template") {
			node$1.content = {
				type: "root",
				children: node$1.children
			};
			node$1.children = [];
		}
		return node$1;
	}
	return h$2;
}
function isChild(value) {
	if (value === null || typeof value !== "object" || Array.isArray(value)) return true;
	if (typeof value.type !== "string") return false;
	const record = value;
	const keys$1 = Object.keys(value);
	for (const key of keys$1) {
		const value$1 = record[key];
		if (value$1 && typeof value$1 === "object") {
			if (!Array.isArray(value$1)) return true;
			const list$3 = value$1;
			for (const item of list$3) if (typeof item !== "number" && typeof item !== "string") return true;
		}
	}
	if ("children" in value && Array.isArray(value.children)) return true;
	return false;
}
function addProperty(schema, properties$1, key, value) {
	const info = find(schema, key);
	let result;
	if (value === null || value === void 0) return;
	if (typeof value === "number") {
		if (Number.isNaN(value)) return;
		result = value;
	} else if (typeof value === "boolean") result = value;
	else if (typeof value === "string") if (info.spaceSeparated) result = parse$2(value);
	else if (info.commaSeparated) result = parse$1(value);
	else if (info.commaOrSpaceSeparated) result = parse$2(parse$1(value).join(" "));
	else result = parsePrimitive(info, info.property, value);
	else if (Array.isArray(value)) result = [...value];
	else result = info.property === "style" ? style(value) : String(value);
	if (Array.isArray(result)) {
		const finalResult = [];
		for (const item of result) finalResult.push(parsePrimitive(info, info.property, item));
		result = finalResult;
	}
	if (info.property === "className" && Array.isArray(properties$1.className)) result = properties$1.className.concat(result);
	properties$1[info.property] = result;
}
function addChild(nodes, value) {
	if (value === null || value === void 0) {} else if (typeof value === "number" || typeof value === "string") nodes.push({
		type: "text",
		value: String(value)
	});
	else if (Array.isArray(value)) for (const child of value) addChild(nodes, child);
	else if (typeof value === "object" && "type" in value) if (value.type === "root") addChild(nodes, value.children);
	else nodes.push(value);
	else throw new Error("Expected node, nodes, or string, got `" + value + "`");
}
function parsePrimitive(info, name$2, value) {
	if (typeof value === "string") {
		if (info.number && value && !Number.isNaN(Number(value))) return Number(value);
		if ((info.boolean || info.overloadedBoolean) && (value === "" || normalize(value) === normalize(name$2))) return true;
	}
	return value;
}
function style(styles) {
	const result = [];
	for (const [key, value] of Object.entries(styles)) result.push([key, value].join(": "));
	return result.join("; ");
}
function createAdjustMap(values) {
	const result = new Map();
	for (const value of values) result.set(value.toLowerCase(), value);
	return result;
}
const svgCaseSensitiveTagNames = [
	"altGlyph",
	"altGlyphDef",
	"altGlyphItem",
	"animateColor",
	"animateMotion",
	"animateTransform",
	"clipPath",
	"feBlend",
	"feColorMatrix",
	"feComponentTransfer",
	"feComposite",
	"feConvolveMatrix",
	"feDiffuseLighting",
	"feDisplacementMap",
	"feDistantLight",
	"feDropShadow",
	"feFlood",
	"feFuncA",
	"feFuncB",
	"feFuncG",
	"feFuncR",
	"feGaussianBlur",
	"feImage",
	"feMerge",
	"feMergeNode",
	"feMorphology",
	"feOffset",
	"fePointLight",
	"feSpecularLighting",
	"feSpotLight",
	"feTile",
	"feTurbulence",
	"foreignObject",
	"glyphRef",
	"linearGradient",
	"radialGradient",
	"solidColor",
	"textArea",
	"textPath"
];
const h = createH(html$2, "div");
const s = createH(svg, "g", svgCaseSensitiveTagNames);
function location(file) {
	const value = String(file);
	const indices = [];
	return {
		toOffset,
		toPoint
	};
	function toPoint(offset) {
		if (typeof offset === "number" && offset > -1 && offset <= value.length) {
			let index$1 = 0;
			while (true) {
				let end = indices[index$1];
				if (end === void 0) {
					const eol = next(value, indices[index$1 - 1]);
					end = eol === -1 ? value.length + 1 : eol + 1;
					indices[index$1] = end;
				}
				if (end > offset) return {
					line: index$1 + 1,
					column: offset - (index$1 > 0 ? indices[index$1 - 1] : 0) + 1,
					offset
				};
				index$1++;
			}
		}
	}
	function toOffset(point$4) {
		if (point$4 && typeof point$4.line === "number" && typeof point$4.column === "number" && !Number.isNaN(point$4.line) && !Number.isNaN(point$4.column)) {
			while (indices.length < point$4.line) {
				const from = indices[indices.length - 1];
				const eol = next(value, from);
				const end = eol === -1 ? value.length + 1 : eol + 1;
				if (from === end) break;
				indices.push(end);
			}
			const offset = (point$4.line > 1 ? indices[point$4.line - 2] : 0) + point$4.column - 1;
			if (offset < indices[point$4.line - 1]) return offset;
		}
	}
}
function next(value, from) {
	const cr = value.indexOf("\r", from);
	const lf = value.indexOf("\n", from);
	if (lf === -1) return cr;
	if (cr === -1 || cr + 1 === lf) return lf;
	return cr < lf ? cr : lf;
}
const webNamespaces = {
	html: "http://www.w3.org/1999/xhtml",
	mathml: "http://www.w3.org/1998/Math/MathML",
	svg: "http://www.w3.org/2000/svg",
	xlink: "http://www.w3.org/1999/xlink",
	xml: "http://www.w3.org/XML/1998/namespace",
	xmlns: "http://www.w3.org/2000/xmlns/"
};
const own$6 = {}.hasOwnProperty;
const proto = Object.prototype;
function fromParse5(tree, options) {
	const settings = options || {};
	return one$3({
		file: settings.file || void 0,
		location: false,
		schema: settings.space === "svg" ? svg : html$2,
		verbose: settings.verbose || false
	}, tree);
}
function one$3(state, node$1) {
	let result;
	switch (node$1.nodeName) {
		case "#comment": {
			const reference = node$1;
			result = {
				type: "comment",
				value: reference.data
			};
			patch$2(state, reference, result);
			return result;
		}
		case "#document":
		case "#document-fragment": {
			const reference = node$1;
			const quirksMode = "mode" in reference ? reference.mode === "quirks" || reference.mode === "limited-quirks" : false;
			result = {
				type: "root",
				children: all$3(state, node$1.childNodes),
				data: { quirksMode }
			};
			if (state.file && state.location) {
				const document$3 = String(state.file);
				const loc = location(document$3);
				const start = loc.toPoint(0);
				const end = loc.toPoint(document$3.length);
				ok(start, "expected `start`");
				ok(end, "expected `end`");
				result.position = {
					start,
					end
				};
			}
			return result;
		}
		case "#documentType": {
			const reference = node$1;
			result = { type: "doctype" };
			patch$2(state, reference, result);
			return result;
		}
		case "#text": {
			const reference = node$1;
			result = {
				type: "text",
				value: reference.value
			};
			patch$2(state, reference, result);
			return result;
		}
		default: {
			const reference = node$1;
			result = element$4(state, reference);
			return result;
		}
	}
}
function all$3(state, nodes) {
	let index$1 = -1;
	const results = [];
	while (++index$1 < nodes.length) {
		const result = one$3(state, nodes[index$1]);
		results.push(result);
	}
	return results;
}
function element$4(state, node$1) {
	const schema = state.schema;
	state.schema = node$1.namespaceURI === webNamespaces.svg ? svg : html$2;
	let index$1 = -1;
	const properties$1 = {};
	while (++index$1 < node$1.attrs.length) {
		const attribute$1 = node$1.attrs[index$1];
		const name$2 = (attribute$1.prefix ? attribute$1.prefix + ":" : "") + attribute$1.name;
		if (!own$6.call(proto, name$2)) properties$1[name$2] = attribute$1.value;
	}
	const x = state.schema.space === "svg" ? s : h;
	const result = x(node$1.tagName, properties$1, all$3(state, node$1.childNodes));
	patch$2(state, node$1, result);
	if (result.tagName === "template") {
		const reference = node$1;
		const pos = reference.sourceCodeLocation;
		const startTag$1 = pos && pos.startTag && position$2(pos.startTag);
		const endTag$1 = pos && pos.endTag && position$2(pos.endTag);
		const content$2 = one$3(state, reference.content);
		if (startTag$1 && endTag$1 && state.file) content$2.position = {
			start: startTag$1.end,
			end: endTag$1.start
		};
		result.content = content$2;
	}
	state.schema = schema;
	return result;
}
function patch$2(state, from, to) {
	if ("sourceCodeLocation" in from && from.sourceCodeLocation && state.file) {
		const position$3 = createLocation(state, to, from.sourceCodeLocation);
		if (position$3) {
			state.location = true;
			to.position = position$3;
		}
	}
}
function createLocation(state, node$1, location$1) {
	const result = position$2(location$1);
	if (node$1.type === "element") {
		const tail = node$1.children[node$1.children.length - 1];
		if (result && !location$1.endTag && tail && tail.position && tail.position.end) result.end = Object.assign({}, tail.position.end);
		if (state.verbose) {
			const properties$1 = {};
			let key;
			if (location$1.attrs) {
				for (key in location$1.attrs) if (own$6.call(location$1.attrs, key)) properties$1[find(state.schema, key).property] = position$2(location$1.attrs[key]);
			}
			ok(location$1.startTag, "a start tag should exist");
			const opening = position$2(location$1.startTag);
			const closing = location$1.endTag ? position$2(location$1.endTag) : void 0;
			const data = { opening };
			if (closing) data.closing = closing;
			data.properties = properties$1;
			node$1.data = { position: data };
		}
	}
	return result;
}
function position$2(loc) {
	const start = point$3({
		line: loc.startLine,
		column: loc.startCol,
		offset: loc.startOffset
	});
	const end = point$3({
		line: loc.endLine,
		column: loc.endCol,
		offset: loc.endOffset
	});
	return start || end ? {
		start,
		end
	} : void 0;
}
function point$3(point$4) {
	return point$4.line && point$4.column ? point$4 : void 0;
}
const emptyOptions$6 = {};
const own$5 = {}.hasOwnProperty;
const one$2 = zwitch("type", { handlers: {
	root: root$4,
	element: element$3,
	text: text$7,
	comment: comment$1,
	doctype: doctype$1
} });
function toParse5(tree, options) {
	const settings = options || emptyOptions$6;
	const space$1 = settings.space;
	return one$2(tree, space$1 === "svg" ? svg$1 : html$3);
}
function root$4(node$1, schema) {
	const result = {
		nodeName: "#document",
		mode: (node$1.data || {}).quirksMode ? "quirks" : "no-quirks",
		childNodes: []
	};
	result.childNodes = all$2(node$1.children, result, schema);
	patch$1(node$1, result);
	return result;
}
function fragment(node$1, schema) {
	const result = {
		nodeName: "#document-fragment",
		childNodes: []
	};
	result.childNodes = all$2(node$1.children, result, schema);
	patch$1(node$1, result);
	return result;
}
function doctype$1(node$1) {
	const result = {
		nodeName: "#documentType",
		name: "html",
		publicId: "",
		systemId: "",
		parentNode: null
	};
	patch$1(node$1, result);
	return result;
}
function text$7(node$1) {
	const result = {
		nodeName: "#text",
		value: node$1.value,
		parentNode: null
	};
	patch$1(node$1, result);
	return result;
}
function comment$1(node$1) {
	const result = {
		nodeName: "#comment",
		data: node$1.value,
		parentNode: null
	};
	patch$1(node$1, result);
	return result;
}
function element$3(node$1, schema) {
	const parentSchema = schema;
	let currentSchema = parentSchema;
	if (node$1.type === "element" && node$1.tagName.toLowerCase() === "svg" && parentSchema.space === "html") currentSchema = svg$1;
	const attrs = [];
	let prop;
	if (node$1.properties) {
		for (prop in node$1.properties) if (prop !== "children" && own$5.call(node$1.properties, prop)) {
			const result$1 = createProperty$1(currentSchema, prop, node$1.properties[prop]);
			if (result$1) attrs.push(result$1);
		}
	}
	const space$1 = currentSchema.space;
	ok(space$1);
	const result = {
		nodeName: node$1.tagName,
		tagName: node$1.tagName,
		attrs,
		namespaceURI: webNamespaces[space$1],
		childNodes: [],
		parentNode: null
	};
	result.childNodes = all$2(node$1.children, result, currentSchema);
	patch$1(node$1, result);
	if (node$1.tagName === "template" && node$1.content) result.content = fragment(node$1.content, currentSchema);
	return result;
}
function createProperty$1(schema, prop, value) {
	const info = find$1(schema, prop);
	if (value === false || value === null || value === void 0 || typeof value === "number" && Number.isNaN(value) || !value && info.boolean) return;
	if (Array.isArray(value)) value = info.commaSeparated ? stringify(value) : stringify$1(value);
	const attribute$1 = {
		name: info.attribute,
		value: value === true ? "" : String(value)
	};
	if (info.space && info.space !== "html" && info.space !== "svg") {
		const index$1 = attribute$1.name.indexOf(":");
		if (index$1 < 0) attribute$1.prefix = "";
		else {
			attribute$1.name = attribute$1.name.slice(index$1 + 1);
			attribute$1.prefix = info.attribute.slice(0, index$1);
		}
		attribute$1.namespace = webNamespaces[info.space];
	}
	return attribute$1;
}
function all$2(children, parentNode, schema) {
	let index$1 = -1;
	const results = [];
	if (children) while (++index$1 < children.length) {
		const child = one$2(children[index$1], schema);
		child.parentNode = parentNode;
		results.push(child);
	}
	return results;
}
function patch$1(from, to) {
	const position$3 = from.position;
	if (position$3 && position$3.start && position$3.end) {
		ok(typeof position$3.start.offset === "number");
		ok(typeof position$3.end.offset === "number");
		to.sourceCodeLocation = {
			startLine: position$3.start.line,
			startCol: position$3.start.column,
			startOffset: position$3.start.offset,
			endLine: position$3.end.line,
			endCol: position$3.end.column,
			endOffset: position$3.end.offset
		};
	}
}
const htmlVoidElements = [
	"area",
	"base",
	"basefont",
	"bgsound",
	"br",
	"col",
	"command",
	"embed",
	"frame",
	"hr",
	"image",
	"img",
	"input",
	"keygen",
	"link",
	"meta",
	"param",
	"source",
	"track",
	"wbr"
];
const UNDEFINED_CODE_POINTS = new Set([
	65534,
	65535,
	131070,
	131071,
	196606,
	196607,
	262142,
	262143,
	327678,
	327679,
	393214,
	393215,
	458750,
	458751,
	524286,
	524287,
	589822,
	589823,
	655358,
	655359,
	720894,
	720895,
	786430,
	786431,
	851966,
	851967,
	917502,
	917503,
	983038,
	983039,
	1048574,
	1048575,
	1114110,
	1114111
]);
const REPLACEMENT_CHARACTER = "�";
var CODE_POINTS;
(function(CODE_POINTS$1) {
	CODE_POINTS$1[CODE_POINTS$1["EOF"] = -1] = "EOF";
	CODE_POINTS$1[CODE_POINTS$1["NULL"] = 0] = "NULL";
	CODE_POINTS$1[CODE_POINTS$1["TABULATION"] = 9] = "TABULATION";
	CODE_POINTS$1[CODE_POINTS$1["CARRIAGE_RETURN"] = 13] = "CARRIAGE_RETURN";
	CODE_POINTS$1[CODE_POINTS$1["LINE_FEED"] = 10] = "LINE_FEED";
	CODE_POINTS$1[CODE_POINTS$1["FORM_FEED"] = 12] = "FORM_FEED";
	CODE_POINTS$1[CODE_POINTS$1["SPACE"] = 32] = "SPACE";
	CODE_POINTS$1[CODE_POINTS$1["EXCLAMATION_MARK"] = 33] = "EXCLAMATION_MARK";
	CODE_POINTS$1[CODE_POINTS$1["QUOTATION_MARK"] = 34] = "QUOTATION_MARK";
	CODE_POINTS$1[CODE_POINTS$1["AMPERSAND"] = 38] = "AMPERSAND";
	CODE_POINTS$1[CODE_POINTS$1["APOSTROPHE"] = 39] = "APOSTROPHE";
	CODE_POINTS$1[CODE_POINTS$1["HYPHEN_MINUS"] = 45] = "HYPHEN_MINUS";
	CODE_POINTS$1[CODE_POINTS$1["SOLIDUS"] = 47] = "SOLIDUS";
	CODE_POINTS$1[CODE_POINTS$1["DIGIT_0"] = 48] = "DIGIT_0";
	CODE_POINTS$1[CODE_POINTS$1["DIGIT_9"] = 57] = "DIGIT_9";
	CODE_POINTS$1[CODE_POINTS$1["SEMICOLON"] = 59] = "SEMICOLON";
	CODE_POINTS$1[CODE_POINTS$1["LESS_THAN_SIGN"] = 60] = "LESS_THAN_SIGN";
	CODE_POINTS$1[CODE_POINTS$1["EQUALS_SIGN"] = 61] = "EQUALS_SIGN";
	CODE_POINTS$1[CODE_POINTS$1["GREATER_THAN_SIGN"] = 62] = "GREATER_THAN_SIGN";
	CODE_POINTS$1[CODE_POINTS$1["QUESTION_MARK"] = 63] = "QUESTION_MARK";
	CODE_POINTS$1[CODE_POINTS$1["LATIN_CAPITAL_A"] = 65] = "LATIN_CAPITAL_A";
	CODE_POINTS$1[CODE_POINTS$1["LATIN_CAPITAL_Z"] = 90] = "LATIN_CAPITAL_Z";
	CODE_POINTS$1[CODE_POINTS$1["RIGHT_SQUARE_BRACKET"] = 93] = "RIGHT_SQUARE_BRACKET";
	CODE_POINTS$1[CODE_POINTS$1["GRAVE_ACCENT"] = 96] = "GRAVE_ACCENT";
	CODE_POINTS$1[CODE_POINTS$1["LATIN_SMALL_A"] = 97] = "LATIN_SMALL_A";
	CODE_POINTS$1[CODE_POINTS$1["LATIN_SMALL_Z"] = 122] = "LATIN_SMALL_Z";
})(CODE_POINTS || (CODE_POINTS = {}));
const SEQUENCES = {
	DASH_DASH: "--",
	CDATA_START: "[CDATA[",
	DOCTYPE: "doctype",
	SCRIPT: "script",
	PUBLIC: "public",
	SYSTEM: "system"
};
function isSurrogate(cp) {
	return cp >= 55296 && cp <= 57343;
}
function isSurrogatePair(cp) {
	return cp >= 56320 && cp <= 57343;
}
function getSurrogatePairCodePoint(cp1, cp2) {
	return (cp1 - 55296) * 1024 + 9216 + cp2;
}
function isControlCodePoint(cp) {
	return cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31 || cp >= 127 && cp <= 159;
}
function isUndefinedCodePoint(cp) {
	return cp >= 64976 && cp <= 65007 || UNDEFINED_CODE_POINTS.has(cp);
}
var ERR;
(function(ERR$1) {
	ERR$1["controlCharacterInInputStream"] = "control-character-in-input-stream";
	ERR$1["noncharacterInInputStream"] = "noncharacter-in-input-stream";
	ERR$1["surrogateInInputStream"] = "surrogate-in-input-stream";
	ERR$1["nonVoidHtmlElementStartTagWithTrailingSolidus"] = "non-void-html-element-start-tag-with-trailing-solidus";
	ERR$1["endTagWithAttributes"] = "end-tag-with-attributes";
	ERR$1["endTagWithTrailingSolidus"] = "end-tag-with-trailing-solidus";
	ERR$1["unexpectedSolidusInTag"] = "unexpected-solidus-in-tag";
	ERR$1["unexpectedNullCharacter"] = "unexpected-null-character";
	ERR$1["unexpectedQuestionMarkInsteadOfTagName"] = "unexpected-question-mark-instead-of-tag-name";
	ERR$1["invalidFirstCharacterOfTagName"] = "invalid-first-character-of-tag-name";
	ERR$1["unexpectedEqualsSignBeforeAttributeName"] = "unexpected-equals-sign-before-attribute-name";
	ERR$1["missingEndTagName"] = "missing-end-tag-name";
	ERR$1["unexpectedCharacterInAttributeName"] = "unexpected-character-in-attribute-name";
	ERR$1["unknownNamedCharacterReference"] = "unknown-named-character-reference";
	ERR$1["missingSemicolonAfterCharacterReference"] = "missing-semicolon-after-character-reference";
	ERR$1["unexpectedCharacterAfterDoctypeSystemIdentifier"] = "unexpected-character-after-doctype-system-identifier";
	ERR$1["unexpectedCharacterInUnquotedAttributeValue"] = "unexpected-character-in-unquoted-attribute-value";
	ERR$1["eofBeforeTagName"] = "eof-before-tag-name";
	ERR$1["eofInTag"] = "eof-in-tag";
	ERR$1["missingAttributeValue"] = "missing-attribute-value";
	ERR$1["missingWhitespaceBetweenAttributes"] = "missing-whitespace-between-attributes";
	ERR$1["missingWhitespaceAfterDoctypePublicKeyword"] = "missing-whitespace-after-doctype-public-keyword";
	ERR$1["missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers"] = "missing-whitespace-between-doctype-public-and-system-identifiers";
	ERR$1["missingWhitespaceAfterDoctypeSystemKeyword"] = "missing-whitespace-after-doctype-system-keyword";
	ERR$1["missingQuoteBeforeDoctypePublicIdentifier"] = "missing-quote-before-doctype-public-identifier";
	ERR$1["missingQuoteBeforeDoctypeSystemIdentifier"] = "missing-quote-before-doctype-system-identifier";
	ERR$1["missingDoctypePublicIdentifier"] = "missing-doctype-public-identifier";
	ERR$1["missingDoctypeSystemIdentifier"] = "missing-doctype-system-identifier";
	ERR$1["abruptDoctypePublicIdentifier"] = "abrupt-doctype-public-identifier";
	ERR$1["abruptDoctypeSystemIdentifier"] = "abrupt-doctype-system-identifier";
	ERR$1["cdataInHtmlContent"] = "cdata-in-html-content";
	ERR$1["incorrectlyOpenedComment"] = "incorrectly-opened-comment";
	ERR$1["eofInScriptHtmlCommentLikeText"] = "eof-in-script-html-comment-like-text";
	ERR$1["eofInDoctype"] = "eof-in-doctype";
	ERR$1["nestedComment"] = "nested-comment";
	ERR$1["abruptClosingOfEmptyComment"] = "abrupt-closing-of-empty-comment";
	ERR$1["eofInComment"] = "eof-in-comment";
	ERR$1["incorrectlyClosedComment"] = "incorrectly-closed-comment";
	ERR$1["eofInCdata"] = "eof-in-cdata";
	ERR$1["absenceOfDigitsInNumericCharacterReference"] = "absence-of-digits-in-numeric-character-reference";
	ERR$1["nullCharacterReference"] = "null-character-reference";
	ERR$1["surrogateCharacterReference"] = "surrogate-character-reference";
	ERR$1["characterReferenceOutsideUnicodeRange"] = "character-reference-outside-unicode-range";
	ERR$1["controlCharacterReference"] = "control-character-reference";
	ERR$1["noncharacterCharacterReference"] = "noncharacter-character-reference";
	ERR$1["missingWhitespaceBeforeDoctypeName"] = "missing-whitespace-before-doctype-name";
	ERR$1["missingDoctypeName"] = "missing-doctype-name";
	ERR$1["invalidCharacterSequenceAfterDoctypeName"] = "invalid-character-sequence-after-doctype-name";
	ERR$1["duplicateAttribute"] = "duplicate-attribute";
	ERR$1["nonConformingDoctype"] = "non-conforming-doctype";
	ERR$1["missingDoctype"] = "missing-doctype";
	ERR$1["misplacedDoctype"] = "misplaced-doctype";
	ERR$1["endTagWithoutMatchingOpenElement"] = "end-tag-without-matching-open-element";
	ERR$1["closingOfElementWithOpenChildElements"] = "closing-of-element-with-open-child-elements";
	ERR$1["disallowedContentInNoscriptInHead"] = "disallowed-content-in-noscript-in-head";
	ERR$1["openElementsLeftAfterEof"] = "open-elements-left-after-eof";
	ERR$1["abandonedHeadElementChild"] = "abandoned-head-element-child";
	ERR$1["misplacedStartTagForHeadElement"] = "misplaced-start-tag-for-head-element";
	ERR$1["nestedNoscriptInHead"] = "nested-noscript-in-head";
	ERR$1["eofInElementThatCanContainOnlyText"] = "eof-in-element-that-can-contain-only-text";
})(ERR || (ERR = {}));
const DEFAULT_BUFFER_WATERLINE = 65536;
var Preprocessor = class {
	constructor(handler) {
		this.handler = handler;
		this.html = "";
		this.pos = -1;
		this.lastGapPos = -2;
		this.gapStack = [];
		this.skipNextNewLine = false;
		this.lastChunkWritten = false;
		this.endOfChunkHit = false;
		this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
		this.isEol = false;
		this.lineStartPos = 0;
		this.droppedBufferSize = 0;
		this.line = 1;
		this.lastErrOffset = -1;
	}
	get col() {
		return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);
	}
	get offset() {
		return this.droppedBufferSize + this.pos;
	}
	getError(code$3, cpOffset) {
		const { line, col, offset } = this;
		const startCol = col + cpOffset;
		const startOffset = offset + cpOffset;
		return {
			code: code$3,
			startLine: line,
			endLine: line,
			startCol,
			endCol: startCol,
			startOffset,
			endOffset: startOffset
		};
	}
	_err(code$3) {
		if (this.handler.onParseError && this.lastErrOffset !== this.offset) {
			this.lastErrOffset = this.offset;
			this.handler.onParseError(this.getError(code$3, 0));
		}
	}
	_addGap() {
		this.gapStack.push(this.lastGapPos);
		this.lastGapPos = this.pos;
	}
	_processSurrogate(cp) {
		if (this.pos !== this.html.length - 1) {
			const nextCp = this.html.charCodeAt(this.pos + 1);
			if (isSurrogatePair(nextCp)) {
				this.pos++;
				this._addGap();
				return getSurrogatePairCodePoint(cp, nextCp);
			}
		} else if (!this.lastChunkWritten) {
			this.endOfChunkHit = true;
			return CODE_POINTS.EOF;
		}
		this._err(ERR.surrogateInInputStream);
		return cp;
	}
	willDropParsedChunk() {
		return this.pos > this.bufferWaterline;
	}
	dropParsedChunk() {
		if (this.willDropParsedChunk()) {
			this.html = this.html.substring(this.pos);
			this.lineStartPos -= this.pos;
			this.droppedBufferSize += this.pos;
			this.pos = 0;
			this.lastGapPos = -2;
			this.gapStack.length = 0;
		}
	}
	write(chunk, isLastChunk) {
		if (this.html.length > 0) this.html += chunk;
		else this.html = chunk;
		this.endOfChunkHit = false;
		this.lastChunkWritten = isLastChunk;
	}
	insertHtmlAtCurrentPos(chunk) {
		this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);
		this.endOfChunkHit = false;
	}
	startsWith(pattern, caseSensitive) {
		if (this.pos + pattern.length > this.html.length) {
			this.endOfChunkHit = !this.lastChunkWritten;
			return false;
		}
		if (caseSensitive) return this.html.startsWith(pattern, this.pos);
		for (let i = 0; i < pattern.length; i++) {
			const cp = this.html.charCodeAt(this.pos + i) | 32;
			if (cp !== pattern.charCodeAt(i)) return false;
		}
		return true;
	}
	peek(offset) {
		const pos = this.pos + offset;
		if (pos >= this.html.length) {
			this.endOfChunkHit = !this.lastChunkWritten;
			return CODE_POINTS.EOF;
		}
		const code$3 = this.html.charCodeAt(pos);
		return code$3 === CODE_POINTS.CARRIAGE_RETURN ? CODE_POINTS.LINE_FEED : code$3;
	}
	advance() {
		this.pos++;
		if (this.isEol) {
			this.isEol = false;
			this.line++;
			this.lineStartPos = this.pos;
		}
		if (this.pos >= this.html.length) {
			this.endOfChunkHit = !this.lastChunkWritten;
			return CODE_POINTS.EOF;
		}
		let cp = this.html.charCodeAt(this.pos);
		if (cp === CODE_POINTS.CARRIAGE_RETURN) {
			this.isEol = true;
			this.skipNextNewLine = true;
			return CODE_POINTS.LINE_FEED;
		}
		if (cp === CODE_POINTS.LINE_FEED) {
			this.isEol = true;
			if (this.skipNextNewLine) {
				this.line--;
				this.skipNextNewLine = false;
				this._addGap();
				return this.advance();
			}
		}
		this.skipNextNewLine = false;
		if (isSurrogate(cp)) cp = this._processSurrogate(cp);
		const isCommonValidRange = this.handler.onParseError === null || cp > 31 && cp < 127 || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.CARRIAGE_RETURN || cp > 159 && cp < 64976;
		if (!isCommonValidRange) this._checkForProblematicCharacters(cp);
		return cp;
	}
	_checkForProblematicCharacters(cp) {
		if (isControlCodePoint(cp)) this._err(ERR.controlCharacterInInputStream);
		else if (isUndefinedCodePoint(cp)) this._err(ERR.noncharacterInInputStream);
	}
	retreat(count$1) {
		this.pos -= count$1;
		while (this.pos < this.lastGapPos) {
			this.lastGapPos = this.gapStack.pop();
			this.pos--;
		}
		this.isEol = false;
	}
};
var TokenType;
(function(TokenType$1) {
	TokenType$1[TokenType$1["CHARACTER"] = 0] = "CHARACTER";
	TokenType$1[TokenType$1["NULL_CHARACTER"] = 1] = "NULL_CHARACTER";
	TokenType$1[TokenType$1["WHITESPACE_CHARACTER"] = 2] = "WHITESPACE_CHARACTER";
	TokenType$1[TokenType$1["START_TAG"] = 3] = "START_TAG";
	TokenType$1[TokenType$1["END_TAG"] = 4] = "END_TAG";
	TokenType$1[TokenType$1["COMMENT"] = 5] = "COMMENT";
	TokenType$1[TokenType$1["DOCTYPE"] = 6] = "DOCTYPE";
	TokenType$1[TokenType$1["EOF"] = 7] = "EOF";
	TokenType$1[TokenType$1["HIBERNATION"] = 8] = "HIBERNATION";
})(TokenType || (TokenType = {}));
function getTokenAttr(token, attrName) {
	for (let i = token.attrs.length - 1; i >= 0; i--) if (token.attrs[i].name === attrName) return token.attrs[i].value;
	return null;
}
const htmlDecodeTree = new Uint16Array("ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻\"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻\xA0ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌".split("").map((c$2) => c$2.charCodeAt(0)));
var _a;
const decodeMap = new Map([
	[0, 65533],
	[128, 8364],
	[130, 8218],
	[131, 402],
	[132, 8222],
	[133, 8230],
	[134, 8224],
	[135, 8225],
	[136, 710],
	[137, 8240],
	[138, 352],
	[139, 8249],
	[140, 338],
	[142, 381],
	[145, 8216],
	[146, 8217],
	[147, 8220],
	[148, 8221],
	[149, 8226],
	[150, 8211],
	[151, 8212],
	[152, 732],
	[153, 8482],
	[154, 353],
	[155, 8250],
	[156, 339],
	[158, 382],
	[159, 376]
]);
const fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
	let output = "";
	if (codePoint > 65535) {
		codePoint -= 65536;
		output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
		codePoint = 56320 | codePoint & 1023;
	}
	output += String.fromCharCode(codePoint);
	return output;
};
function replaceCodePoint(codePoint) {
	var _a$1;
	if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) return 65533;
	return (_a$1 = decodeMap.get(codePoint)) !== null && _a$1 !== void 0 ? _a$1 : codePoint;
}
var CharCodes;
(function(CharCodes$1) {
	CharCodes$1[CharCodes$1["NUM"] = 35] = "NUM";
	CharCodes$1[CharCodes$1["SEMI"] = 59] = "SEMI";
	CharCodes$1[CharCodes$1["EQUALS"] = 61] = "EQUALS";
	CharCodes$1[CharCodes$1["ZERO"] = 48] = "ZERO";
	CharCodes$1[CharCodes$1["NINE"] = 57] = "NINE";
	CharCodes$1[CharCodes$1["LOWER_A"] = 97] = "LOWER_A";
	CharCodes$1[CharCodes$1["LOWER_F"] = 102] = "LOWER_F";
	CharCodes$1[CharCodes$1["LOWER_X"] = 120] = "LOWER_X";
	CharCodes$1[CharCodes$1["LOWER_Z"] = 122] = "LOWER_Z";
	CharCodes$1[CharCodes$1["UPPER_A"] = 65] = "UPPER_A";
	CharCodes$1[CharCodes$1["UPPER_F"] = 70] = "UPPER_F";
	CharCodes$1[CharCodes$1["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
const TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags$1) {
	BinTrieFlags$1[BinTrieFlags$1["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
	BinTrieFlags$1[BinTrieFlags$1["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
	BinTrieFlags$1[BinTrieFlags$1["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code$3) {
	return code$3 >= CharCodes.ZERO && code$3 <= CharCodes.NINE;
}
function isHexadecimalCharacter(code$3) {
	return code$3 >= CharCodes.UPPER_A && code$3 <= CharCodes.UPPER_F || code$3 >= CharCodes.LOWER_A && code$3 <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric$1(code$3) {
	return code$3 >= CharCodes.UPPER_A && code$3 <= CharCodes.UPPER_Z || code$3 >= CharCodes.LOWER_A && code$3 <= CharCodes.LOWER_Z || isNumber(code$3);
}
function isEntityInAttributeInvalidEnd(code$3) {
	return code$3 === CharCodes.EQUALS || isAsciiAlphaNumeric$1(code$3);
}
var EntityDecoderState;
(function(EntityDecoderState$1) {
	EntityDecoderState$1[EntityDecoderState$1["EntityStart"] = 0] = "EntityStart";
	EntityDecoderState$1[EntityDecoderState$1["NumericStart"] = 1] = "NumericStart";
	EntityDecoderState$1[EntityDecoderState$1["NumericDecimal"] = 2] = "NumericDecimal";
	EntityDecoderState$1[EntityDecoderState$1["NumericHex"] = 3] = "NumericHex";
	EntityDecoderState$1[EntityDecoderState$1["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode$1) {
	DecodingMode$1[DecodingMode$1["Legacy"] = 0] = "Legacy";
	DecodingMode$1[DecodingMode$1["Strict"] = 1] = "Strict";
	DecodingMode$1[DecodingMode$1["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
	constructor(decodeTree, emitCodePoint, errors) {
		this.decodeTree = decodeTree;
		this.emitCodePoint = emitCodePoint;
		this.errors = errors;
		this.state = EntityDecoderState.EntityStart;
		this.consumed = 1;
		this.result = 0;
		this.treeIndex = 0;
		this.excess = 1;
		this.decodeMode = DecodingMode.Strict;
	}
	startEntity(decodeMode) {
		this.decodeMode = decodeMode;
		this.state = EntityDecoderState.EntityStart;
		this.result = 0;
		this.treeIndex = 0;
		this.excess = 1;
		this.consumed = 1;
	}
	write(input, offset) {
		switch (this.state) {
			case EntityDecoderState.EntityStart: {
				if (input.charCodeAt(offset) === CharCodes.NUM) {
					this.state = EntityDecoderState.NumericStart;
					this.consumed += 1;
					return this.stateNumericStart(input, offset + 1);
				}
				this.state = EntityDecoderState.NamedEntity;
				return this.stateNamedEntity(input, offset);
			}
			case EntityDecoderState.NumericStart: return this.stateNumericStart(input, offset);
			case EntityDecoderState.NumericDecimal: return this.stateNumericDecimal(input, offset);
			case EntityDecoderState.NumericHex: return this.stateNumericHex(input, offset);
			case EntityDecoderState.NamedEntity: return this.stateNamedEntity(input, offset);
		}
	}
	stateNumericStart(input, offset) {
		if (offset >= input.length) return -1;
		if ((input.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
			this.state = EntityDecoderState.NumericHex;
			this.consumed += 1;
			return this.stateNumericHex(input, offset + 1);
		}
		this.state = EntityDecoderState.NumericDecimal;
		return this.stateNumericDecimal(input, offset);
	}
	addToNumericResult(input, start, end, base) {
		if (start !== end) {
			const digitCount = end - start;
			this.result = this.result * Math.pow(base, digitCount) + Number.parseInt(input.substr(start, digitCount), base);
			this.consumed += digitCount;
		}
	}
	stateNumericHex(input, offset) {
		const startIndex = offset;
		while (offset < input.length) {
			const char = input.charCodeAt(offset);
			if (isNumber(char) || isHexadecimalCharacter(char)) offset += 1;
			else {
				this.addToNumericResult(input, startIndex, offset, 16);
				return this.emitNumericEntity(char, 3);
			}
		}
		this.addToNumericResult(input, startIndex, offset, 16);
		return -1;
	}
	stateNumericDecimal(input, offset) {
		const startIndex = offset;
		while (offset < input.length) {
			const char = input.charCodeAt(offset);
			if (isNumber(char)) offset += 1;
			else {
				this.addToNumericResult(input, startIndex, offset, 10);
				return this.emitNumericEntity(char, 2);
			}
		}
		this.addToNumericResult(input, startIndex, offset, 10);
		return -1;
	}
	emitNumericEntity(lastCp, expectedLength) {
		var _a$1;
		if (this.consumed <= expectedLength) {
			(_a$1 = this.errors) === null || _a$1 === void 0 || _a$1.absenceOfDigitsInNumericCharacterReference(this.consumed);
			return 0;
		}
		if (lastCp === CharCodes.SEMI) this.consumed += 1;
		else if (this.decodeMode === DecodingMode.Strict) return 0;
		this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
		if (this.errors) {
			if (lastCp !== CharCodes.SEMI) this.errors.missingSemicolonAfterCharacterReference();
			this.errors.validateNumericCharacterReference(this.result);
		}
		return this.consumed;
	}
	stateNamedEntity(input, offset) {
		const { decodeTree } = this;
		let current = decodeTree[this.treeIndex];
		let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
		for (; offset < input.length; offset++, this.excess++) {
			const char = input.charCodeAt(offset);
			this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
			if (this.treeIndex < 0) return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
			current = decodeTree[this.treeIndex];
			valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
			if (valueLength !== 0) {
				if (char === CharCodes.SEMI) return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
				if (this.decodeMode !== DecodingMode.Strict) {
					this.result = this.treeIndex;
					this.consumed += this.excess;
					this.excess = 0;
				}
			}
		}
		return -1;
	}
	emitNotTerminatedNamedEntity() {
		var _a$1;
		const { result, decodeTree } = this;
		const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
		this.emitNamedEntityData(result, valueLength, this.consumed);
		(_a$1 = this.errors) === null || _a$1 === void 0 || _a$1.missingSemicolonAfterCharacterReference();
		return this.consumed;
	}
	emitNamedEntityData(result, valueLength, consumed) {
		const { decodeTree } = this;
		this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
		if (valueLength === 3) this.emitCodePoint(decodeTree[result + 2], consumed);
		return consumed;
	}
	end() {
		var _a$1;
		switch (this.state) {
			case EntityDecoderState.NamedEntity: return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
			case EntityDecoderState.NumericDecimal: return this.emitNumericEntity(0, 2);
			case EntityDecoderState.NumericHex: return this.emitNumericEntity(0, 3);
			case EntityDecoderState.NumericStart: {
				(_a$1 = this.errors) === null || _a$1 === void 0 || _a$1.absenceOfDigitsInNumericCharacterReference(this.consumed);
				return 0;
			}
			case EntityDecoderState.EntityStart: return 0;
		}
	}
};
function determineBranch(decodeTree, current, nodeIndex, char) {
	const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
	const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
	if (branchCount === 0) return jumpOffset !== 0 && char === jumpOffset ? nodeIndex : -1;
	if (jumpOffset) {
		const value = char - jumpOffset;
		return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIndex + value] - 1;
	}
	let lo = nodeIndex;
	let hi = lo + branchCount - 1;
	while (lo <= hi) {
		const mid = lo + hi >>> 1;
		const midValue = decodeTree[mid];
		if (midValue < char) lo = mid + 1;
		else if (midValue > char) hi = mid - 1;
		else return decodeTree[mid + branchCount];
	}
	return -1;
}
var NS;
(function(NS$1) {
	NS$1["HTML"] = "http://www.w3.org/1999/xhtml";
	NS$1["MATHML"] = "http://www.w3.org/1998/Math/MathML";
	NS$1["SVG"] = "http://www.w3.org/2000/svg";
	NS$1["XLINK"] = "http://www.w3.org/1999/xlink";
	NS$1["XML"] = "http://www.w3.org/XML/1998/namespace";
	NS$1["XMLNS"] = "http://www.w3.org/2000/xmlns/";
})(NS || (NS = {}));
var ATTRS;
(function(ATTRS$1) {
	ATTRS$1["TYPE"] = "type";
	ATTRS$1["ACTION"] = "action";
	ATTRS$1["ENCODING"] = "encoding";
	ATTRS$1["PROMPT"] = "prompt";
	ATTRS$1["NAME"] = "name";
	ATTRS$1["COLOR"] = "color";
	ATTRS$1["FACE"] = "face";
	ATTRS$1["SIZE"] = "size";
})(ATTRS || (ATTRS = {}));
var DOCUMENT_MODE;
(function(DOCUMENT_MODE$1) {
	DOCUMENT_MODE$1["NO_QUIRKS"] = "no-quirks";
	DOCUMENT_MODE$1["QUIRKS"] = "quirks";
	DOCUMENT_MODE$1["LIMITED_QUIRKS"] = "limited-quirks";
})(DOCUMENT_MODE || (DOCUMENT_MODE = {}));
var TAG_NAMES;
(function(TAG_NAMES$1) {
	TAG_NAMES$1["A"] = "a";
	TAG_NAMES$1["ADDRESS"] = "address";
	TAG_NAMES$1["ANNOTATION_XML"] = "annotation-xml";
	TAG_NAMES$1["APPLET"] = "applet";
	TAG_NAMES$1["AREA"] = "area";
	TAG_NAMES$1["ARTICLE"] = "article";
	TAG_NAMES$1["ASIDE"] = "aside";
	TAG_NAMES$1["B"] = "b";
	TAG_NAMES$1["BASE"] = "base";
	TAG_NAMES$1["BASEFONT"] = "basefont";
	TAG_NAMES$1["BGSOUND"] = "bgsound";
	TAG_NAMES$1["BIG"] = "big";
	TAG_NAMES$1["BLOCKQUOTE"] = "blockquote";
	TAG_NAMES$1["BODY"] = "body";
	TAG_NAMES$1["BR"] = "br";
	TAG_NAMES$1["BUTTON"] = "button";
	TAG_NAMES$1["CAPTION"] = "caption";
	TAG_NAMES$1["CENTER"] = "center";
	TAG_NAMES$1["CODE"] = "code";
	TAG_NAMES$1["COL"] = "col";
	TAG_NAMES$1["COLGROUP"] = "colgroup";
	TAG_NAMES$1["DD"] = "dd";
	TAG_NAMES$1["DESC"] = "desc";
	TAG_NAMES$1["DETAILS"] = "details";
	TAG_NAMES$1["DIALOG"] = "dialog";
	TAG_NAMES$1["DIR"] = "dir";
	TAG_NAMES$1["DIV"] = "div";
	TAG_NAMES$1["DL"] = "dl";
	TAG_NAMES$1["DT"] = "dt";
	TAG_NAMES$1["EM"] = "em";
	TAG_NAMES$1["EMBED"] = "embed";
	TAG_NAMES$1["FIELDSET"] = "fieldset";
	TAG_NAMES$1["FIGCAPTION"] = "figcaption";
	TAG_NAMES$1["FIGURE"] = "figure";
	TAG_NAMES$1["FONT"] = "font";
	TAG_NAMES$1["FOOTER"] = "footer";
	TAG_NAMES$1["FOREIGN_OBJECT"] = "foreignObject";
	TAG_NAMES$1["FORM"] = "form";
	TAG_NAMES$1["FRAME"] = "frame";
	TAG_NAMES$1["FRAMESET"] = "frameset";
	TAG_NAMES$1["H1"] = "h1";
	TAG_NAMES$1["H2"] = "h2";
	TAG_NAMES$1["H3"] = "h3";
	TAG_NAMES$1["H4"] = "h4";
	TAG_NAMES$1["H5"] = "h5";
	TAG_NAMES$1["H6"] = "h6";
	TAG_NAMES$1["HEAD"] = "head";
	TAG_NAMES$1["HEADER"] = "header";
	TAG_NAMES$1["HGROUP"] = "hgroup";
	TAG_NAMES$1["HR"] = "hr";
	TAG_NAMES$1["HTML"] = "html";
	TAG_NAMES$1["I"] = "i";
	TAG_NAMES$1["IMG"] = "img";
	TAG_NAMES$1["IMAGE"] = "image";
	TAG_NAMES$1["INPUT"] = "input";
	TAG_NAMES$1["IFRAME"] = "iframe";
	TAG_NAMES$1["KEYGEN"] = "keygen";
	TAG_NAMES$1["LABEL"] = "label";
	TAG_NAMES$1["LI"] = "li";
	TAG_NAMES$1["LINK"] = "link";
	TAG_NAMES$1["LISTING"] = "listing";
	TAG_NAMES$1["MAIN"] = "main";
	TAG_NAMES$1["MALIGNMARK"] = "malignmark";
	TAG_NAMES$1["MARQUEE"] = "marquee";
	TAG_NAMES$1["MATH"] = "math";
	TAG_NAMES$1["MENU"] = "menu";
	TAG_NAMES$1["META"] = "meta";
	TAG_NAMES$1["MGLYPH"] = "mglyph";
	TAG_NAMES$1["MI"] = "mi";
	TAG_NAMES$1["MO"] = "mo";
	TAG_NAMES$1["MN"] = "mn";
	TAG_NAMES$1["MS"] = "ms";
	TAG_NAMES$1["MTEXT"] = "mtext";
	TAG_NAMES$1["NAV"] = "nav";
	TAG_NAMES$1["NOBR"] = "nobr";
	TAG_NAMES$1["NOFRAMES"] = "noframes";
	TAG_NAMES$1["NOEMBED"] = "noembed";
	TAG_NAMES$1["NOSCRIPT"] = "noscript";
	TAG_NAMES$1["OBJECT"] = "object";
	TAG_NAMES$1["OL"] = "ol";
	TAG_NAMES$1["OPTGROUP"] = "optgroup";
	TAG_NAMES$1["OPTION"] = "option";
	TAG_NAMES$1["P"] = "p";
	TAG_NAMES$1["PARAM"] = "param";
	TAG_NAMES$1["PLAINTEXT"] = "plaintext";
	TAG_NAMES$1["PRE"] = "pre";
	TAG_NAMES$1["RB"] = "rb";
	TAG_NAMES$1["RP"] = "rp";
	TAG_NAMES$1["RT"] = "rt";
	TAG_NAMES$1["RTC"] = "rtc";
	TAG_NAMES$1["RUBY"] = "ruby";
	TAG_NAMES$1["S"] = "s";
	TAG_NAMES$1["SCRIPT"] = "script";
	TAG_NAMES$1["SEARCH"] = "search";
	TAG_NAMES$1["SECTION"] = "section";
	TAG_NAMES$1["SELECT"] = "select";
	TAG_NAMES$1["SOURCE"] = "source";
	TAG_NAMES$1["SMALL"] = "small";
	TAG_NAMES$1["SPAN"] = "span";
	TAG_NAMES$1["STRIKE"] = "strike";
	TAG_NAMES$1["STRONG"] = "strong";
	TAG_NAMES$1["STYLE"] = "style";
	TAG_NAMES$1["SUB"] = "sub";
	TAG_NAMES$1["SUMMARY"] = "summary";
	TAG_NAMES$1["SUP"] = "sup";
	TAG_NAMES$1["TABLE"] = "table";
	TAG_NAMES$1["TBODY"] = "tbody";
	TAG_NAMES$1["TEMPLATE"] = "template";
	TAG_NAMES$1["TEXTAREA"] = "textarea";
	TAG_NAMES$1["TFOOT"] = "tfoot";
	TAG_NAMES$1["TD"] = "td";
	TAG_NAMES$1["TH"] = "th";
	TAG_NAMES$1["THEAD"] = "thead";
	TAG_NAMES$1["TITLE"] = "title";
	TAG_NAMES$1["TR"] = "tr";
	TAG_NAMES$1["TRACK"] = "track";
	TAG_NAMES$1["TT"] = "tt";
	TAG_NAMES$1["U"] = "u";
	TAG_NAMES$1["UL"] = "ul";
	TAG_NAMES$1["SVG"] = "svg";
	TAG_NAMES$1["VAR"] = "var";
	TAG_NAMES$1["WBR"] = "wbr";
	TAG_NAMES$1["XMP"] = "xmp";
})(TAG_NAMES || (TAG_NAMES = {}));
var TAG_ID;
(function(TAG_ID$1) {
	TAG_ID$1[TAG_ID$1["UNKNOWN"] = 0] = "UNKNOWN";
	TAG_ID$1[TAG_ID$1["A"] = 1] = "A";
	TAG_ID$1[TAG_ID$1["ADDRESS"] = 2] = "ADDRESS";
	TAG_ID$1[TAG_ID$1["ANNOTATION_XML"] = 3] = "ANNOTATION_XML";
	TAG_ID$1[TAG_ID$1["APPLET"] = 4] = "APPLET";
	TAG_ID$1[TAG_ID$1["AREA"] = 5] = "AREA";
	TAG_ID$1[TAG_ID$1["ARTICLE"] = 6] = "ARTICLE";
	TAG_ID$1[TAG_ID$1["ASIDE"] = 7] = "ASIDE";
	TAG_ID$1[TAG_ID$1["B"] = 8] = "B";
	TAG_ID$1[TAG_ID$1["BASE"] = 9] = "BASE";
	TAG_ID$1[TAG_ID$1["BASEFONT"] = 10] = "BASEFONT";
	TAG_ID$1[TAG_ID$1["BGSOUND"] = 11] = "BGSOUND";
	TAG_ID$1[TAG_ID$1["BIG"] = 12] = "BIG";
	TAG_ID$1[TAG_ID$1["BLOCKQUOTE"] = 13] = "BLOCKQUOTE";
	TAG_ID$1[TAG_ID$1["BODY"] = 14] = "BODY";
	TAG_ID$1[TAG_ID$1["BR"] = 15] = "BR";
	TAG_ID$1[TAG_ID$1["BUTTON"] = 16] = "BUTTON";
	TAG_ID$1[TAG_ID$1["CAPTION"] = 17] = "CAPTION";
	TAG_ID$1[TAG_ID$1["CENTER"] = 18] = "CENTER";
	TAG_ID$1[TAG_ID$1["CODE"] = 19] = "CODE";
	TAG_ID$1[TAG_ID$1["COL"] = 20] = "COL";
	TAG_ID$1[TAG_ID$1["COLGROUP"] = 21] = "COLGROUP";
	TAG_ID$1[TAG_ID$1["DD"] = 22] = "DD";
	TAG_ID$1[TAG_ID$1["DESC"] = 23] = "DESC";
	TAG_ID$1[TAG_ID$1["DETAILS"] = 24] = "DETAILS";
	TAG_ID$1[TAG_ID$1["DIALOG"] = 25] = "DIALOG";
	TAG_ID$1[TAG_ID$1["DIR"] = 26] = "DIR";
	TAG_ID$1[TAG_ID$1["DIV"] = 27] = "DIV";
	TAG_ID$1[TAG_ID$1["DL"] = 28] = "DL";
	TAG_ID$1[TAG_ID$1["DT"] = 29] = "DT";
	TAG_ID$1[TAG_ID$1["EM"] = 30] = "EM";
	TAG_ID$1[TAG_ID$1["EMBED"] = 31] = "EMBED";
	TAG_ID$1[TAG_ID$1["FIELDSET"] = 32] = "FIELDSET";
	TAG_ID$1[TAG_ID$1["FIGCAPTION"] = 33] = "FIGCAPTION";
	TAG_ID$1[TAG_ID$1["FIGURE"] = 34] = "FIGURE";
	TAG_ID$1[TAG_ID$1["FONT"] = 35] = "FONT";
	TAG_ID$1[TAG_ID$1["FOOTER"] = 36] = "FOOTER";
	TAG_ID$1[TAG_ID$1["FOREIGN_OBJECT"] = 37] = "FOREIGN_OBJECT";
	TAG_ID$1[TAG_ID$1["FORM"] = 38] = "FORM";
	TAG_ID$1[TAG_ID$1["FRAME"] = 39] = "FRAME";
	TAG_ID$1[TAG_ID$1["FRAMESET"] = 40] = "FRAMESET";
	TAG_ID$1[TAG_ID$1["H1"] = 41] = "H1";
	TAG_ID$1[TAG_ID$1["H2"] = 42] = "H2";
	TAG_ID$1[TAG_ID$1["H3"] = 43] = "H3";
	TAG_ID$1[TAG_ID$1["H4"] = 44] = "H4";
	TAG_ID$1[TAG_ID$1["H5"] = 45] = "H5";
	TAG_ID$1[TAG_ID$1["H6"] = 46] = "H6";
	TAG_ID$1[TAG_ID$1["HEAD"] = 47] = "HEAD";
	TAG_ID$1[TAG_ID$1["HEADER"] = 48] = "HEADER";
	TAG_ID$1[TAG_ID$1["HGROUP"] = 49] = "HGROUP";
	TAG_ID$1[TAG_ID$1["HR"] = 50] = "HR";
	TAG_ID$1[TAG_ID$1["HTML"] = 51] = "HTML";
	TAG_ID$1[TAG_ID$1["I"] = 52] = "I";
	TAG_ID$1[TAG_ID$1["IMG"] = 53] = "IMG";
	TAG_ID$1[TAG_ID$1["IMAGE"] = 54] = "IMAGE";
	TAG_ID$1[TAG_ID$1["INPUT"] = 55] = "INPUT";
	TAG_ID$1[TAG_ID$1["IFRAME"] = 56] = "IFRAME";
	TAG_ID$1[TAG_ID$1["KEYGEN"] = 57] = "KEYGEN";
	TAG_ID$1[TAG_ID$1["LABEL"] = 58] = "LABEL";
	TAG_ID$1[TAG_ID$1["LI"] = 59] = "LI";
	TAG_ID$1[TAG_ID$1["LINK"] = 60] = "LINK";
	TAG_ID$1[TAG_ID$1["LISTING"] = 61] = "LISTING";
	TAG_ID$1[TAG_ID$1["MAIN"] = 62] = "MAIN";
	TAG_ID$1[TAG_ID$1["MALIGNMARK"] = 63] = "MALIGNMARK";
	TAG_ID$1[TAG_ID$1["MARQUEE"] = 64] = "MARQUEE";
	TAG_ID$1[TAG_ID$1["MATH"] = 65] = "MATH";
	TAG_ID$1[TAG_ID$1["MENU"] = 66] = "MENU";
	TAG_ID$1[TAG_ID$1["META"] = 67] = "META";
	TAG_ID$1[TAG_ID$1["MGLYPH"] = 68] = "MGLYPH";
	TAG_ID$1[TAG_ID$1["MI"] = 69] = "MI";
	TAG_ID$1[TAG_ID$1["MO"] = 70] = "MO";
	TAG_ID$1[TAG_ID$1["MN"] = 71] = "MN";
	TAG_ID$1[TAG_ID$1["MS"] = 72] = "MS";
	TAG_ID$1[TAG_ID$1["MTEXT"] = 73] = "MTEXT";
	TAG_ID$1[TAG_ID$1["NAV"] = 74] = "NAV";
	TAG_ID$1[TAG_ID$1["NOBR"] = 75] = "NOBR";
	TAG_ID$1[TAG_ID$1["NOFRAMES"] = 76] = "NOFRAMES";
	TAG_ID$1[TAG_ID$1["NOEMBED"] = 77] = "NOEMBED";
	TAG_ID$1[TAG_ID$1["NOSCRIPT"] = 78] = "NOSCRIPT";
	TAG_ID$1[TAG_ID$1["OBJECT"] = 79] = "OBJECT";
	TAG_ID$1[TAG_ID$1["OL"] = 80] = "OL";
	TAG_ID$1[TAG_ID$1["OPTGROUP"] = 81] = "OPTGROUP";
	TAG_ID$1[TAG_ID$1["OPTION"] = 82] = "OPTION";
	TAG_ID$1[TAG_ID$1["P"] = 83] = "P";
	TAG_ID$1[TAG_ID$1["PARAM"] = 84] = "PARAM";
	TAG_ID$1[TAG_ID$1["PLAINTEXT"] = 85] = "PLAINTEXT";
	TAG_ID$1[TAG_ID$1["PRE"] = 86] = "PRE";
	TAG_ID$1[TAG_ID$1["RB"] = 87] = "RB";
	TAG_ID$1[TAG_ID$1["RP"] = 88] = "RP";
	TAG_ID$1[TAG_ID$1["RT"] = 89] = "RT";
	TAG_ID$1[TAG_ID$1["RTC"] = 90] = "RTC";
	TAG_ID$1[TAG_ID$1["RUBY"] = 91] = "RUBY";
	TAG_ID$1[TAG_ID$1["S"] = 92] = "S";
	TAG_ID$1[TAG_ID$1["SCRIPT"] = 93] = "SCRIPT";
	TAG_ID$1[TAG_ID$1["SEARCH"] = 94] = "SEARCH";
	TAG_ID$1[TAG_ID$1["SECTION"] = 95] = "SECTION";
	TAG_ID$1[TAG_ID$1["SELECT"] = 96] = "SELECT";
	TAG_ID$1[TAG_ID$1["SOURCE"] = 97] = "SOURCE";
	TAG_ID$1[TAG_ID$1["SMALL"] = 98] = "SMALL";
	TAG_ID$1[TAG_ID$1["SPAN"] = 99] = "SPAN";
	TAG_ID$1[TAG_ID$1["STRIKE"] = 100] = "STRIKE";
	TAG_ID$1[TAG_ID$1["STRONG"] = 101] = "STRONG";
	TAG_ID$1[TAG_ID$1["STYLE"] = 102] = "STYLE";
	TAG_ID$1[TAG_ID$1["SUB"] = 103] = "SUB";
	TAG_ID$1[TAG_ID$1["SUMMARY"] = 104] = "SUMMARY";
	TAG_ID$1[TAG_ID$1["SUP"] = 105] = "SUP";
	TAG_ID$1[TAG_ID$1["TABLE"] = 106] = "TABLE";
	TAG_ID$1[TAG_ID$1["TBODY"] = 107] = "TBODY";
	TAG_ID$1[TAG_ID$1["TEMPLATE"] = 108] = "TEMPLATE";
	TAG_ID$1[TAG_ID$1["TEXTAREA"] = 109] = "TEXTAREA";
	TAG_ID$1[TAG_ID$1["TFOOT"] = 110] = "TFOOT";
	TAG_ID$1[TAG_ID$1["TD"] = 111] = "TD";
	TAG_ID$1[TAG_ID$1["TH"] = 112] = "TH";
	TAG_ID$1[TAG_ID$1["THEAD"] = 113] = "THEAD";
	TAG_ID$1[TAG_ID$1["TITLE"] = 114] = "TITLE";
	TAG_ID$1[TAG_ID$1["TR"] = 115] = "TR";
	TAG_ID$1[TAG_ID$1["TRACK"] = 116] = "TRACK";
	TAG_ID$1[TAG_ID$1["TT"] = 117] = "TT";
	TAG_ID$1[TAG_ID$1["U"] = 118] = "U";
	TAG_ID$1[TAG_ID$1["UL"] = 119] = "UL";
	TAG_ID$1[TAG_ID$1["SVG"] = 120] = "SVG";
	TAG_ID$1[TAG_ID$1["VAR"] = 121] = "VAR";
	TAG_ID$1[TAG_ID$1["WBR"] = 122] = "WBR";
	TAG_ID$1[TAG_ID$1["XMP"] = 123] = "XMP";
})(TAG_ID || (TAG_ID = {}));
const TAG_NAME_TO_ID = new Map([
	[TAG_NAMES.A, TAG_ID.A],
	[TAG_NAMES.ADDRESS, TAG_ID.ADDRESS],
	[TAG_NAMES.ANNOTATION_XML, TAG_ID.ANNOTATION_XML],
	[TAG_NAMES.APPLET, TAG_ID.APPLET],
	[TAG_NAMES.AREA, TAG_ID.AREA],
	[TAG_NAMES.ARTICLE, TAG_ID.ARTICLE],
	[TAG_NAMES.ASIDE, TAG_ID.ASIDE],
	[TAG_NAMES.B, TAG_ID.B],
	[TAG_NAMES.BASE, TAG_ID.BASE],
	[TAG_NAMES.BASEFONT, TAG_ID.BASEFONT],
	[TAG_NAMES.BGSOUND, TAG_ID.BGSOUND],
	[TAG_NAMES.BIG, TAG_ID.BIG],
	[TAG_NAMES.BLOCKQUOTE, TAG_ID.BLOCKQUOTE],
	[TAG_NAMES.BODY, TAG_ID.BODY],
	[TAG_NAMES.BR, TAG_ID.BR],
	[TAG_NAMES.BUTTON, TAG_ID.BUTTON],
	[TAG_NAMES.CAPTION, TAG_ID.CAPTION],
	[TAG_NAMES.CENTER, TAG_ID.CENTER],
	[TAG_NAMES.CODE, TAG_ID.CODE],
	[TAG_NAMES.COL, TAG_ID.COL],
	[TAG_NAMES.COLGROUP, TAG_ID.COLGROUP],
	[TAG_NAMES.DD, TAG_ID.DD],
	[TAG_NAMES.DESC, TAG_ID.DESC],
	[TAG_NAMES.DETAILS, TAG_ID.DETAILS],
	[TAG_NAMES.DIALOG, TAG_ID.DIALOG],
	[TAG_NAMES.DIR, TAG_ID.DIR],
	[TAG_NAMES.DIV, TAG_ID.DIV],
	[TAG_NAMES.DL, TAG_ID.DL],
	[TAG_NAMES.DT, TAG_ID.DT],
	[TAG_NAMES.EM, TAG_ID.EM],
	[TAG_NAMES.EMBED, TAG_ID.EMBED],
	[TAG_NAMES.FIELDSET, TAG_ID.FIELDSET],
	[TAG_NAMES.FIGCAPTION, TAG_ID.FIGCAPTION],
	[TAG_NAMES.FIGURE, TAG_ID.FIGURE],
	[TAG_NAMES.FONT, TAG_ID.FONT],
	[TAG_NAMES.FOOTER, TAG_ID.FOOTER],
	[TAG_NAMES.FOREIGN_OBJECT, TAG_ID.FOREIGN_OBJECT],
	[TAG_NAMES.FORM, TAG_ID.FORM],
	[TAG_NAMES.FRAME, TAG_ID.FRAME],
	[TAG_NAMES.FRAMESET, TAG_ID.FRAMESET],
	[TAG_NAMES.H1, TAG_ID.H1],
	[TAG_NAMES.H2, TAG_ID.H2],
	[TAG_NAMES.H3, TAG_ID.H3],
	[TAG_NAMES.H4, TAG_ID.H4],
	[TAG_NAMES.H5, TAG_ID.H5],
	[TAG_NAMES.H6, TAG_ID.H6],
	[TAG_NAMES.HEAD, TAG_ID.HEAD],
	[TAG_NAMES.HEADER, TAG_ID.HEADER],
	[TAG_NAMES.HGROUP, TAG_ID.HGROUP],
	[TAG_NAMES.HR, TAG_ID.HR],
	[TAG_NAMES.HTML, TAG_ID.HTML],
	[TAG_NAMES.I, TAG_ID.I],
	[TAG_NAMES.IMG, TAG_ID.IMG],
	[TAG_NAMES.IMAGE, TAG_ID.IMAGE],
	[TAG_NAMES.INPUT, TAG_ID.INPUT],
	[TAG_NAMES.IFRAME, TAG_ID.IFRAME],
	[TAG_NAMES.KEYGEN, TAG_ID.KEYGEN],
	[TAG_NAMES.LABEL, TAG_ID.LABEL],
	[TAG_NAMES.LI, TAG_ID.LI],
	[TAG_NAMES.LINK, TAG_ID.LINK],
	[TAG_NAMES.LISTING, TAG_ID.LISTING],
	[TAG_NAMES.MAIN, TAG_ID.MAIN],
	[TAG_NAMES.MALIGNMARK, TAG_ID.MALIGNMARK],
	[TAG_NAMES.MARQUEE, TAG_ID.MARQUEE],
	[TAG_NAMES.MATH, TAG_ID.MATH],
	[TAG_NAMES.MENU, TAG_ID.MENU],
	[TAG_NAMES.META, TAG_ID.META],
	[TAG_NAMES.MGLYPH, TAG_ID.MGLYPH],
	[TAG_NAMES.MI, TAG_ID.MI],
	[TAG_NAMES.MO, TAG_ID.MO],
	[TAG_NAMES.MN, TAG_ID.MN],
	[TAG_NAMES.MS, TAG_ID.MS],
	[TAG_NAMES.MTEXT, TAG_ID.MTEXT],
	[TAG_NAMES.NAV, TAG_ID.NAV],
	[TAG_NAMES.NOBR, TAG_ID.NOBR],
	[TAG_NAMES.NOFRAMES, TAG_ID.NOFRAMES],
	[TAG_NAMES.NOEMBED, TAG_ID.NOEMBED],
	[TAG_NAMES.NOSCRIPT, TAG_ID.NOSCRIPT],
	[TAG_NAMES.OBJECT, TAG_ID.OBJECT],
	[TAG_NAMES.OL, TAG_ID.OL],
	[TAG_NAMES.OPTGROUP, TAG_ID.OPTGROUP],
	[TAG_NAMES.OPTION, TAG_ID.OPTION],
	[TAG_NAMES.P, TAG_ID.P],
	[TAG_NAMES.PARAM, TAG_ID.PARAM],
	[TAG_NAMES.PLAINTEXT, TAG_ID.PLAINTEXT],
	[TAG_NAMES.PRE, TAG_ID.PRE],
	[TAG_NAMES.RB, TAG_ID.RB],
	[TAG_NAMES.RP, TAG_ID.RP],
	[TAG_NAMES.RT, TAG_ID.RT],
	[TAG_NAMES.RTC, TAG_ID.RTC],
	[TAG_NAMES.RUBY, TAG_ID.RUBY],
	[TAG_NAMES.S, TAG_ID.S],
	[TAG_NAMES.SCRIPT, TAG_ID.SCRIPT],
	[TAG_NAMES.SEARCH, TAG_ID.SEARCH],
	[TAG_NAMES.SECTION, TAG_ID.SECTION],
	[TAG_NAMES.SELECT, TAG_ID.SELECT],
	[TAG_NAMES.SOURCE, TAG_ID.SOURCE],
	[TAG_NAMES.SMALL, TAG_ID.SMALL],
	[TAG_NAMES.SPAN, TAG_ID.SPAN],
	[TAG_NAMES.STRIKE, TAG_ID.STRIKE],
	[TAG_NAMES.STRONG, TAG_ID.STRONG],
	[TAG_NAMES.STYLE, TAG_ID.STYLE],
	[TAG_NAMES.SUB, TAG_ID.SUB],
	[TAG_NAMES.SUMMARY, TAG_ID.SUMMARY],
	[TAG_NAMES.SUP, TAG_ID.SUP],
	[TAG_NAMES.TABLE, TAG_ID.TABLE],
	[TAG_NAMES.TBODY, TAG_ID.TBODY],
	[TAG_NAMES.TEMPLATE, TAG_ID.TEMPLATE],
	[TAG_NAMES.TEXTAREA, TAG_ID.TEXTAREA],
	[TAG_NAMES.TFOOT, TAG_ID.TFOOT],
	[TAG_NAMES.TD, TAG_ID.TD],
	[TAG_NAMES.TH, TAG_ID.TH],
	[TAG_NAMES.THEAD, TAG_ID.THEAD],
	[TAG_NAMES.TITLE, TAG_ID.TITLE],
	[TAG_NAMES.TR, TAG_ID.TR],
	[TAG_NAMES.TRACK, TAG_ID.TRACK],
	[TAG_NAMES.TT, TAG_ID.TT],
	[TAG_NAMES.U, TAG_ID.U],
	[TAG_NAMES.UL, TAG_ID.UL],
	[TAG_NAMES.SVG, TAG_ID.SVG],
	[TAG_NAMES.VAR, TAG_ID.VAR],
	[TAG_NAMES.WBR, TAG_ID.WBR],
	[TAG_NAMES.XMP, TAG_ID.XMP]
]);
function getTagID(tagName) {
	var _a$1;
	return (_a$1 = TAG_NAME_TO_ID.get(tagName)) !== null && _a$1 !== void 0 ? _a$1 : TAG_ID.UNKNOWN;
}
const $ = TAG_ID;
const SPECIAL_ELEMENTS = {
	[NS.HTML]: new Set([
		$.ADDRESS,
		$.APPLET,
		$.AREA,
		$.ARTICLE,
		$.ASIDE,
		$.BASE,
		$.BASEFONT,
		$.BGSOUND,
		$.BLOCKQUOTE,
		$.BODY,
		$.BR,
		$.BUTTON,
		$.CAPTION,
		$.CENTER,
		$.COL,
		$.COLGROUP,
		$.DD,
		$.DETAILS,
		$.DIR,
		$.DIV,
		$.DL,
		$.DT,
		$.EMBED,
		$.FIELDSET,
		$.FIGCAPTION,
		$.FIGURE,
		$.FOOTER,
		$.FORM,
		$.FRAME,
		$.FRAMESET,
		$.H1,
		$.H2,
		$.H3,
		$.H4,
		$.H5,
		$.H6,
		$.HEAD,
		$.HEADER,
		$.HGROUP,
		$.HR,
		$.HTML,
		$.IFRAME,
		$.IMG,
		$.INPUT,
		$.LI,
		$.LINK,
		$.LISTING,
		$.MAIN,
		$.MARQUEE,
		$.MENU,
		$.META,
		$.NAV,
		$.NOEMBED,
		$.NOFRAMES,
		$.NOSCRIPT,
		$.OBJECT,
		$.OL,
		$.P,
		$.PARAM,
		$.PLAINTEXT,
		$.PRE,
		$.SCRIPT,
		$.SECTION,
		$.SELECT,
		$.SOURCE,
		$.STYLE,
		$.SUMMARY,
		$.TABLE,
		$.TBODY,
		$.TD,
		$.TEMPLATE,
		$.TEXTAREA,
		$.TFOOT,
		$.TH,
		$.THEAD,
		$.TITLE,
		$.TR,
		$.TRACK,
		$.UL,
		$.WBR,
		$.XMP
	]),
	[NS.MATHML]: new Set([
		$.MI,
		$.MO,
		$.MN,
		$.MS,
		$.MTEXT,
		$.ANNOTATION_XML
	]),
	[NS.SVG]: new Set([
		$.TITLE,
		$.FOREIGN_OBJECT,
		$.DESC
	]),
	[NS.XLINK]: new Set(),
	[NS.XML]: new Set(),
	[NS.XMLNS]: new Set()
};
const NUMBERED_HEADERS = new Set([
	$.H1,
	$.H2,
	$.H3,
	$.H4,
	$.H5,
	$.H6
]);
const UNESCAPED_TEXT = new Set([
	TAG_NAMES.STYLE,
	TAG_NAMES.SCRIPT,
	TAG_NAMES.XMP,
	TAG_NAMES.IFRAME,
	TAG_NAMES.NOEMBED,
	TAG_NAMES.NOFRAMES,
	TAG_NAMES.PLAINTEXT
]);
var State;
(function(State$1) {
	State$1[State$1["DATA"] = 0] = "DATA";
	State$1[State$1["RCDATA"] = 1] = "RCDATA";
	State$1[State$1["RAWTEXT"] = 2] = "RAWTEXT";
	State$1[State$1["SCRIPT_DATA"] = 3] = "SCRIPT_DATA";
	State$1[State$1["PLAINTEXT"] = 4] = "PLAINTEXT";
	State$1[State$1["TAG_OPEN"] = 5] = "TAG_OPEN";
	State$1[State$1["END_TAG_OPEN"] = 6] = "END_TAG_OPEN";
	State$1[State$1["TAG_NAME"] = 7] = "TAG_NAME";
	State$1[State$1["RCDATA_LESS_THAN_SIGN"] = 8] = "RCDATA_LESS_THAN_SIGN";
	State$1[State$1["RCDATA_END_TAG_OPEN"] = 9] = "RCDATA_END_TAG_OPEN";
	State$1[State$1["RCDATA_END_TAG_NAME"] = 10] = "RCDATA_END_TAG_NAME";
	State$1[State$1["RAWTEXT_LESS_THAN_SIGN"] = 11] = "RAWTEXT_LESS_THAN_SIGN";
	State$1[State$1["RAWTEXT_END_TAG_OPEN"] = 12] = "RAWTEXT_END_TAG_OPEN";
	State$1[State$1["RAWTEXT_END_TAG_NAME"] = 13] = "RAWTEXT_END_TAG_NAME";
	State$1[State$1["SCRIPT_DATA_LESS_THAN_SIGN"] = 14] = "SCRIPT_DATA_LESS_THAN_SIGN";
	State$1[State$1["SCRIPT_DATA_END_TAG_OPEN"] = 15] = "SCRIPT_DATA_END_TAG_OPEN";
	State$1[State$1["SCRIPT_DATA_END_TAG_NAME"] = 16] = "SCRIPT_DATA_END_TAG_NAME";
	State$1[State$1["SCRIPT_DATA_ESCAPE_START"] = 17] = "SCRIPT_DATA_ESCAPE_START";
	State$1[State$1["SCRIPT_DATA_ESCAPE_START_DASH"] = 18] = "SCRIPT_DATA_ESCAPE_START_DASH";
	State$1[State$1["SCRIPT_DATA_ESCAPED"] = 19] = "SCRIPT_DATA_ESCAPED";
	State$1[State$1["SCRIPT_DATA_ESCAPED_DASH"] = 20] = "SCRIPT_DATA_ESCAPED_DASH";
	State$1[State$1["SCRIPT_DATA_ESCAPED_DASH_DASH"] = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH";
	State$1[State$1["SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"] = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN";
	State$1[State$1["SCRIPT_DATA_ESCAPED_END_TAG_OPEN"] = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN";
	State$1[State$1["SCRIPT_DATA_ESCAPED_END_TAG_NAME"] = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME";
	State$1[State$1["SCRIPT_DATA_DOUBLE_ESCAPE_START"] = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START";
	State$1[State$1["SCRIPT_DATA_DOUBLE_ESCAPED"] = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED";
	State$1[State$1["SCRIPT_DATA_DOUBLE_ESCAPED_DASH"] = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH";
	State$1[State$1["SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"] = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH";
	State$1[State$1["SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"] = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN";
	State$1[State$1["SCRIPT_DATA_DOUBLE_ESCAPE_END"] = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END";
	State$1[State$1["BEFORE_ATTRIBUTE_NAME"] = 31] = "BEFORE_ATTRIBUTE_NAME";
	State$1[State$1["ATTRIBUTE_NAME"] = 32] = "ATTRIBUTE_NAME";
	State$1[State$1["AFTER_ATTRIBUTE_NAME"] = 33] = "AFTER_ATTRIBUTE_NAME";
	State$1[State$1["BEFORE_ATTRIBUTE_VALUE"] = 34] = "BEFORE_ATTRIBUTE_VALUE";
	State$1[State$1["ATTRIBUTE_VALUE_DOUBLE_QUOTED"] = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED";
	State$1[State$1["ATTRIBUTE_VALUE_SINGLE_QUOTED"] = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED";
	State$1[State$1["ATTRIBUTE_VALUE_UNQUOTED"] = 37] = "ATTRIBUTE_VALUE_UNQUOTED";
	State$1[State$1["AFTER_ATTRIBUTE_VALUE_QUOTED"] = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED";
	State$1[State$1["SELF_CLOSING_START_TAG"] = 39] = "SELF_CLOSING_START_TAG";
	State$1[State$1["BOGUS_COMMENT"] = 40] = "BOGUS_COMMENT";
	State$1[State$1["MARKUP_DECLARATION_OPEN"] = 41] = "MARKUP_DECLARATION_OPEN";
	State$1[State$1["COMMENT_START"] = 42] = "COMMENT_START";
	State$1[State$1["COMMENT_START_DASH"] = 43] = "COMMENT_START_DASH";
	State$1[State$1["COMMENT"] = 44] = "COMMENT";
	State$1[State$1["COMMENT_LESS_THAN_SIGN"] = 45] = "COMMENT_LESS_THAN_SIGN";
	State$1[State$1["COMMENT_LESS_THAN_SIGN_BANG"] = 46] = "COMMENT_LESS_THAN_SIGN_BANG";
	State$1[State$1["COMMENT_LESS_THAN_SIGN_BANG_DASH"] = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH";
	State$1[State$1["COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"] = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH";
	State$1[State$1["COMMENT_END_DASH"] = 49] = "COMMENT_END_DASH";
	State$1[State$1["COMMENT_END"] = 50] = "COMMENT_END";
	State$1[State$1["COMMENT_END_BANG"] = 51] = "COMMENT_END_BANG";
	State$1[State$1["DOCTYPE"] = 52] = "DOCTYPE";
	State$1[State$1["BEFORE_DOCTYPE_NAME"] = 53] = "BEFORE_DOCTYPE_NAME";
	State$1[State$1["DOCTYPE_NAME"] = 54] = "DOCTYPE_NAME";
	State$1[State$1["AFTER_DOCTYPE_NAME"] = 55] = "AFTER_DOCTYPE_NAME";
	State$1[State$1["AFTER_DOCTYPE_PUBLIC_KEYWORD"] = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD";
	State$1[State$1["BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"] = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER";
	State$1[State$1["DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"] = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED";
	State$1[State$1["DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"] = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED";
	State$1[State$1["AFTER_DOCTYPE_PUBLIC_IDENTIFIER"] = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER";
	State$1[State$1["BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"] = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS";
	State$1[State$1["AFTER_DOCTYPE_SYSTEM_KEYWORD"] = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD";
	State$1[State$1["BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"] = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER";
	State$1[State$1["DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"] = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED";
	State$1[State$1["DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"] = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED";
	State$1[State$1["AFTER_DOCTYPE_SYSTEM_IDENTIFIER"] = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER";
	State$1[State$1["BOGUS_DOCTYPE"] = 67] = "BOGUS_DOCTYPE";
	State$1[State$1["CDATA_SECTION"] = 68] = "CDATA_SECTION";
	State$1[State$1["CDATA_SECTION_BRACKET"] = 69] = "CDATA_SECTION_BRACKET";
	State$1[State$1["CDATA_SECTION_END"] = 70] = "CDATA_SECTION_END";
	State$1[State$1["CHARACTER_REFERENCE"] = 71] = "CHARACTER_REFERENCE";
	State$1[State$1["AMBIGUOUS_AMPERSAND"] = 72] = "AMBIGUOUS_AMPERSAND";
})(State || (State = {}));
const TokenizerMode = {
	DATA: State.DATA,
	RCDATA: State.RCDATA,
	RAWTEXT: State.RAWTEXT,
	SCRIPT_DATA: State.SCRIPT_DATA,
	PLAINTEXT: State.PLAINTEXT,
	CDATA_SECTION: State.CDATA_SECTION
};
function isAsciiDigit(cp) {
	return cp >= CODE_POINTS.DIGIT_0 && cp <= CODE_POINTS.DIGIT_9;
}
function isAsciiUpper(cp) {
	return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_Z;
}
function isAsciiLower(cp) {
	return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_Z;
}
function isAsciiLetter(cp) {
	return isAsciiLower(cp) || isAsciiUpper(cp);
}
function isAsciiAlphaNumeric(cp) {
	return isAsciiLetter(cp) || isAsciiDigit(cp);
}
function toAsciiLower(cp) {
	return cp + 32;
}
function isWhitespace(cp) {
	return cp === CODE_POINTS.SPACE || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.TABULATION || cp === CODE_POINTS.FORM_FEED;
}
function isScriptDataDoubleEscapeSequenceEnd(cp) {
	return isWhitespace(cp) || cp === CODE_POINTS.SOLIDUS || cp === CODE_POINTS.GREATER_THAN_SIGN;
}
function getErrorForNumericCharacterReference(code$3) {
	if (code$3 === CODE_POINTS.NULL) return ERR.nullCharacterReference;
	else if (code$3 > 1114111) return ERR.characterReferenceOutsideUnicodeRange;
	else if (isSurrogate(code$3)) return ERR.surrogateCharacterReference;
	else if (isUndefinedCodePoint(code$3)) return ERR.noncharacterCharacterReference;
	else if (isControlCodePoint(code$3) || code$3 === CODE_POINTS.CARRIAGE_RETURN) return ERR.controlCharacterReference;
	return null;
}
var Tokenizer = class {
	constructor(options, handler) {
		this.options = options;
		this.handler = handler;
		this.paused = false;
		this.inLoop = false;
		this.inForeignNode = false;
		this.lastStartTagName = "";
		this.active = false;
		this.state = State.DATA;
		this.returnState = State.DATA;
		this.entityStartPos = 0;
		this.consumedAfterSnapshot = -1;
		this.currentCharacterToken = null;
		this.currentToken = null;
		this.currentAttr = {
			name: "",
			value: ""
		};
		this.preprocessor = new Preprocessor(handler);
		this.currentLocation = this.getCurrentLocation(-1);
		this.entityDecoder = new EntityDecoder(htmlDecodeTree, (cp, consumed) => {
			this.preprocessor.pos = this.entityStartPos + consumed - 1;
			this._flushCodePointConsumedAsCharacterReference(cp);
		}, handler.onParseError ? {
			missingSemicolonAfterCharacterReference: () => {
				this._err(ERR.missingSemicolonAfterCharacterReference, 1);
			},
			absenceOfDigitsInNumericCharacterReference: (consumed) => {
				this._err(ERR.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + consumed);
			},
			validateNumericCharacterReference: (code$3) => {
				const error = getErrorForNumericCharacterReference(code$3);
				if (error) this._err(error, 1);
			}
		} : void 0);
	}
	_err(code$3, cpOffset = 0) {
		var _a$1, _b;
		(_b = (_a$1 = this.handler).onParseError) === null || _b === void 0 || _b.call(_a$1, this.preprocessor.getError(code$3, cpOffset));
	}
	getCurrentLocation(offset) {
		if (!this.options.sourceCodeLocationInfo) return null;
		return {
			startLine: this.preprocessor.line,
			startCol: this.preprocessor.col - offset,
			startOffset: this.preprocessor.offset - offset,
			endLine: -1,
			endCol: -1,
			endOffset: -1
		};
	}
	_runParsingLoop() {
		if (this.inLoop) return;
		this.inLoop = true;
		while (this.active && !this.paused) {
			this.consumedAfterSnapshot = 0;
			const cp = this._consume();
			if (!this._ensureHibernation()) this._callState(cp);
		}
		this.inLoop = false;
	}
	pause() {
		this.paused = true;
	}
	resume(writeCallback) {
		if (!this.paused) throw new Error("Parser was already resumed");
		this.paused = false;
		if (this.inLoop) return;
		this._runParsingLoop();
		if (!this.paused) writeCallback === null || writeCallback === void 0 || writeCallback();
	}
	write(chunk, isLastChunk, writeCallback) {
		this.active = true;
		this.preprocessor.write(chunk, isLastChunk);
		this._runParsingLoop();
		if (!this.paused) writeCallback === null || writeCallback === void 0 || writeCallback();
	}
	insertHtmlAtCurrentPos(chunk) {
		this.active = true;
		this.preprocessor.insertHtmlAtCurrentPos(chunk);
		this._runParsingLoop();
	}
	_ensureHibernation() {
		if (this.preprocessor.endOfChunkHit) {
			this.preprocessor.retreat(this.consumedAfterSnapshot);
			this.consumedAfterSnapshot = 0;
			this.active = false;
			return true;
		}
		return false;
	}
	_consume() {
		this.consumedAfterSnapshot++;
		return this.preprocessor.advance();
	}
	_advanceBy(count$1) {
		this.consumedAfterSnapshot += count$1;
		for (let i = 0; i < count$1; i++) this.preprocessor.advance();
	}
	_consumeSequenceIfMatch(pattern, caseSensitive) {
		if (this.preprocessor.startsWith(pattern, caseSensitive)) {
			this._advanceBy(pattern.length - 1);
			return true;
		}
		return false;
	}
	_createStartTagToken() {
		this.currentToken = {
			type: TokenType.START_TAG,
			tagName: "",
			tagID: TAG_ID.UNKNOWN,
			selfClosing: false,
			ackSelfClosing: false,
			attrs: [],
			location: this.getCurrentLocation(1)
		};
	}
	_createEndTagToken() {
		this.currentToken = {
			type: TokenType.END_TAG,
			tagName: "",
			tagID: TAG_ID.UNKNOWN,
			selfClosing: false,
			ackSelfClosing: false,
			attrs: [],
			location: this.getCurrentLocation(2)
		};
	}
	_createCommentToken(offset) {
		this.currentToken = {
			type: TokenType.COMMENT,
			data: "",
			location: this.getCurrentLocation(offset)
		};
	}
	_createDoctypeToken(initialName) {
		this.currentToken = {
			type: TokenType.DOCTYPE,
			name: initialName,
			forceQuirks: false,
			publicId: null,
			systemId: null,
			location: this.currentLocation
		};
	}
	_createCharacterToken(type, chars) {
		this.currentCharacterToken = {
			type,
			chars,
			location: this.currentLocation
		};
	}
	_createAttr(attrNameFirstCh) {
		this.currentAttr = {
			name: attrNameFirstCh,
			value: ""
		};
		this.currentLocation = this.getCurrentLocation(0);
	}
	_leaveAttrName() {
		var _a$1;
		var _b;
		const token = this.currentToken;
		if (getTokenAttr(token, this.currentAttr.name) === null) {
			token.attrs.push(this.currentAttr);
			if (token.location && this.currentLocation) {
				const attrLocations = (_a$1 = (_b = token.location).attrs) !== null && _a$1 !== void 0 ? _a$1 : _b.attrs = Object.create(null);
				attrLocations[this.currentAttr.name] = this.currentLocation;
				this._leaveAttrValue();
			}
		} else this._err(ERR.duplicateAttribute);
	}
	_leaveAttrValue() {
		if (this.currentLocation) {
			this.currentLocation.endLine = this.preprocessor.line;
			this.currentLocation.endCol = this.preprocessor.col;
			this.currentLocation.endOffset = this.preprocessor.offset;
		}
	}
	prepareToken(ct) {
		this._emitCurrentCharacterToken(ct.location);
		this.currentToken = null;
		if (ct.location) {
			ct.location.endLine = this.preprocessor.line;
			ct.location.endCol = this.preprocessor.col + 1;
			ct.location.endOffset = this.preprocessor.offset + 1;
		}
		this.currentLocation = this.getCurrentLocation(-1);
	}
	emitCurrentTagToken() {
		const ct = this.currentToken;
		this.prepareToken(ct);
		ct.tagID = getTagID(ct.tagName);
		if (ct.type === TokenType.START_TAG) {
			this.lastStartTagName = ct.tagName;
			this.handler.onStartTag(ct);
		} else {
			if (ct.attrs.length > 0) this._err(ERR.endTagWithAttributes);
			if (ct.selfClosing) this._err(ERR.endTagWithTrailingSolidus);
			this.handler.onEndTag(ct);
		}
		this.preprocessor.dropParsedChunk();
	}
	emitCurrentComment(ct) {
		this.prepareToken(ct);
		this.handler.onComment(ct);
		this.preprocessor.dropParsedChunk();
	}
	emitCurrentDoctype(ct) {
		this.prepareToken(ct);
		this.handler.onDoctype(ct);
		this.preprocessor.dropParsedChunk();
	}
	_emitCurrentCharacterToken(nextLocation) {
		if (this.currentCharacterToken) {
			if (nextLocation && this.currentCharacterToken.location) {
				this.currentCharacterToken.location.endLine = nextLocation.startLine;
				this.currentCharacterToken.location.endCol = nextLocation.startCol;
				this.currentCharacterToken.location.endOffset = nextLocation.startOffset;
			}
			switch (this.currentCharacterToken.type) {
				case TokenType.CHARACTER: {
					this.handler.onCharacter(this.currentCharacterToken);
					break;
				}
				case TokenType.NULL_CHARACTER: {
					this.handler.onNullCharacter(this.currentCharacterToken);
					break;
				}
				case TokenType.WHITESPACE_CHARACTER: {
					this.handler.onWhitespaceCharacter(this.currentCharacterToken);
					break;
				}
			}
			this.currentCharacterToken = null;
		}
	}
	_emitEOFToken() {
		const location$1 = this.getCurrentLocation(0);
		if (location$1) {
			location$1.endLine = location$1.startLine;
			location$1.endCol = location$1.startCol;
			location$1.endOffset = location$1.startOffset;
		}
		this._emitCurrentCharacterToken(location$1);
		this.handler.onEof({
			type: TokenType.EOF,
			location: location$1
		});
		this.active = false;
	}
	_appendCharToCurrentCharacterToken(type, ch) {
		if (this.currentCharacterToken) if (this.currentCharacterToken.type === type) {
			this.currentCharacterToken.chars += ch;
			return;
		} else {
			this.currentLocation = this.getCurrentLocation(0);
			this._emitCurrentCharacterToken(this.currentLocation);
			this.preprocessor.dropParsedChunk();
		}
		this._createCharacterToken(type, ch);
	}
	_emitCodePoint(cp) {
		const type = isWhitespace(cp) ? TokenType.WHITESPACE_CHARACTER : cp === CODE_POINTS.NULL ? TokenType.NULL_CHARACTER : TokenType.CHARACTER;
		this._appendCharToCurrentCharacterToken(type, String.fromCodePoint(cp));
	}
	_emitChars(ch) {
		this._appendCharToCurrentCharacterToken(TokenType.CHARACTER, ch);
	}
	_startCharacterReference() {
		this.returnState = this.state;
		this.state = State.CHARACTER_REFERENCE;
		this.entityStartPos = this.preprocessor.pos;
		this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? DecodingMode.Attribute : DecodingMode.Legacy);
	}
	_isCharacterReferenceInAttribute() {
		return this.returnState === State.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_UNQUOTED;
	}
	_flushCodePointConsumedAsCharacterReference(cp) {
		if (this._isCharacterReferenceInAttribute()) this.currentAttr.value += String.fromCodePoint(cp);
		else this._emitCodePoint(cp);
	}
	_callState(cp) {
		switch (this.state) {
			case State.DATA: {
				this._stateData(cp);
				break;
			}
			case State.RCDATA: {
				this._stateRcdata(cp);
				break;
			}
			case State.RAWTEXT: {
				this._stateRawtext(cp);
				break;
			}
			case State.SCRIPT_DATA: {
				this._stateScriptData(cp);
				break;
			}
			case State.PLAINTEXT: {
				this._statePlaintext(cp);
				break;
			}
			case State.TAG_OPEN: {
				this._stateTagOpen(cp);
				break;
			}
			case State.END_TAG_OPEN: {
				this._stateEndTagOpen(cp);
				break;
			}
			case State.TAG_NAME: {
				this._stateTagName(cp);
				break;
			}
			case State.RCDATA_LESS_THAN_SIGN: {
				this._stateRcdataLessThanSign(cp);
				break;
			}
			case State.RCDATA_END_TAG_OPEN: {
				this._stateRcdataEndTagOpen(cp);
				break;
			}
			case State.RCDATA_END_TAG_NAME: {
				this._stateRcdataEndTagName(cp);
				break;
			}
			case State.RAWTEXT_LESS_THAN_SIGN: {
				this._stateRawtextLessThanSign(cp);
				break;
			}
			case State.RAWTEXT_END_TAG_OPEN: {
				this._stateRawtextEndTagOpen(cp);
				break;
			}
			case State.RAWTEXT_END_TAG_NAME: {
				this._stateRawtextEndTagName(cp);
				break;
			}
			case State.SCRIPT_DATA_LESS_THAN_SIGN: {
				this._stateScriptDataLessThanSign(cp);
				break;
			}
			case State.SCRIPT_DATA_END_TAG_OPEN: {
				this._stateScriptDataEndTagOpen(cp);
				break;
			}
			case State.SCRIPT_DATA_END_TAG_NAME: {
				this._stateScriptDataEndTagName(cp);
				break;
			}
			case State.SCRIPT_DATA_ESCAPE_START: {
				this._stateScriptDataEscapeStart(cp);
				break;
			}
			case State.SCRIPT_DATA_ESCAPE_START_DASH: {
				this._stateScriptDataEscapeStartDash(cp);
				break;
			}
			case State.SCRIPT_DATA_ESCAPED: {
				this._stateScriptDataEscaped(cp);
				break;
			}
			case State.SCRIPT_DATA_ESCAPED_DASH: {
				this._stateScriptDataEscapedDash(cp);
				break;
			}
			case State.SCRIPT_DATA_ESCAPED_DASH_DASH: {
				this._stateScriptDataEscapedDashDash(cp);
				break;
			}
			case State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
				this._stateScriptDataEscapedLessThanSign(cp);
				break;
			}
			case State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
				this._stateScriptDataEscapedEndTagOpen(cp);
				break;
			}
			case State.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
				this._stateScriptDataEscapedEndTagName(cp);
				break;
			}
			case State.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
				this._stateScriptDataDoubleEscapeStart(cp);
				break;
			}
			case State.SCRIPT_DATA_DOUBLE_ESCAPED: {
				this._stateScriptDataDoubleEscaped(cp);
				break;
			}
			case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
				this._stateScriptDataDoubleEscapedDash(cp);
				break;
			}
			case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
				this._stateScriptDataDoubleEscapedDashDash(cp);
				break;
			}
			case State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
				this._stateScriptDataDoubleEscapedLessThanSign(cp);
				break;
			}
			case State.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
				this._stateScriptDataDoubleEscapeEnd(cp);
				break;
			}
			case State.BEFORE_ATTRIBUTE_NAME: {
				this._stateBeforeAttributeName(cp);
				break;
			}
			case State.ATTRIBUTE_NAME: {
				this._stateAttributeName(cp);
				break;
			}
			case State.AFTER_ATTRIBUTE_NAME: {
				this._stateAfterAttributeName(cp);
				break;
			}
			case State.BEFORE_ATTRIBUTE_VALUE: {
				this._stateBeforeAttributeValue(cp);
				break;
			}
			case State.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
				this._stateAttributeValueDoubleQuoted(cp);
				break;
			}
			case State.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
				this._stateAttributeValueSingleQuoted(cp);
				break;
			}
			case State.ATTRIBUTE_VALUE_UNQUOTED: {
				this._stateAttributeValueUnquoted(cp);
				break;
			}
			case State.AFTER_ATTRIBUTE_VALUE_QUOTED: {
				this._stateAfterAttributeValueQuoted(cp);
				break;
			}
			case State.SELF_CLOSING_START_TAG: {
				this._stateSelfClosingStartTag(cp);
				break;
			}
			case State.BOGUS_COMMENT: {
				this._stateBogusComment(cp);
				break;
			}
			case State.MARKUP_DECLARATION_OPEN: {
				this._stateMarkupDeclarationOpen(cp);
				break;
			}
			case State.COMMENT_START: {
				this._stateCommentStart(cp);
				break;
			}
			case State.COMMENT_START_DASH: {
				this._stateCommentStartDash(cp);
				break;
			}
			case State.COMMENT: {
				this._stateComment(cp);
				break;
			}
			case State.COMMENT_LESS_THAN_SIGN: {
				this._stateCommentLessThanSign(cp);
				break;
			}
			case State.COMMENT_LESS_THAN_SIGN_BANG: {
				this._stateCommentLessThanSignBang(cp);
				break;
			}
			case State.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
				this._stateCommentLessThanSignBangDash(cp);
				break;
			}
			case State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
				this._stateCommentLessThanSignBangDashDash(cp);
				break;
			}
			case State.COMMENT_END_DASH: {
				this._stateCommentEndDash(cp);
				break;
			}
			case State.COMMENT_END: {
				this._stateCommentEnd(cp);
				break;
			}
			case State.COMMENT_END_BANG: {
				this._stateCommentEndBang(cp);
				break;
			}
			case State.DOCTYPE: {
				this._stateDoctype(cp);
				break;
			}
			case State.BEFORE_DOCTYPE_NAME: {
				this._stateBeforeDoctypeName(cp);
				break;
			}
			case State.DOCTYPE_NAME: {
				this._stateDoctypeName(cp);
				break;
			}
			case State.AFTER_DOCTYPE_NAME: {
				this._stateAfterDoctypeName(cp);
				break;
			}
			case State.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
				this._stateAfterDoctypePublicKeyword(cp);
				break;
			}
			case State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
				this._stateBeforeDoctypePublicIdentifier(cp);
				break;
			}
			case State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
				this._stateDoctypePublicIdentifierDoubleQuoted(cp);
				break;
			}
			case State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
				this._stateDoctypePublicIdentifierSingleQuoted(cp);
				break;
			}
			case State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
				this._stateAfterDoctypePublicIdentifier(cp);
				break;
			}
			case State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
				this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);
				break;
			}
			case State.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
				this._stateAfterDoctypeSystemKeyword(cp);
				break;
			}
			case State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
				this._stateBeforeDoctypeSystemIdentifier(cp);
				break;
			}
			case State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
				this._stateDoctypeSystemIdentifierDoubleQuoted(cp);
				break;
			}
			case State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
				this._stateDoctypeSystemIdentifierSingleQuoted(cp);
				break;
			}
			case State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
				this._stateAfterDoctypeSystemIdentifier(cp);
				break;
			}
			case State.BOGUS_DOCTYPE: {
				this._stateBogusDoctype(cp);
				break;
			}
			case State.CDATA_SECTION: {
				this._stateCdataSection(cp);
				break;
			}
			case State.CDATA_SECTION_BRACKET: {
				this._stateCdataSectionBracket(cp);
				break;
			}
			case State.CDATA_SECTION_END: {
				this._stateCdataSectionEnd(cp);
				break;
			}
			case State.CHARACTER_REFERENCE: {
				this._stateCharacterReference();
				break;
			}
			case State.AMBIGUOUS_AMPERSAND: {
				this._stateAmbiguousAmpersand(cp);
				break;
			}
			default: throw new Error("Unknown state");
		}
	}
	_stateData(cp) {
		switch (cp) {
			case CODE_POINTS.LESS_THAN_SIGN: {
				this.state = State.TAG_OPEN;
				break;
			}
			case CODE_POINTS.AMPERSAND: {
				this._startCharacterReference();
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this._emitCodePoint(cp);
				break;
			}
			case CODE_POINTS.EOF: {
				this._emitEOFToken();
				break;
			}
			default: this._emitCodePoint(cp);
		}
	}
	_stateRcdata(cp) {
		switch (cp) {
			case CODE_POINTS.AMPERSAND: {
				this._startCharacterReference();
				break;
			}
			case CODE_POINTS.LESS_THAN_SIGN: {
				this.state = State.RCDATA_LESS_THAN_SIGN;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this._emitChars(REPLACEMENT_CHARACTER);
				break;
			}
			case CODE_POINTS.EOF: {
				this._emitEOFToken();
				break;
			}
			default: this._emitCodePoint(cp);
		}
	}
	_stateRawtext(cp) {
		switch (cp) {
			case CODE_POINTS.LESS_THAN_SIGN: {
				this.state = State.RAWTEXT_LESS_THAN_SIGN;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this._emitChars(REPLACEMENT_CHARACTER);
				break;
			}
			case CODE_POINTS.EOF: {
				this._emitEOFToken();
				break;
			}
			default: this._emitCodePoint(cp);
		}
	}
	_stateScriptData(cp) {
		switch (cp) {
			case CODE_POINTS.LESS_THAN_SIGN: {
				this.state = State.SCRIPT_DATA_LESS_THAN_SIGN;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this._emitChars(REPLACEMENT_CHARACTER);
				break;
			}
			case CODE_POINTS.EOF: {
				this._emitEOFToken();
				break;
			}
			default: this._emitCodePoint(cp);
		}
	}
	_statePlaintext(cp) {
		switch (cp) {
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this._emitChars(REPLACEMENT_CHARACTER);
				break;
			}
			case CODE_POINTS.EOF: {
				this._emitEOFToken();
				break;
			}
			default: this._emitCodePoint(cp);
		}
	}
	_stateTagOpen(cp) {
		if (isAsciiLetter(cp)) {
			this._createStartTagToken();
			this.state = State.TAG_NAME;
			this._stateTagName(cp);
		} else switch (cp) {
			case CODE_POINTS.EXCLAMATION_MARK: {
				this.state = State.MARKUP_DECLARATION_OPEN;
				break;
			}
			case CODE_POINTS.SOLIDUS: {
				this.state = State.END_TAG_OPEN;
				break;
			}
			case CODE_POINTS.QUESTION_MARK: {
				this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);
				this._createCommentToken(1);
				this.state = State.BOGUS_COMMENT;
				this._stateBogusComment(cp);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofBeforeTagName);
				this._emitChars("<");
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.invalidFirstCharacterOfTagName);
				this._emitChars("<");
				this.state = State.DATA;
				this._stateData(cp);
			}
		}
	}
	_stateEndTagOpen(cp) {
		if (isAsciiLetter(cp)) {
			this._createEndTagToken();
			this.state = State.TAG_NAME;
			this._stateTagName(cp);
		} else switch (cp) {
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.missingEndTagName);
				this.state = State.DATA;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofBeforeTagName);
				this._emitChars("</");
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.invalidFirstCharacterOfTagName);
				this._createCommentToken(2);
				this.state = State.BOGUS_COMMENT;
				this._stateBogusComment(cp);
			}
		}
	}
	_stateTagName(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				this.state = State.BEFORE_ATTRIBUTE_NAME;
				break;
			}
			case CODE_POINTS.SOLIDUS: {
				this.state = State.SELF_CLOSING_START_TAG;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.DATA;
				this.emitCurrentTagToken();
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				token.tagName += REPLACEMENT_CHARACTER;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInTag);
				this._emitEOFToken();
				break;
			}
			default: token.tagName += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
		}
	}
	_stateRcdataLessThanSign(cp) {
		if (cp === CODE_POINTS.SOLIDUS) this.state = State.RCDATA_END_TAG_OPEN;
		else {
			this._emitChars("<");
			this.state = State.RCDATA;
			this._stateRcdata(cp);
		}
	}
	_stateRcdataEndTagOpen(cp) {
		if (isAsciiLetter(cp)) {
			this.state = State.RCDATA_END_TAG_NAME;
			this._stateRcdataEndTagName(cp);
		} else {
			this._emitChars("</");
			this.state = State.RCDATA;
			this._stateRcdata(cp);
		}
	}
	handleSpecialEndTag(_cp) {
		if (!this.preprocessor.startsWith(this.lastStartTagName, false)) return !this._ensureHibernation();
		this._createEndTagToken();
		const token = this.currentToken;
		token.tagName = this.lastStartTagName;
		const cp = this.preprocessor.peek(this.lastStartTagName.length);
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				this._advanceBy(this.lastStartTagName.length);
				this.state = State.BEFORE_ATTRIBUTE_NAME;
				return false;
			}
			case CODE_POINTS.SOLIDUS: {
				this._advanceBy(this.lastStartTagName.length);
				this.state = State.SELF_CLOSING_START_TAG;
				return false;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._advanceBy(this.lastStartTagName.length);
				this.emitCurrentTagToken();
				this.state = State.DATA;
				return false;
			}
			default: return !this._ensureHibernation();
		}
	}
	_stateRcdataEndTagName(cp) {
		if (this.handleSpecialEndTag(cp)) {
			this._emitChars("</");
			this.state = State.RCDATA;
			this._stateRcdata(cp);
		}
	}
	_stateRawtextLessThanSign(cp) {
		if (cp === CODE_POINTS.SOLIDUS) this.state = State.RAWTEXT_END_TAG_OPEN;
		else {
			this._emitChars("<");
			this.state = State.RAWTEXT;
			this._stateRawtext(cp);
		}
	}
	_stateRawtextEndTagOpen(cp) {
		if (isAsciiLetter(cp)) {
			this.state = State.RAWTEXT_END_TAG_NAME;
			this._stateRawtextEndTagName(cp);
		} else {
			this._emitChars("</");
			this.state = State.RAWTEXT;
			this._stateRawtext(cp);
		}
	}
	_stateRawtextEndTagName(cp) {
		if (this.handleSpecialEndTag(cp)) {
			this._emitChars("</");
			this.state = State.RAWTEXT;
			this._stateRawtext(cp);
		}
	}
	_stateScriptDataLessThanSign(cp) {
		switch (cp) {
			case CODE_POINTS.SOLIDUS: {
				this.state = State.SCRIPT_DATA_END_TAG_OPEN;
				break;
			}
			case CODE_POINTS.EXCLAMATION_MARK: {
				this.state = State.SCRIPT_DATA_ESCAPE_START;
				this._emitChars("<!");
				break;
			}
			default: {
				this._emitChars("<");
				this.state = State.SCRIPT_DATA;
				this._stateScriptData(cp);
			}
		}
	}
	_stateScriptDataEndTagOpen(cp) {
		if (isAsciiLetter(cp)) {
			this.state = State.SCRIPT_DATA_END_TAG_NAME;
			this._stateScriptDataEndTagName(cp);
		} else {
			this._emitChars("</");
			this.state = State.SCRIPT_DATA;
			this._stateScriptData(cp);
		}
	}
	_stateScriptDataEndTagName(cp) {
		if (this.handleSpecialEndTag(cp)) {
			this._emitChars("</");
			this.state = State.SCRIPT_DATA;
			this._stateScriptData(cp);
		}
	}
	_stateScriptDataEscapeStart(cp) {
		if (cp === CODE_POINTS.HYPHEN_MINUS) {
			this.state = State.SCRIPT_DATA_ESCAPE_START_DASH;
			this._emitChars("-");
		} else {
			this.state = State.SCRIPT_DATA;
			this._stateScriptData(cp);
		}
	}
	_stateScriptDataEscapeStartDash(cp) {
		if (cp === CODE_POINTS.HYPHEN_MINUS) {
			this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
			this._emitChars("-");
		} else {
			this.state = State.SCRIPT_DATA;
			this._stateScriptData(cp);
		}
	}
	_stateScriptDataEscaped(cp) {
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				this.state = State.SCRIPT_DATA_ESCAPED_DASH;
				this._emitChars("-");
				break;
			}
			case CODE_POINTS.LESS_THAN_SIGN: {
				this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this._emitChars(REPLACEMENT_CHARACTER);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInScriptHtmlCommentLikeText);
				this._emitEOFToken();
				break;
			}
			default: this._emitCodePoint(cp);
		}
	}
	_stateScriptDataEscapedDash(cp) {
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
				this._emitChars("-");
				break;
			}
			case CODE_POINTS.LESS_THAN_SIGN: {
				this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this.state = State.SCRIPT_DATA_ESCAPED;
				this._emitChars(REPLACEMENT_CHARACTER);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInScriptHtmlCommentLikeText);
				this._emitEOFToken();
				break;
			}
			default: {
				this.state = State.SCRIPT_DATA_ESCAPED;
				this._emitCodePoint(cp);
			}
		}
	}
	_stateScriptDataEscapedDashDash(cp) {
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				this._emitChars("-");
				break;
			}
			case CODE_POINTS.LESS_THAN_SIGN: {
				this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.SCRIPT_DATA;
				this._emitChars(">");
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this.state = State.SCRIPT_DATA_ESCAPED;
				this._emitChars(REPLACEMENT_CHARACTER);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInScriptHtmlCommentLikeText);
				this._emitEOFToken();
				break;
			}
			default: {
				this.state = State.SCRIPT_DATA_ESCAPED;
				this._emitCodePoint(cp);
			}
		}
	}
	_stateScriptDataEscapedLessThanSign(cp) {
		if (cp === CODE_POINTS.SOLIDUS) this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;
		else if (isAsciiLetter(cp)) {
			this._emitChars("<");
			this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_START;
			this._stateScriptDataDoubleEscapeStart(cp);
		} else {
			this._emitChars("<");
			this.state = State.SCRIPT_DATA_ESCAPED;
			this._stateScriptDataEscaped(cp);
		}
	}
	_stateScriptDataEscapedEndTagOpen(cp) {
		if (isAsciiLetter(cp)) {
			this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_NAME;
			this._stateScriptDataEscapedEndTagName(cp);
		} else {
			this._emitChars("</");
			this.state = State.SCRIPT_DATA_ESCAPED;
			this._stateScriptDataEscaped(cp);
		}
	}
	_stateScriptDataEscapedEndTagName(cp) {
		if (this.handleSpecialEndTag(cp)) {
			this._emitChars("</");
			this.state = State.SCRIPT_DATA_ESCAPED;
			this._stateScriptDataEscaped(cp);
		}
	}
	_stateScriptDataDoubleEscapeStart(cp) {
		if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
			this._emitCodePoint(cp);
			for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) this._emitCodePoint(this._consume());
			this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
		} else if (!this._ensureHibernation()) {
			this.state = State.SCRIPT_DATA_ESCAPED;
			this._stateScriptDataEscaped(cp);
		}
	}
	_stateScriptDataDoubleEscaped(cp) {
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;
				this._emitChars("-");
				break;
			}
			case CODE_POINTS.LESS_THAN_SIGN: {
				this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
				this._emitChars("<");
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this._emitChars(REPLACEMENT_CHARACTER);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInScriptHtmlCommentLikeText);
				this._emitEOFToken();
				break;
			}
			default: this._emitCodePoint(cp);
		}
	}
	_stateScriptDataDoubleEscapedDash(cp) {
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;
				this._emitChars("-");
				break;
			}
			case CODE_POINTS.LESS_THAN_SIGN: {
				this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
				this._emitChars("<");
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
				this._emitChars(REPLACEMENT_CHARACTER);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInScriptHtmlCommentLikeText);
				this._emitEOFToken();
				break;
			}
			default: {
				this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
				this._emitCodePoint(cp);
			}
		}
	}
	_stateScriptDataDoubleEscapedDashDash(cp) {
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				this._emitChars("-");
				break;
			}
			case CODE_POINTS.LESS_THAN_SIGN: {
				this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
				this._emitChars("<");
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.SCRIPT_DATA;
				this._emitChars(">");
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
				this._emitChars(REPLACEMENT_CHARACTER);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInScriptHtmlCommentLikeText);
				this._emitEOFToken();
				break;
			}
			default: {
				this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
				this._emitCodePoint(cp);
			}
		}
	}
	_stateScriptDataDoubleEscapedLessThanSign(cp) {
		if (cp === CODE_POINTS.SOLIDUS) {
			this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_END;
			this._emitChars("/");
		} else {
			this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
			this._stateScriptDataDoubleEscaped(cp);
		}
	}
	_stateScriptDataDoubleEscapeEnd(cp) {
		if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
			this._emitCodePoint(cp);
			for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) this._emitCodePoint(this._consume());
			this.state = State.SCRIPT_DATA_ESCAPED;
		} else if (!this._ensureHibernation()) {
			this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
			this._stateScriptDataDoubleEscaped(cp);
		}
	}
	_stateBeforeAttributeName(cp) {
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: break;
			case CODE_POINTS.SOLIDUS:
			case CODE_POINTS.GREATER_THAN_SIGN:
			case CODE_POINTS.EOF: {
				this.state = State.AFTER_ATTRIBUTE_NAME;
				this._stateAfterAttributeName(cp);
				break;
			}
			case CODE_POINTS.EQUALS_SIGN: {
				this._err(ERR.unexpectedEqualsSignBeforeAttributeName);
				this._createAttr("=");
				this.state = State.ATTRIBUTE_NAME;
				break;
			}
			default: {
				this._createAttr("");
				this.state = State.ATTRIBUTE_NAME;
				this._stateAttributeName(cp);
			}
		}
	}
	_stateAttributeName(cp) {
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED:
			case CODE_POINTS.SOLIDUS:
			case CODE_POINTS.GREATER_THAN_SIGN:
			case CODE_POINTS.EOF: {
				this._leaveAttrName();
				this.state = State.AFTER_ATTRIBUTE_NAME;
				this._stateAfterAttributeName(cp);
				break;
			}
			case CODE_POINTS.EQUALS_SIGN: {
				this._leaveAttrName();
				this.state = State.BEFORE_ATTRIBUTE_VALUE;
				break;
			}
			case CODE_POINTS.QUOTATION_MARK:
			case CODE_POINTS.APOSTROPHE:
			case CODE_POINTS.LESS_THAN_SIGN: {
				this._err(ERR.unexpectedCharacterInAttributeName);
				this.currentAttr.name += String.fromCodePoint(cp);
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this.currentAttr.name += REPLACEMENT_CHARACTER;
				break;
			}
			default: this.currentAttr.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
		}
	}
	_stateAfterAttributeName(cp) {
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: break;
			case CODE_POINTS.SOLIDUS: {
				this.state = State.SELF_CLOSING_START_TAG;
				break;
			}
			case CODE_POINTS.EQUALS_SIGN: {
				this.state = State.BEFORE_ATTRIBUTE_VALUE;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.DATA;
				this.emitCurrentTagToken();
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInTag);
				this._emitEOFToken();
				break;
			}
			default: {
				this._createAttr("");
				this.state = State.ATTRIBUTE_NAME;
				this._stateAttributeName(cp);
			}
		}
	}
	_stateBeforeAttributeValue(cp) {
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: break;
			case CODE_POINTS.QUOTATION_MARK: {
				this.state = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
				break;
			}
			case CODE_POINTS.APOSTROPHE: {
				this.state = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.missingAttributeValue);
				this.state = State.DATA;
				this.emitCurrentTagToken();
				break;
			}
			default: {
				this.state = State.ATTRIBUTE_VALUE_UNQUOTED;
				this._stateAttributeValueUnquoted(cp);
			}
		}
	}
	_stateAttributeValueDoubleQuoted(cp) {
		switch (cp) {
			case CODE_POINTS.QUOTATION_MARK: {
				this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
				break;
			}
			case CODE_POINTS.AMPERSAND: {
				this._startCharacterReference();
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this.currentAttr.value += REPLACEMENT_CHARACTER;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInTag);
				this._emitEOFToken();
				break;
			}
			default: this.currentAttr.value += String.fromCodePoint(cp);
		}
	}
	_stateAttributeValueSingleQuoted(cp) {
		switch (cp) {
			case CODE_POINTS.APOSTROPHE: {
				this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
				break;
			}
			case CODE_POINTS.AMPERSAND: {
				this._startCharacterReference();
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this.currentAttr.value += REPLACEMENT_CHARACTER;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInTag);
				this._emitEOFToken();
				break;
			}
			default: this.currentAttr.value += String.fromCodePoint(cp);
		}
	}
	_stateAttributeValueUnquoted(cp) {
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				this._leaveAttrValue();
				this.state = State.BEFORE_ATTRIBUTE_NAME;
				break;
			}
			case CODE_POINTS.AMPERSAND: {
				this._startCharacterReference();
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._leaveAttrValue();
				this.state = State.DATA;
				this.emitCurrentTagToken();
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this.currentAttr.value += REPLACEMENT_CHARACTER;
				break;
			}
			case CODE_POINTS.QUOTATION_MARK:
			case CODE_POINTS.APOSTROPHE:
			case CODE_POINTS.LESS_THAN_SIGN:
			case CODE_POINTS.EQUALS_SIGN:
			case CODE_POINTS.GRAVE_ACCENT: {
				this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);
				this.currentAttr.value += String.fromCodePoint(cp);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInTag);
				this._emitEOFToken();
				break;
			}
			default: this.currentAttr.value += String.fromCodePoint(cp);
		}
	}
	_stateAfterAttributeValueQuoted(cp) {
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				this._leaveAttrValue();
				this.state = State.BEFORE_ATTRIBUTE_NAME;
				break;
			}
			case CODE_POINTS.SOLIDUS: {
				this._leaveAttrValue();
				this.state = State.SELF_CLOSING_START_TAG;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._leaveAttrValue();
				this.state = State.DATA;
				this.emitCurrentTagToken();
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInTag);
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.missingWhitespaceBetweenAttributes);
				this.state = State.BEFORE_ATTRIBUTE_NAME;
				this._stateBeforeAttributeName(cp);
			}
		}
	}
	_stateSelfClosingStartTag(cp) {
		switch (cp) {
			case CODE_POINTS.GREATER_THAN_SIGN: {
				const token = this.currentToken;
				token.selfClosing = true;
				this.state = State.DATA;
				this.emitCurrentTagToken();
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInTag);
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.unexpectedSolidusInTag);
				this.state = State.BEFORE_ATTRIBUTE_NAME;
				this._stateBeforeAttributeName(cp);
			}
		}
	}
	_stateBogusComment(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.DATA;
				this.emitCurrentComment(token);
				break;
			}
			case CODE_POINTS.EOF: {
				this.emitCurrentComment(token);
				this._emitEOFToken();
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				token.data += REPLACEMENT_CHARACTER;
				break;
			}
			default: token.data += String.fromCodePoint(cp);
		}
	}
	_stateMarkupDeclarationOpen(cp) {
		if (this._consumeSequenceIfMatch(SEQUENCES.DASH_DASH, true)) {
			this._createCommentToken(SEQUENCES.DASH_DASH.length + 1);
			this.state = State.COMMENT_START;
		} else if (this._consumeSequenceIfMatch(SEQUENCES.DOCTYPE, false)) {
			this.currentLocation = this.getCurrentLocation(SEQUENCES.DOCTYPE.length + 1);
			this.state = State.DOCTYPE;
		} else if (this._consumeSequenceIfMatch(SEQUENCES.CDATA_START, true)) if (this.inForeignNode) this.state = State.CDATA_SECTION;
		else {
			this._err(ERR.cdataInHtmlContent);
			this._createCommentToken(SEQUENCES.CDATA_START.length + 1);
			this.currentToken.data = "[CDATA[";
			this.state = State.BOGUS_COMMENT;
		}
		else if (!this._ensureHibernation()) {
			this._err(ERR.incorrectlyOpenedComment);
			this._createCommentToken(2);
			this.state = State.BOGUS_COMMENT;
			this._stateBogusComment(cp);
		}
	}
	_stateCommentStart(cp) {
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				this.state = State.COMMENT_START_DASH;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.abruptClosingOfEmptyComment);
				this.state = State.DATA;
				const token = this.currentToken;
				this.emitCurrentComment(token);
				break;
			}
			default: {
				this.state = State.COMMENT;
				this._stateComment(cp);
			}
		}
	}
	_stateCommentStartDash(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				this.state = State.COMMENT_END;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.abruptClosingOfEmptyComment);
				this.state = State.DATA;
				this.emitCurrentComment(token);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInComment);
				this.emitCurrentComment(token);
				this._emitEOFToken();
				break;
			}
			default: {
				token.data += "-";
				this.state = State.COMMENT;
				this._stateComment(cp);
			}
		}
	}
	_stateComment(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				this.state = State.COMMENT_END_DASH;
				break;
			}
			case CODE_POINTS.LESS_THAN_SIGN: {
				token.data += "<";
				this.state = State.COMMENT_LESS_THAN_SIGN;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				token.data += REPLACEMENT_CHARACTER;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInComment);
				this.emitCurrentComment(token);
				this._emitEOFToken();
				break;
			}
			default: token.data += String.fromCodePoint(cp);
		}
	}
	_stateCommentLessThanSign(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.EXCLAMATION_MARK: {
				token.data += "!";
				this.state = State.COMMENT_LESS_THAN_SIGN_BANG;
				break;
			}
			case CODE_POINTS.LESS_THAN_SIGN: {
				token.data += "<";
				break;
			}
			default: {
				this.state = State.COMMENT;
				this._stateComment(cp);
			}
		}
	}
	_stateCommentLessThanSignBang(cp) {
		if (cp === CODE_POINTS.HYPHEN_MINUS) this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH;
		else {
			this.state = State.COMMENT;
			this._stateComment(cp);
		}
	}
	_stateCommentLessThanSignBangDash(cp) {
		if (cp === CODE_POINTS.HYPHEN_MINUS) this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;
		else {
			this.state = State.COMMENT_END_DASH;
			this._stateCommentEndDash(cp);
		}
	}
	_stateCommentLessThanSignBangDashDash(cp) {
		if (cp !== CODE_POINTS.GREATER_THAN_SIGN && cp !== CODE_POINTS.EOF) this._err(ERR.nestedComment);
		this.state = State.COMMENT_END;
		this._stateCommentEnd(cp);
	}
	_stateCommentEndDash(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				this.state = State.COMMENT_END;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInComment);
				this.emitCurrentComment(token);
				this._emitEOFToken();
				break;
			}
			default: {
				token.data += "-";
				this.state = State.COMMENT;
				this._stateComment(cp);
			}
		}
	}
	_stateCommentEnd(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.DATA;
				this.emitCurrentComment(token);
				break;
			}
			case CODE_POINTS.EXCLAMATION_MARK: {
				this.state = State.COMMENT_END_BANG;
				break;
			}
			case CODE_POINTS.HYPHEN_MINUS: {
				token.data += "-";
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInComment);
				this.emitCurrentComment(token);
				this._emitEOFToken();
				break;
			}
			default: {
				token.data += "--";
				this.state = State.COMMENT;
				this._stateComment(cp);
			}
		}
	}
	_stateCommentEndBang(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.HYPHEN_MINUS: {
				token.data += "--!";
				this.state = State.COMMENT_END_DASH;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.incorrectlyClosedComment);
				this.state = State.DATA;
				this.emitCurrentComment(token);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInComment);
				this.emitCurrentComment(token);
				this._emitEOFToken();
				break;
			}
			default: {
				token.data += "--!";
				this.state = State.COMMENT;
				this._stateComment(cp);
			}
		}
	}
	_stateDoctype(cp) {
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				this.state = State.BEFORE_DOCTYPE_NAME;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.BEFORE_DOCTYPE_NAME;
				this._stateBeforeDoctypeName(cp);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				this._createDoctypeToken(null);
				const token = this.currentToken;
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.missingWhitespaceBeforeDoctypeName);
				this.state = State.BEFORE_DOCTYPE_NAME;
				this._stateBeforeDoctypeName(cp);
			}
		}
	}
	_stateBeforeDoctypeName(cp) {
		if (isAsciiUpper(cp)) {
			this._createDoctypeToken(String.fromCharCode(toAsciiLower(cp)));
			this.state = State.DOCTYPE_NAME;
		} else switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: break;
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				this._createDoctypeToken(REPLACEMENT_CHARACTER);
				this.state = State.DOCTYPE_NAME;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.missingDoctypeName);
				this._createDoctypeToken(null);
				const token = this.currentToken;
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this.state = State.DATA;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				this._createDoctypeToken(null);
				const token = this.currentToken;
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				this._createDoctypeToken(String.fromCodePoint(cp));
				this.state = State.DOCTYPE_NAME;
			}
		}
	}
	_stateDoctypeName(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				this.state = State.AFTER_DOCTYPE_NAME;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.DATA;
				this.emitCurrentDoctype(token);
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				token.name += REPLACEMENT_CHARACTER;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: token.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
		}
	}
	_stateAfterDoctypeName(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: break;
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.DATA;
				this.emitCurrentDoctype(token);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: if (this._consumeSequenceIfMatch(SEQUENCES.PUBLIC, false)) this.state = State.AFTER_DOCTYPE_PUBLIC_KEYWORD;
			else if (this._consumeSequenceIfMatch(SEQUENCES.SYSTEM, false)) this.state = State.AFTER_DOCTYPE_SYSTEM_KEYWORD;
			else if (!this._ensureHibernation()) {
				this._err(ERR.invalidCharacterSequenceAfterDoctypeName);
				token.forceQuirks = true;
				this.state = State.BOGUS_DOCTYPE;
				this._stateBogusDoctype(cp);
			}
		}
	}
	_stateAfterDoctypePublicKeyword(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				this.state = State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
				break;
			}
			case CODE_POINTS.QUOTATION_MARK: {
				this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
				token.publicId = "";
				this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
				break;
			}
			case CODE_POINTS.APOSTROPHE: {
				this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
				token.publicId = "";
				this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.missingDoctypePublicIdentifier);
				token.forceQuirks = true;
				this.state = State.DATA;
				this.emitCurrentDoctype(token);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
				token.forceQuirks = true;
				this.state = State.BOGUS_DOCTYPE;
				this._stateBogusDoctype(cp);
			}
		}
	}
	_stateBeforeDoctypePublicIdentifier(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: break;
			case CODE_POINTS.QUOTATION_MARK: {
				token.publicId = "";
				this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
				break;
			}
			case CODE_POINTS.APOSTROPHE: {
				token.publicId = "";
				this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.missingDoctypePublicIdentifier);
				token.forceQuirks = true;
				this.state = State.DATA;
				this.emitCurrentDoctype(token);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
				token.forceQuirks = true;
				this.state = State.BOGUS_DOCTYPE;
				this._stateBogusDoctype(cp);
			}
		}
	}
	_stateDoctypePublicIdentifierDoubleQuoted(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.QUOTATION_MARK: {
				this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				token.publicId += REPLACEMENT_CHARACTER;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.abruptDoctypePublicIdentifier);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this.state = State.DATA;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: token.publicId += String.fromCodePoint(cp);
		}
	}
	_stateDoctypePublicIdentifierSingleQuoted(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.APOSTROPHE: {
				this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				token.publicId += REPLACEMENT_CHARACTER;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.abruptDoctypePublicIdentifier);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this.state = State.DATA;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: token.publicId += String.fromCodePoint(cp);
		}
	}
	_stateAfterDoctypePublicIdentifier(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				this.state = State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.DATA;
				this.emitCurrentDoctype(token);
				break;
			}
			case CODE_POINTS.QUOTATION_MARK: {
				this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
				token.systemId = "";
				this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
				break;
			}
			case CODE_POINTS.APOSTROPHE: {
				this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
				token.systemId = "";
				this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
				token.forceQuirks = true;
				this.state = State.BOGUS_DOCTYPE;
				this._stateBogusDoctype(cp);
			}
		}
	}
	_stateBetweenDoctypePublicAndSystemIdentifiers(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: break;
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.emitCurrentDoctype(token);
				this.state = State.DATA;
				break;
			}
			case CODE_POINTS.QUOTATION_MARK: {
				token.systemId = "";
				this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
				break;
			}
			case CODE_POINTS.APOSTROPHE: {
				token.systemId = "";
				this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
				token.forceQuirks = true;
				this.state = State.BOGUS_DOCTYPE;
				this._stateBogusDoctype(cp);
			}
		}
	}
	_stateAfterDoctypeSystemKeyword(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: {
				this.state = State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
				break;
			}
			case CODE_POINTS.QUOTATION_MARK: {
				this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
				token.systemId = "";
				this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
				break;
			}
			case CODE_POINTS.APOSTROPHE: {
				this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
				token.systemId = "";
				this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.missingDoctypeSystemIdentifier);
				token.forceQuirks = true;
				this.state = State.DATA;
				this.emitCurrentDoctype(token);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
				token.forceQuirks = true;
				this.state = State.BOGUS_DOCTYPE;
				this._stateBogusDoctype(cp);
			}
		}
	}
	_stateBeforeDoctypeSystemIdentifier(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: break;
			case CODE_POINTS.QUOTATION_MARK: {
				token.systemId = "";
				this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
				break;
			}
			case CODE_POINTS.APOSTROPHE: {
				token.systemId = "";
				this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.missingDoctypeSystemIdentifier);
				token.forceQuirks = true;
				this.state = State.DATA;
				this.emitCurrentDoctype(token);
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
				token.forceQuirks = true;
				this.state = State.BOGUS_DOCTYPE;
				this._stateBogusDoctype(cp);
			}
		}
	}
	_stateDoctypeSystemIdentifierDoubleQuoted(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.QUOTATION_MARK: {
				this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				token.systemId += REPLACEMENT_CHARACTER;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.abruptDoctypeSystemIdentifier);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this.state = State.DATA;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: token.systemId += String.fromCodePoint(cp);
		}
	}
	_stateDoctypeSystemIdentifierSingleQuoted(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.APOSTROPHE: {
				this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				token.systemId += REPLACEMENT_CHARACTER;
				break;
			}
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this._err(ERR.abruptDoctypeSystemIdentifier);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this.state = State.DATA;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: token.systemId += String.fromCodePoint(cp);
		}
	}
	_stateAfterDoctypeSystemIdentifier(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.SPACE:
			case CODE_POINTS.LINE_FEED:
			case CODE_POINTS.TABULATION:
			case CODE_POINTS.FORM_FEED: break;
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.emitCurrentDoctype(token);
				this.state = State.DATA;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInDoctype);
				token.forceQuirks = true;
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default: {
				this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
				this.state = State.BOGUS_DOCTYPE;
				this._stateBogusDoctype(cp);
			}
		}
	}
	_stateBogusDoctype(cp) {
		const token = this.currentToken;
		switch (cp) {
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.emitCurrentDoctype(token);
				this.state = State.DATA;
				break;
			}
			case CODE_POINTS.NULL: {
				this._err(ERR.unexpectedNullCharacter);
				break;
			}
			case CODE_POINTS.EOF: {
				this.emitCurrentDoctype(token);
				this._emitEOFToken();
				break;
			}
			default:
		}
	}
	_stateCdataSection(cp) {
		switch (cp) {
			case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
				this.state = State.CDATA_SECTION_BRACKET;
				break;
			}
			case CODE_POINTS.EOF: {
				this._err(ERR.eofInCdata);
				this._emitEOFToken();
				break;
			}
			default: this._emitCodePoint(cp);
		}
	}
	_stateCdataSectionBracket(cp) {
		if (cp === CODE_POINTS.RIGHT_SQUARE_BRACKET) this.state = State.CDATA_SECTION_END;
		else {
			this._emitChars("]");
			this.state = State.CDATA_SECTION;
			this._stateCdataSection(cp);
		}
	}
	_stateCdataSectionEnd(cp) {
		switch (cp) {
			case CODE_POINTS.GREATER_THAN_SIGN: {
				this.state = State.DATA;
				break;
			}
			case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
				this._emitChars("]");
				break;
			}
			default: {
				this._emitChars("]]");
				this.state = State.CDATA_SECTION;
				this._stateCdataSection(cp);
			}
		}
	}
	_stateCharacterReference() {
		let length = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);
		if (length < 0) if (this.preprocessor.lastChunkWritten) length = this.entityDecoder.end();
		else {
			this.active = false;
			this.preprocessor.pos = this.preprocessor.html.length - 1;
			this.consumedAfterSnapshot = 0;
			this.preprocessor.endOfChunkHit = true;
			return;
		}
		if (length === 0) {
			this.preprocessor.pos = this.entityStartPos;
			this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
			this.state = !this._isCharacterReferenceInAttribute() && isAsciiAlphaNumeric(this.preprocessor.peek(1)) ? State.AMBIGUOUS_AMPERSAND : this.returnState;
		} else this.state = this.returnState;
	}
	_stateAmbiguousAmpersand(cp) {
		if (isAsciiAlphaNumeric(cp)) this._flushCodePointConsumedAsCharacterReference(cp);
		else {
			if (cp === CODE_POINTS.SEMICOLON) this._err(ERR.unknownNamedCharacterReference);
			this.state = this.returnState;
			this._callState(cp);
		}
	}
};
const IMPLICIT_END_TAG_REQUIRED = new Set([
	TAG_ID.DD,
	TAG_ID.DT,
	TAG_ID.LI,
	TAG_ID.OPTGROUP,
	TAG_ID.OPTION,
	TAG_ID.P,
	TAG_ID.RB,
	TAG_ID.RP,
	TAG_ID.RT,
	TAG_ID.RTC
]);
const IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = new Set([
	...IMPLICIT_END_TAG_REQUIRED,
	TAG_ID.CAPTION,
	TAG_ID.COLGROUP,
	TAG_ID.TBODY,
	TAG_ID.TD,
	TAG_ID.TFOOT,
	TAG_ID.TH,
	TAG_ID.THEAD,
	TAG_ID.TR
]);
const SCOPING_ELEMENTS_HTML = new Set([
	TAG_ID.APPLET,
	TAG_ID.CAPTION,
	TAG_ID.HTML,
	TAG_ID.MARQUEE,
	TAG_ID.OBJECT,
	TAG_ID.TABLE,
	TAG_ID.TD,
	TAG_ID.TEMPLATE,
	TAG_ID.TH
]);
const SCOPING_ELEMENTS_HTML_LIST = new Set([
	...SCOPING_ELEMENTS_HTML,
	TAG_ID.OL,
	TAG_ID.UL
]);
const SCOPING_ELEMENTS_HTML_BUTTON = new Set([...SCOPING_ELEMENTS_HTML, TAG_ID.BUTTON]);
const SCOPING_ELEMENTS_MATHML = new Set([
	TAG_ID.ANNOTATION_XML,
	TAG_ID.MI,
	TAG_ID.MN,
	TAG_ID.MO,
	TAG_ID.MS,
	TAG_ID.MTEXT
]);
const SCOPING_ELEMENTS_SVG = new Set([
	TAG_ID.DESC,
	TAG_ID.FOREIGN_OBJECT,
	TAG_ID.TITLE
]);
const TABLE_ROW_CONTEXT = new Set([
	TAG_ID.TR,
	TAG_ID.TEMPLATE,
	TAG_ID.HTML
]);
const TABLE_BODY_CONTEXT = new Set([
	TAG_ID.TBODY,
	TAG_ID.TFOOT,
	TAG_ID.THEAD,
	TAG_ID.TEMPLATE,
	TAG_ID.HTML
]);
const TABLE_CONTEXT = new Set([
	TAG_ID.TABLE,
	TAG_ID.TEMPLATE,
	TAG_ID.HTML
]);
const TABLE_CELLS = new Set([TAG_ID.TD, TAG_ID.TH]);
var OpenElementStack = class {
	get currentTmplContentOrNode() {
		return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
	}
	constructor(document$3, treeAdapter, handler) {
		this.treeAdapter = treeAdapter;
		this.handler = handler;
		this.items = [];
		this.tagIDs = [];
		this.stackTop = -1;
		this.tmplCount = 0;
		this.currentTagId = TAG_ID.UNKNOWN;
		this.current = document$3;
	}
	_indexOf(element$5) {
		return this.items.lastIndexOf(element$5, this.stackTop);
	}
	_isInTemplate() {
		return this.currentTagId === TAG_ID.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;
	}
	_updateCurrentElement() {
		this.current = this.items[this.stackTop];
		this.currentTagId = this.tagIDs[this.stackTop];
	}
	push(element$5, tagID) {
		this.stackTop++;
		this.items[this.stackTop] = element$5;
		this.current = element$5;
		this.tagIDs[this.stackTop] = tagID;
		this.currentTagId = tagID;
		if (this._isInTemplate()) this.tmplCount++;
		this.handler.onItemPush(element$5, tagID, true);
	}
	pop() {
		const popped = this.current;
		if (this.tmplCount > 0 && this._isInTemplate()) this.tmplCount--;
		this.stackTop--;
		this._updateCurrentElement();
		this.handler.onItemPop(popped, true);
	}
	replace(oldElement, newElement) {
		const idx = this._indexOf(oldElement);
		this.items[idx] = newElement;
		if (idx === this.stackTop) this.current = newElement;
	}
	insertAfter(referenceElement, newElement, newElementID) {
		const insertionIdx = this._indexOf(referenceElement) + 1;
		this.items.splice(insertionIdx, 0, newElement);
		this.tagIDs.splice(insertionIdx, 0, newElementID);
		this.stackTop++;
		if (insertionIdx === this.stackTop) this._updateCurrentElement();
		if (this.current && this.currentTagId !== void 0) this.handler.onItemPush(this.current, this.currentTagId, insertionIdx === this.stackTop);
	}
	popUntilTagNamePopped(tagName) {
		let targetIdx = this.stackTop + 1;
		do
			targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);
		while (targetIdx > 0 && this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== NS.HTML);
		this.shortenToLength(Math.max(targetIdx, 0));
	}
	shortenToLength(idx) {
		while (this.stackTop >= idx) {
			const popped = this.current;
			if (this.tmplCount > 0 && this._isInTemplate()) this.tmplCount -= 1;
			this.stackTop--;
			this._updateCurrentElement();
			this.handler.onItemPop(popped, this.stackTop < idx);
		}
	}
	popUntilElementPopped(element$5) {
		const idx = this._indexOf(element$5);
		this.shortenToLength(Math.max(idx, 0));
	}
	popUntilPopped(tagNames, targetNS) {
		const idx = this._indexOfTagNames(tagNames, targetNS);
		this.shortenToLength(Math.max(idx, 0));
	}
	popUntilNumberedHeaderPopped() {
		this.popUntilPopped(NUMBERED_HEADERS, NS.HTML);
	}
	popUntilTableCellPopped() {
		this.popUntilPopped(TABLE_CELLS, NS.HTML);
	}
	popAllUpToHtmlElement() {
		this.tmplCount = 0;
		this.shortenToLength(1);
	}
	_indexOfTagNames(tagNames, namespace) {
		for (let i = this.stackTop; i >= 0; i--) if (tagNames.has(this.tagIDs[i]) && this.treeAdapter.getNamespaceURI(this.items[i]) === namespace) return i;
		return -1;
	}
	clearBackTo(tagNames, targetNS) {
		const idx = this._indexOfTagNames(tagNames, targetNS);
		this.shortenToLength(idx + 1);
	}
	clearBackToTableContext() {
		this.clearBackTo(TABLE_CONTEXT, NS.HTML);
	}
	clearBackToTableBodyContext() {
		this.clearBackTo(TABLE_BODY_CONTEXT, NS.HTML);
	}
	clearBackToTableRowContext() {
		this.clearBackTo(TABLE_ROW_CONTEXT, NS.HTML);
	}
	remove(element$5) {
		const idx = this._indexOf(element$5);
		if (idx >= 0) if (idx === this.stackTop) this.pop();
		else {
			this.items.splice(idx, 1);
			this.tagIDs.splice(idx, 1);
			this.stackTop--;
			this._updateCurrentElement();
			this.handler.onItemPop(element$5, false);
		}
	}
	tryPeekProperlyNestedBodyElement() {
		return this.stackTop >= 1 && this.tagIDs[1] === TAG_ID.BODY ? this.items[1] : null;
	}
	contains(element$5) {
		return this._indexOf(element$5) > -1;
	}
	getCommonAncestor(element$5) {
		const elementIdx = this._indexOf(element$5) - 1;
		return elementIdx >= 0 ? this.items[elementIdx] : null;
	}
	isRootHtmlElementCurrent() {
		return this.stackTop === 0 && this.tagIDs[0] === TAG_ID.HTML;
	}
	hasInDynamicScope(tagName, htmlScope) {
		for (let i = this.stackTop; i >= 0; i--) {
			const tn = this.tagIDs[i];
			switch (this.treeAdapter.getNamespaceURI(this.items[i])) {
				case NS.HTML: {
					if (tn === tagName) return true;
					if (htmlScope.has(tn)) return false;
					break;
				}
				case NS.SVG: {
					if (SCOPING_ELEMENTS_SVG.has(tn)) return false;
					break;
				}
				case NS.MATHML: {
					if (SCOPING_ELEMENTS_MATHML.has(tn)) return false;
					break;
				}
			}
		}
		return true;
	}
	hasInScope(tagName) {
		return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML);
	}
	hasInListItemScope(tagName) {
		return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML_LIST);
	}
	hasInButtonScope(tagName) {
		return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML_BUTTON);
	}
	hasNumberedHeaderInScope() {
		for (let i = this.stackTop; i >= 0; i--) {
			const tn = this.tagIDs[i];
			switch (this.treeAdapter.getNamespaceURI(this.items[i])) {
				case NS.HTML: {
					if (NUMBERED_HEADERS.has(tn)) return true;
					if (SCOPING_ELEMENTS_HTML.has(tn)) return false;
					break;
				}
				case NS.SVG: {
					if (SCOPING_ELEMENTS_SVG.has(tn)) return false;
					break;
				}
				case NS.MATHML: {
					if (SCOPING_ELEMENTS_MATHML.has(tn)) return false;
					break;
				}
			}
		}
		return true;
	}
	hasInTableScope(tagName) {
		for (let i = this.stackTop; i >= 0; i--) {
			if (this.treeAdapter.getNamespaceURI(this.items[i]) !== NS.HTML) continue;
			switch (this.tagIDs[i]) {
				case tagName: return true;
				case TAG_ID.TABLE:
				case TAG_ID.HTML: return false;
			}
		}
		return true;
	}
	hasTableBodyContextInTableScope() {
		for (let i = this.stackTop; i >= 0; i--) {
			if (this.treeAdapter.getNamespaceURI(this.items[i]) !== NS.HTML) continue;
			switch (this.tagIDs[i]) {
				case TAG_ID.TBODY:
				case TAG_ID.THEAD:
				case TAG_ID.TFOOT: return true;
				case TAG_ID.TABLE:
				case TAG_ID.HTML: return false;
			}
		}
		return true;
	}
	hasInSelectScope(tagName) {
		for (let i = this.stackTop; i >= 0; i--) {
			if (this.treeAdapter.getNamespaceURI(this.items[i]) !== NS.HTML) continue;
			switch (this.tagIDs[i]) {
				case tagName: return true;
				case TAG_ID.OPTION:
				case TAG_ID.OPTGROUP: break;
				default: return false;
			}
		}
		return true;
	}
	generateImpliedEndTags() {
		while (this.currentTagId !== void 0 && IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId)) this.pop();
	}
	generateImpliedEndTagsThoroughly() {
		while (this.currentTagId !== void 0 && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) this.pop();
	}
	generateImpliedEndTagsWithExclusion(exclusionId) {
		while (this.currentTagId !== void 0 && this.currentTagId !== exclusionId && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) this.pop();
	}
};
const NOAH_ARK_CAPACITY = 3;
var EntryType;
(function(EntryType$1) {
	EntryType$1[EntryType$1["Marker"] = 0] = "Marker";
	EntryType$1[EntryType$1["Element"] = 1] = "Element";
})(EntryType || (EntryType = {}));
const MARKER = { type: EntryType.Marker };
var FormattingElementList = class {
	constructor(treeAdapter) {
		this.treeAdapter = treeAdapter;
		this.entries = [];
		this.bookmark = null;
	}
	_getNoahArkConditionCandidates(newElement, neAttrs) {
		const candidates = [];
		const neAttrsLength = neAttrs.length;
		const neTagName = this.treeAdapter.getTagName(newElement);
		const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
		for (let i = 0; i < this.entries.length; i++) {
			const entry = this.entries[i];
			if (entry.type === EntryType.Marker) break;
			const { element: element$5 } = entry;
			if (this.treeAdapter.getTagName(element$5) === neTagName && this.treeAdapter.getNamespaceURI(element$5) === neNamespaceURI) {
				const elementAttrs = this.treeAdapter.getAttrList(element$5);
				if (elementAttrs.length === neAttrsLength) candidates.push({
					idx: i,
					attrs: elementAttrs
				});
			}
		}
		return candidates;
	}
	_ensureNoahArkCondition(newElement) {
		if (this.entries.length < NOAH_ARK_CAPACITY) return;
		const neAttrs = this.treeAdapter.getAttrList(newElement);
		const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);
		if (candidates.length < NOAH_ARK_CAPACITY) return;
		const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));
		let validCandidates = 0;
		for (let i = 0; i < candidates.length; i++) {
			const candidate = candidates[i];
			if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {
				validCandidates += 1;
				if (validCandidates >= NOAH_ARK_CAPACITY) this.entries.splice(candidate.idx, 1);
			}
		}
	}
	insertMarker() {
		this.entries.unshift(MARKER);
	}
	pushElement(element$5, token) {
		this._ensureNoahArkCondition(element$5);
		this.entries.unshift({
			type: EntryType.Element,
			element: element$5,
			token
		});
	}
	insertElementAfterBookmark(element$5, token) {
		const bookmarkIdx = this.entries.indexOf(this.bookmark);
		this.entries.splice(bookmarkIdx, 0, {
			type: EntryType.Element,
			element: element$5,
			token
		});
	}
	removeEntry(entry) {
		const entryIndex = this.entries.indexOf(entry);
		if (entryIndex !== -1) this.entries.splice(entryIndex, 1);
	}
	clearToLastMarker() {
		const markerIdx = this.entries.indexOf(MARKER);
		if (markerIdx === -1) this.entries.length = 0;
		else this.entries.splice(0, markerIdx + 1);
	}
	getElementEntryInScopeWithTagName(tagName) {
		const entry = this.entries.find((entry$1) => entry$1.type === EntryType.Marker || this.treeAdapter.getTagName(entry$1.element) === tagName);
		return entry && entry.type === EntryType.Element ? entry : null;
	}
	getElementEntry(element$5) {
		return this.entries.find((entry) => entry.type === EntryType.Element && entry.element === element$5);
	}
};
const defaultTreeAdapter = {
	createDocument() {
		return {
			nodeName: "#document",
			mode: DOCUMENT_MODE.NO_QUIRKS,
			childNodes: []
		};
	},
	createDocumentFragment() {
		return {
			nodeName: "#document-fragment",
			childNodes: []
		};
	},
	createElement(tagName, namespaceURI, attrs) {
		return {
			nodeName: tagName,
			tagName,
			attrs,
			namespaceURI,
			childNodes: [],
			parentNode: null
		};
	},
	createCommentNode(data) {
		return {
			nodeName: "#comment",
			data,
			parentNode: null
		};
	},
	createTextNode(value) {
		return {
			nodeName: "#text",
			value,
			parentNode: null
		};
	},
	appendChild(parentNode, newNode) {
		parentNode.childNodes.push(newNode);
		newNode.parentNode = parentNode;
	},
	insertBefore(parentNode, newNode, referenceNode) {
		const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
		parentNode.childNodes.splice(insertionIdx, 0, newNode);
		newNode.parentNode = parentNode;
	},
	setTemplateContent(templateElement, contentElement) {
		templateElement.content = contentElement;
	},
	getTemplateContent(templateElement) {
		return templateElement.content;
	},
	setDocumentType(document$3, name$2, publicId, systemId) {
		const doctypeNode = document$3.childNodes.find((node$1) => node$1.nodeName === "#documentType");
		if (doctypeNode) {
			doctypeNode.name = name$2;
			doctypeNode.publicId = publicId;
			doctypeNode.systemId = systemId;
		} else {
			const node$1 = {
				nodeName: "#documentType",
				name: name$2,
				publicId,
				systemId,
				parentNode: null
			};
			defaultTreeAdapter.appendChild(document$3, node$1);
		}
	},
	setDocumentMode(document$3, mode) {
		document$3.mode = mode;
	},
	getDocumentMode(document$3) {
		return document$3.mode;
	},
	detachNode(node$1) {
		if (node$1.parentNode) {
			const idx = node$1.parentNode.childNodes.indexOf(node$1);
			node$1.parentNode.childNodes.splice(idx, 1);
			node$1.parentNode = null;
		}
	},
	insertText(parentNode, text$8) {
		if (parentNode.childNodes.length > 0) {
			const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
			if (defaultTreeAdapter.isTextNode(prevNode)) {
				prevNode.value += text$8;
				return;
			}
		}
		defaultTreeAdapter.appendChild(parentNode, defaultTreeAdapter.createTextNode(text$8));
	},
	insertTextBefore(parentNode, text$8, referenceNode) {
		const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
		if (prevNode && defaultTreeAdapter.isTextNode(prevNode)) prevNode.value += text$8;
		else defaultTreeAdapter.insertBefore(parentNode, defaultTreeAdapter.createTextNode(text$8), referenceNode);
	},
	adoptAttributes(recipient, attrs) {
		const recipientAttrsMap = new Set(recipient.attrs.map((attr) => attr.name));
		for (let j$1 = 0; j$1 < attrs.length; j$1++) if (!recipientAttrsMap.has(attrs[j$1].name)) recipient.attrs.push(attrs[j$1]);
	},
	getFirstChild(node$1) {
		return node$1.childNodes[0];
	},
	getChildNodes(node$1) {
		return node$1.childNodes;
	},
	getParentNode(node$1) {
		return node$1.parentNode;
	},
	getAttrList(element$5) {
		return element$5.attrs;
	},
	getTagName(element$5) {
		return element$5.tagName;
	},
	getNamespaceURI(element$5) {
		return element$5.namespaceURI;
	},
	getTextNodeContent(textNode) {
		return textNode.value;
	},
	getCommentNodeContent(commentNode) {
		return commentNode.data;
	},
	getDocumentTypeNodeName(doctypeNode) {
		return doctypeNode.name;
	},
	getDocumentTypeNodePublicId(doctypeNode) {
		return doctypeNode.publicId;
	},
	getDocumentTypeNodeSystemId(doctypeNode) {
		return doctypeNode.systemId;
	},
	isTextNode(node$1) {
		return node$1.nodeName === "#text";
	},
	isCommentNode(node$1) {
		return node$1.nodeName === "#comment";
	},
	isDocumentTypeNode(node$1) {
		return node$1.nodeName === "#documentType";
	},
	isElementNode(node$1) {
		return Object.prototype.hasOwnProperty.call(node$1, "tagName");
	},
	setNodeSourceCodeLocation(node$1, location$1) {
		node$1.sourceCodeLocation = location$1;
	},
	getNodeSourceCodeLocation(node$1) {
		return node$1.sourceCodeLocation;
	},
	updateNodeSourceCodeLocation(node$1, endLocation) {
		node$1.sourceCodeLocation = {
			...node$1.sourceCodeLocation,
			...endLocation
		};
	}
};
const VALID_DOCTYPE_NAME = "html";
const VALID_SYSTEM_ID = "about:legacy-compat";
const QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
const QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
	"+//silmaril//dtd html pro v0r11 19970101//",
	"-//as//dtd html 3.0 aswedit + extensions//",
	"-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
	"-//ietf//dtd html 2.0 level 1//",
	"-//ietf//dtd html 2.0 level 2//",
	"-//ietf//dtd html 2.0 strict level 1//",
	"-//ietf//dtd html 2.0 strict level 2//",
	"-//ietf//dtd html 2.0 strict//",
	"-//ietf//dtd html 2.0//",
	"-//ietf//dtd html 2.1e//",
	"-//ietf//dtd html 3.0//",
	"-//ietf//dtd html 3.2 final//",
	"-//ietf//dtd html 3.2//",
	"-//ietf//dtd html 3//",
	"-//ietf//dtd html level 0//",
	"-//ietf//dtd html level 1//",
	"-//ietf//dtd html level 2//",
	"-//ietf//dtd html level 3//",
	"-//ietf//dtd html strict level 0//",
	"-//ietf//dtd html strict level 1//",
	"-//ietf//dtd html strict level 2//",
	"-//ietf//dtd html strict level 3//",
	"-//ietf//dtd html strict//",
	"-//ietf//dtd html//",
	"-//metrius//dtd metrius presentational//",
	"-//microsoft//dtd internet explorer 2.0 html strict//",
	"-//microsoft//dtd internet explorer 2.0 html//",
	"-//microsoft//dtd internet explorer 2.0 tables//",
	"-//microsoft//dtd internet explorer 3.0 html strict//",
	"-//microsoft//dtd internet explorer 3.0 html//",
	"-//microsoft//dtd internet explorer 3.0 tables//",
	"-//netscape comm. corp.//dtd html//",
	"-//netscape comm. corp.//dtd strict html//",
	"-//o'reilly and associates//dtd html 2.0//",
	"-//o'reilly and associates//dtd html extended 1.0//",
	"-//o'reilly and associates//dtd html extended relaxed 1.0//",
	"-//sq//dtd html 2.0 hotmetal + extensions//",
	"-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
	"-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
	"-//spyglass//dtd html 2.0 extended//",
	"-//sun microsystems corp.//dtd hotjava html//",
	"-//sun microsystems corp.//dtd hotjava strict html//",
	"-//w3c//dtd html 3 1995-03-24//",
	"-//w3c//dtd html 3.2 draft//",
	"-//w3c//dtd html 3.2 final//",
	"-//w3c//dtd html 3.2//",
	"-//w3c//dtd html 3.2s draft//",
	"-//w3c//dtd html 4.0 frameset//",
	"-//w3c//dtd html 4.0 transitional//",
	"-//w3c//dtd html experimental 19960712//",
	"-//w3c//dtd html experimental 970421//",
	"-//w3c//dtd w3 html//",
	"-//w3o//dtd w3 html 3.0//",
	"-//webtechs//dtd mozilla html 2.0//",
	"-//webtechs//dtd mozilla html//"
];
const QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
	...QUIRKS_MODE_PUBLIC_ID_PREFIXES,
	"-//w3c//dtd html 4.01 frameset//",
	"-//w3c//dtd html 4.01 transitional//"
];
const QUIRKS_MODE_PUBLIC_IDS = new Set([
	"-//w3o//dtd w3 html strict 3.0//en//",
	"-/w3c/dtd html 4.0 transitional/en",
	"html"
]);
const LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"];
const LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
	...LIMITED_QUIRKS_PUBLIC_ID_PREFIXES,
	"-//w3c//dtd html 4.01 frameset//",
	"-//w3c//dtd html 4.01 transitional//"
];
function hasPrefix(publicId, prefixes) {
	return prefixes.some((prefix) => publicId.startsWith(prefix));
}
function isConforming(token) {
	return token.name === VALID_DOCTYPE_NAME && token.publicId === null && (token.systemId === null || token.systemId === VALID_SYSTEM_ID);
}
function getDocumentMode(token) {
	if (token.name !== VALID_DOCTYPE_NAME) return DOCUMENT_MODE.QUIRKS;
	const { systemId } = token;
	if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) return DOCUMENT_MODE.QUIRKS;
	let { publicId } = token;
	if (publicId !== null) {
		publicId = publicId.toLowerCase();
		if (QUIRKS_MODE_PUBLIC_IDS.has(publicId)) return DOCUMENT_MODE.QUIRKS;
		let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
		if (hasPrefix(publicId, prefixes)) return DOCUMENT_MODE.QUIRKS;
		prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
		if (hasPrefix(publicId, prefixes)) return DOCUMENT_MODE.LIMITED_QUIRKS;
	}
	return DOCUMENT_MODE.NO_QUIRKS;
}
const MIME_TYPES = {
	TEXT_HTML: "text/html",
	APPLICATION_XML: "application/xhtml+xml"
};
const DEFINITION_URL_ATTR = "definitionurl";
const ADJUSTED_DEFINITION_URL_ATTR = "definitionURL";
const SVG_ATTRS_ADJUSTMENT_MAP = new Map([
	"attributeName",
	"attributeType",
	"baseFrequency",
	"baseProfile",
	"calcMode",
	"clipPathUnits",
	"diffuseConstant",
	"edgeMode",
	"filterUnits",
	"glyphRef",
	"gradientTransform",
	"gradientUnits",
	"kernelMatrix",
	"kernelUnitLength",
	"keyPoints",
	"keySplines",
	"keyTimes",
	"lengthAdjust",
	"limitingConeAngle",
	"markerHeight",
	"markerUnits",
	"markerWidth",
	"maskContentUnits",
	"maskUnits",
	"numOctaves",
	"pathLength",
	"patternContentUnits",
	"patternTransform",
	"patternUnits",
	"pointsAtX",
	"pointsAtY",
	"pointsAtZ",
	"preserveAlpha",
	"preserveAspectRatio",
	"primitiveUnits",
	"refX",
	"refY",
	"repeatCount",
	"repeatDur",
	"requiredExtensions",
	"requiredFeatures",
	"specularConstant",
	"specularExponent",
	"spreadMethod",
	"startOffset",
	"stdDeviation",
	"stitchTiles",
	"surfaceScale",
	"systemLanguage",
	"tableValues",
	"targetX",
	"targetY",
	"textLength",
	"viewBox",
	"viewTarget",
	"xChannelSelector",
	"yChannelSelector",
	"zoomAndPan"
].map((attr) => [attr.toLowerCase(), attr]));
const XML_ATTRS_ADJUSTMENT_MAP = new Map([
	["xlink:actuate", {
		prefix: "xlink",
		name: "actuate",
		namespace: NS.XLINK
	}],
	["xlink:arcrole", {
		prefix: "xlink",
		name: "arcrole",
		namespace: NS.XLINK
	}],
	["xlink:href", {
		prefix: "xlink",
		name: "href",
		namespace: NS.XLINK
	}],
	["xlink:role", {
		prefix: "xlink",
		name: "role",
		namespace: NS.XLINK
	}],
	["xlink:show", {
		prefix: "xlink",
		name: "show",
		namespace: NS.XLINK
	}],
	["xlink:title", {
		prefix: "xlink",
		name: "title",
		namespace: NS.XLINK
	}],
	["xlink:type", {
		prefix: "xlink",
		name: "type",
		namespace: NS.XLINK
	}],
	["xml:lang", {
		prefix: "xml",
		name: "lang",
		namespace: NS.XML
	}],
	["xml:space", {
		prefix: "xml",
		name: "space",
		namespace: NS.XML
	}],
	["xmlns", {
		prefix: "",
		name: "xmlns",
		namespace: NS.XMLNS
	}],
	["xmlns:xlink", {
		prefix: "xmlns",
		name: "xlink",
		namespace: NS.XMLNS
	}]
]);
const SVG_TAG_NAMES_ADJUSTMENT_MAP = new Map([
	"altGlyph",
	"altGlyphDef",
	"altGlyphItem",
	"animateColor",
	"animateMotion",
	"animateTransform",
	"clipPath",
	"feBlend",
	"feColorMatrix",
	"feComponentTransfer",
	"feComposite",
	"feConvolveMatrix",
	"feDiffuseLighting",
	"feDisplacementMap",
	"feDistantLight",
	"feFlood",
	"feFuncA",
	"feFuncB",
	"feFuncG",
	"feFuncR",
	"feGaussianBlur",
	"feImage",
	"feMerge",
	"feMergeNode",
	"feMorphology",
	"feOffset",
	"fePointLight",
	"feSpecularLighting",
	"feSpotLight",
	"feTile",
	"feTurbulence",
	"foreignObject",
	"glyphRef",
	"linearGradient",
	"radialGradient",
	"textPath"
].map((tn) => [tn.toLowerCase(), tn]));
const EXITS_FOREIGN_CONTENT = new Set([
	TAG_ID.B,
	TAG_ID.BIG,
	TAG_ID.BLOCKQUOTE,
	TAG_ID.BODY,
	TAG_ID.BR,
	TAG_ID.CENTER,
	TAG_ID.CODE,
	TAG_ID.DD,
	TAG_ID.DIV,
	TAG_ID.DL,
	TAG_ID.DT,
	TAG_ID.EM,
	TAG_ID.EMBED,
	TAG_ID.H1,
	TAG_ID.H2,
	TAG_ID.H3,
	TAG_ID.H4,
	TAG_ID.H5,
	TAG_ID.H6,
	TAG_ID.HEAD,
	TAG_ID.HR,
	TAG_ID.I,
	TAG_ID.IMG,
	TAG_ID.LI,
	TAG_ID.LISTING,
	TAG_ID.MENU,
	TAG_ID.META,
	TAG_ID.NOBR,
	TAG_ID.OL,
	TAG_ID.P,
	TAG_ID.PRE,
	TAG_ID.RUBY,
	TAG_ID.S,
	TAG_ID.SMALL,
	TAG_ID.SPAN,
	TAG_ID.STRONG,
	TAG_ID.STRIKE,
	TAG_ID.SUB,
	TAG_ID.SUP,
	TAG_ID.TABLE,
	TAG_ID.TT,
	TAG_ID.U,
	TAG_ID.UL,
	TAG_ID.VAR
]);
function causesExit(startTagToken) {
	const tn = startTagToken.tagID;
	const isFontWithAttrs = tn === TAG_ID.FONT && startTagToken.attrs.some(({ name: name$2 }) => name$2 === ATTRS.COLOR || name$2 === ATTRS.SIZE || name$2 === ATTRS.FACE);
	return isFontWithAttrs || EXITS_FOREIGN_CONTENT.has(tn);
}
function adjustTokenMathMLAttrs(token) {
	for (let i = 0; i < token.attrs.length; i++) if (token.attrs[i].name === DEFINITION_URL_ATTR) {
		token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
		break;
	}
}
function adjustTokenSVGAttrs(token) {
	for (let i = 0; i < token.attrs.length; i++) {
		const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
		if (adjustedAttrName != null) token.attrs[i].name = adjustedAttrName;
	}
}
function adjustTokenXMLAttrs(token) {
	for (let i = 0; i < token.attrs.length; i++) {
		const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
		if (adjustedAttrEntry) {
			token.attrs[i].prefix = adjustedAttrEntry.prefix;
			token.attrs[i].name = adjustedAttrEntry.name;
			token.attrs[i].namespace = adjustedAttrEntry.namespace;
		}
	}
}
function adjustTokenSVGTagName(token) {
	const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP.get(token.tagName);
	if (adjustedTagName != null) {
		token.tagName = adjustedTagName;
		token.tagID = getTagID(token.tagName);
	}
}
function isMathMLTextIntegrationPoint(tn, ns) {
	return ns === NS.MATHML && (tn === TAG_ID.MI || tn === TAG_ID.MO || tn === TAG_ID.MN || tn === TAG_ID.MS || tn === TAG_ID.MTEXT);
}
function isHtmlIntegrationPoint(tn, ns, attrs) {
	if (ns === NS.MATHML && tn === TAG_ID.ANNOTATION_XML) {
		for (let i = 0; i < attrs.length; i++) if (attrs[i].name === ATTRS.ENCODING) {
			const value = attrs[i].value.toLowerCase();
			return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
		}
	}
	return ns === NS.SVG && (tn === TAG_ID.FOREIGN_OBJECT || tn === TAG_ID.DESC || tn === TAG_ID.TITLE);
}
function isIntegrationPoint(tn, ns, attrs, foreignNS) {
	return (!foreignNS || foreignNS === NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs) || (!foreignNS || foreignNS === NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns);
}
const HIDDEN_INPUT_TYPE = "hidden";
const AA_OUTER_LOOP_ITER = 8;
const AA_INNER_LOOP_ITER = 3;
var InsertionMode;
(function(InsertionMode$1) {
	InsertionMode$1[InsertionMode$1["INITIAL"] = 0] = "INITIAL";
	InsertionMode$1[InsertionMode$1["BEFORE_HTML"] = 1] = "BEFORE_HTML";
	InsertionMode$1[InsertionMode$1["BEFORE_HEAD"] = 2] = "BEFORE_HEAD";
	InsertionMode$1[InsertionMode$1["IN_HEAD"] = 3] = "IN_HEAD";
	InsertionMode$1[InsertionMode$1["IN_HEAD_NO_SCRIPT"] = 4] = "IN_HEAD_NO_SCRIPT";
	InsertionMode$1[InsertionMode$1["AFTER_HEAD"] = 5] = "AFTER_HEAD";
	InsertionMode$1[InsertionMode$1["IN_BODY"] = 6] = "IN_BODY";
	InsertionMode$1[InsertionMode$1["TEXT"] = 7] = "TEXT";
	InsertionMode$1[InsertionMode$1["IN_TABLE"] = 8] = "IN_TABLE";
	InsertionMode$1[InsertionMode$1["IN_TABLE_TEXT"] = 9] = "IN_TABLE_TEXT";
	InsertionMode$1[InsertionMode$1["IN_CAPTION"] = 10] = "IN_CAPTION";
	InsertionMode$1[InsertionMode$1["IN_COLUMN_GROUP"] = 11] = "IN_COLUMN_GROUP";
	InsertionMode$1[InsertionMode$1["IN_TABLE_BODY"] = 12] = "IN_TABLE_BODY";
	InsertionMode$1[InsertionMode$1["IN_ROW"] = 13] = "IN_ROW";
	InsertionMode$1[InsertionMode$1["IN_CELL"] = 14] = "IN_CELL";
	InsertionMode$1[InsertionMode$1["IN_SELECT"] = 15] = "IN_SELECT";
	InsertionMode$1[InsertionMode$1["IN_SELECT_IN_TABLE"] = 16] = "IN_SELECT_IN_TABLE";
	InsertionMode$1[InsertionMode$1["IN_TEMPLATE"] = 17] = "IN_TEMPLATE";
	InsertionMode$1[InsertionMode$1["AFTER_BODY"] = 18] = "AFTER_BODY";
	InsertionMode$1[InsertionMode$1["IN_FRAMESET"] = 19] = "IN_FRAMESET";
	InsertionMode$1[InsertionMode$1["AFTER_FRAMESET"] = 20] = "AFTER_FRAMESET";
	InsertionMode$1[InsertionMode$1["AFTER_AFTER_BODY"] = 21] = "AFTER_AFTER_BODY";
	InsertionMode$1[InsertionMode$1["AFTER_AFTER_FRAMESET"] = 22] = "AFTER_AFTER_FRAMESET";
})(InsertionMode || (InsertionMode = {}));
const BASE_LOC = {
	startLine: -1,
	startCol: -1,
	startOffset: -1,
	endLine: -1,
	endCol: -1,
	endOffset: -1
};
const TABLE_STRUCTURE_TAGS = new Set([
	TAG_ID.TABLE,
	TAG_ID.TBODY,
	TAG_ID.TFOOT,
	TAG_ID.THEAD,
	TAG_ID.TR
]);
const defaultParserOptions = {
	scriptingEnabled: true,
	sourceCodeLocationInfo: false,
	treeAdapter: defaultTreeAdapter,
	onParseError: null
};
var Parser = class {
	constructor(options, document$3, fragmentContext = null, scriptHandler = null) {
		this.fragmentContext = fragmentContext;
		this.scriptHandler = scriptHandler;
		this.currentToken = null;
		this.stopped = false;
		this.insertionMode = InsertionMode.INITIAL;
		this.originalInsertionMode = InsertionMode.INITIAL;
		this.headElement = null;
		this.formElement = null;
		this.currentNotInHTML = false;
		this.tmplInsertionModeStack = [];
		this.pendingCharacterTokens = [];
		this.hasNonWhitespacePendingCharacterToken = false;
		this.framesetOk = true;
		this.skipNextNewLine = false;
		this.fosterParentingEnabled = false;
		this.options = {
			...defaultParserOptions,
			...options
		};
		this.treeAdapter = this.options.treeAdapter;
		this.onParseError = this.options.onParseError;
		if (this.onParseError) this.options.sourceCodeLocationInfo = true;
		this.document = document$3 !== null && document$3 !== void 0 ? document$3 : this.treeAdapter.createDocument();
		this.tokenizer = new Tokenizer(this.options, this);
		this.activeFormattingElements = new FormattingElementList(this.treeAdapter);
		this.fragmentContextID = fragmentContext ? getTagID(this.treeAdapter.getTagName(fragmentContext)) : TAG_ID.UNKNOWN;
		this._setContextModes(fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : this.document, this.fragmentContextID);
		this.openElements = new OpenElementStack(this.document, this.treeAdapter, this);
	}
	static parse(html$6, options) {
		const parser$1 = new this(options);
		parser$1.tokenizer.write(html$6, true);
		return parser$1.document;
	}
	static getFragmentParser(fragmentContext, options) {
		const opts = {
			...defaultParserOptions,
			...options
		};
		fragmentContext !== null && fragmentContext !== void 0 || (fragmentContext = opts.treeAdapter.createElement(TAG_NAMES.TEMPLATE, NS.HTML, []));
		const documentMock = opts.treeAdapter.createElement("documentmock", NS.HTML, []);
		const parser$1 = new this(opts, documentMock, fragmentContext);
		if (parser$1.fragmentContextID === TAG_ID.TEMPLATE) parser$1.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
		parser$1._initTokenizerForFragmentParsing();
		parser$1._insertFakeRootElement();
		parser$1._resetInsertionMode();
		parser$1._findFormInFragmentContext();
		return parser$1;
	}
	getFragment() {
		const rootElement = this.treeAdapter.getFirstChild(this.document);
		const fragment$1 = this.treeAdapter.createDocumentFragment();
		this._adoptNodes(rootElement, fragment$1);
		return fragment$1;
	}
	_err(token, code$3, beforeToken) {
		var _a$1;
		if (!this.onParseError) return;
		const loc = (_a$1 = token.location) !== null && _a$1 !== void 0 ? _a$1 : BASE_LOC;
		const err = {
			code: code$3,
			startLine: loc.startLine,
			startCol: loc.startCol,
			startOffset: loc.startOffset,
			endLine: beforeToken ? loc.startLine : loc.endLine,
			endCol: beforeToken ? loc.startCol : loc.endCol,
			endOffset: beforeToken ? loc.startOffset : loc.endOffset
		};
		this.onParseError(err);
	}
	onItemPush(node$1, tid, isTop) {
		var _a$1, _b;
		(_b = (_a$1 = this.treeAdapter).onItemPush) === null || _b === void 0 || _b.call(_a$1, node$1);
		if (isTop && this.openElements.stackTop > 0) this._setContextModes(node$1, tid);
	}
	onItemPop(node$1, isTop) {
		var _a$1, _b;
		if (this.options.sourceCodeLocationInfo) this._setEndLocation(node$1, this.currentToken);
		(_b = (_a$1 = this.treeAdapter).onItemPop) === null || _b === void 0 || _b.call(_a$1, node$1, this.openElements.current);
		if (isTop) {
			let current;
			let currentTagId;
			if (this.openElements.stackTop === 0 && this.fragmentContext) {
				current = this.fragmentContext;
				currentTagId = this.fragmentContextID;
			} else ({current, currentTagId} = this.openElements);
			this._setContextModes(current, currentTagId);
		}
	}
	_setContextModes(current, tid) {
		const isHTML = current === this.document || current && this.treeAdapter.getNamespaceURI(current) === NS.HTML;
		this.currentNotInHTML = !isHTML;
		this.tokenizer.inForeignNode = !isHTML && current !== void 0 && tid !== void 0 && !this._isIntegrationPoint(tid, current);
	}
	_switchToTextParsing(currentToken, nextTokenizerState) {
		this._insertElement(currentToken, NS.HTML);
		this.tokenizer.state = nextTokenizerState;
		this.originalInsertionMode = this.insertionMode;
		this.insertionMode = InsertionMode.TEXT;
	}
	switchToPlaintextParsing() {
		this.insertionMode = InsertionMode.TEXT;
		this.originalInsertionMode = InsertionMode.IN_BODY;
		this.tokenizer.state = TokenizerMode.PLAINTEXT;
	}
	_getAdjustedCurrentElement() {
		return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
	}
	_findFormInFragmentContext() {
		let node$1 = this.fragmentContext;
		while (node$1) {
			if (this.treeAdapter.getTagName(node$1) === TAG_NAMES.FORM) {
				this.formElement = node$1;
				break;
			}
			node$1 = this.treeAdapter.getParentNode(node$1);
		}
	}
	_initTokenizerForFragmentParsing() {
		if (!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== NS.HTML) return;
		switch (this.fragmentContextID) {
			case TAG_ID.TITLE:
			case TAG_ID.TEXTAREA: {
				this.tokenizer.state = TokenizerMode.RCDATA;
				break;
			}
			case TAG_ID.STYLE:
			case TAG_ID.XMP:
			case TAG_ID.IFRAME:
			case TAG_ID.NOEMBED:
			case TAG_ID.NOFRAMES:
			case TAG_ID.NOSCRIPT: {
				this.tokenizer.state = TokenizerMode.RAWTEXT;
				break;
			}
			case TAG_ID.SCRIPT: {
				this.tokenizer.state = TokenizerMode.SCRIPT_DATA;
				break;
			}
			case TAG_ID.PLAINTEXT: {
				this.tokenizer.state = TokenizerMode.PLAINTEXT;
				break;
			}
			default:
		}
	}
	_setDocumentType(token) {
		const name$2 = token.name || "";
		const publicId = token.publicId || "";
		const systemId = token.systemId || "";
		this.treeAdapter.setDocumentType(this.document, name$2, publicId, systemId);
		if (token.location) {
			const documentChildren = this.treeAdapter.getChildNodes(this.document);
			const docTypeNode = documentChildren.find((node$1) => this.treeAdapter.isDocumentTypeNode(node$1));
			if (docTypeNode) this.treeAdapter.setNodeSourceCodeLocation(docTypeNode, token.location);
		}
	}
	_attachElementToTree(element$5, location$1) {
		if (this.options.sourceCodeLocationInfo) {
			const loc = location$1 && {
				...location$1,
				startTag: location$1
			};
			this.treeAdapter.setNodeSourceCodeLocation(element$5, loc);
		}
		if (this._shouldFosterParentOnInsertion()) this._fosterParentElement(element$5);
		else {
			const parent$1 = this.openElements.currentTmplContentOrNode;
			this.treeAdapter.appendChild(parent$1 !== null && parent$1 !== void 0 ? parent$1 : this.document, element$5);
		}
	}
	_appendElement(token, namespaceURI) {
		const element$5 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
		this._attachElementToTree(element$5, token.location);
	}
	_insertElement(token, namespaceURI) {
		const element$5 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
		this._attachElementToTree(element$5, token.location);
		this.openElements.push(element$5, token.tagID);
	}
	_insertFakeElement(tagName, tagID) {
		const element$5 = this.treeAdapter.createElement(tagName, NS.HTML, []);
		this._attachElementToTree(element$5, null);
		this.openElements.push(element$5, tagID);
	}
	_insertTemplate(token) {
		const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);
		const content$2 = this.treeAdapter.createDocumentFragment();
		this.treeAdapter.setTemplateContent(tmpl, content$2);
		this._attachElementToTree(tmpl, token.location);
		this.openElements.push(tmpl, token.tagID);
		if (this.options.sourceCodeLocationInfo) this.treeAdapter.setNodeSourceCodeLocation(content$2, null);
	}
	_insertFakeRootElement() {
		const element$5 = this.treeAdapter.createElement(TAG_NAMES.HTML, NS.HTML, []);
		if (this.options.sourceCodeLocationInfo) this.treeAdapter.setNodeSourceCodeLocation(element$5, null);
		this.treeAdapter.appendChild(this.openElements.current, element$5);
		this.openElements.push(element$5, TAG_ID.HTML);
	}
	_appendCommentNode(token, parent$1) {
		const commentNode = this.treeAdapter.createCommentNode(token.data);
		this.treeAdapter.appendChild(parent$1, commentNode);
		if (this.options.sourceCodeLocationInfo) this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
	}
	_insertCharacters(token) {
		let parent$1;
		let beforeElement;
		if (this._shouldFosterParentOnInsertion()) {
			({parent: parent$1, beforeElement} = this._findFosterParentingLocation());
			if (beforeElement) this.treeAdapter.insertTextBefore(parent$1, token.chars, beforeElement);
			else this.treeAdapter.insertText(parent$1, token.chars);
		} else {
			parent$1 = this.openElements.currentTmplContentOrNode;
			this.treeAdapter.insertText(parent$1, token.chars);
		}
		if (!token.location) return;
		const siblings = this.treeAdapter.getChildNodes(parent$1);
		const textNodeIdx = beforeElement ? siblings.lastIndexOf(beforeElement) : siblings.length;
		const textNode = siblings[textNodeIdx - 1];
		const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
		if (tnLoc) {
			const { endLine, endCol, endOffset } = token.location;
			this.treeAdapter.updateNodeSourceCodeLocation(textNode, {
				endLine,
				endCol,
				endOffset
			});
		} else if (this.options.sourceCodeLocationInfo) this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
	}
	_adoptNodes(donor, recipient) {
		for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
			this.treeAdapter.detachNode(child);
			this.treeAdapter.appendChild(recipient, child);
		}
	}
	_setEndLocation(element$5, closingToken) {
		if (this.treeAdapter.getNodeSourceCodeLocation(element$5) && closingToken.location) {
			const ctLoc = closingToken.location;
			const tn = this.treeAdapter.getTagName(element$5);
			const endLoc = closingToken.type === TokenType.END_TAG && tn === closingToken.tagName ? {
				endTag: { ...ctLoc },
				endLine: ctLoc.endLine,
				endCol: ctLoc.endCol,
				endOffset: ctLoc.endOffset
			} : {
				endLine: ctLoc.startLine,
				endCol: ctLoc.startCol,
				endOffset: ctLoc.startOffset
			};
			this.treeAdapter.updateNodeSourceCodeLocation(element$5, endLoc);
		}
	}
	shouldProcessStartTagTokenInForeignContent(token) {
		if (!this.currentNotInHTML) return false;
		let current;
		let currentTagId;
		if (this.openElements.stackTop === 0 && this.fragmentContext) {
			current = this.fragmentContext;
			currentTagId = this.fragmentContextID;
		} else ({current, currentTagId} = this.openElements);
		if (token.tagID === TAG_ID.SVG && this.treeAdapter.getTagName(current) === TAG_NAMES.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(current) === NS.MATHML) return false;
		return this.tokenizer.inForeignNode || (token.tagID === TAG_ID.MGLYPH || token.tagID === TAG_ID.MALIGNMARK) && currentTagId !== void 0 && !this._isIntegrationPoint(currentTagId, current, NS.HTML);
	}
	_processToken(token) {
		switch (token.type) {
			case TokenType.CHARACTER: {
				this.onCharacter(token);
				break;
			}
			case TokenType.NULL_CHARACTER: {
				this.onNullCharacter(token);
				break;
			}
			case TokenType.COMMENT: {
				this.onComment(token);
				break;
			}
			case TokenType.DOCTYPE: {
				this.onDoctype(token);
				break;
			}
			case TokenType.START_TAG: {
				this._processStartTag(token);
				break;
			}
			case TokenType.END_TAG: {
				this.onEndTag(token);
				break;
			}
			case TokenType.EOF: {
				this.onEof(token);
				break;
			}
			case TokenType.WHITESPACE_CHARACTER: {
				this.onWhitespaceCharacter(token);
				break;
			}
		}
	}
	_isIntegrationPoint(tid, element$5, foreignNS) {
		const ns = this.treeAdapter.getNamespaceURI(element$5);
		const attrs = this.treeAdapter.getAttrList(element$5);
		return isIntegrationPoint(tid, ns, attrs, foreignNS);
	}
	_reconstructActiveFormattingElements() {
		const listLength = this.activeFormattingElements.entries.length;
		if (listLength) {
			const endIndex = this.activeFormattingElements.entries.findIndex((entry) => entry.type === EntryType.Marker || this.openElements.contains(entry.element));
			const unopenIdx = endIndex === -1 ? listLength - 1 : endIndex - 1;
			for (let i = unopenIdx; i >= 0; i--) {
				const entry = this.activeFormattingElements.entries[i];
				this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
				entry.element = this.openElements.current;
			}
		}
	}
	_closeTableCell() {
		this.openElements.generateImpliedEndTags();
		this.openElements.popUntilTableCellPopped();
		this.activeFormattingElements.clearToLastMarker();
		this.insertionMode = InsertionMode.IN_ROW;
	}
	_closePElement() {
		this.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.P);
		this.openElements.popUntilTagNamePopped(TAG_ID.P);
	}
	_resetInsertionMode() {
		for (let i = this.openElements.stackTop; i >= 0; i--) switch (i === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[i]) {
			case TAG_ID.TR: {
				this.insertionMode = InsertionMode.IN_ROW;
				return;
			}
			case TAG_ID.TBODY:
			case TAG_ID.THEAD:
			case TAG_ID.TFOOT: {
				this.insertionMode = InsertionMode.IN_TABLE_BODY;
				return;
			}
			case TAG_ID.CAPTION: {
				this.insertionMode = InsertionMode.IN_CAPTION;
				return;
			}
			case TAG_ID.COLGROUP: {
				this.insertionMode = InsertionMode.IN_COLUMN_GROUP;
				return;
			}
			case TAG_ID.TABLE: {
				this.insertionMode = InsertionMode.IN_TABLE;
				return;
			}
			case TAG_ID.BODY: {
				this.insertionMode = InsertionMode.IN_BODY;
				return;
			}
			case TAG_ID.FRAMESET: {
				this.insertionMode = InsertionMode.IN_FRAMESET;
				return;
			}
			case TAG_ID.SELECT: {
				this._resetInsertionModeForSelect(i);
				return;
			}
			case TAG_ID.TEMPLATE: {
				this.insertionMode = this.tmplInsertionModeStack[0];
				return;
			}
			case TAG_ID.HTML: {
				this.insertionMode = this.headElement ? InsertionMode.AFTER_HEAD : InsertionMode.BEFORE_HEAD;
				return;
			}
			case TAG_ID.TD:
			case TAG_ID.TH: {
				if (i > 0) {
					this.insertionMode = InsertionMode.IN_CELL;
					return;
				}
				break;
			}
			case TAG_ID.HEAD: {
				if (i > 0) {
					this.insertionMode = InsertionMode.IN_HEAD;
					return;
				}
				break;
			}
		}
		this.insertionMode = InsertionMode.IN_BODY;
	}
	_resetInsertionModeForSelect(selectIdx) {
		if (selectIdx > 0) for (let i = selectIdx - 1; i > 0; i--) {
			const tn = this.openElements.tagIDs[i];
			if (tn === TAG_ID.TEMPLATE) break;
			else if (tn === TAG_ID.TABLE) {
				this.insertionMode = InsertionMode.IN_SELECT_IN_TABLE;
				return;
			}
		}
		this.insertionMode = InsertionMode.IN_SELECT;
	}
	_isElementCausesFosterParenting(tn) {
		return TABLE_STRUCTURE_TAGS.has(tn);
	}
	_shouldFosterParentOnInsertion() {
		return this.fosterParentingEnabled && this.openElements.currentTagId !== void 0 && this._isElementCausesFosterParenting(this.openElements.currentTagId);
	}
	_findFosterParentingLocation() {
		for (let i = this.openElements.stackTop; i >= 0; i--) {
			const openElement = this.openElements.items[i];
			switch (this.openElements.tagIDs[i]) {
				case TAG_ID.TEMPLATE: {
					if (this.treeAdapter.getNamespaceURI(openElement) === NS.HTML) return {
						parent: this.treeAdapter.getTemplateContent(openElement),
						beforeElement: null
					};
					break;
				}
				case TAG_ID.TABLE: {
					const parent$1 = this.treeAdapter.getParentNode(openElement);
					if (parent$1) return {
						parent: parent$1,
						beforeElement: openElement
					};
					return {
						parent: this.openElements.items[i - 1],
						beforeElement: null
					};
				}
				default:
			}
		}
		return {
			parent: this.openElements.items[0],
			beforeElement: null
		};
	}
	_fosterParentElement(element$5) {
		const location$1 = this._findFosterParentingLocation();
		if (location$1.beforeElement) this.treeAdapter.insertBefore(location$1.parent, element$5, location$1.beforeElement);
		else this.treeAdapter.appendChild(location$1.parent, element$5);
	}
	_isSpecialElement(element$5, id$1) {
		const ns = this.treeAdapter.getNamespaceURI(element$5);
		return SPECIAL_ELEMENTS[ns].has(id$1);
	}
	onCharacter(token) {
		this.skipNextNewLine = false;
		if (this.tokenizer.inForeignNode) {
			characterInForeignContent(this, token);
			return;
		}
		switch (this.insertionMode) {
			case InsertionMode.INITIAL: {
				tokenInInitialMode(this, token);
				break;
			}
			case InsertionMode.BEFORE_HTML: {
				tokenBeforeHtml(this, token);
				break;
			}
			case InsertionMode.BEFORE_HEAD: {
				tokenBeforeHead(this, token);
				break;
			}
			case InsertionMode.IN_HEAD: {
				tokenInHead(this, token);
				break;
			}
			case InsertionMode.IN_HEAD_NO_SCRIPT: {
				tokenInHeadNoScript(this, token);
				break;
			}
			case InsertionMode.AFTER_HEAD: {
				tokenAfterHead(this, token);
				break;
			}
			case InsertionMode.IN_BODY:
			case InsertionMode.IN_CAPTION:
			case InsertionMode.IN_CELL:
			case InsertionMode.IN_TEMPLATE: {
				characterInBody(this, token);
				break;
			}
			case InsertionMode.TEXT:
			case InsertionMode.IN_SELECT:
			case InsertionMode.IN_SELECT_IN_TABLE: {
				this._insertCharacters(token);
				break;
			}
			case InsertionMode.IN_TABLE:
			case InsertionMode.IN_TABLE_BODY:
			case InsertionMode.IN_ROW: {
				characterInTable(this, token);
				break;
			}
			case InsertionMode.IN_TABLE_TEXT: {
				characterInTableText(this, token);
				break;
			}
			case InsertionMode.IN_COLUMN_GROUP: {
				tokenInColumnGroup(this, token);
				break;
			}
			case InsertionMode.AFTER_BODY: {
				tokenAfterBody(this, token);
				break;
			}
			case InsertionMode.AFTER_AFTER_BODY: {
				tokenAfterAfterBody(this, token);
				break;
			}
			default:
		}
	}
	onNullCharacter(token) {
		this.skipNextNewLine = false;
		if (this.tokenizer.inForeignNode) {
			nullCharacterInForeignContent(this, token);
			return;
		}
		switch (this.insertionMode) {
			case InsertionMode.INITIAL: {
				tokenInInitialMode(this, token);
				break;
			}
			case InsertionMode.BEFORE_HTML: {
				tokenBeforeHtml(this, token);
				break;
			}
			case InsertionMode.BEFORE_HEAD: {
				tokenBeforeHead(this, token);
				break;
			}
			case InsertionMode.IN_HEAD: {
				tokenInHead(this, token);
				break;
			}
			case InsertionMode.IN_HEAD_NO_SCRIPT: {
				tokenInHeadNoScript(this, token);
				break;
			}
			case InsertionMode.AFTER_HEAD: {
				tokenAfterHead(this, token);
				break;
			}
			case InsertionMode.TEXT: {
				this._insertCharacters(token);
				break;
			}
			case InsertionMode.IN_TABLE:
			case InsertionMode.IN_TABLE_BODY:
			case InsertionMode.IN_ROW: {
				characterInTable(this, token);
				break;
			}
			case InsertionMode.IN_COLUMN_GROUP: {
				tokenInColumnGroup(this, token);
				break;
			}
			case InsertionMode.AFTER_BODY: {
				tokenAfterBody(this, token);
				break;
			}
			case InsertionMode.AFTER_AFTER_BODY: {
				tokenAfterAfterBody(this, token);
				break;
			}
			default:
		}
	}
	onComment(token) {
		this.skipNextNewLine = false;
		if (this.currentNotInHTML) {
			appendComment(this, token);
			return;
		}
		switch (this.insertionMode) {
			case InsertionMode.INITIAL:
			case InsertionMode.BEFORE_HTML:
			case InsertionMode.BEFORE_HEAD:
			case InsertionMode.IN_HEAD:
			case InsertionMode.IN_HEAD_NO_SCRIPT:
			case InsertionMode.AFTER_HEAD:
			case InsertionMode.IN_BODY:
			case InsertionMode.IN_TABLE:
			case InsertionMode.IN_CAPTION:
			case InsertionMode.IN_COLUMN_GROUP:
			case InsertionMode.IN_TABLE_BODY:
			case InsertionMode.IN_ROW:
			case InsertionMode.IN_CELL:
			case InsertionMode.IN_SELECT:
			case InsertionMode.IN_SELECT_IN_TABLE:
			case InsertionMode.IN_TEMPLATE:
			case InsertionMode.IN_FRAMESET:
			case InsertionMode.AFTER_FRAMESET: {
				appendComment(this, token);
				break;
			}
			case InsertionMode.IN_TABLE_TEXT: {
				tokenInTableText(this, token);
				break;
			}
			case InsertionMode.AFTER_BODY: {
				appendCommentToRootHtmlElement(this, token);
				break;
			}
			case InsertionMode.AFTER_AFTER_BODY:
			case InsertionMode.AFTER_AFTER_FRAMESET: {
				appendCommentToDocument(this, token);
				break;
			}
			default:
		}
	}
	onDoctype(token) {
		this.skipNextNewLine = false;
		switch (this.insertionMode) {
			case InsertionMode.INITIAL: {
				doctypeInInitialMode(this, token);
				break;
			}
			case InsertionMode.BEFORE_HEAD:
			case InsertionMode.IN_HEAD:
			case InsertionMode.IN_HEAD_NO_SCRIPT:
			case InsertionMode.AFTER_HEAD: {
				this._err(token, ERR.misplacedDoctype);
				break;
			}
			case InsertionMode.IN_TABLE_TEXT: {
				tokenInTableText(this, token);
				break;
			}
			default:
		}
	}
	onStartTag(token) {
		this.skipNextNewLine = false;
		this.currentToken = token;
		this._processStartTag(token);
		if (token.selfClosing && !token.ackSelfClosing) this._err(token, ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
	}
	_processStartTag(token) {
		if (this.shouldProcessStartTagTokenInForeignContent(token)) startTagInForeignContent(this, token);
		else this._startTagOutsideForeignContent(token);
	}
	_startTagOutsideForeignContent(token) {
		switch (this.insertionMode) {
			case InsertionMode.INITIAL: {
				tokenInInitialMode(this, token);
				break;
			}
			case InsertionMode.BEFORE_HTML: {
				startTagBeforeHtml(this, token);
				break;
			}
			case InsertionMode.BEFORE_HEAD: {
				startTagBeforeHead(this, token);
				break;
			}
			case InsertionMode.IN_HEAD: {
				startTagInHead(this, token);
				break;
			}
			case InsertionMode.IN_HEAD_NO_SCRIPT: {
				startTagInHeadNoScript(this, token);
				break;
			}
			case InsertionMode.AFTER_HEAD: {
				startTagAfterHead(this, token);
				break;
			}
			case InsertionMode.IN_BODY: {
				startTagInBody(this, token);
				break;
			}
			case InsertionMode.IN_TABLE: {
				startTagInTable(this, token);
				break;
			}
			case InsertionMode.IN_TABLE_TEXT: {
				tokenInTableText(this, token);
				break;
			}
			case InsertionMode.IN_CAPTION: {
				startTagInCaption(this, token);
				break;
			}
			case InsertionMode.IN_COLUMN_GROUP: {
				startTagInColumnGroup(this, token);
				break;
			}
			case InsertionMode.IN_TABLE_BODY: {
				startTagInTableBody(this, token);
				break;
			}
			case InsertionMode.IN_ROW: {
				startTagInRow(this, token);
				break;
			}
			case InsertionMode.IN_CELL: {
				startTagInCell(this, token);
				break;
			}
			case InsertionMode.IN_SELECT: {
				startTagInSelect(this, token);
				break;
			}
			case InsertionMode.IN_SELECT_IN_TABLE: {
				startTagInSelectInTable(this, token);
				break;
			}
			case InsertionMode.IN_TEMPLATE: {
				startTagInTemplate(this, token);
				break;
			}
			case InsertionMode.AFTER_BODY: {
				startTagAfterBody(this, token);
				break;
			}
			case InsertionMode.IN_FRAMESET: {
				startTagInFrameset(this, token);
				break;
			}
			case InsertionMode.AFTER_FRAMESET: {
				startTagAfterFrameset(this, token);
				break;
			}
			case InsertionMode.AFTER_AFTER_BODY: {
				startTagAfterAfterBody(this, token);
				break;
			}
			case InsertionMode.AFTER_AFTER_FRAMESET: {
				startTagAfterAfterFrameset(this, token);
				break;
			}
			default:
		}
	}
	onEndTag(token) {
		this.skipNextNewLine = false;
		this.currentToken = token;
		if (this.currentNotInHTML) endTagInForeignContent(this, token);
		else this._endTagOutsideForeignContent(token);
	}
	_endTagOutsideForeignContent(token) {
		switch (this.insertionMode) {
			case InsertionMode.INITIAL: {
				tokenInInitialMode(this, token);
				break;
			}
			case InsertionMode.BEFORE_HTML: {
				endTagBeforeHtml(this, token);
				break;
			}
			case InsertionMode.BEFORE_HEAD: {
				endTagBeforeHead(this, token);
				break;
			}
			case InsertionMode.IN_HEAD: {
				endTagInHead(this, token);
				break;
			}
			case InsertionMode.IN_HEAD_NO_SCRIPT: {
				endTagInHeadNoScript(this, token);
				break;
			}
			case InsertionMode.AFTER_HEAD: {
				endTagAfterHead(this, token);
				break;
			}
			case InsertionMode.IN_BODY: {
				endTagInBody(this, token);
				break;
			}
			case InsertionMode.TEXT: {
				endTagInText(this, token);
				break;
			}
			case InsertionMode.IN_TABLE: {
				endTagInTable(this, token);
				break;
			}
			case InsertionMode.IN_TABLE_TEXT: {
				tokenInTableText(this, token);
				break;
			}
			case InsertionMode.IN_CAPTION: {
				endTagInCaption(this, token);
				break;
			}
			case InsertionMode.IN_COLUMN_GROUP: {
				endTagInColumnGroup(this, token);
				break;
			}
			case InsertionMode.IN_TABLE_BODY: {
				endTagInTableBody(this, token);
				break;
			}
			case InsertionMode.IN_ROW: {
				endTagInRow(this, token);
				break;
			}
			case InsertionMode.IN_CELL: {
				endTagInCell(this, token);
				break;
			}
			case InsertionMode.IN_SELECT: {
				endTagInSelect(this, token);
				break;
			}
			case InsertionMode.IN_SELECT_IN_TABLE: {
				endTagInSelectInTable(this, token);
				break;
			}
			case InsertionMode.IN_TEMPLATE: {
				endTagInTemplate(this, token);
				break;
			}
			case InsertionMode.AFTER_BODY: {
				endTagAfterBody(this, token);
				break;
			}
			case InsertionMode.IN_FRAMESET: {
				endTagInFrameset(this, token);
				break;
			}
			case InsertionMode.AFTER_FRAMESET: {
				endTagAfterFrameset(this, token);
				break;
			}
			case InsertionMode.AFTER_AFTER_BODY: {
				tokenAfterAfterBody(this, token);
				break;
			}
			default:
		}
	}
	onEof(token) {
		switch (this.insertionMode) {
			case InsertionMode.INITIAL: {
				tokenInInitialMode(this, token);
				break;
			}
			case InsertionMode.BEFORE_HTML: {
				tokenBeforeHtml(this, token);
				break;
			}
			case InsertionMode.BEFORE_HEAD: {
				tokenBeforeHead(this, token);
				break;
			}
			case InsertionMode.IN_HEAD: {
				tokenInHead(this, token);
				break;
			}
			case InsertionMode.IN_HEAD_NO_SCRIPT: {
				tokenInHeadNoScript(this, token);
				break;
			}
			case InsertionMode.AFTER_HEAD: {
				tokenAfterHead(this, token);
				break;
			}
			case InsertionMode.IN_BODY:
			case InsertionMode.IN_TABLE:
			case InsertionMode.IN_CAPTION:
			case InsertionMode.IN_COLUMN_GROUP:
			case InsertionMode.IN_TABLE_BODY:
			case InsertionMode.IN_ROW:
			case InsertionMode.IN_CELL:
			case InsertionMode.IN_SELECT:
			case InsertionMode.IN_SELECT_IN_TABLE: {
				eofInBody(this, token);
				break;
			}
			case InsertionMode.TEXT: {
				eofInText(this, token);
				break;
			}
			case InsertionMode.IN_TABLE_TEXT: {
				tokenInTableText(this, token);
				break;
			}
			case InsertionMode.IN_TEMPLATE: {
				eofInTemplate(this, token);
				break;
			}
			case InsertionMode.AFTER_BODY:
			case InsertionMode.IN_FRAMESET:
			case InsertionMode.AFTER_FRAMESET:
			case InsertionMode.AFTER_AFTER_BODY:
			case InsertionMode.AFTER_AFTER_FRAMESET: {
				stopParsing(this, token);
				break;
			}
			default:
		}
	}
	onWhitespaceCharacter(token) {
		if (this.skipNextNewLine) {
			this.skipNextNewLine = false;
			if (token.chars.charCodeAt(0) === CODE_POINTS.LINE_FEED) {
				if (token.chars.length === 1) return;
				token.chars = token.chars.substr(1);
			}
		}
		if (this.tokenizer.inForeignNode) {
			this._insertCharacters(token);
			return;
		}
		switch (this.insertionMode) {
			case InsertionMode.IN_HEAD:
			case InsertionMode.IN_HEAD_NO_SCRIPT:
			case InsertionMode.AFTER_HEAD:
			case InsertionMode.TEXT:
			case InsertionMode.IN_COLUMN_GROUP:
			case InsertionMode.IN_SELECT:
			case InsertionMode.IN_SELECT_IN_TABLE:
			case InsertionMode.IN_FRAMESET:
			case InsertionMode.AFTER_FRAMESET: {
				this._insertCharacters(token);
				break;
			}
			case InsertionMode.IN_BODY:
			case InsertionMode.IN_CAPTION:
			case InsertionMode.IN_CELL:
			case InsertionMode.IN_TEMPLATE:
			case InsertionMode.AFTER_BODY:
			case InsertionMode.AFTER_AFTER_BODY:
			case InsertionMode.AFTER_AFTER_FRAMESET: {
				whitespaceCharacterInBody(this, token);
				break;
			}
			case InsertionMode.IN_TABLE:
			case InsertionMode.IN_TABLE_BODY:
			case InsertionMode.IN_ROW: {
				characterInTable(this, token);
				break;
			}
			case InsertionMode.IN_TABLE_TEXT: {
				whitespaceCharacterInTableText(this, token);
				break;
			}
			default:
		}
	}
};
function aaObtainFormattingElementEntry(p$1, token) {
	let formattingElementEntry = p$1.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
	if (formattingElementEntry) {
		if (!p$1.openElements.contains(formattingElementEntry.element)) {
			p$1.activeFormattingElements.removeEntry(formattingElementEntry);
			formattingElementEntry = null;
		} else if (!p$1.openElements.hasInScope(token.tagID)) formattingElementEntry = null;
	} else genericEndTagInBody(p$1, token);
	return formattingElementEntry;
}
function aaObtainFurthestBlock(p$1, formattingElementEntry) {
	let furthestBlock = null;
	let idx = p$1.openElements.stackTop;
	for (; idx >= 0; idx--) {
		const element$5 = p$1.openElements.items[idx];
		if (element$5 === formattingElementEntry.element) break;
		if (p$1._isSpecialElement(element$5, p$1.openElements.tagIDs[idx])) furthestBlock = element$5;
	}
	if (!furthestBlock) {
		p$1.openElements.shortenToLength(Math.max(idx, 0));
		p$1.activeFormattingElements.removeEntry(formattingElementEntry);
	}
	return furthestBlock;
}
function aaInnerLoop(p$1, furthestBlock, formattingElement) {
	let lastElement = furthestBlock;
	let nextElement = p$1.openElements.getCommonAncestor(furthestBlock);
	for (let i = 0, element$5 = nextElement; element$5 !== formattingElement; i++, element$5 = nextElement) {
		nextElement = p$1.openElements.getCommonAncestor(element$5);
		const elementEntry = p$1.activeFormattingElements.getElementEntry(element$5);
		const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
		const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
		if (shouldRemoveFromOpenElements) {
			if (counterOverflow) p$1.activeFormattingElements.removeEntry(elementEntry);
			p$1.openElements.remove(element$5);
		} else {
			element$5 = aaRecreateElementFromEntry(p$1, elementEntry);
			if (lastElement === furthestBlock) p$1.activeFormattingElements.bookmark = elementEntry;
			p$1.treeAdapter.detachNode(lastElement);
			p$1.treeAdapter.appendChild(element$5, lastElement);
			lastElement = element$5;
		}
	}
	return lastElement;
}
function aaRecreateElementFromEntry(p$1, elementEntry) {
	const ns = p$1.treeAdapter.getNamespaceURI(elementEntry.element);
	const newElement = p$1.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
	p$1.openElements.replace(elementEntry.element, newElement);
	elementEntry.element = newElement;
	return newElement;
}
function aaInsertLastNodeInCommonAncestor(p$1, commonAncestor, lastElement) {
	const tn = p$1.treeAdapter.getTagName(commonAncestor);
	const tid = getTagID(tn);
	if (p$1._isElementCausesFosterParenting(tid)) p$1._fosterParentElement(lastElement);
	else {
		const ns = p$1.treeAdapter.getNamespaceURI(commonAncestor);
		if (tid === TAG_ID.TEMPLATE && ns === NS.HTML) commonAncestor = p$1.treeAdapter.getTemplateContent(commonAncestor);
		p$1.treeAdapter.appendChild(commonAncestor, lastElement);
	}
}
function aaReplaceFormattingElement(p$1, furthestBlock, formattingElementEntry) {
	const ns = p$1.treeAdapter.getNamespaceURI(formattingElementEntry.element);
	const { token } = formattingElementEntry;
	const newElement = p$1.treeAdapter.createElement(token.tagName, ns, token.attrs);
	p$1._adoptNodes(furthestBlock, newElement);
	p$1.treeAdapter.appendChild(furthestBlock, newElement);
	p$1.activeFormattingElements.insertElementAfterBookmark(newElement, token);
	p$1.activeFormattingElements.removeEntry(formattingElementEntry);
	p$1.openElements.remove(formattingElementEntry.element);
	p$1.openElements.insertAfter(furthestBlock, newElement, token.tagID);
}
function callAdoptionAgency(p$1, token) {
	for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
		const formattingElementEntry = aaObtainFormattingElementEntry(p$1, token);
		if (!formattingElementEntry) break;
		const furthestBlock = aaObtainFurthestBlock(p$1, formattingElementEntry);
		if (!furthestBlock) break;
		p$1.activeFormattingElements.bookmark = formattingElementEntry;
		const lastElement = aaInnerLoop(p$1, furthestBlock, formattingElementEntry.element);
		const commonAncestor = p$1.openElements.getCommonAncestor(formattingElementEntry.element);
		p$1.treeAdapter.detachNode(lastElement);
		if (commonAncestor) aaInsertLastNodeInCommonAncestor(p$1, commonAncestor, lastElement);
		aaReplaceFormattingElement(p$1, furthestBlock, formattingElementEntry);
	}
}
function appendComment(p$1, token) {
	p$1._appendCommentNode(token, p$1.openElements.currentTmplContentOrNode);
}
function appendCommentToRootHtmlElement(p$1, token) {
	p$1._appendCommentNode(token, p$1.openElements.items[0]);
}
function appendCommentToDocument(p$1, token) {
	p$1._appendCommentNode(token, p$1.document);
}
function stopParsing(p$1, token) {
	p$1.stopped = true;
	if (token.location) {
		const target = p$1.fragmentContext ? 0 : 2;
		for (let i = p$1.openElements.stackTop; i >= target; i--) p$1._setEndLocation(p$1.openElements.items[i], token);
		if (!p$1.fragmentContext && p$1.openElements.stackTop >= 0) {
			const htmlElement = p$1.openElements.items[0];
			const htmlLocation = p$1.treeAdapter.getNodeSourceCodeLocation(htmlElement);
			if (htmlLocation && !htmlLocation.endTag) {
				p$1._setEndLocation(htmlElement, token);
				if (p$1.openElements.stackTop >= 1) {
					const bodyElement = p$1.openElements.items[1];
					const bodyLocation = p$1.treeAdapter.getNodeSourceCodeLocation(bodyElement);
					if (bodyLocation && !bodyLocation.endTag) p$1._setEndLocation(bodyElement, token);
				}
			}
		}
	}
}
function doctypeInInitialMode(p$1, token) {
	p$1._setDocumentType(token);
	const mode = token.forceQuirks ? DOCUMENT_MODE.QUIRKS : getDocumentMode(token);
	if (!isConforming(token)) p$1._err(token, ERR.nonConformingDoctype);
	p$1.treeAdapter.setDocumentMode(p$1.document, mode);
	p$1.insertionMode = InsertionMode.BEFORE_HTML;
}
function tokenInInitialMode(p$1, token) {
	p$1._err(token, ERR.missingDoctype, true);
	p$1.treeAdapter.setDocumentMode(p$1.document, DOCUMENT_MODE.QUIRKS);
	p$1.insertionMode = InsertionMode.BEFORE_HTML;
	p$1._processToken(token);
}
function startTagBeforeHtml(p$1, token) {
	if (token.tagID === TAG_ID.HTML) {
		p$1._insertElement(token, NS.HTML);
		p$1.insertionMode = InsertionMode.BEFORE_HEAD;
	} else tokenBeforeHtml(p$1, token);
}
function endTagBeforeHtml(p$1, token) {
	const tn = token.tagID;
	if (tn === TAG_ID.HTML || tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.BR) tokenBeforeHtml(p$1, token);
}
function tokenBeforeHtml(p$1, token) {
	p$1._insertFakeRootElement();
	p$1.insertionMode = InsertionMode.BEFORE_HEAD;
	p$1._processToken(token);
}
function startTagBeforeHead(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.HTML: {
			startTagInBody(p$1, token);
			break;
		}
		case TAG_ID.HEAD: {
			p$1._insertElement(token, NS.HTML);
			p$1.headElement = p$1.openElements.current;
			p$1.insertionMode = InsertionMode.IN_HEAD;
			break;
		}
		default: tokenBeforeHead(p$1, token);
	}
}
function endTagBeforeHead(p$1, token) {
	const tn = token.tagID;
	if (tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.HTML || tn === TAG_ID.BR) tokenBeforeHead(p$1, token);
	else p$1._err(token, ERR.endTagWithoutMatchingOpenElement);
}
function tokenBeforeHead(p$1, token) {
	p$1._insertFakeElement(TAG_NAMES.HEAD, TAG_ID.HEAD);
	p$1.headElement = p$1.openElements.current;
	p$1.insertionMode = InsertionMode.IN_HEAD;
	p$1._processToken(token);
}
function startTagInHead(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.HTML: {
			startTagInBody(p$1, token);
			break;
		}
		case TAG_ID.BASE:
		case TAG_ID.BASEFONT:
		case TAG_ID.BGSOUND:
		case TAG_ID.LINK:
		case TAG_ID.META: {
			p$1._appendElement(token, NS.HTML);
			token.ackSelfClosing = true;
			break;
		}
		case TAG_ID.TITLE: {
			p$1._switchToTextParsing(token, TokenizerMode.RCDATA);
			break;
		}
		case TAG_ID.NOSCRIPT: {
			if (p$1.options.scriptingEnabled) p$1._switchToTextParsing(token, TokenizerMode.RAWTEXT);
			else {
				p$1._insertElement(token, NS.HTML);
				p$1.insertionMode = InsertionMode.IN_HEAD_NO_SCRIPT;
			}
			break;
		}
		case TAG_ID.NOFRAMES:
		case TAG_ID.STYLE: {
			p$1._switchToTextParsing(token, TokenizerMode.RAWTEXT);
			break;
		}
		case TAG_ID.SCRIPT: {
			p$1._switchToTextParsing(token, TokenizerMode.SCRIPT_DATA);
			break;
		}
		case TAG_ID.TEMPLATE: {
			p$1._insertTemplate(token);
			p$1.activeFormattingElements.insertMarker();
			p$1.framesetOk = false;
			p$1.insertionMode = InsertionMode.IN_TEMPLATE;
			p$1.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
			break;
		}
		case TAG_ID.HEAD: {
			p$1._err(token, ERR.misplacedStartTagForHeadElement);
			break;
		}
		default: tokenInHead(p$1, token);
	}
}
function endTagInHead(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.HEAD: {
			p$1.openElements.pop();
			p$1.insertionMode = InsertionMode.AFTER_HEAD;
			break;
		}
		case TAG_ID.BODY:
		case TAG_ID.BR:
		case TAG_ID.HTML: {
			tokenInHead(p$1, token);
			break;
		}
		case TAG_ID.TEMPLATE: {
			templateEndTagInHead(p$1, token);
			break;
		}
		default: p$1._err(token, ERR.endTagWithoutMatchingOpenElement);
	}
}
function templateEndTagInHead(p$1, token) {
	if (p$1.openElements.tmplCount > 0) {
		p$1.openElements.generateImpliedEndTagsThoroughly();
		if (p$1.openElements.currentTagId !== TAG_ID.TEMPLATE) p$1._err(token, ERR.closingOfElementWithOpenChildElements);
		p$1.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
		p$1.activeFormattingElements.clearToLastMarker();
		p$1.tmplInsertionModeStack.shift();
		p$1._resetInsertionMode();
	} else p$1._err(token, ERR.endTagWithoutMatchingOpenElement);
}
function tokenInHead(p$1, token) {
	p$1.openElements.pop();
	p$1.insertionMode = InsertionMode.AFTER_HEAD;
	p$1._processToken(token);
}
function startTagInHeadNoScript(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.HTML: {
			startTagInBody(p$1, token);
			break;
		}
		case TAG_ID.BASEFONT:
		case TAG_ID.BGSOUND:
		case TAG_ID.HEAD:
		case TAG_ID.LINK:
		case TAG_ID.META:
		case TAG_ID.NOFRAMES:
		case TAG_ID.STYLE: {
			startTagInHead(p$1, token);
			break;
		}
		case TAG_ID.NOSCRIPT: {
			p$1._err(token, ERR.nestedNoscriptInHead);
			break;
		}
		default: tokenInHeadNoScript(p$1, token);
	}
}
function endTagInHeadNoScript(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.NOSCRIPT: {
			p$1.openElements.pop();
			p$1.insertionMode = InsertionMode.IN_HEAD;
			break;
		}
		case TAG_ID.BR: {
			tokenInHeadNoScript(p$1, token);
			break;
		}
		default: p$1._err(token, ERR.endTagWithoutMatchingOpenElement);
	}
}
function tokenInHeadNoScript(p$1, token) {
	const errCode = token.type === TokenType.EOF ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;
	p$1._err(token, errCode);
	p$1.openElements.pop();
	p$1.insertionMode = InsertionMode.IN_HEAD;
	p$1._processToken(token);
}
function startTagAfterHead(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.HTML: {
			startTagInBody(p$1, token);
			break;
		}
		case TAG_ID.BODY: {
			p$1._insertElement(token, NS.HTML);
			p$1.framesetOk = false;
			p$1.insertionMode = InsertionMode.IN_BODY;
			break;
		}
		case TAG_ID.FRAMESET: {
			p$1._insertElement(token, NS.HTML);
			p$1.insertionMode = InsertionMode.IN_FRAMESET;
			break;
		}
		case TAG_ID.BASE:
		case TAG_ID.BASEFONT:
		case TAG_ID.BGSOUND:
		case TAG_ID.LINK:
		case TAG_ID.META:
		case TAG_ID.NOFRAMES:
		case TAG_ID.SCRIPT:
		case TAG_ID.STYLE:
		case TAG_ID.TEMPLATE:
		case TAG_ID.TITLE: {
			p$1._err(token, ERR.abandonedHeadElementChild);
			p$1.openElements.push(p$1.headElement, TAG_ID.HEAD);
			startTagInHead(p$1, token);
			p$1.openElements.remove(p$1.headElement);
			break;
		}
		case TAG_ID.HEAD: {
			p$1._err(token, ERR.misplacedStartTagForHeadElement);
			break;
		}
		default: tokenAfterHead(p$1, token);
	}
}
function endTagAfterHead(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.BODY:
		case TAG_ID.HTML:
		case TAG_ID.BR: {
			tokenAfterHead(p$1, token);
			break;
		}
		case TAG_ID.TEMPLATE: {
			templateEndTagInHead(p$1, token);
			break;
		}
		default: p$1._err(token, ERR.endTagWithoutMatchingOpenElement);
	}
}
function tokenAfterHead(p$1, token) {
	p$1._insertFakeElement(TAG_NAMES.BODY, TAG_ID.BODY);
	p$1.insertionMode = InsertionMode.IN_BODY;
	modeInBody(p$1, token);
}
function modeInBody(p$1, token) {
	switch (token.type) {
		case TokenType.CHARACTER: {
			characterInBody(p$1, token);
			break;
		}
		case TokenType.WHITESPACE_CHARACTER: {
			whitespaceCharacterInBody(p$1, token);
			break;
		}
		case TokenType.COMMENT: {
			appendComment(p$1, token);
			break;
		}
		case TokenType.START_TAG: {
			startTagInBody(p$1, token);
			break;
		}
		case TokenType.END_TAG: {
			endTagInBody(p$1, token);
			break;
		}
		case TokenType.EOF: {
			eofInBody(p$1, token);
			break;
		}
		default:
	}
}
function whitespaceCharacterInBody(p$1, token) {
	p$1._reconstructActiveFormattingElements();
	p$1._insertCharacters(token);
}
function characterInBody(p$1, token) {
	p$1._reconstructActiveFormattingElements();
	p$1._insertCharacters(token);
	p$1.framesetOk = false;
}
function htmlStartTagInBody(p$1, token) {
	if (p$1.openElements.tmplCount === 0) p$1.treeAdapter.adoptAttributes(p$1.openElements.items[0], token.attrs);
}
function bodyStartTagInBody(p$1, token) {
	const bodyElement = p$1.openElements.tryPeekProperlyNestedBodyElement();
	if (bodyElement && p$1.openElements.tmplCount === 0) {
		p$1.framesetOk = false;
		p$1.treeAdapter.adoptAttributes(bodyElement, token.attrs);
	}
}
function framesetStartTagInBody(p$1, token) {
	const bodyElement = p$1.openElements.tryPeekProperlyNestedBodyElement();
	if (p$1.framesetOk && bodyElement) {
		p$1.treeAdapter.detachNode(bodyElement);
		p$1.openElements.popAllUpToHtmlElement();
		p$1._insertElement(token, NS.HTML);
		p$1.insertionMode = InsertionMode.IN_FRAMESET;
	}
}
function addressStartTagInBody(p$1, token) {
	if (p$1.openElements.hasInButtonScope(TAG_ID.P)) p$1._closePElement();
	p$1._insertElement(token, NS.HTML);
}
function numberedHeaderStartTagInBody(p$1, token) {
	if (p$1.openElements.hasInButtonScope(TAG_ID.P)) p$1._closePElement();
	if (p$1.openElements.currentTagId !== void 0 && NUMBERED_HEADERS.has(p$1.openElements.currentTagId)) p$1.openElements.pop();
	p$1._insertElement(token, NS.HTML);
}
function preStartTagInBody(p$1, token) {
	if (p$1.openElements.hasInButtonScope(TAG_ID.P)) p$1._closePElement();
	p$1._insertElement(token, NS.HTML);
	p$1.skipNextNewLine = true;
	p$1.framesetOk = false;
}
function formStartTagInBody(p$1, token) {
	const inTemplate = p$1.openElements.tmplCount > 0;
	if (!p$1.formElement || inTemplate) {
		if (p$1.openElements.hasInButtonScope(TAG_ID.P)) p$1._closePElement();
		p$1._insertElement(token, NS.HTML);
		if (!inTemplate) p$1.formElement = p$1.openElements.current;
	}
}
function listItemStartTagInBody(p$1, token) {
	p$1.framesetOk = false;
	const tn = token.tagID;
	for (let i = p$1.openElements.stackTop; i >= 0; i--) {
		const elementId = p$1.openElements.tagIDs[i];
		if (tn === TAG_ID.LI && elementId === TAG_ID.LI || (tn === TAG_ID.DD || tn === TAG_ID.DT) && (elementId === TAG_ID.DD || elementId === TAG_ID.DT)) {
			p$1.openElements.generateImpliedEndTagsWithExclusion(elementId);
			p$1.openElements.popUntilTagNamePopped(elementId);
			break;
		}
		if (elementId !== TAG_ID.ADDRESS && elementId !== TAG_ID.DIV && elementId !== TAG_ID.P && p$1._isSpecialElement(p$1.openElements.items[i], elementId)) break;
	}
	if (p$1.openElements.hasInButtonScope(TAG_ID.P)) p$1._closePElement();
	p$1._insertElement(token, NS.HTML);
}
function plaintextStartTagInBody(p$1, token) {
	if (p$1.openElements.hasInButtonScope(TAG_ID.P)) p$1._closePElement();
	p$1._insertElement(token, NS.HTML);
	p$1.tokenizer.state = TokenizerMode.PLAINTEXT;
}
function buttonStartTagInBody(p$1, token) {
	if (p$1.openElements.hasInScope(TAG_ID.BUTTON)) {
		p$1.openElements.generateImpliedEndTags();
		p$1.openElements.popUntilTagNamePopped(TAG_ID.BUTTON);
	}
	p$1._reconstructActiveFormattingElements();
	p$1._insertElement(token, NS.HTML);
	p$1.framesetOk = false;
}
function aStartTagInBody(p$1, token) {
	const activeElementEntry = p$1.activeFormattingElements.getElementEntryInScopeWithTagName(TAG_NAMES.A);
	if (activeElementEntry) {
		callAdoptionAgency(p$1, token);
		p$1.openElements.remove(activeElementEntry.element);
		p$1.activeFormattingElements.removeEntry(activeElementEntry);
	}
	p$1._reconstructActiveFormattingElements();
	p$1._insertElement(token, NS.HTML);
	p$1.activeFormattingElements.pushElement(p$1.openElements.current, token);
}
function bStartTagInBody(p$1, token) {
	p$1._reconstructActiveFormattingElements();
	p$1._insertElement(token, NS.HTML);
	p$1.activeFormattingElements.pushElement(p$1.openElements.current, token);
}
function nobrStartTagInBody(p$1, token) {
	p$1._reconstructActiveFormattingElements();
	if (p$1.openElements.hasInScope(TAG_ID.NOBR)) {
		callAdoptionAgency(p$1, token);
		p$1._reconstructActiveFormattingElements();
	}
	p$1._insertElement(token, NS.HTML);
	p$1.activeFormattingElements.pushElement(p$1.openElements.current, token);
}
function appletStartTagInBody(p$1, token) {
	p$1._reconstructActiveFormattingElements();
	p$1._insertElement(token, NS.HTML);
	p$1.activeFormattingElements.insertMarker();
	p$1.framesetOk = false;
}
function tableStartTagInBody(p$1, token) {
	if (p$1.treeAdapter.getDocumentMode(p$1.document) !== DOCUMENT_MODE.QUIRKS && p$1.openElements.hasInButtonScope(TAG_ID.P)) p$1._closePElement();
	p$1._insertElement(token, NS.HTML);
	p$1.framesetOk = false;
	p$1.insertionMode = InsertionMode.IN_TABLE;
}
function areaStartTagInBody(p$1, token) {
	p$1._reconstructActiveFormattingElements();
	p$1._appendElement(token, NS.HTML);
	p$1.framesetOk = false;
	token.ackSelfClosing = true;
}
function isHiddenInput(token) {
	const inputType = getTokenAttr(token, ATTRS.TYPE);
	return inputType != null && inputType.toLowerCase() === HIDDEN_INPUT_TYPE;
}
function inputStartTagInBody(p$1, token) {
	p$1._reconstructActiveFormattingElements();
	p$1._appendElement(token, NS.HTML);
	if (!isHiddenInput(token)) p$1.framesetOk = false;
	token.ackSelfClosing = true;
}
function paramStartTagInBody(p$1, token) {
	p$1._appendElement(token, NS.HTML);
	token.ackSelfClosing = true;
}
function hrStartTagInBody(p$1, token) {
	if (p$1.openElements.hasInButtonScope(TAG_ID.P)) p$1._closePElement();
	p$1._appendElement(token, NS.HTML);
	p$1.framesetOk = false;
	token.ackSelfClosing = true;
}
function imageStartTagInBody(p$1, token) {
	token.tagName = TAG_NAMES.IMG;
	token.tagID = TAG_ID.IMG;
	areaStartTagInBody(p$1, token);
}
function textareaStartTagInBody(p$1, token) {
	p$1._insertElement(token, NS.HTML);
	p$1.skipNextNewLine = true;
	p$1.tokenizer.state = TokenizerMode.RCDATA;
	p$1.originalInsertionMode = p$1.insertionMode;
	p$1.framesetOk = false;
	p$1.insertionMode = InsertionMode.TEXT;
}
function xmpStartTagInBody(p$1, token) {
	if (p$1.openElements.hasInButtonScope(TAG_ID.P)) p$1._closePElement();
	p$1._reconstructActiveFormattingElements();
	p$1.framesetOk = false;
	p$1._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function iframeStartTagInBody(p$1, token) {
	p$1.framesetOk = false;
	p$1._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function rawTextStartTagInBody(p$1, token) {
	p$1._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function selectStartTagInBody(p$1, token) {
	p$1._reconstructActiveFormattingElements();
	p$1._insertElement(token, NS.HTML);
	p$1.framesetOk = false;
	p$1.insertionMode = p$1.insertionMode === InsertionMode.IN_TABLE || p$1.insertionMode === InsertionMode.IN_CAPTION || p$1.insertionMode === InsertionMode.IN_TABLE_BODY || p$1.insertionMode === InsertionMode.IN_ROW || p$1.insertionMode === InsertionMode.IN_CELL ? InsertionMode.IN_SELECT_IN_TABLE : InsertionMode.IN_SELECT;
}
function optgroupStartTagInBody(p$1, token) {
	if (p$1.openElements.currentTagId === TAG_ID.OPTION) p$1.openElements.pop();
	p$1._reconstructActiveFormattingElements();
	p$1._insertElement(token, NS.HTML);
}
function rbStartTagInBody(p$1, token) {
	if (p$1.openElements.hasInScope(TAG_ID.RUBY)) p$1.openElements.generateImpliedEndTags();
	p$1._insertElement(token, NS.HTML);
}
function rtStartTagInBody(p$1, token) {
	if (p$1.openElements.hasInScope(TAG_ID.RUBY)) p$1.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.RTC);
	p$1._insertElement(token, NS.HTML);
}
function mathStartTagInBody(p$1, token) {
	p$1._reconstructActiveFormattingElements();
	adjustTokenMathMLAttrs(token);
	adjustTokenXMLAttrs(token);
	if (token.selfClosing) p$1._appendElement(token, NS.MATHML);
	else p$1._insertElement(token, NS.MATHML);
	token.ackSelfClosing = true;
}
function svgStartTagInBody(p$1, token) {
	p$1._reconstructActiveFormattingElements();
	adjustTokenSVGAttrs(token);
	adjustTokenXMLAttrs(token);
	if (token.selfClosing) p$1._appendElement(token, NS.SVG);
	else p$1._insertElement(token, NS.SVG);
	token.ackSelfClosing = true;
}
function genericStartTagInBody(p$1, token) {
	p$1._reconstructActiveFormattingElements();
	p$1._insertElement(token, NS.HTML);
}
function startTagInBody(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.I:
		case TAG_ID.S:
		case TAG_ID.B:
		case TAG_ID.U:
		case TAG_ID.EM:
		case TAG_ID.TT:
		case TAG_ID.BIG:
		case TAG_ID.CODE:
		case TAG_ID.FONT:
		case TAG_ID.SMALL:
		case TAG_ID.STRIKE:
		case TAG_ID.STRONG: {
			bStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.A: {
			aStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.H1:
		case TAG_ID.H2:
		case TAG_ID.H3:
		case TAG_ID.H4:
		case TAG_ID.H5:
		case TAG_ID.H6: {
			numberedHeaderStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.P:
		case TAG_ID.DL:
		case TAG_ID.OL:
		case TAG_ID.UL:
		case TAG_ID.DIV:
		case TAG_ID.DIR:
		case TAG_ID.NAV:
		case TAG_ID.MAIN:
		case TAG_ID.MENU:
		case TAG_ID.ASIDE:
		case TAG_ID.CENTER:
		case TAG_ID.FIGURE:
		case TAG_ID.FOOTER:
		case TAG_ID.HEADER:
		case TAG_ID.HGROUP:
		case TAG_ID.DIALOG:
		case TAG_ID.DETAILS:
		case TAG_ID.ADDRESS:
		case TAG_ID.ARTICLE:
		case TAG_ID.SEARCH:
		case TAG_ID.SECTION:
		case TAG_ID.SUMMARY:
		case TAG_ID.FIELDSET:
		case TAG_ID.BLOCKQUOTE:
		case TAG_ID.FIGCAPTION: {
			addressStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.LI:
		case TAG_ID.DD:
		case TAG_ID.DT: {
			listItemStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.BR:
		case TAG_ID.IMG:
		case TAG_ID.WBR:
		case TAG_ID.AREA:
		case TAG_ID.EMBED:
		case TAG_ID.KEYGEN: {
			areaStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.HR: {
			hrStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.RB:
		case TAG_ID.RTC: {
			rbStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.RT:
		case TAG_ID.RP: {
			rtStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.PRE:
		case TAG_ID.LISTING: {
			preStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.XMP: {
			xmpStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.SVG: {
			svgStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.HTML: {
			htmlStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.BASE:
		case TAG_ID.LINK:
		case TAG_ID.META:
		case TAG_ID.STYLE:
		case TAG_ID.TITLE:
		case TAG_ID.SCRIPT:
		case TAG_ID.BGSOUND:
		case TAG_ID.BASEFONT:
		case TAG_ID.TEMPLATE: {
			startTagInHead(p$1, token);
			break;
		}
		case TAG_ID.BODY: {
			bodyStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.FORM: {
			formStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.NOBR: {
			nobrStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.MATH: {
			mathStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.TABLE: {
			tableStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.INPUT: {
			inputStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.PARAM:
		case TAG_ID.TRACK:
		case TAG_ID.SOURCE: {
			paramStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.IMAGE: {
			imageStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.BUTTON: {
			buttonStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.APPLET:
		case TAG_ID.OBJECT:
		case TAG_ID.MARQUEE: {
			appletStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.IFRAME: {
			iframeStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.SELECT: {
			selectStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.OPTION:
		case TAG_ID.OPTGROUP: {
			optgroupStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.NOEMBED:
		case TAG_ID.NOFRAMES: {
			rawTextStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.FRAMESET: {
			framesetStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.TEXTAREA: {
			textareaStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.NOSCRIPT: {
			if (p$1.options.scriptingEnabled) rawTextStartTagInBody(p$1, token);
			else genericStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.PLAINTEXT: {
			plaintextStartTagInBody(p$1, token);
			break;
		}
		case TAG_ID.COL:
		case TAG_ID.TH:
		case TAG_ID.TD:
		case TAG_ID.TR:
		case TAG_ID.HEAD:
		case TAG_ID.FRAME:
		case TAG_ID.TBODY:
		case TAG_ID.TFOOT:
		case TAG_ID.THEAD:
		case TAG_ID.CAPTION:
		case TAG_ID.COLGROUP: break;
		default: genericStartTagInBody(p$1, token);
	}
}
function bodyEndTagInBody(p$1, token) {
	if (p$1.openElements.hasInScope(TAG_ID.BODY)) {
		p$1.insertionMode = InsertionMode.AFTER_BODY;
		if (p$1.options.sourceCodeLocationInfo) {
			const bodyElement = p$1.openElements.tryPeekProperlyNestedBodyElement();
			if (bodyElement) p$1._setEndLocation(bodyElement, token);
		}
	}
}
function htmlEndTagInBody(p$1, token) {
	if (p$1.openElements.hasInScope(TAG_ID.BODY)) {
		p$1.insertionMode = InsertionMode.AFTER_BODY;
		endTagAfterBody(p$1, token);
	}
}
function addressEndTagInBody(p$1, token) {
	const tn = token.tagID;
	if (p$1.openElements.hasInScope(tn)) {
		p$1.openElements.generateImpliedEndTags();
		p$1.openElements.popUntilTagNamePopped(tn);
	}
}
function formEndTagInBody(p$1) {
	const inTemplate = p$1.openElements.tmplCount > 0;
	const { formElement } = p$1;
	if (!inTemplate) p$1.formElement = null;
	if ((formElement || inTemplate) && p$1.openElements.hasInScope(TAG_ID.FORM)) {
		p$1.openElements.generateImpliedEndTags();
		if (inTemplate) p$1.openElements.popUntilTagNamePopped(TAG_ID.FORM);
		else if (formElement) p$1.openElements.remove(formElement);
	}
}
function pEndTagInBody(p$1) {
	if (!p$1.openElements.hasInButtonScope(TAG_ID.P)) p$1._insertFakeElement(TAG_NAMES.P, TAG_ID.P);
	p$1._closePElement();
}
function liEndTagInBody(p$1) {
	if (p$1.openElements.hasInListItemScope(TAG_ID.LI)) {
		p$1.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.LI);
		p$1.openElements.popUntilTagNamePopped(TAG_ID.LI);
	}
}
function ddEndTagInBody(p$1, token) {
	const tn = token.tagID;
	if (p$1.openElements.hasInScope(tn)) {
		p$1.openElements.generateImpliedEndTagsWithExclusion(tn);
		p$1.openElements.popUntilTagNamePopped(tn);
	}
}
function numberedHeaderEndTagInBody(p$1) {
	if (p$1.openElements.hasNumberedHeaderInScope()) {
		p$1.openElements.generateImpliedEndTags();
		p$1.openElements.popUntilNumberedHeaderPopped();
	}
}
function appletEndTagInBody(p$1, token) {
	const tn = token.tagID;
	if (p$1.openElements.hasInScope(tn)) {
		p$1.openElements.generateImpliedEndTags();
		p$1.openElements.popUntilTagNamePopped(tn);
		p$1.activeFormattingElements.clearToLastMarker();
	}
}
function brEndTagInBody(p$1) {
	p$1._reconstructActiveFormattingElements();
	p$1._insertFakeElement(TAG_NAMES.BR, TAG_ID.BR);
	p$1.openElements.pop();
	p$1.framesetOk = false;
}
function genericEndTagInBody(p$1, token) {
	const tn = token.tagName;
	const tid = token.tagID;
	for (let i = p$1.openElements.stackTop; i > 0; i--) {
		const element$5 = p$1.openElements.items[i];
		const elementId = p$1.openElements.tagIDs[i];
		if (tid === elementId && (tid !== TAG_ID.UNKNOWN || p$1.treeAdapter.getTagName(element$5) === tn)) {
			p$1.openElements.generateImpliedEndTagsWithExclusion(tid);
			if (p$1.openElements.stackTop >= i) p$1.openElements.shortenToLength(i);
			break;
		}
		if (p$1._isSpecialElement(element$5, elementId)) break;
	}
}
function endTagInBody(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.A:
		case TAG_ID.B:
		case TAG_ID.I:
		case TAG_ID.S:
		case TAG_ID.U:
		case TAG_ID.EM:
		case TAG_ID.TT:
		case TAG_ID.BIG:
		case TAG_ID.CODE:
		case TAG_ID.FONT:
		case TAG_ID.NOBR:
		case TAG_ID.SMALL:
		case TAG_ID.STRIKE:
		case TAG_ID.STRONG: {
			callAdoptionAgency(p$1, token);
			break;
		}
		case TAG_ID.P: {
			pEndTagInBody(p$1);
			break;
		}
		case TAG_ID.DL:
		case TAG_ID.UL:
		case TAG_ID.OL:
		case TAG_ID.DIR:
		case TAG_ID.DIV:
		case TAG_ID.NAV:
		case TAG_ID.PRE:
		case TAG_ID.MAIN:
		case TAG_ID.MENU:
		case TAG_ID.ASIDE:
		case TAG_ID.BUTTON:
		case TAG_ID.CENTER:
		case TAG_ID.FIGURE:
		case TAG_ID.FOOTER:
		case TAG_ID.HEADER:
		case TAG_ID.HGROUP:
		case TAG_ID.DIALOG:
		case TAG_ID.ADDRESS:
		case TAG_ID.ARTICLE:
		case TAG_ID.DETAILS:
		case TAG_ID.SEARCH:
		case TAG_ID.SECTION:
		case TAG_ID.SUMMARY:
		case TAG_ID.LISTING:
		case TAG_ID.FIELDSET:
		case TAG_ID.BLOCKQUOTE:
		case TAG_ID.FIGCAPTION: {
			addressEndTagInBody(p$1, token);
			break;
		}
		case TAG_ID.LI: {
			liEndTagInBody(p$1);
			break;
		}
		case TAG_ID.DD:
		case TAG_ID.DT: {
			ddEndTagInBody(p$1, token);
			break;
		}
		case TAG_ID.H1:
		case TAG_ID.H2:
		case TAG_ID.H3:
		case TAG_ID.H4:
		case TAG_ID.H5:
		case TAG_ID.H6: {
			numberedHeaderEndTagInBody(p$1);
			break;
		}
		case TAG_ID.BR: {
			brEndTagInBody(p$1);
			break;
		}
		case TAG_ID.BODY: {
			bodyEndTagInBody(p$1, token);
			break;
		}
		case TAG_ID.HTML: {
			htmlEndTagInBody(p$1, token);
			break;
		}
		case TAG_ID.FORM: {
			formEndTagInBody(p$1);
			break;
		}
		case TAG_ID.APPLET:
		case TAG_ID.OBJECT:
		case TAG_ID.MARQUEE: {
			appletEndTagInBody(p$1, token);
			break;
		}
		case TAG_ID.TEMPLATE: {
			templateEndTagInHead(p$1, token);
			break;
		}
		default: genericEndTagInBody(p$1, token);
	}
}
function eofInBody(p$1, token) {
	if (p$1.tmplInsertionModeStack.length > 0) eofInTemplate(p$1, token);
	else stopParsing(p$1, token);
}
function endTagInText(p$1, token) {
	var _a$1;
	if (token.tagID === TAG_ID.SCRIPT) (_a$1 = p$1.scriptHandler) === null || _a$1 === void 0 || _a$1.call(p$1, p$1.openElements.current);
	p$1.openElements.pop();
	p$1.insertionMode = p$1.originalInsertionMode;
}
function eofInText(p$1, token) {
	p$1._err(token, ERR.eofInElementThatCanContainOnlyText);
	p$1.openElements.pop();
	p$1.insertionMode = p$1.originalInsertionMode;
	p$1.onEof(token);
}
function characterInTable(p$1, token) {
	if (p$1.openElements.currentTagId !== void 0 && TABLE_STRUCTURE_TAGS.has(p$1.openElements.currentTagId)) {
		p$1.pendingCharacterTokens.length = 0;
		p$1.hasNonWhitespacePendingCharacterToken = false;
		p$1.originalInsertionMode = p$1.insertionMode;
		p$1.insertionMode = InsertionMode.IN_TABLE_TEXT;
		switch (token.type) {
			case TokenType.CHARACTER: {
				characterInTableText(p$1, token);
				break;
			}
			case TokenType.WHITESPACE_CHARACTER: {
				whitespaceCharacterInTableText(p$1, token);
				break;
			}
		}
	} else tokenInTable(p$1, token);
}
function captionStartTagInTable(p$1, token) {
	p$1.openElements.clearBackToTableContext();
	p$1.activeFormattingElements.insertMarker();
	p$1._insertElement(token, NS.HTML);
	p$1.insertionMode = InsertionMode.IN_CAPTION;
}
function colgroupStartTagInTable(p$1, token) {
	p$1.openElements.clearBackToTableContext();
	p$1._insertElement(token, NS.HTML);
	p$1.insertionMode = InsertionMode.IN_COLUMN_GROUP;
}
function colStartTagInTable(p$1, token) {
	p$1.openElements.clearBackToTableContext();
	p$1._insertFakeElement(TAG_NAMES.COLGROUP, TAG_ID.COLGROUP);
	p$1.insertionMode = InsertionMode.IN_COLUMN_GROUP;
	startTagInColumnGroup(p$1, token);
}
function tbodyStartTagInTable(p$1, token) {
	p$1.openElements.clearBackToTableContext();
	p$1._insertElement(token, NS.HTML);
	p$1.insertionMode = InsertionMode.IN_TABLE_BODY;
}
function tdStartTagInTable(p$1, token) {
	p$1.openElements.clearBackToTableContext();
	p$1._insertFakeElement(TAG_NAMES.TBODY, TAG_ID.TBODY);
	p$1.insertionMode = InsertionMode.IN_TABLE_BODY;
	startTagInTableBody(p$1, token);
}
function tableStartTagInTable(p$1, token) {
	if (p$1.openElements.hasInTableScope(TAG_ID.TABLE)) {
		p$1.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
		p$1._resetInsertionMode();
		p$1._processStartTag(token);
	}
}
function inputStartTagInTable(p$1, token) {
	if (isHiddenInput(token)) p$1._appendElement(token, NS.HTML);
	else tokenInTable(p$1, token);
	token.ackSelfClosing = true;
}
function formStartTagInTable(p$1, token) {
	if (!p$1.formElement && p$1.openElements.tmplCount === 0) {
		p$1._insertElement(token, NS.HTML);
		p$1.formElement = p$1.openElements.current;
		p$1.openElements.pop();
	}
}
function startTagInTable(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.TD:
		case TAG_ID.TH:
		case TAG_ID.TR: {
			tdStartTagInTable(p$1, token);
			break;
		}
		case TAG_ID.STYLE:
		case TAG_ID.SCRIPT:
		case TAG_ID.TEMPLATE: {
			startTagInHead(p$1, token);
			break;
		}
		case TAG_ID.COL: {
			colStartTagInTable(p$1, token);
			break;
		}
		case TAG_ID.FORM: {
			formStartTagInTable(p$1, token);
			break;
		}
		case TAG_ID.TABLE: {
			tableStartTagInTable(p$1, token);
			break;
		}
		case TAG_ID.TBODY:
		case TAG_ID.TFOOT:
		case TAG_ID.THEAD: {
			tbodyStartTagInTable(p$1, token);
			break;
		}
		case TAG_ID.INPUT: {
			inputStartTagInTable(p$1, token);
			break;
		}
		case TAG_ID.CAPTION: {
			captionStartTagInTable(p$1, token);
			break;
		}
		case TAG_ID.COLGROUP: {
			colgroupStartTagInTable(p$1, token);
			break;
		}
		default: tokenInTable(p$1, token);
	}
}
function endTagInTable(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.TABLE: {
			if (p$1.openElements.hasInTableScope(TAG_ID.TABLE)) {
				p$1.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
				p$1._resetInsertionMode();
			}
			break;
		}
		case TAG_ID.TEMPLATE: {
			templateEndTagInHead(p$1, token);
			break;
		}
		case TAG_ID.BODY:
		case TAG_ID.CAPTION:
		case TAG_ID.COL:
		case TAG_ID.COLGROUP:
		case TAG_ID.HTML:
		case TAG_ID.TBODY:
		case TAG_ID.TD:
		case TAG_ID.TFOOT:
		case TAG_ID.TH:
		case TAG_ID.THEAD:
		case TAG_ID.TR: break;
		default: tokenInTable(p$1, token);
	}
}
function tokenInTable(p$1, token) {
	const savedFosterParentingState = p$1.fosterParentingEnabled;
	p$1.fosterParentingEnabled = true;
	modeInBody(p$1, token);
	p$1.fosterParentingEnabled = savedFosterParentingState;
}
function whitespaceCharacterInTableText(p$1, token) {
	p$1.pendingCharacterTokens.push(token);
}
function characterInTableText(p$1, token) {
	p$1.pendingCharacterTokens.push(token);
	p$1.hasNonWhitespacePendingCharacterToken = true;
}
function tokenInTableText(p$1, token) {
	let i = 0;
	if (p$1.hasNonWhitespacePendingCharacterToken) for (; i < p$1.pendingCharacterTokens.length; i++) tokenInTable(p$1, p$1.pendingCharacterTokens[i]);
	else for (; i < p$1.pendingCharacterTokens.length; i++) p$1._insertCharacters(p$1.pendingCharacterTokens[i]);
	p$1.insertionMode = p$1.originalInsertionMode;
	p$1._processToken(token);
}
const TABLE_VOID_ELEMENTS = new Set([
	TAG_ID.CAPTION,
	TAG_ID.COL,
	TAG_ID.COLGROUP,
	TAG_ID.TBODY,
	TAG_ID.TD,
	TAG_ID.TFOOT,
	TAG_ID.TH,
	TAG_ID.THEAD,
	TAG_ID.TR
]);
function startTagInCaption(p$1, token) {
	const tn = token.tagID;
	if (TABLE_VOID_ELEMENTS.has(tn)) {
		if (p$1.openElements.hasInTableScope(TAG_ID.CAPTION)) {
			p$1.openElements.generateImpliedEndTags();
			p$1.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
			p$1.activeFormattingElements.clearToLastMarker();
			p$1.insertionMode = InsertionMode.IN_TABLE;
			startTagInTable(p$1, token);
		}
	} else startTagInBody(p$1, token);
}
function endTagInCaption(p$1, token) {
	const tn = token.tagID;
	switch (tn) {
		case TAG_ID.CAPTION:
		case TAG_ID.TABLE: {
			if (p$1.openElements.hasInTableScope(TAG_ID.CAPTION)) {
				p$1.openElements.generateImpliedEndTags();
				p$1.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
				p$1.activeFormattingElements.clearToLastMarker();
				p$1.insertionMode = InsertionMode.IN_TABLE;
				if (tn === TAG_ID.TABLE) endTagInTable(p$1, token);
			}
			break;
		}
		case TAG_ID.BODY:
		case TAG_ID.COL:
		case TAG_ID.COLGROUP:
		case TAG_ID.HTML:
		case TAG_ID.TBODY:
		case TAG_ID.TD:
		case TAG_ID.TFOOT:
		case TAG_ID.TH:
		case TAG_ID.THEAD:
		case TAG_ID.TR: break;
		default: endTagInBody(p$1, token);
	}
}
function startTagInColumnGroup(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.HTML: {
			startTagInBody(p$1, token);
			break;
		}
		case TAG_ID.COL: {
			p$1._appendElement(token, NS.HTML);
			token.ackSelfClosing = true;
			break;
		}
		case TAG_ID.TEMPLATE: {
			startTagInHead(p$1, token);
			break;
		}
		default: tokenInColumnGroup(p$1, token);
	}
}
function endTagInColumnGroup(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.COLGROUP: {
			if (p$1.openElements.currentTagId === TAG_ID.COLGROUP) {
				p$1.openElements.pop();
				p$1.insertionMode = InsertionMode.IN_TABLE;
			}
			break;
		}
		case TAG_ID.TEMPLATE: {
			templateEndTagInHead(p$1, token);
			break;
		}
		case TAG_ID.COL: break;
		default: tokenInColumnGroup(p$1, token);
	}
}
function tokenInColumnGroup(p$1, token) {
	if (p$1.openElements.currentTagId === TAG_ID.COLGROUP) {
		p$1.openElements.pop();
		p$1.insertionMode = InsertionMode.IN_TABLE;
		p$1._processToken(token);
	}
}
function startTagInTableBody(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.TR: {
			p$1.openElements.clearBackToTableBodyContext();
			p$1._insertElement(token, NS.HTML);
			p$1.insertionMode = InsertionMode.IN_ROW;
			break;
		}
		case TAG_ID.TH:
		case TAG_ID.TD: {
			p$1.openElements.clearBackToTableBodyContext();
			p$1._insertFakeElement(TAG_NAMES.TR, TAG_ID.TR);
			p$1.insertionMode = InsertionMode.IN_ROW;
			startTagInRow(p$1, token);
			break;
		}
		case TAG_ID.CAPTION:
		case TAG_ID.COL:
		case TAG_ID.COLGROUP:
		case TAG_ID.TBODY:
		case TAG_ID.TFOOT:
		case TAG_ID.THEAD: {
			if (p$1.openElements.hasTableBodyContextInTableScope()) {
				p$1.openElements.clearBackToTableBodyContext();
				p$1.openElements.pop();
				p$1.insertionMode = InsertionMode.IN_TABLE;
				startTagInTable(p$1, token);
			}
			break;
		}
		default: startTagInTable(p$1, token);
	}
}
function endTagInTableBody(p$1, token) {
	const tn = token.tagID;
	switch (token.tagID) {
		case TAG_ID.TBODY:
		case TAG_ID.TFOOT:
		case TAG_ID.THEAD: {
			if (p$1.openElements.hasInTableScope(tn)) {
				p$1.openElements.clearBackToTableBodyContext();
				p$1.openElements.pop();
				p$1.insertionMode = InsertionMode.IN_TABLE;
			}
			break;
		}
		case TAG_ID.TABLE: {
			if (p$1.openElements.hasTableBodyContextInTableScope()) {
				p$1.openElements.clearBackToTableBodyContext();
				p$1.openElements.pop();
				p$1.insertionMode = InsertionMode.IN_TABLE;
				endTagInTable(p$1, token);
			}
			break;
		}
		case TAG_ID.BODY:
		case TAG_ID.CAPTION:
		case TAG_ID.COL:
		case TAG_ID.COLGROUP:
		case TAG_ID.HTML:
		case TAG_ID.TD:
		case TAG_ID.TH:
		case TAG_ID.TR: break;
		default: endTagInTable(p$1, token);
	}
}
function startTagInRow(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.TH:
		case TAG_ID.TD: {
			p$1.openElements.clearBackToTableRowContext();
			p$1._insertElement(token, NS.HTML);
			p$1.insertionMode = InsertionMode.IN_CELL;
			p$1.activeFormattingElements.insertMarker();
			break;
		}
		case TAG_ID.CAPTION:
		case TAG_ID.COL:
		case TAG_ID.COLGROUP:
		case TAG_ID.TBODY:
		case TAG_ID.TFOOT:
		case TAG_ID.THEAD:
		case TAG_ID.TR: {
			if (p$1.openElements.hasInTableScope(TAG_ID.TR)) {
				p$1.openElements.clearBackToTableRowContext();
				p$1.openElements.pop();
				p$1.insertionMode = InsertionMode.IN_TABLE_BODY;
				startTagInTableBody(p$1, token);
			}
			break;
		}
		default: startTagInTable(p$1, token);
	}
}
function endTagInRow(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.TR: {
			if (p$1.openElements.hasInTableScope(TAG_ID.TR)) {
				p$1.openElements.clearBackToTableRowContext();
				p$1.openElements.pop();
				p$1.insertionMode = InsertionMode.IN_TABLE_BODY;
			}
			break;
		}
		case TAG_ID.TABLE: {
			if (p$1.openElements.hasInTableScope(TAG_ID.TR)) {
				p$1.openElements.clearBackToTableRowContext();
				p$1.openElements.pop();
				p$1.insertionMode = InsertionMode.IN_TABLE_BODY;
				endTagInTableBody(p$1, token);
			}
			break;
		}
		case TAG_ID.TBODY:
		case TAG_ID.TFOOT:
		case TAG_ID.THEAD: {
			if (p$1.openElements.hasInTableScope(token.tagID) || p$1.openElements.hasInTableScope(TAG_ID.TR)) {
				p$1.openElements.clearBackToTableRowContext();
				p$1.openElements.pop();
				p$1.insertionMode = InsertionMode.IN_TABLE_BODY;
				endTagInTableBody(p$1, token);
			}
			break;
		}
		case TAG_ID.BODY:
		case TAG_ID.CAPTION:
		case TAG_ID.COL:
		case TAG_ID.COLGROUP:
		case TAG_ID.HTML:
		case TAG_ID.TD:
		case TAG_ID.TH: break;
		default: endTagInTable(p$1, token);
	}
}
function startTagInCell(p$1, token) {
	const tn = token.tagID;
	if (TABLE_VOID_ELEMENTS.has(tn)) {
		if (p$1.openElements.hasInTableScope(TAG_ID.TD) || p$1.openElements.hasInTableScope(TAG_ID.TH)) {
			p$1._closeTableCell();
			startTagInRow(p$1, token);
		}
	} else startTagInBody(p$1, token);
}
function endTagInCell(p$1, token) {
	const tn = token.tagID;
	switch (tn) {
		case TAG_ID.TD:
		case TAG_ID.TH: {
			if (p$1.openElements.hasInTableScope(tn)) {
				p$1.openElements.generateImpliedEndTags();
				p$1.openElements.popUntilTagNamePopped(tn);
				p$1.activeFormattingElements.clearToLastMarker();
				p$1.insertionMode = InsertionMode.IN_ROW;
			}
			break;
		}
		case TAG_ID.TABLE:
		case TAG_ID.TBODY:
		case TAG_ID.TFOOT:
		case TAG_ID.THEAD:
		case TAG_ID.TR: {
			if (p$1.openElements.hasInTableScope(tn)) {
				p$1._closeTableCell();
				endTagInRow(p$1, token);
			}
			break;
		}
		case TAG_ID.BODY:
		case TAG_ID.CAPTION:
		case TAG_ID.COL:
		case TAG_ID.COLGROUP:
		case TAG_ID.HTML: break;
		default: endTagInBody(p$1, token);
	}
}
function startTagInSelect(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.HTML: {
			startTagInBody(p$1, token);
			break;
		}
		case TAG_ID.OPTION: {
			if (p$1.openElements.currentTagId === TAG_ID.OPTION) p$1.openElements.pop();
			p$1._insertElement(token, NS.HTML);
			break;
		}
		case TAG_ID.OPTGROUP: {
			if (p$1.openElements.currentTagId === TAG_ID.OPTION) p$1.openElements.pop();
			if (p$1.openElements.currentTagId === TAG_ID.OPTGROUP) p$1.openElements.pop();
			p$1._insertElement(token, NS.HTML);
			break;
		}
		case TAG_ID.HR: {
			if (p$1.openElements.currentTagId === TAG_ID.OPTION) p$1.openElements.pop();
			if (p$1.openElements.currentTagId === TAG_ID.OPTGROUP) p$1.openElements.pop();
			p$1._appendElement(token, NS.HTML);
			token.ackSelfClosing = true;
			break;
		}
		case TAG_ID.INPUT:
		case TAG_ID.KEYGEN:
		case TAG_ID.TEXTAREA:
		case TAG_ID.SELECT: {
			if (p$1.openElements.hasInSelectScope(TAG_ID.SELECT)) {
				p$1.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
				p$1._resetInsertionMode();
				if (token.tagID !== TAG_ID.SELECT) p$1._processStartTag(token);
			}
			break;
		}
		case TAG_ID.SCRIPT:
		case TAG_ID.TEMPLATE: {
			startTagInHead(p$1, token);
			break;
		}
		default:
	}
}
function endTagInSelect(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.OPTGROUP: {
			if (p$1.openElements.stackTop > 0 && p$1.openElements.currentTagId === TAG_ID.OPTION && p$1.openElements.tagIDs[p$1.openElements.stackTop - 1] === TAG_ID.OPTGROUP) p$1.openElements.pop();
			if (p$1.openElements.currentTagId === TAG_ID.OPTGROUP) p$1.openElements.pop();
			break;
		}
		case TAG_ID.OPTION: {
			if (p$1.openElements.currentTagId === TAG_ID.OPTION) p$1.openElements.pop();
			break;
		}
		case TAG_ID.SELECT: {
			if (p$1.openElements.hasInSelectScope(TAG_ID.SELECT)) {
				p$1.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
				p$1._resetInsertionMode();
			}
			break;
		}
		case TAG_ID.TEMPLATE: {
			templateEndTagInHead(p$1, token);
			break;
		}
		default:
	}
}
function startTagInSelectInTable(p$1, token) {
	const tn = token.tagID;
	if (tn === TAG_ID.CAPTION || tn === TAG_ID.TABLE || tn === TAG_ID.TBODY || tn === TAG_ID.TFOOT || tn === TAG_ID.THEAD || tn === TAG_ID.TR || tn === TAG_ID.TD || tn === TAG_ID.TH) {
		p$1.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
		p$1._resetInsertionMode();
		p$1._processStartTag(token);
	} else startTagInSelect(p$1, token);
}
function endTagInSelectInTable(p$1, token) {
	const tn = token.tagID;
	if (tn === TAG_ID.CAPTION || tn === TAG_ID.TABLE || tn === TAG_ID.TBODY || tn === TAG_ID.TFOOT || tn === TAG_ID.THEAD || tn === TAG_ID.TR || tn === TAG_ID.TD || tn === TAG_ID.TH) {
		if (p$1.openElements.hasInTableScope(tn)) {
			p$1.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
			p$1._resetInsertionMode();
			p$1.onEndTag(token);
		}
	} else endTagInSelect(p$1, token);
}
function startTagInTemplate(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.BASE:
		case TAG_ID.BASEFONT:
		case TAG_ID.BGSOUND:
		case TAG_ID.LINK:
		case TAG_ID.META:
		case TAG_ID.NOFRAMES:
		case TAG_ID.SCRIPT:
		case TAG_ID.STYLE:
		case TAG_ID.TEMPLATE:
		case TAG_ID.TITLE: {
			startTagInHead(p$1, token);
			break;
		}
		case TAG_ID.CAPTION:
		case TAG_ID.COLGROUP:
		case TAG_ID.TBODY:
		case TAG_ID.TFOOT:
		case TAG_ID.THEAD: {
			p$1.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE;
			p$1.insertionMode = InsertionMode.IN_TABLE;
			startTagInTable(p$1, token);
			break;
		}
		case TAG_ID.COL: {
			p$1.tmplInsertionModeStack[0] = InsertionMode.IN_COLUMN_GROUP;
			p$1.insertionMode = InsertionMode.IN_COLUMN_GROUP;
			startTagInColumnGroup(p$1, token);
			break;
		}
		case TAG_ID.TR: {
			p$1.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE_BODY;
			p$1.insertionMode = InsertionMode.IN_TABLE_BODY;
			startTagInTableBody(p$1, token);
			break;
		}
		case TAG_ID.TD:
		case TAG_ID.TH: {
			p$1.tmplInsertionModeStack[0] = InsertionMode.IN_ROW;
			p$1.insertionMode = InsertionMode.IN_ROW;
			startTagInRow(p$1, token);
			break;
		}
		default: {
			p$1.tmplInsertionModeStack[0] = InsertionMode.IN_BODY;
			p$1.insertionMode = InsertionMode.IN_BODY;
			startTagInBody(p$1, token);
		}
	}
}
function endTagInTemplate(p$1, token) {
	if (token.tagID === TAG_ID.TEMPLATE) templateEndTagInHead(p$1, token);
}
function eofInTemplate(p$1, token) {
	if (p$1.openElements.tmplCount > 0) {
		p$1.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
		p$1.activeFormattingElements.clearToLastMarker();
		p$1.tmplInsertionModeStack.shift();
		p$1._resetInsertionMode();
		p$1.onEof(token);
	} else stopParsing(p$1, token);
}
function startTagAfterBody(p$1, token) {
	if (token.tagID === TAG_ID.HTML) startTagInBody(p$1, token);
	else tokenAfterBody(p$1, token);
}
function endTagAfterBody(p$1, token) {
	var _a$1;
	if (token.tagID === TAG_ID.HTML) {
		if (!p$1.fragmentContext) p$1.insertionMode = InsertionMode.AFTER_AFTER_BODY;
		if (p$1.options.sourceCodeLocationInfo && p$1.openElements.tagIDs[0] === TAG_ID.HTML) {
			p$1._setEndLocation(p$1.openElements.items[0], token);
			const bodyElement = p$1.openElements.items[1];
			if (bodyElement && !((_a$1 = p$1.treeAdapter.getNodeSourceCodeLocation(bodyElement)) === null || _a$1 === void 0 ? void 0 : _a$1.endTag)) p$1._setEndLocation(bodyElement, token);
		}
	} else tokenAfterBody(p$1, token);
}
function tokenAfterBody(p$1, token) {
	p$1.insertionMode = InsertionMode.IN_BODY;
	modeInBody(p$1, token);
}
function startTagInFrameset(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.HTML: {
			startTagInBody(p$1, token);
			break;
		}
		case TAG_ID.FRAMESET: {
			p$1._insertElement(token, NS.HTML);
			break;
		}
		case TAG_ID.FRAME: {
			p$1._appendElement(token, NS.HTML);
			token.ackSelfClosing = true;
			break;
		}
		case TAG_ID.NOFRAMES: {
			startTagInHead(p$1, token);
			break;
		}
		default:
	}
}
function endTagInFrameset(p$1, token) {
	if (token.tagID === TAG_ID.FRAMESET && !p$1.openElements.isRootHtmlElementCurrent()) {
		p$1.openElements.pop();
		if (!p$1.fragmentContext && p$1.openElements.currentTagId !== TAG_ID.FRAMESET) p$1.insertionMode = InsertionMode.AFTER_FRAMESET;
	}
}
function startTagAfterFrameset(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.HTML: {
			startTagInBody(p$1, token);
			break;
		}
		case TAG_ID.NOFRAMES: {
			startTagInHead(p$1, token);
			break;
		}
		default:
	}
}
function endTagAfterFrameset(p$1, token) {
	if (token.tagID === TAG_ID.HTML) p$1.insertionMode = InsertionMode.AFTER_AFTER_FRAMESET;
}
function startTagAfterAfterBody(p$1, token) {
	if (token.tagID === TAG_ID.HTML) startTagInBody(p$1, token);
	else tokenAfterAfterBody(p$1, token);
}
function tokenAfterAfterBody(p$1, token) {
	p$1.insertionMode = InsertionMode.IN_BODY;
	modeInBody(p$1, token);
}
function startTagAfterAfterFrameset(p$1, token) {
	switch (token.tagID) {
		case TAG_ID.HTML: {
			startTagInBody(p$1, token);
			break;
		}
		case TAG_ID.NOFRAMES: {
			startTagInHead(p$1, token);
			break;
		}
		default:
	}
}
function nullCharacterInForeignContent(p$1, token) {
	token.chars = REPLACEMENT_CHARACTER;
	p$1._insertCharacters(token);
}
function characterInForeignContent(p$1, token) {
	p$1._insertCharacters(token);
	p$1.framesetOk = false;
}
function popUntilHtmlOrIntegrationPoint(p$1) {
	while (p$1.treeAdapter.getNamespaceURI(p$1.openElements.current) !== NS.HTML && p$1.openElements.currentTagId !== void 0 && !p$1._isIntegrationPoint(p$1.openElements.currentTagId, p$1.openElements.current)) p$1.openElements.pop();
}
function startTagInForeignContent(p$1, token) {
	if (causesExit(token)) {
		popUntilHtmlOrIntegrationPoint(p$1);
		p$1._startTagOutsideForeignContent(token);
	} else {
		const current = p$1._getAdjustedCurrentElement();
		const currentNs = p$1.treeAdapter.getNamespaceURI(current);
		if (currentNs === NS.MATHML) adjustTokenMathMLAttrs(token);
		else if (currentNs === NS.SVG) {
			adjustTokenSVGTagName(token);
			adjustTokenSVGAttrs(token);
		}
		adjustTokenXMLAttrs(token);
		if (token.selfClosing) p$1._appendElement(token, currentNs);
		else p$1._insertElement(token, currentNs);
		token.ackSelfClosing = true;
	}
}
function endTagInForeignContent(p$1, token) {
	if (token.tagID === TAG_ID.P || token.tagID === TAG_ID.BR) {
		popUntilHtmlOrIntegrationPoint(p$1);
		p$1._endTagOutsideForeignContent(token);
		return;
	}
	for (let i = p$1.openElements.stackTop; i > 0; i--) {
		const element$5 = p$1.openElements.items[i];
		if (p$1.treeAdapter.getNamespaceURI(element$5) === NS.HTML) {
			p$1._endTagOutsideForeignContent(token);
			break;
		}
		const tagName = p$1.treeAdapter.getTagName(element$5);
		if (tagName.toLowerCase() === token.tagName) {
			token.tagName = tagName;
			p$1.openElements.shortenToLength(i);
			break;
		}
	}
}
const VOID_ELEMENTS = new Set([
	TAG_NAMES.AREA,
	TAG_NAMES.BASE,
	TAG_NAMES.BASEFONT,
	TAG_NAMES.BGSOUND,
	TAG_NAMES.BR,
	TAG_NAMES.COL,
	TAG_NAMES.EMBED,
	TAG_NAMES.FRAME,
	TAG_NAMES.HR,
	TAG_NAMES.IMG,
	TAG_NAMES.INPUT,
	TAG_NAMES.KEYGEN,
	TAG_NAMES.LINK,
	TAG_NAMES.META,
	TAG_NAMES.PARAM,
	TAG_NAMES.SOURCE,
	TAG_NAMES.TRACK,
	TAG_NAMES.WBR
]);
const pointEnd = point$2("end");
const pointStart = point$2("start");
function point$2(type) {
	return point$4;
	function point$4(node$1) {
		const point$5 = node$1 && node$1.position && node$1.position[type] || {};
		if (typeof point$5.line === "number" && point$5.line > 0 && typeof point$5.column === "number" && point$5.column > 0) return {
			line: point$5.line,
			column: point$5.column,
			offset: typeof point$5.offset === "number" && point$5.offset > -1 ? point$5.offset : void 0
		};
	}
}
function position(node$1) {
	const start = pointStart(node$1);
	const end = pointEnd(node$1);
	if (start && end) return {
		start,
		end
	};
}
const gfmTagfilterExpression = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\t\n\f\r />])/gi;
const knownMdxNames = new Set([
	"mdxFlowExpression",
	"mdxJsxFlowElement",
	"mdxJsxTextElement",
	"mdxTextExpression",
	"mdxjsEsm"
]);
const parseOptions = {
	sourceCodeLocationInfo: true,
	scriptingEnabled: false
};
function raw(tree, options) {
	const document$3 = documentMode(tree);
	const one$6 = zwitch("type", {
		handlers: {
			root: root$3,
			element: element$2,
			text: text$6,
			comment,
			doctype,
			raw: handleRaw
		},
		unknown
	});
	const state = {
		parser: document$3 ? new Parser(parseOptions) : Parser.getFragmentParser(void 0, parseOptions),
		handle(node$1) {
			one$6(node$1, state);
		},
		stitches: false,
		options: options || {}
	};
	one$6(tree, state);
	resetTokenizer(state, pointStart());
	const p5 = document$3 ? state.parser.document : state.parser.getFragment();
	const result = fromParse5(p5, { file: state.options.file });
	if (state.stitches) visit(result, "comment", function(node$1, index$1, parent$1) {
		const stitch$1 = node$1;
		if (stitch$1.value.stitch && parent$1 && index$1 !== void 0) {
			const siblings = parent$1.children;
			siblings[index$1] = stitch$1.value.stitch;
			return index$1;
		}
	});
	if (result.type === "root" && result.children.length === 1 && result.children[0].type === tree.type) return result.children[0];
	return result;
}
function all$1(nodes, state) {
	let index$1 = -1;
	if (nodes) while (++index$1 < nodes.length) state.handle(nodes[index$1]);
}
function root$3(node$1, state) {
	all$1(node$1.children, state);
}
function element$2(node$1, state) {
	startTag(node$1, state);
	all$1(node$1.children, state);
	endTag(node$1, state);
}
function text$6(node$1, state) {
	if (state.parser.tokenizer.state > 4) state.parser.tokenizer.state = 0;
	const token = {
		type: TokenType.CHARACTER,
		chars: node$1.value,
		location: createParse5Location(node$1)
	};
	resetTokenizer(state, pointStart(node$1));
	state.parser.currentToken = token;
	state.parser._processToken(state.parser.currentToken);
}
function doctype(node$1, state) {
	const token = {
		type: TokenType.DOCTYPE,
		name: "html",
		forceQuirks: false,
		publicId: "",
		systemId: "",
		location: createParse5Location(node$1)
	};
	resetTokenizer(state, pointStart(node$1));
	state.parser.currentToken = token;
	state.parser._processToken(state.parser.currentToken);
}
function stitch(node$1, state) {
	state.stitches = true;
	const clone$1 = cloneWithoutChildren(node$1);
	if ("children" in node$1 && "children" in clone$1) {
		const fakeRoot = raw({
			type: "root",
			children: node$1.children
		}, state.options);
		clone$1.children = fakeRoot.children;
	}
	comment({
		type: "comment",
		value: { stitch: clone$1 }
	}, state);
}
function comment(node$1, state) {
	const data = node$1.value;
	const token = {
		type: TokenType.COMMENT,
		data,
		location: createParse5Location(node$1)
	};
	resetTokenizer(state, pointStart(node$1));
	state.parser.currentToken = token;
	state.parser._processToken(state.parser.currentToken);
}
function handleRaw(node$1, state) {
	state.parser.tokenizer.preprocessor.html = "";
	state.parser.tokenizer.preprocessor.pos = -1;
	state.parser.tokenizer.preprocessor.lastGapPos = -2;
	state.parser.tokenizer.preprocessor.gapStack = [];
	state.parser.tokenizer.preprocessor.skipNextNewLine = false;
	state.parser.tokenizer.preprocessor.lastChunkWritten = false;
	state.parser.tokenizer.preprocessor.endOfChunkHit = false;
	state.parser.tokenizer.preprocessor.isEol = false;
	setPoint(state, pointStart(node$1));
	state.parser.tokenizer.write(state.options.tagfilter ? node$1.value.replace(gfmTagfilterExpression, "&lt;$1$2") : node$1.value, false);
	state.parser.tokenizer._runParsingLoop();
	if (state.parser.tokenizer.state === 72 || state.parser.tokenizer.state === 78) {
		state.parser.tokenizer.preprocessor.lastChunkWritten = true;
		const cp = state.parser.tokenizer._consume();
		state.parser.tokenizer._callState(cp);
	}
}
function unknown(node_, state) {
	const node$1 = node_;
	if (state.options.passThrough && state.options.passThrough.includes(node$1.type)) stitch(node$1, state);
	else {
		let extra = "";
		if (knownMdxNames.has(node$1.type)) extra = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax";
		throw new Error("Cannot compile `" + node$1.type + "` node" + extra);
	}
}
function resetTokenizer(state, point$4) {
	setPoint(state, point$4);
	const token = state.parser.tokenizer.currentCharacterToken;
	if (token && token.location) {
		token.location.endLine = state.parser.tokenizer.preprocessor.line;
		token.location.endCol = state.parser.tokenizer.preprocessor.col + 1;
		token.location.endOffset = state.parser.tokenizer.preprocessor.offset + 1;
		state.parser.currentToken = token;
		state.parser._processToken(state.parser.currentToken);
	}
	state.parser.tokenizer.paused = false;
	state.parser.tokenizer.inLoop = false;
	state.parser.tokenizer.active = false;
	state.parser.tokenizer.returnState = TokenizerMode.DATA;
	state.parser.tokenizer.charRefCode = -1;
	state.parser.tokenizer.consumedAfterSnapshot = -1;
	state.parser.tokenizer.currentLocation = null;
	state.parser.tokenizer.currentCharacterToken = null;
	state.parser.tokenizer.currentToken = null;
	state.parser.tokenizer.currentAttr = {
		name: "",
		value: ""
	};
}
function setPoint(state, point$4) {
	if (point$4 && point$4.offset !== void 0) {
		const location$1 = {
			startLine: point$4.line,
			startCol: point$4.column,
			startOffset: point$4.offset,
			endLine: -1,
			endCol: -1,
			endOffset: -1
		};
		state.parser.tokenizer.preprocessor.lineStartPos = -point$4.column + 1;
		state.parser.tokenizer.preprocessor.droppedBufferSize = point$4.offset;
		state.parser.tokenizer.preprocessor.line = point$4.line;
		state.parser.tokenizer.currentLocation = location$1;
	}
}
function startTag(node$1, state) {
	const tagName = node$1.tagName.toLowerCase();
	if (state.parser.tokenizer.state === TokenizerMode.PLAINTEXT) return;
	resetTokenizer(state, pointStart(node$1));
	const current = state.parser.openElements.current;
	let ns = "namespaceURI" in current ? current.namespaceURI : webNamespaces.html;
	if (ns === webNamespaces.html && tagName === "svg") ns = webNamespaces.svg;
	const result = toParse5({
		...node$1,
		children: []
	}, { space: ns === webNamespaces.svg ? "svg" : "html" });
	const tag = {
		type: TokenType.START_TAG,
		tagName,
		tagID: getTagID(tagName),
		selfClosing: false,
		ackSelfClosing: false,
		attrs: "attrs" in result ? result.attrs : [],
		location: createParse5Location(node$1)
	};
	state.parser.currentToken = tag;
	state.parser._processToken(state.parser.currentToken);
	state.parser.tokenizer.lastStartTagName = tagName;
}
function endTag(node$1, state) {
	const tagName = node$1.tagName.toLowerCase();
	if (!state.parser.tokenizer.inForeignNode && htmlVoidElements.includes(tagName)) return;
	if (state.parser.tokenizer.state === TokenizerMode.PLAINTEXT) return;
	resetTokenizer(state, pointEnd(node$1));
	const tag = {
		type: TokenType.END_TAG,
		tagName,
		tagID: getTagID(tagName),
		selfClosing: false,
		ackSelfClosing: false,
		attrs: [],
		location: createParse5Location(node$1)
	};
	state.parser.currentToken = tag;
	state.parser._processToken(state.parser.currentToken);
	if (tagName === state.parser.tokenizer.lastStartTagName && (state.parser.tokenizer.state === TokenizerMode.RCDATA || state.parser.tokenizer.state === TokenizerMode.RAWTEXT || state.parser.tokenizer.state === TokenizerMode.SCRIPT_DATA)) state.parser.tokenizer.state = TokenizerMode.DATA;
}
function documentMode(node$1) {
	const head = node$1.type === "root" ? node$1.children[0] : node$1;
	return Boolean(head && (head.type === "doctype" || head.type === "element" && head.tagName.toLowerCase() === "html"));
}
function createParse5Location(node$1) {
	const start = pointStart(node$1) || {
		line: void 0,
		column: void 0,
		offset: void 0
	};
	const end = pointEnd(node$1) || {
		line: void 0,
		column: void 0,
		offset: void 0
	};
	const location$1 = {
		startLine: start.line,
		startCol: start.column,
		startOffset: start.offset,
		endLine: end.line,
		endCol: end.column,
		endOffset: end.offset
	};
	return location$1;
}
function cloneWithoutChildren(node$1) {
	return "children" in node$1 ? esm_default$1({
		...node$1,
		children: []
	}) : esm_default$1(node$1);
}
function rehypeRaw(options) {
	return function(tree, file) {
		const result = raw(tree, {
			...options,
			file
		});
		return result;
	};
}
const nameRe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
const nameReJsx = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
const emptyOptions$5 = {};
function name(name$2, options) {
	const settings = options || emptyOptions$5;
	const re$1 = settings.jsx ? nameReJsx : nameRe;
	return re$1.test(name$2);
}
var require_inline_style_parser = __commonJSMin((exports, module) => {
	var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
	var NEWLINE_REGEX = /\n/g;
	var WHITESPACE_REGEX = /^\s*/;
	var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
	var COLON_REGEX = /^:\s*/;
	var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
	var SEMICOLON_REGEX = /^[;\s]*/;
	var TRIM_REGEX = /^\s+|\s+$/g;
	var NEWLINE = "\n";
	var FORWARD_SLASH = "/";
	var ASTERISK = "*";
	var EMPTY_STRING = "";
	var TYPE_COMMENT = "comment";
	var TYPE_DECLARATION = "declaration";
	module.exports = function(style$2, options) {
		if (typeof style$2 !== "string") throw new TypeError("First argument must be a string");
		if (!style$2) return [];
		options = options || {};
		var lineno = 1;
		var column = 1;
		function updatePosition(str) {
			var lines = str.match(NEWLINE_REGEX);
			if (lines) lineno += lines.length;
			var i = str.lastIndexOf(NEWLINE);
			column = ~i ? str.length - i : column + str.length;
		}
		function position$3() {
			var start = {
				line: lineno,
				column
			};
			return function(node$1) {
				node$1.position = new Position(start);
				whitespace$2();
				return node$1;
			};
		}
		function Position(start) {
			this.start = start;
			this.end = {
				line: lineno,
				column
			};
			this.source = options.source;
		}
		Position.prototype.content = style$2;
		var errorsList = [];
		function error(msg) {
			var err = new Error(options.source + ":" + lineno + ":" + column + ": " + msg);
			err.reason = msg;
			err.filename = options.source;
			err.line = lineno;
			err.column = column;
			err.source = style$2;
			if (options.silent) errorsList.push(err);
			else throw err;
		}
		function match(re$1) {
			var m = re$1.exec(style$2);
			if (!m) return;
			var str = m[0];
			updatePosition(str);
			style$2 = style$2.slice(str.length);
			return m;
		}
		function whitespace$2() {
			match(WHITESPACE_REGEX);
		}
		function comments(rules) {
			var c$2;
			rules = rules || [];
			while (c$2 = comment$2()) if (c$2 !== false) rules.push(c$2);
			return rules;
		}
		function comment$2() {
			var pos = position$3();
			if (FORWARD_SLASH != style$2.charAt(0) || ASTERISK != style$2.charAt(1)) return;
			var i = 2;
			while (EMPTY_STRING != style$2.charAt(i) && (ASTERISK != style$2.charAt(i) || FORWARD_SLASH != style$2.charAt(i + 1))) ++i;
			i += 2;
			if (EMPTY_STRING === style$2.charAt(i - 1)) return error("End of comment missing");
			var str = style$2.slice(2, i - 2);
			column += 2;
			updatePosition(str);
			style$2 = style$2.slice(i);
			column += 2;
			return pos({
				type: TYPE_COMMENT,
				comment: str
			});
		}
		function declaration() {
			var pos = position$3();
			var prop = match(PROPERTY_REGEX);
			if (!prop) return;
			comment$2();
			if (!match(COLON_REGEX)) return error("property missing ':'");
			var val = match(VALUE_REGEX);
			var ret = pos({
				type: TYPE_DECLARATION,
				property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
				value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
			});
			match(SEMICOLON_REGEX);
			return ret;
		}
		function declarations() {
			var decls = [];
			comments(decls);
			var decl;
			while (decl = declaration()) if (decl !== false) {
				decls.push(decl);
				comments(decls);
			}
			return decls;
		}
		whitespace$2();
		return declarations();
	};
	function trim(str) {
		return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
	}
});
var require_cjs$1 = __commonJSMin((exports) => {
	var __importDefault$1 = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = StyleToObject;
	var inline_style_parser_1 = __importDefault$1(require_inline_style_parser());
	function StyleToObject(style$2, iterator) {
		var styleObject = null;
		if (!style$2 || typeof style$2 !== "string") return styleObject;
		var declarations = (0, inline_style_parser_1.default)(style$2);
		var hasIterator = typeof iterator === "function";
		declarations.forEach(function(declaration) {
			if (declaration.type !== "declaration") return;
			var property = declaration.property, value = declaration.value;
			if (hasIterator) iterator(property, value, declaration);
			else if (value) {
				styleObject = styleObject || {};
				styleObject[property] = value;
			}
		});
		return styleObject;
	}
});
var require_utilities = __commonJSMin((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var CUSTOM_PROPERTY_REGEX = /^--[a-zA-Z0-9_-]+$/;
	var HYPHEN_REGEX = /-([a-z])/g;
	var NO_HYPHEN_REGEX = /^[^-]+$/;
	var VENDOR_PREFIX_REGEX = /^-(webkit|moz|ms|o|khtml)-/;
	var MS_VENDOR_PREFIX_REGEX = /^-(ms)-/;
	var skipCamelCase = function(property) {
		return !property || NO_HYPHEN_REGEX.test(property) || CUSTOM_PROPERTY_REGEX.test(property);
	};
	var capitalize = function(match, character) {
		return character.toUpperCase();
	};
	var trimHyphen = function(match, prefix) {
		return "".concat(prefix, "-");
	};
	var camelCase = function(property, options) {
		if (options === void 0) options = {};
		if (skipCamelCase(property)) return property;
		property = property.toLowerCase();
		if (options.reactCompat) property = property.replace(MS_VENDOR_PREFIX_REGEX, trimHyphen);
		else property = property.replace(VENDOR_PREFIX_REGEX, trimHyphen);
		return property.replace(HYPHEN_REGEX, capitalize);
	};
	exports.camelCase = camelCase;
});
var require_cjs = __commonJSMin((exports, module) => {
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	var style_to_object_1 = __importDefault(require_cjs$1());
	var utilities_1 = require_utilities();
	function StyleToJS(style$2, options) {
		var output = {};
		if (!style$2 || typeof style$2 !== "string") return output;
		(0, style_to_object_1.default)(style$2, function(property, value) {
			if (property && value) output[(0, utilities_1.camelCase)(property, options)] = value;
		});
		return output;
	}
	StyleToJS.default = StyleToJS;
	module.exports = StyleToJS;
});
function stringifyPosition(value) {
	if (!value || typeof value !== "object") return "";
	if ("position" in value || "type" in value) return position$1(value.position);
	if ("start" in value || "end" in value) return position$1(value);
	if ("line" in value || "column" in value) return point$1(value);
	return "";
}
function point$1(point$4) {
	return index(point$4 && point$4.line) + ":" + index(point$4 && point$4.column);
}
function position$1(pos) {
	return point$1(pos && pos.start) + "-" + point$1(pos && pos.end);
}
function index(value) {
	return value && typeof value === "number" ? value : 1;
}
var VFileMessage = class extends Error {
	constructor(causeOrReason, optionsOrParentOrPlace, origin) {
		super();
		if (typeof optionsOrParentOrPlace === "string") {
			origin = optionsOrParentOrPlace;
			optionsOrParentOrPlace = void 0;
		}
		let reason$1 = "";
		let options = {};
		let legacyCause = false;
		if (optionsOrParentOrPlace) if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) options = { place: optionsOrParentOrPlace };
		else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) options = { place: optionsOrParentOrPlace };
		else if ("type" in optionsOrParentOrPlace) options = {
			ancestors: [optionsOrParentOrPlace],
			place: optionsOrParentOrPlace.position
		};
		else options = { ...optionsOrParentOrPlace };
		if (typeof causeOrReason === "string") reason$1 = causeOrReason;
		else if (!options.cause && causeOrReason) {
			legacyCause = true;
			reason$1 = causeOrReason.message;
			options.cause = causeOrReason;
		}
		if (!options.ruleId && !options.source && typeof origin === "string") {
			const index$1 = origin.indexOf(":");
			if (index$1 === -1) options.ruleId = origin;
			else {
				options.source = origin.slice(0, index$1);
				options.ruleId = origin.slice(index$1 + 1);
			}
		}
		if (!options.place && options.ancestors && options.ancestors) {
			const parent$1 = options.ancestors[options.ancestors.length - 1];
			if (parent$1) options.place = parent$1.position;
		}
		const start = options.place && "start" in options.place ? options.place.start : options.place;
		this.ancestors = options.ancestors || void 0;
		this.cause = options.cause || void 0;
		this.column = start ? start.column : void 0;
		this.fatal = void 0;
		this.file = "";
		this.message = reason$1;
		this.line = start ? start.line : void 0;
		this.name = stringifyPosition(options.place) || "1:1";
		this.place = options.place || void 0;
		this.reason = this.message;
		this.ruleId = options.ruleId || void 0;
		this.source = options.source || void 0;
		this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
		this.actual = void 0;
		this.expected = void 0;
		this.note = void 0;
		this.url = void 0;
	}
};
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = void 0;
VFileMessage.prototype.line = void 0;
VFileMessage.prototype.ancestors = void 0;
VFileMessage.prototype.cause = void 0;
VFileMessage.prototype.fatal = void 0;
VFileMessage.prototype.place = void 0;
VFileMessage.prototype.ruleId = void 0;
VFileMessage.prototype.source = void 0;
var import_cjs = __toESM(require_cjs());
const own$4 = {}.hasOwnProperty;
const emptyMap = new Map();
const cap = /[A-Z]/g;
const tableElements = new Set([
	"table",
	"tbody",
	"thead",
	"tfoot",
	"tr"
]);
const tableCellElement = new Set(["td", "th"]);
const docs = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function toJsxRuntime(tree, options) {
	if (!options || options.Fragment === void 0) throw new TypeError("Expected `Fragment` in options");
	const filePath = options.filePath || void 0;
	let create$3;
	if (options.development) {
		if (typeof options.jsxDEV !== "function") throw new TypeError("Expected `jsxDEV` in options when `development: true`");
		create$3 = developmentCreate(filePath, options.jsxDEV);
	} else {
		if (typeof options.jsx !== "function") throw new TypeError("Expected `jsx` in production options");
		if (typeof options.jsxs !== "function") throw new TypeError("Expected `jsxs` in production options");
		create$3 = productionCreate(filePath, options.jsx, options.jsxs);
	}
	const state = {
		Fragment: options.Fragment,
		ancestors: [],
		components: options.components || {},
		create: create$3,
		elementAttributeNameCase: options.elementAttributeNameCase || "react",
		evaluater: options.createEvaluater ? options.createEvaluater() : void 0,
		filePath,
		ignoreInvalidStyle: options.ignoreInvalidStyle || false,
		passKeys: options.passKeys !== false,
		passNode: options.passNode || false,
		schema: options.space === "svg" ? svg : html$2,
		stylePropertyNameCase: options.stylePropertyNameCase || "dom",
		tableCellAlignToStyle: options.tableCellAlignToStyle !== false
	};
	const result = one$1(state, tree, void 0);
	if (result && typeof result !== "string") return result;
	return state.create(tree, state.Fragment, { children: result || void 0 }, void 0);
}
function one$1(state, node$1, key) {
	if (node$1.type === "element") return element$1(state, node$1, key);
	if (node$1.type === "mdxFlowExpression" || node$1.type === "mdxTextExpression") return mdxExpression(state, node$1);
	if (node$1.type === "mdxJsxFlowElement" || node$1.type === "mdxJsxTextElement") return mdxJsxElement(state, node$1, key);
	if (node$1.type === "mdxjsEsm") return mdxEsm(state, node$1);
	if (node$1.type === "root") return root$2(state, node$1, key);
	if (node$1.type === "text") return text$5(state, node$1);
}
function element$1(state, node$1, key) {
	const parentSchema = state.schema;
	let schema = parentSchema;
	if (node$1.tagName.toLowerCase() === "svg" && parentSchema.space === "html") {
		schema = svg;
		state.schema = schema;
	}
	state.ancestors.push(node$1);
	const type = findComponentFromName(state, node$1.tagName, false);
	const props = createElementProps(state, node$1);
	let children = createChildren(state, node$1);
	if (tableElements.has(node$1.tagName)) children = children.filter(function(child) {
		return typeof child === "string" ? !whitespace(child) : true;
	});
	addNode(state, props, type, node$1);
	addChildren(props, children);
	state.ancestors.pop();
	state.schema = parentSchema;
	return state.create(node$1, type, props, key);
}
function mdxExpression(state, node$1) {
	if (node$1.data && node$1.data.estree && state.evaluater) {
		const program = node$1.data.estree;
		const expression = program.body[0];
		ok(expression.type === "ExpressionStatement");
		return state.evaluater.evaluateExpression(expression.expression);
	}
	crashEstree(state, node$1.position);
}
function mdxEsm(state, node$1) {
	if (node$1.data && node$1.data.estree && state.evaluater) return state.evaluater.evaluateProgram(node$1.data.estree);
	crashEstree(state, node$1.position);
}
function mdxJsxElement(state, node$1, key) {
	const parentSchema = state.schema;
	let schema = parentSchema;
	if (node$1.name === "svg" && parentSchema.space === "html") {
		schema = svg;
		state.schema = schema;
	}
	state.ancestors.push(node$1);
	const type = node$1.name === null ? state.Fragment : findComponentFromName(state, node$1.name, true);
	const props = createJsxElementProps(state, node$1);
	const children = createChildren(state, node$1);
	addNode(state, props, type, node$1);
	addChildren(props, children);
	state.ancestors.pop();
	state.schema = parentSchema;
	return state.create(node$1, type, props, key);
}
function root$2(state, node$1, key) {
	const props = {};
	addChildren(props, createChildren(state, node$1));
	return state.create(node$1, state.Fragment, props, key);
}
function text$5(_$1, node$1) {
	return node$1.value;
}
function addNode(state, props, type, node$1) {
	if (typeof type !== "string" && type !== state.Fragment && state.passNode) props.node = node$1;
}
function addChildren(props, children) {
	if (children.length > 0) {
		const value = children.length > 1 ? children : children[0];
		if (value) props.children = value;
	}
}
function productionCreate(_$1, jsx$2, jsxs$1) {
	return create$3;
	function create$3(_$2, type, props, key) {
		const isStaticChildren = Array.isArray(props.children);
		const fn = isStaticChildren ? jsxs$1 : jsx$2;
		return key ? fn(type, props, key) : fn(type, props);
	}
}
function developmentCreate(filePath, jsxDEV) {
	return create$3;
	function create$3(node$1, type, props, key) {
		const isStaticChildren = Array.isArray(props.children);
		const point$4 = pointStart(node$1);
		return jsxDEV(type, props, key, isStaticChildren, {
			columnNumber: point$4 ? point$4.column - 1 : void 0,
			fileName: filePath,
			lineNumber: point$4 ? point$4.line : void 0
		}, void 0);
	}
}
function createElementProps(state, node$1) {
	const props = {};
	let alignValue;
	let prop;
	for (prop in node$1.properties) if (prop !== "children" && own$4.call(node$1.properties, prop)) {
		const result = createProperty(state, prop, node$1.properties[prop]);
		if (result) {
			const [key, value] = result;
			if (state.tableCellAlignToStyle && key === "align" && typeof value === "string" && tableCellElement.has(node$1.tagName)) alignValue = value;
			else props[key] = value;
		}
	}
	if (alignValue) {
		const style$2 = props.style || (props.style = {});
		style$2[state.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = alignValue;
	}
	return props;
}
function createJsxElementProps(state, node$1) {
	const props = {};
	for (const attribute$1 of node$1.attributes) if (attribute$1.type === "mdxJsxExpressionAttribute") if (attribute$1.data && attribute$1.data.estree && state.evaluater) {
		const program = attribute$1.data.estree;
		const expression = program.body[0];
		ok(expression.type === "ExpressionStatement");
		const objectExpression = expression.expression;
		ok(objectExpression.type === "ObjectExpression");
		const property = objectExpression.properties[0];
		ok(property.type === "SpreadElement");
		Object.assign(props, state.evaluater.evaluateExpression(property.argument));
	} else crashEstree(state, node$1.position);
	else {
		const name$2 = attribute$1.name;
		let value;
		if (attribute$1.value && typeof attribute$1.value === "object") if (attribute$1.value.data && attribute$1.value.data.estree && state.evaluater) {
			const program = attribute$1.value.data.estree;
			const expression = program.body[0];
			ok(expression.type === "ExpressionStatement");
			value = state.evaluater.evaluateExpression(expression.expression);
		} else crashEstree(state, node$1.position);
		else value = attribute$1.value === null ? true : attribute$1.value;
		props[name$2] = value;
	}
	return props;
}
function createChildren(state, node$1) {
	const children = [];
	let index$1 = -1;
	const countsByName = state.passKeys ? new Map() : emptyMap;
	while (++index$1 < node$1.children.length) {
		const child = node$1.children[index$1];
		let key;
		if (state.passKeys) {
			const name$2 = child.type === "element" ? child.tagName : child.type === "mdxJsxFlowElement" || child.type === "mdxJsxTextElement" ? child.name : void 0;
			if (name$2) {
				const count$1 = countsByName.get(name$2) || 0;
				key = name$2 + "-" + count$1;
				countsByName.set(name$2, count$1 + 1);
			}
		}
		const result = one$1(state, child, key);
		if (result !== void 0) children.push(result);
	}
	return children;
}
function createProperty(state, prop, value) {
	const info = find(state.schema, prop);
	if (value === null || value === void 0 || typeof value === "number" && Number.isNaN(value)) return;
	if (Array.isArray(value)) value = info.commaSeparated ? stringify(value) : stringify$1(value);
	if (info.property === "style") {
		let styleObject = typeof value === "object" ? value : parseStyle(state, String(value));
		if (state.stylePropertyNameCase === "css") styleObject = transformStylesToCssCasing(styleObject);
		return ["style", styleObject];
	}
	return [state.elementAttributeNameCase === "react" && info.space ? hastToReact[info.property] || info.property : info.attribute, value];
}
function parseStyle(state, value) {
	try {
		return (0, import_cjs.default)(value, { reactCompat: true });
	} catch (error) {
		if (state.ignoreInvalidStyle) return {};
		const cause = error;
		const message = new VFileMessage("Cannot parse `style` attribute", {
			ancestors: state.ancestors,
			cause,
			ruleId: "style",
			source: "hast-util-to-jsx-runtime"
		});
		message.file = state.filePath || void 0;
		message.url = docs + "#cannot-parse-style-attribute";
		throw message;
	}
}
function findComponentFromName(state, name$2, allowExpression) {
	let result;
	if (!allowExpression) result = {
		type: "Literal",
		value: name$2
	};
	else if (name$2.includes(".")) {
		const identifiers = name$2.split(".");
		let index$1 = -1;
		let node$1;
		while (++index$1 < identifiers.length) {
			const prop = name(identifiers[index$1]) ? {
				type: "Identifier",
				name: identifiers[index$1]
			} : {
				type: "Literal",
				value: identifiers[index$1]
			};
			node$1 = node$1 ? {
				type: "MemberExpression",
				object: node$1,
				property: prop,
				computed: Boolean(index$1 && prop.type === "Literal"),
				optional: false
			} : prop;
		}
		ok(node$1, "always a result");
		result = node$1;
	} else result = name(name$2) && !/^[a-z]/.test(name$2) ? {
		type: "Identifier",
		name: name$2
	} : {
		type: "Literal",
		value: name$2
	};
	if (result.type === "Literal") {
		const name$3 = result.value;
		return own$4.call(state.components, name$3) ? state.components[name$3] : name$3;
	}
	if (state.evaluater) return state.evaluater.evaluateExpression(result);
	crashEstree(state);
}
function crashEstree(state, place) {
	const message = new VFileMessage("Cannot handle MDX estrees without `createEvaluater`", {
		ancestors: state.ancestors,
		place,
		ruleId: "mdx-estree",
		source: "hast-util-to-jsx-runtime"
	});
	message.file = state.filePath || void 0;
	message.url = docs + "#cannot-handle-mdx-estrees-without-createevaluater";
	throw message;
}
function transformStylesToCssCasing(domCasing) {
	const cssCasing = {};
	let from;
	for (from in domCasing) if (own$4.call(domCasing, from)) cssCasing[transformStyleToCssCasing(from)] = domCasing[from];
	return cssCasing;
}
function transformStyleToCssCasing(from) {
	let to = from.replace(cap, toDash);
	if (to.slice(0, 3) === "ms-") to = "-" + to;
	return to;
}
function toDash($0) {
	return "-" + $0.toLowerCase();
}
const urlAttributes = {
	action: ["form"],
	cite: [
		"blockquote",
		"del",
		"ins",
		"q"
	],
	data: ["object"],
	formAction: ["button", "input"],
	href: [
		"a",
		"area",
		"base",
		"link"
	],
	icon: ["menuitem"],
	itemId: null,
	manifest: ["html"],
	ping: ["a", "area"],
	poster: ["video"],
	src: [
		"audio",
		"embed",
		"iframe",
		"img",
		"input",
		"script",
		"source",
		"track",
		"video"
	]
};
const emptyOptions$4 = {};
function toString$1(value, options) {
	const settings = options || emptyOptions$4;
	const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
	const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
	return one(value, includeImageAlt, includeHtml);
}
function one(value, includeImageAlt, includeHtml) {
	if (node(value)) {
		if ("value" in value) return value.type === "html" && !includeHtml ? "" : value.value;
		if (includeImageAlt && "alt" in value && value.alt) return value.alt;
		if ("children" in value) return all(value.children, includeImageAlt, includeHtml);
	}
	if (Array.isArray(value)) return all(value, includeImageAlt, includeHtml);
	return "";
}
function all(values, includeImageAlt, includeHtml) {
	const result = [];
	let index$1 = -1;
	while (++index$1 < values.length) result[index$1] = one(values[index$1], includeImageAlt, includeHtml);
	return result.join("");
}
function node(value) {
	return Boolean(value && typeof value === "object");
}
function splice(list$3, start, remove, items) {
	const end = list$3.length;
	let chunkStart = 0;
	let parameters;
	if (start < 0) start = -start > end ? 0 : end + start;
	else start = start > end ? end : start;
	remove = remove > 0 ? remove : 0;
	if (items.length < 1e4) {
		parameters = Array.from(items);
		parameters.unshift(start, remove);
		list$3.splice(...parameters);
	} else {
		if (remove) list$3.splice(start, remove);
		while (chunkStart < items.length) {
			parameters = items.slice(chunkStart, chunkStart + 1e4);
			parameters.unshift(start, 0);
			list$3.splice(...parameters);
			chunkStart += 1e4;
			start += 1e4;
		}
	}
}
function push(list$3, items) {
	if (list$3.length > 0) {
		splice(list$3, list$3.length, 0, items);
		return list$3;
	}
	return items;
}
const hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
	const all$6 = {};
	let index$1 = -1;
	while (++index$1 < extensions.length) syntaxExtension(all$6, extensions[index$1]);
	return all$6;
}
function syntaxExtension(all$6, extension$1) {
	let hook;
	for (hook in extension$1) {
		const maybe = hasOwnProperty.call(all$6, hook) ? all$6[hook] : void 0;
		const left = maybe || (all$6[hook] = {});
		const right = extension$1[hook];
		let code$3;
		if (right) for (code$3 in right) {
			if (!hasOwnProperty.call(left, code$3)) left[code$3] = [];
			const value = right[code$3];
			constructs(left[code$3], Array.isArray(value) ? value : value ? [value] : []);
		}
	}
}
function constructs(existing, list$3) {
	let index$1 = -1;
	const before = [];
	while (++index$1 < list$3.length) (list$3[index$1].add === "after" ? existing : before).push(list$3[index$1]);
	splice(existing, 0, 0, before);
}
function decodeNumericCharacterReference(value, base) {
	const code$3 = Number.parseInt(value, base);
	if (code$3 < 9 || code$3 === 11 || code$3 > 13 && code$3 < 32 || code$3 > 126 && code$3 < 160 || code$3 > 55295 && code$3 < 57344 || code$3 > 64975 && code$3 < 65008 || (code$3 & 65535) === 65535 || (code$3 & 65535) === 65534 || code$3 > 1114111) return "�";
	return String.fromCodePoint(code$3);
}
function normalizeIdentifier(value) {
	return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const asciiAlpha = regexCheck(/[A-Za-z]/);
const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code$3) {
	return code$3 !== null && (code$3 < 32 || code$3 === 127);
}
const asciiDigit = regexCheck(/\d/);
const asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code$3) {
	return code$3 !== null && code$3 < -2;
}
function markdownLineEndingOrSpace(code$3) {
	return code$3 !== null && (code$3 < 0 || code$3 === 32);
}
function markdownSpace(code$3) {
	return code$3 === -2 || code$3 === -1 || code$3 === 32;
}
const unicodePunctuation = regexCheck(/\p{P}|\p{S}/u);
const unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex$2) {
	return check;
	function check(code$3) {
		return code$3 !== null && code$3 > -1 && regex$2.test(String.fromCharCode(code$3));
	}
}
function normalizeUri(value) {
	const result = [];
	let index$1 = -1;
	let start = 0;
	let skip = 0;
	while (++index$1 < value.length) {
		const code$3 = value.charCodeAt(index$1);
		let replace$1 = "";
		if (code$3 === 37 && asciiAlphanumeric(value.charCodeAt(index$1 + 1)) && asciiAlphanumeric(value.charCodeAt(index$1 + 2))) skip = 2;
		else if (code$3 < 128) {
			if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code$3))) replace$1 = String.fromCharCode(code$3);
		} else if (code$3 > 55295 && code$3 < 57344) {
			const next$1 = value.charCodeAt(index$1 + 1);
			if (code$3 < 56320 && next$1 > 56319 && next$1 < 57344) {
				replace$1 = String.fromCharCode(code$3, next$1);
				skip = 1;
			} else replace$1 = "�";
		} else replace$1 = String.fromCharCode(code$3);
		if (replace$1) {
			result.push(value.slice(start, index$1), encodeURIComponent(replace$1));
			start = index$1 + skip + 1;
			replace$1 = "";
		}
		if (skip) {
			index$1 += skip;
			skip = 0;
		}
	}
	return result.join("") + value.slice(start);
}
function factorySpace(effects, ok$2, type, max) {
	const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
	let size = 0;
	return start;
	function start(code$3) {
		if (markdownSpace(code$3)) {
			effects.enter(type);
			return prefix(code$3);
		}
		return ok$2(code$3);
	}
	function prefix(code$3) {
		if (markdownSpace(code$3) && size++ < limit) {
			effects.consume(code$3);
			return prefix;
		}
		effects.exit(type);
		return ok$2(code$3);
	}
}
const content = { tokenize: initializeContent };
function initializeContent(effects) {
	const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
	let previous$2;
	return contentStart;
	function afterContentStartConstruct(code$3) {
		if (code$3 === null) {
			effects.consume(code$3);
			return;
		}
		effects.enter("lineEnding");
		effects.consume(code$3);
		effects.exit("lineEnding");
		return factorySpace(effects, contentStart, "linePrefix");
	}
	function paragraphInitial(code$3) {
		effects.enter("paragraph");
		return lineStart(code$3);
	}
	function lineStart(code$3) {
		const token = effects.enter("chunkText", {
			contentType: "text",
			previous: previous$2
		});
		if (previous$2) previous$2.next = token;
		previous$2 = token;
		return data(code$3);
	}
	function data(code$3) {
		if (code$3 === null) {
			effects.exit("chunkText");
			effects.exit("paragraph");
			effects.consume(code$3);
			return;
		}
		if (markdownLineEnding(code$3)) {
			effects.consume(code$3);
			effects.exit("chunkText");
			return lineStart;
		}
		effects.consume(code$3);
		return data;
	}
}
const document$1 = { tokenize: initializeDocument };
const containerConstruct = { tokenize: tokenizeContainer };
function initializeDocument(effects) {
	const self$1 = this;
	const stack = [];
	let continued = 0;
	let childFlow;
	let childToken;
	let lineStartOffset;
	return start;
	function start(code$3) {
		if (continued < stack.length) {
			const item = stack[continued];
			self$1.containerState = item[1];
			return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code$3);
		}
		return checkNewContainers(code$3);
	}
	function documentContinue(code$3) {
		continued++;
		if (self$1.containerState._closeFlow) {
			self$1.containerState._closeFlow = void 0;
			if (childFlow) closeFlow();
			const indexBeforeExits = self$1.events.length;
			let indexBeforeFlow = indexBeforeExits;
			let point$4;
			while (indexBeforeFlow--) if (self$1.events[indexBeforeFlow][0] === "exit" && self$1.events[indexBeforeFlow][1].type === "chunkFlow") {
				point$4 = self$1.events[indexBeforeFlow][1].end;
				break;
			}
			exitContainers(continued);
			let index$1 = indexBeforeExits;
			while (index$1 < self$1.events.length) {
				self$1.events[index$1][1].end = { ...point$4 };
				index$1++;
			}
			splice(self$1.events, indexBeforeFlow + 1, 0, self$1.events.slice(indexBeforeExits));
			self$1.events.length = index$1;
			return checkNewContainers(code$3);
		}
		return start(code$3);
	}
	function checkNewContainers(code$3) {
		if (continued === stack.length) {
			if (!childFlow) return documentContinued(code$3);
			if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) return flowStart(code$3);
			self$1.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);
		}
		self$1.containerState = {};
		return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code$3);
	}
	function thereIsANewContainer(code$3) {
		if (childFlow) closeFlow();
		exitContainers(continued);
		return documentContinued(code$3);
	}
	function thereIsNoNewContainer(code$3) {
		self$1.parser.lazy[self$1.now().line] = continued !== stack.length;
		lineStartOffset = self$1.now().offset;
		return flowStart(code$3);
	}
	function documentContinued(code$3) {
		self$1.containerState = {};
		return effects.attempt(containerConstruct, containerContinue, flowStart)(code$3);
	}
	function containerContinue(code$3) {
		continued++;
		stack.push([self$1.currentConstruct, self$1.containerState]);
		return documentContinued(code$3);
	}
	function flowStart(code$3) {
		if (code$3 === null) {
			if (childFlow) closeFlow();
			exitContainers(0);
			effects.consume(code$3);
			return;
		}
		childFlow = childFlow || self$1.parser.flow(self$1.now());
		effects.enter("chunkFlow", {
			_tokenizer: childFlow,
			contentType: "flow",
			previous: childToken
		});
		return flowContinue(code$3);
	}
	function flowContinue(code$3) {
		if (code$3 === null) {
			writeToChild(effects.exit("chunkFlow"), true);
			exitContainers(0);
			effects.consume(code$3);
			return;
		}
		if (markdownLineEnding(code$3)) {
			effects.consume(code$3);
			writeToChild(effects.exit("chunkFlow"));
			continued = 0;
			self$1.interrupt = void 0;
			return start;
		}
		effects.consume(code$3);
		return flowContinue;
	}
	function writeToChild(token, endOfFile) {
		const stream = self$1.sliceStream(token);
		if (endOfFile) stream.push(null);
		token.previous = childToken;
		if (childToken) childToken.next = token;
		childToken = token;
		childFlow.defineSkip(token.start);
		childFlow.write(stream);
		if (self$1.parser.lazy[token.start.line]) {
			let index$1 = childFlow.events.length;
			while (index$1--) if (childFlow.events[index$1][1].start.offset < lineStartOffset && (!childFlow.events[index$1][1].end || childFlow.events[index$1][1].end.offset > lineStartOffset)) return;
			const indexBeforeExits = self$1.events.length;
			let indexBeforeFlow = indexBeforeExits;
			let seen;
			let point$4;
			while (indexBeforeFlow--) if (self$1.events[indexBeforeFlow][0] === "exit" && self$1.events[indexBeforeFlow][1].type === "chunkFlow") {
				if (seen) {
					point$4 = self$1.events[indexBeforeFlow][1].end;
					break;
				}
				seen = true;
			}
			exitContainers(continued);
			index$1 = indexBeforeExits;
			while (index$1 < self$1.events.length) {
				self$1.events[index$1][1].end = { ...point$4 };
				index$1++;
			}
			splice(self$1.events, indexBeforeFlow + 1, 0, self$1.events.slice(indexBeforeExits));
			self$1.events.length = index$1;
		}
	}
	function exitContainers(size) {
		let index$1 = stack.length;
		while (index$1-- > size) {
			const entry = stack[index$1];
			self$1.containerState = entry[1];
			entry[0].exit.call(self$1, effects);
		}
		stack.length = size;
	}
	function closeFlow() {
		childFlow.write([null]);
		childToken = void 0;
		childFlow = void 0;
		self$1.containerState._closeFlow = void 0;
	}
}
function tokenizeContainer(effects, ok$2, nok) {
	return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok$2, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function classifyCharacter(code$3) {
	if (code$3 === null || markdownLineEndingOrSpace(code$3) || unicodeWhitespace(code$3)) return 1;
	if (unicodePunctuation(code$3)) return 2;
}
function resolveAll(constructs$1, events, context) {
	const called = [];
	let index$1 = -1;
	while (++index$1 < constructs$1.length) {
		const resolve = constructs$1[index$1].resolveAll;
		if (resolve && !called.includes(resolve)) {
			events = resolve(events, context);
			called.push(resolve);
		}
	}
	return events;
}
const attention = {
	name: "attention",
	resolveAll: resolveAllAttention,
	tokenize: tokenizeAttention
};
function resolveAllAttention(events, context) {
	let index$1 = -1;
	let open;
	let group;
	let text$8;
	let openingSequence;
	let closingSequence;
	let use;
	let nextEvents;
	let offset;
	while (++index$1 < events.length) if (events[index$1][0] === "enter" && events[index$1][1].type === "attentionSequence" && events[index$1][1]._close) {
		open = index$1;
		while (open--) if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index$1][1]).charCodeAt(0)) {
			if ((events[open][1]._close || events[index$1][1]._open) && (events[index$1][1].end.offset - events[index$1][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index$1][1].end.offset - events[index$1][1].start.offset) % 3)) continue;
			use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index$1][1].end.offset - events[index$1][1].start.offset > 1 ? 2 : 1;
			const start = { ...events[open][1].end };
			const end = { ...events[index$1][1].start };
			movePoint(start, -use);
			movePoint(end, use);
			openingSequence = {
				type: use > 1 ? "strongSequence" : "emphasisSequence",
				start,
				end: { ...events[open][1].end }
			};
			closingSequence = {
				type: use > 1 ? "strongSequence" : "emphasisSequence",
				start: { ...events[index$1][1].start },
				end
			};
			text$8 = {
				type: use > 1 ? "strongText" : "emphasisText",
				start: { ...events[open][1].end },
				end: { ...events[index$1][1].start }
			};
			group = {
				type: use > 1 ? "strong" : "emphasis",
				start: { ...openingSequence.start },
				end: { ...closingSequence.end }
			};
			events[open][1].end = { ...openingSequence.start };
			events[index$1][1].start = { ...closingSequence.end };
			nextEvents = [];
			if (events[open][1].end.offset - events[open][1].start.offset) nextEvents = push(nextEvents, [[
				"enter",
				events[open][1],
				context
			], [
				"exit",
				events[open][1],
				context
			]]);
			nextEvents = push(nextEvents, [
				[
					"enter",
					group,
					context
				],
				[
					"enter",
					openingSequence,
					context
				],
				[
					"exit",
					openingSequence,
					context
				],
				[
					"enter",
					text$8,
					context
				]
			]);
			nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index$1), context));
			nextEvents = push(nextEvents, [
				[
					"exit",
					text$8,
					context
				],
				[
					"enter",
					closingSequence,
					context
				],
				[
					"exit",
					closingSequence,
					context
				],
				[
					"exit",
					group,
					context
				]
			]);
			if (events[index$1][1].end.offset - events[index$1][1].start.offset) {
				offset = 2;
				nextEvents = push(nextEvents, [[
					"enter",
					events[index$1][1],
					context
				], [
					"exit",
					events[index$1][1],
					context
				]]);
			} else offset = 0;
			splice(events, open - 1, index$1 - open + 3, nextEvents);
			index$1 = open + nextEvents.length - offset - 2;
			break;
		}
	}
	index$1 = -1;
	while (++index$1 < events.length) if (events[index$1][1].type === "attentionSequence") events[index$1][1].type = "data";
	return events;
}
function tokenizeAttention(effects, ok$2) {
	const attentionMarkers$1 = this.parser.constructs.attentionMarkers.null;
	const previous$2 = this.previous;
	const before = classifyCharacter(previous$2);
	let marker;
	return start;
	function start(code$3) {
		marker = code$3;
		effects.enter("attentionSequence");
		return inside(code$3);
	}
	function inside(code$3) {
		if (code$3 === marker) {
			effects.consume(code$3);
			return inside;
		}
		const token = effects.exit("attentionSequence");
		const after = classifyCharacter(code$3);
		const open = !after || after === 2 && before || attentionMarkers$1.includes(code$3);
		const close = !before || before === 2 && after || attentionMarkers$1.includes(previous$2);
		token._open = Boolean(marker === 42 ? open : open && (before || !close));
		token._close = Boolean(marker === 42 ? close : close && (after || !open));
		return ok$2(code$3);
	}
}
function movePoint(point$4, offset) {
	point$4.column += offset;
	point$4.offset += offset;
	point$4._bufferIndex += offset;
}
const autolink = {
	name: "autolink",
	tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok$2, nok) {
	let size = 0;
	return start;
	function start(code$3) {
		effects.enter("autolink");
		effects.enter("autolinkMarker");
		effects.consume(code$3);
		effects.exit("autolinkMarker");
		effects.enter("autolinkProtocol");
		return open;
	}
	function open(code$3) {
		if (asciiAlpha(code$3)) {
			effects.consume(code$3);
			return schemeOrEmailAtext;
		}
		if (code$3 === 64) return nok(code$3);
		return emailAtext(code$3);
	}
	function schemeOrEmailAtext(code$3) {
		if (code$3 === 43 || code$3 === 45 || code$3 === 46 || asciiAlphanumeric(code$3)) {
			size = 1;
			return schemeInsideOrEmailAtext(code$3);
		}
		return emailAtext(code$3);
	}
	function schemeInsideOrEmailAtext(code$3) {
		if (code$3 === 58) {
			effects.consume(code$3);
			size = 0;
			return urlInside;
		}
		if ((code$3 === 43 || code$3 === 45 || code$3 === 46 || asciiAlphanumeric(code$3)) && size++ < 32) {
			effects.consume(code$3);
			return schemeInsideOrEmailAtext;
		}
		size = 0;
		return emailAtext(code$3);
	}
	function urlInside(code$3) {
		if (code$3 === 62) {
			effects.exit("autolinkProtocol");
			effects.enter("autolinkMarker");
			effects.consume(code$3);
			effects.exit("autolinkMarker");
			effects.exit("autolink");
			return ok$2;
		}
		if (code$3 === null || code$3 === 32 || code$3 === 60 || asciiControl(code$3)) return nok(code$3);
		effects.consume(code$3);
		return urlInside;
	}
	function emailAtext(code$3) {
		if (code$3 === 64) {
			effects.consume(code$3);
			return emailAtSignOrDot;
		}
		if (asciiAtext(code$3)) {
			effects.consume(code$3);
			return emailAtext;
		}
		return nok(code$3);
	}
	function emailAtSignOrDot(code$3) {
		return asciiAlphanumeric(code$3) ? emailLabel(code$3) : nok(code$3);
	}
	function emailLabel(code$3) {
		if (code$3 === 46) {
			effects.consume(code$3);
			size = 0;
			return emailAtSignOrDot;
		}
		if (code$3 === 62) {
			effects.exit("autolinkProtocol").type = "autolinkEmail";
			effects.enter("autolinkMarker");
			effects.consume(code$3);
			effects.exit("autolinkMarker");
			effects.exit("autolink");
			return ok$2;
		}
		return emailValue(code$3);
	}
	function emailValue(code$3) {
		if ((code$3 === 45 || asciiAlphanumeric(code$3)) && size++ < 63) {
			const next$1 = code$3 === 45 ? emailValue : emailLabel;
			effects.consume(code$3);
			return next$1;
		}
		return nok(code$3);
	}
}
const blankLine = {
	partial: true,
	tokenize: tokenizeBlankLine
};
function tokenizeBlankLine(effects, ok$2, nok) {
	return start;
	function start(code$3) {
		return markdownSpace(code$3) ? factorySpace(effects, after, "linePrefix")(code$3) : after(code$3);
	}
	function after(code$3) {
		return code$3 === null || markdownLineEnding(code$3) ? ok$2(code$3) : nok(code$3);
	}
}
const blockQuote = {
	continuation: { tokenize: tokenizeBlockQuoteContinuation },
	exit: exit$1,
	name: "blockQuote",
	tokenize: tokenizeBlockQuoteStart
};
function tokenizeBlockQuoteStart(effects, ok$2, nok) {
	const self$1 = this;
	return start;
	function start(code$3) {
		if (code$3 === 62) {
			const state = self$1.containerState;
			if (!state.open) {
				effects.enter("blockQuote", { _container: true });
				state.open = true;
			}
			effects.enter("blockQuotePrefix");
			effects.enter("blockQuoteMarker");
			effects.consume(code$3);
			effects.exit("blockQuoteMarker");
			return after;
		}
		return nok(code$3);
	}
	function after(code$3) {
		if (markdownSpace(code$3)) {
			effects.enter("blockQuotePrefixWhitespace");
			effects.consume(code$3);
			effects.exit("blockQuotePrefixWhitespace");
			effects.exit("blockQuotePrefix");
			return ok$2;
		}
		effects.exit("blockQuotePrefix");
		return ok$2(code$3);
	}
}
function tokenizeBlockQuoteContinuation(effects, ok$2, nok) {
	const self$1 = this;
	return contStart;
	function contStart(code$3) {
		if (markdownSpace(code$3)) return factorySpace(effects, contBefore, "linePrefix", self$1.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code$3);
		return contBefore(code$3);
	}
	function contBefore(code$3) {
		return effects.attempt(blockQuote, ok$2, nok)(code$3);
	}
}
function exit$1(effects) {
	effects.exit("blockQuote");
}
const characterEscape = {
	name: "characterEscape",
	tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok$2, nok) {
	return start;
	function start(code$3) {
		effects.enter("characterEscape");
		effects.enter("escapeMarker");
		effects.consume(code$3);
		effects.exit("escapeMarker");
		return inside;
	}
	function inside(code$3) {
		if (asciiPunctuation(code$3)) {
			effects.enter("characterEscapeValue");
			effects.consume(code$3);
			effects.exit("characterEscapeValue");
			effects.exit("characterEscape");
			return ok$2;
		}
		return nok(code$3);
	}
}
const characterReference = {
	name: "characterReference",
	tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok$2, nok) {
	const self$1 = this;
	let size = 0;
	let max;
	let test$1;
	return start;
	function start(code$3) {
		effects.enter("characterReference");
		effects.enter("characterReferenceMarker");
		effects.consume(code$3);
		effects.exit("characterReferenceMarker");
		return open;
	}
	function open(code$3) {
		if (code$3 === 35) {
			effects.enter("characterReferenceMarkerNumeric");
			effects.consume(code$3);
			effects.exit("characterReferenceMarkerNumeric");
			return numeric;
		}
		effects.enter("characterReferenceValue");
		max = 31;
		test$1 = asciiAlphanumeric;
		return value(code$3);
	}
	function numeric(code$3) {
		if (code$3 === 88 || code$3 === 120) {
			effects.enter("characterReferenceMarkerHexadecimal");
			effects.consume(code$3);
			effects.exit("characterReferenceMarkerHexadecimal");
			effects.enter("characterReferenceValue");
			max = 6;
			test$1 = asciiHexDigit;
			return value;
		}
		effects.enter("characterReferenceValue");
		max = 7;
		test$1 = asciiDigit;
		return value(code$3);
	}
	function value(code$3) {
		if (code$3 === 59 && size) {
			const token = effects.exit("characterReferenceValue");
			if (test$1 === asciiAlphanumeric && !decodeNamedCharacterReference(self$1.sliceSerialize(token))) return nok(code$3);
			effects.enter("characterReferenceMarker");
			effects.consume(code$3);
			effects.exit("characterReferenceMarker");
			effects.exit("characterReference");
			return ok$2;
		}
		if (test$1(code$3) && size++ < max) {
			effects.consume(code$3);
			return value;
		}
		return nok(code$3);
	}
}
const nonLazyContinuation = {
	partial: true,
	tokenize: tokenizeNonLazyContinuation
};
const codeFenced = {
	concrete: true,
	name: "codeFenced",
	tokenize: tokenizeCodeFenced
};
function tokenizeCodeFenced(effects, ok$2, nok) {
	const self$1 = this;
	const closeStart = {
		partial: true,
		tokenize: tokenizeCloseStart
	};
	let initialPrefix = 0;
	let sizeOpen = 0;
	let marker;
	return start;
	function start(code$3) {
		return beforeSequenceOpen(code$3);
	}
	function beforeSequenceOpen(code$3) {
		const tail = self$1.events[self$1.events.length - 1];
		initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
		marker = code$3;
		effects.enter("codeFenced");
		effects.enter("codeFencedFence");
		effects.enter("codeFencedFenceSequence");
		return sequenceOpen(code$3);
	}
	function sequenceOpen(code$3) {
		if (code$3 === marker) {
			sizeOpen++;
			effects.consume(code$3);
			return sequenceOpen;
		}
		if (sizeOpen < 3) return nok(code$3);
		effects.exit("codeFencedFenceSequence");
		return markdownSpace(code$3) ? factorySpace(effects, infoBefore, "whitespace")(code$3) : infoBefore(code$3);
	}
	function infoBefore(code$3) {
		if (code$3 === null || markdownLineEnding(code$3)) {
			effects.exit("codeFencedFence");
			return self$1.interrupt ? ok$2(code$3) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code$3);
		}
		effects.enter("codeFencedFenceInfo");
		effects.enter("chunkString", { contentType: "string" });
		return info(code$3);
	}
	function info(code$3) {
		if (code$3 === null || markdownLineEnding(code$3)) {
			effects.exit("chunkString");
			effects.exit("codeFencedFenceInfo");
			return infoBefore(code$3);
		}
		if (markdownSpace(code$3)) {
			effects.exit("chunkString");
			effects.exit("codeFencedFenceInfo");
			return factorySpace(effects, metaBefore, "whitespace")(code$3);
		}
		if (code$3 === 96 && code$3 === marker) return nok(code$3);
		effects.consume(code$3);
		return info;
	}
	function metaBefore(code$3) {
		if (code$3 === null || markdownLineEnding(code$3)) return infoBefore(code$3);
		effects.enter("codeFencedFenceMeta");
		effects.enter("chunkString", { contentType: "string" });
		return meta(code$3);
	}
	function meta(code$3) {
		if (code$3 === null || markdownLineEnding(code$3)) {
			effects.exit("chunkString");
			effects.exit("codeFencedFenceMeta");
			return infoBefore(code$3);
		}
		if (code$3 === 96 && code$3 === marker) return nok(code$3);
		effects.consume(code$3);
		return meta;
	}
	function atNonLazyBreak(code$3) {
		return effects.attempt(closeStart, after, contentBefore)(code$3);
	}
	function contentBefore(code$3) {
		effects.enter("lineEnding");
		effects.consume(code$3);
		effects.exit("lineEnding");
		return contentStart;
	}
	function contentStart(code$3) {
		return initialPrefix > 0 && markdownSpace(code$3) ? factorySpace(effects, beforeContentChunk, "linePrefix", initialPrefix + 1)(code$3) : beforeContentChunk(code$3);
	}
	function beforeContentChunk(code$3) {
		if (code$3 === null || markdownLineEnding(code$3)) return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code$3);
		effects.enter("codeFlowValue");
		return contentChunk(code$3);
	}
	function contentChunk(code$3) {
		if (code$3 === null || markdownLineEnding(code$3)) {
			effects.exit("codeFlowValue");
			return beforeContentChunk(code$3);
		}
		effects.consume(code$3);
		return contentChunk;
	}
	function after(code$3) {
		effects.exit("codeFenced");
		return ok$2(code$3);
	}
	function tokenizeCloseStart(effects$1, ok$3, nok$1) {
		let size = 0;
		return startBefore;
		function startBefore(code$3) {
			effects$1.enter("lineEnding");
			effects$1.consume(code$3);
			effects$1.exit("lineEnding");
			return start$1;
		}
		function start$1(code$3) {
			effects$1.enter("codeFencedFence");
			return markdownSpace(code$3) ? factorySpace(effects$1, beforeSequenceClose, "linePrefix", self$1.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code$3) : beforeSequenceClose(code$3);
		}
		function beforeSequenceClose(code$3) {
			if (code$3 === marker) {
				effects$1.enter("codeFencedFenceSequence");
				return sequenceClose(code$3);
			}
			return nok$1(code$3);
		}
		function sequenceClose(code$3) {
			if (code$3 === marker) {
				size++;
				effects$1.consume(code$3);
				return sequenceClose;
			}
			if (size >= sizeOpen) {
				effects$1.exit("codeFencedFenceSequence");
				return markdownSpace(code$3) ? factorySpace(effects$1, sequenceCloseAfter, "whitespace")(code$3) : sequenceCloseAfter(code$3);
			}
			return nok$1(code$3);
		}
		function sequenceCloseAfter(code$3) {
			if (code$3 === null || markdownLineEnding(code$3)) {
				effects$1.exit("codeFencedFence");
				return ok$3(code$3);
			}
			return nok$1(code$3);
		}
	}
}
function tokenizeNonLazyContinuation(effects, ok$2, nok) {
	const self$1 = this;
	return start;
	function start(code$3) {
		if (code$3 === null) return nok(code$3);
		effects.enter("lineEnding");
		effects.consume(code$3);
		effects.exit("lineEnding");
		return lineStart;
	}
	function lineStart(code$3) {
		return self$1.parser.lazy[self$1.now().line] ? nok(code$3) : ok$2(code$3);
	}
}
const codeIndented = {
	name: "codeIndented",
	tokenize: tokenizeCodeIndented
};
const furtherStart = {
	partial: true,
	tokenize: tokenizeFurtherStart
};
function tokenizeCodeIndented(effects, ok$2, nok) {
	const self$1 = this;
	return start;
	function start(code$3) {
		effects.enter("codeIndented");
		return factorySpace(effects, afterPrefix, "linePrefix", 5)(code$3);
	}
	function afterPrefix(code$3) {
		const tail = self$1.events[self$1.events.length - 1];
		return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code$3) : nok(code$3);
	}
	function atBreak(code$3) {
		if (code$3 === null) return after(code$3);
		if (markdownLineEnding(code$3)) return effects.attempt(furtherStart, atBreak, after)(code$3);
		effects.enter("codeFlowValue");
		return inside(code$3);
	}
	function inside(code$3) {
		if (code$3 === null || markdownLineEnding(code$3)) {
			effects.exit("codeFlowValue");
			return atBreak(code$3);
		}
		effects.consume(code$3);
		return inside;
	}
	function after(code$3) {
		effects.exit("codeIndented");
		return ok$2(code$3);
	}
}
function tokenizeFurtherStart(effects, ok$2, nok) {
	const self$1 = this;
	return furtherStart$1;
	function furtherStart$1(code$3) {
		if (self$1.parser.lazy[self$1.now().line]) return nok(code$3);
		if (markdownLineEnding(code$3)) {
			effects.enter("lineEnding");
			effects.consume(code$3);
			effects.exit("lineEnding");
			return furtherStart$1;
		}
		return factorySpace(effects, afterPrefix, "linePrefix", 5)(code$3);
	}
	function afterPrefix(code$3) {
		const tail = self$1.events[self$1.events.length - 1];
		return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok$2(code$3) : markdownLineEnding(code$3) ? furtherStart$1(code$3) : nok(code$3);
	}
}
const codeText = {
	name: "codeText",
	previous: previous$1,
	resolve: resolveCodeText,
	tokenize: tokenizeCodeText
};
function resolveCodeText(events) {
	let tailExitIndex = events.length - 4;
	let headEnterIndex = 3;
	let index$1;
	let enter;
	if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
		index$1 = headEnterIndex;
		while (++index$1 < tailExitIndex) if (events[index$1][1].type === "codeTextData") {
			events[headEnterIndex][1].type = "codeTextPadding";
			events[tailExitIndex][1].type = "codeTextPadding";
			headEnterIndex += 2;
			tailExitIndex -= 2;
			break;
		}
	}
	index$1 = headEnterIndex - 1;
	tailExitIndex++;
	while (++index$1 <= tailExitIndex) if (enter === void 0) {
		if (index$1 !== tailExitIndex && events[index$1][1].type !== "lineEnding") enter = index$1;
	} else if (index$1 === tailExitIndex || events[index$1][1].type === "lineEnding") {
		events[enter][1].type = "codeTextData";
		if (index$1 !== enter + 2) {
			events[enter][1].end = events[index$1 - 1][1].end;
			events.splice(enter + 2, index$1 - enter - 2);
			tailExitIndex -= index$1 - enter - 2;
			index$1 = enter + 2;
		}
		enter = void 0;
	}
	return events;
}
function previous$1(code$3) {
	return code$3 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok$2, nok) {
	const self$1 = this;
	let sizeOpen = 0;
	let size;
	let token;
	return start;
	function start(code$3) {
		effects.enter("codeText");
		effects.enter("codeTextSequence");
		return sequenceOpen(code$3);
	}
	function sequenceOpen(code$3) {
		if (code$3 === 96) {
			effects.consume(code$3);
			sizeOpen++;
			return sequenceOpen;
		}
		effects.exit("codeTextSequence");
		return between(code$3);
	}
	function between(code$3) {
		if (code$3 === null) return nok(code$3);
		if (code$3 === 32) {
			effects.enter("space");
			effects.consume(code$3);
			effects.exit("space");
			return between;
		}
		if (code$3 === 96) {
			token = effects.enter("codeTextSequence");
			size = 0;
			return sequenceClose(code$3);
		}
		if (markdownLineEnding(code$3)) {
			effects.enter("lineEnding");
			effects.consume(code$3);
			effects.exit("lineEnding");
			return between;
		}
		effects.enter("codeTextData");
		return data(code$3);
	}
	function data(code$3) {
		if (code$3 === null || code$3 === 32 || code$3 === 96 || markdownLineEnding(code$3)) {
			effects.exit("codeTextData");
			return between(code$3);
		}
		effects.consume(code$3);
		return data;
	}
	function sequenceClose(code$3) {
		if (code$3 === 96) {
			effects.consume(code$3);
			size++;
			return sequenceClose;
		}
		if (size === sizeOpen) {
			effects.exit("codeTextSequence");
			effects.exit("codeText");
			return ok$2(code$3);
		}
		token.type = "codeTextData";
		return data(code$3);
	}
}
var SpliceBuffer = class {
	constructor(initial) {
		this.left = initial ? [...initial] : [];
		this.right = [];
	}
	get(index$1) {
		if (index$1 < 0 || index$1 >= this.left.length + this.right.length) throw new RangeError("Cannot access index `" + index$1 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
		if (index$1 < this.left.length) return this.left[index$1];
		return this.right[this.right.length - index$1 + this.left.length - 1];
	}
	get length() {
		return this.left.length + this.right.length;
	}
	shift() {
		this.setCursor(0);
		return this.right.pop();
	}
	slice(start, end) {
		const stop = end === null || end === void 0 ? Number.POSITIVE_INFINITY : end;
		if (stop < this.left.length) return this.left.slice(start, stop);
		if (start > this.left.length) return this.right.slice(this.right.length - stop + this.left.length, this.right.length - start + this.left.length).reverse();
		return this.left.slice(start).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());
	}
	splice(start, deleteCount, items) {
		const count$1 = deleteCount || 0;
		this.setCursor(Math.trunc(start));
		const removed = this.right.splice(this.right.length - count$1, Number.POSITIVE_INFINITY);
		if (items) chunkedPush(this.left, items);
		return removed.reverse();
	}
	pop() {
		this.setCursor(Number.POSITIVE_INFINITY);
		return this.left.pop();
	}
	push(item) {
		this.setCursor(Number.POSITIVE_INFINITY);
		this.left.push(item);
	}
	pushMany(items) {
		this.setCursor(Number.POSITIVE_INFINITY);
		chunkedPush(this.left, items);
	}
	unshift(item) {
		this.setCursor(0);
		this.right.push(item);
	}
	unshiftMany(items) {
		this.setCursor(0);
		chunkedPush(this.right, items.reverse());
	}
	setCursor(n$1) {
		if (n$1 === this.left.length || n$1 > this.left.length && this.right.length === 0 || n$1 < 0 && this.left.length === 0) return;
		if (n$1 < this.left.length) {
			const removed = this.left.splice(n$1, Number.POSITIVE_INFINITY);
			chunkedPush(this.right, removed.reverse());
		} else {
			const removed = this.right.splice(this.left.length + this.right.length - n$1, Number.POSITIVE_INFINITY);
			chunkedPush(this.left, removed.reverse());
		}
	}
};
function chunkedPush(list$3, right) {
	let chunkStart = 0;
	if (right.length < 1e4) list$3.push(...right);
	else while (chunkStart < right.length) {
		list$3.push(...right.slice(chunkStart, chunkStart + 1e4));
		chunkStart += 1e4;
	}
}
function subtokenize(eventsArray) {
	const jumps = {};
	let index$1 = -1;
	let event;
	let lineIndex;
	let otherIndex;
	let otherEvent;
	let parameters;
	let subevents;
	let more;
	const events = new SpliceBuffer(eventsArray);
	while (++index$1 < events.length) {
		while (index$1 in jumps) index$1 = jumps[index$1];
		event = events.get(index$1);
		if (index$1 && event[1].type === "chunkFlow" && events.get(index$1 - 1)[1].type === "listItemPrefix") {
			subevents = event[1]._tokenizer.events;
			otherIndex = 0;
			if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") otherIndex += 2;
			if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") while (++otherIndex < subevents.length) {
				if (subevents[otherIndex][1].type === "content") break;
				if (subevents[otherIndex][1].type === "chunkText") {
					subevents[otherIndex][1]._isInFirstContentOfListItem = true;
					otherIndex++;
				}
			}
		}
		if (event[0] === "enter") {
			if (event[1].contentType) {
				Object.assign(jumps, subcontent(events, index$1));
				index$1 = jumps[index$1];
				more = true;
			}
		} else if (event[1]._container) {
			otherIndex = index$1;
			lineIndex = void 0;
			while (otherIndex--) {
				otherEvent = events.get(otherIndex);
				if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
					if (otherEvent[0] === "enter") {
						if (lineIndex) events.get(lineIndex)[1].type = "lineEndingBlank";
						otherEvent[1].type = "lineEnding";
						lineIndex = otherIndex;
					}
				} else if (otherEvent[1].type === "linePrefix" || otherEvent[1].type === "listItemIndent") {} else break;
			}
			if (lineIndex) {
				event[1].end = { ...events.get(lineIndex)[1].start };
				parameters = events.slice(lineIndex, index$1);
				parameters.unshift(event);
				events.splice(lineIndex, index$1 - lineIndex + 1, parameters);
			}
		}
	}
	splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));
	return !more;
}
function subcontent(events, eventIndex) {
	const token = events.get(eventIndex)[1];
	const context = events.get(eventIndex)[2];
	let startPosition = eventIndex - 1;
	const startPositions = [];
	let tokenizer = token._tokenizer;
	if (!tokenizer) {
		tokenizer = context.parser[token.contentType](token.start);
		if (token._contentTypeTextTrailing) tokenizer._contentTypeTextTrailing = true;
	}
	const childEvents = tokenizer.events;
	const jumps = [];
	const gaps = {};
	let stream;
	let previous$2;
	let index$1 = -1;
	let current = token;
	let adjust = 0;
	let start = 0;
	const breaks = [start];
	while (current) {
		while (events.get(++startPosition)[1] !== current);
		startPositions.push(startPosition);
		if (!current._tokenizer) {
			stream = context.sliceStream(current);
			if (!current.next) stream.push(null);
			if (previous$2) tokenizer.defineSkip(current.start);
			if (current._isInFirstContentOfListItem) tokenizer._gfmTasklistFirstContentOfListItem = true;
			tokenizer.write(stream);
			if (current._isInFirstContentOfListItem) tokenizer._gfmTasklistFirstContentOfListItem = void 0;
		}
		previous$2 = current;
		current = current.next;
	}
	current = token;
	while (++index$1 < childEvents.length) if (childEvents[index$1][0] === "exit" && childEvents[index$1 - 1][0] === "enter" && childEvents[index$1][1].type === childEvents[index$1 - 1][1].type && childEvents[index$1][1].start.line !== childEvents[index$1][1].end.line) {
		start = index$1 + 1;
		breaks.push(start);
		current._tokenizer = void 0;
		current.previous = void 0;
		current = current.next;
	}
	tokenizer.events = [];
	if (current) {
		current._tokenizer = void 0;
		current.previous = void 0;
	} else breaks.pop();
	index$1 = breaks.length;
	while (index$1--) {
		const slice = childEvents.slice(breaks[index$1], breaks[index$1 + 1]);
		const start$1 = startPositions.pop();
		jumps.push([start$1, start$1 + slice.length - 1]);
		events.splice(start$1, 2, slice);
	}
	jumps.reverse();
	index$1 = -1;
	while (++index$1 < jumps.length) {
		gaps[adjust + jumps[index$1][0]] = adjust + jumps[index$1][1];
		adjust += jumps[index$1][1] - jumps[index$1][0] - 1;
	}
	return gaps;
}
const content$1 = {
	resolve: resolveContent,
	tokenize: tokenizeContent
};
const continuationConstruct = {
	partial: true,
	tokenize: tokenizeContinuation
};
function resolveContent(events) {
	subtokenize(events);
	return events;
}
function tokenizeContent(effects, ok$2) {
	let previous$2;
	return chunkStart;
	function chunkStart(code$3) {
		effects.enter("content");
		previous$2 = effects.enter("chunkContent", { contentType: "content" });
		return chunkInside(code$3);
	}
	function chunkInside(code$3) {
		if (code$3 === null) return contentEnd(code$3);
		if (markdownLineEnding(code$3)) return effects.check(continuationConstruct, contentContinue, contentEnd)(code$3);
		effects.consume(code$3);
		return chunkInside;
	}
	function contentEnd(code$3) {
		effects.exit("chunkContent");
		effects.exit("content");
		return ok$2(code$3);
	}
	function contentContinue(code$3) {
		effects.consume(code$3);
		effects.exit("chunkContent");
		previous$2.next = effects.enter("chunkContent", {
			contentType: "content",
			previous: previous$2
		});
		previous$2 = previous$2.next;
		return chunkInside;
	}
}
function tokenizeContinuation(effects, ok$2, nok) {
	const self$1 = this;
	return startLookahead;
	function startLookahead(code$3) {
		effects.exit("chunkContent");
		effects.enter("lineEnding");
		effects.consume(code$3);
		effects.exit("lineEnding");
		return factorySpace(effects, prefixed, "linePrefix");
	}
	function prefixed(code$3) {
		if (code$3 === null || markdownLineEnding(code$3)) return nok(code$3);
		const tail = self$1.events[self$1.events.length - 1];
		if (!self$1.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) return ok$2(code$3);
		return effects.interrupt(self$1.parser.constructs.flow, nok, ok$2)(code$3);
	}
}
function factoryDestination(effects, ok$2, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
	const limit = max || Number.POSITIVE_INFINITY;
	let balance = 0;
	return start;
	function start(code$3) {
		if (code$3 === 60) {
			effects.enter(type);
			effects.enter(literalType);
			effects.enter(literalMarkerType);
			effects.consume(code$3);
			effects.exit(literalMarkerType);
			return enclosedBefore;
		}
		if (code$3 === null || code$3 === 32 || code$3 === 41 || asciiControl(code$3)) return nok(code$3);
		effects.enter(type);
		effects.enter(rawType);
		effects.enter(stringType);
		effects.enter("chunkString", { contentType: "string" });
		return raw$1(code$3);
	}
	function enclosedBefore(code$3) {
		if (code$3 === 62) {
			effects.enter(literalMarkerType);
			effects.consume(code$3);
			effects.exit(literalMarkerType);
			effects.exit(literalType);
			effects.exit(type);
			return ok$2;
		}
		effects.enter(stringType);
		effects.enter("chunkString", { contentType: "string" });
		return enclosed(code$3);
	}
	function enclosed(code$3) {
		if (code$3 === 62) {
			effects.exit("chunkString");
			effects.exit(stringType);
			return enclosedBefore(code$3);
		}
		if (code$3 === null || code$3 === 60 || markdownLineEnding(code$3)) return nok(code$3);
		effects.consume(code$3);
		return code$3 === 92 ? enclosedEscape : enclosed;
	}
	function enclosedEscape(code$3) {
		if (code$3 === 60 || code$3 === 62 || code$3 === 92) {
			effects.consume(code$3);
			return enclosed;
		}
		return enclosed(code$3);
	}
	function raw$1(code$3) {
		if (!balance && (code$3 === null || code$3 === 41 || markdownLineEndingOrSpace(code$3))) {
			effects.exit("chunkString");
			effects.exit(stringType);
			effects.exit(rawType);
			effects.exit(type);
			return ok$2(code$3);
		}
		if (balance < limit && code$3 === 40) {
			effects.consume(code$3);
			balance++;
			return raw$1;
		}
		if (code$3 === 41) {
			effects.consume(code$3);
			balance--;
			return raw$1;
		}
		if (code$3 === null || code$3 === 32 || code$3 === 40 || asciiControl(code$3)) return nok(code$3);
		effects.consume(code$3);
		return code$3 === 92 ? rawEscape : raw$1;
	}
	function rawEscape(code$3) {
		if (code$3 === 40 || code$3 === 41 || code$3 === 92) {
			effects.consume(code$3);
			return raw$1;
		}
		return raw$1(code$3);
	}
}
function factoryLabel(effects, ok$2, nok, type, markerType, stringType) {
	const self$1 = this;
	let size = 0;
	let seen;
	return start;
	function start(code$3) {
		effects.enter(type);
		effects.enter(markerType);
		effects.consume(code$3);
		effects.exit(markerType);
		effects.enter(stringType);
		return atBreak;
	}
	function atBreak(code$3) {
		if (size > 999 || code$3 === null || code$3 === 91 || code$3 === 93 && !seen || code$3 === 94 && !size && "_hiddenFootnoteSupport" in self$1.parser.constructs) return nok(code$3);
		if (code$3 === 93) {
			effects.exit(stringType);
			effects.enter(markerType);
			effects.consume(code$3);
			effects.exit(markerType);
			effects.exit(type);
			return ok$2;
		}
		if (markdownLineEnding(code$3)) {
			effects.enter("lineEnding");
			effects.consume(code$3);
			effects.exit("lineEnding");
			return atBreak;
		}
		effects.enter("chunkString", { contentType: "string" });
		return labelInside(code$3);
	}
	function labelInside(code$3) {
		if (code$3 === null || code$3 === 91 || code$3 === 93 || markdownLineEnding(code$3) || size++ > 999) {
			effects.exit("chunkString");
			return atBreak(code$3);
		}
		effects.consume(code$3);
		if (!seen) seen = !markdownSpace(code$3);
		return code$3 === 92 ? labelEscape : labelInside;
	}
	function labelEscape(code$3) {
		if (code$3 === 91 || code$3 === 92 || code$3 === 93) {
			effects.consume(code$3);
			size++;
			return labelInside;
		}
		return labelInside(code$3);
	}
}
function factoryTitle(effects, ok$2, nok, type, markerType, stringType) {
	let marker;
	return start;
	function start(code$3) {
		if (code$3 === 34 || code$3 === 39 || code$3 === 40) {
			effects.enter(type);
			effects.enter(markerType);
			effects.consume(code$3);
			effects.exit(markerType);
			marker = code$3 === 40 ? 41 : code$3;
			return begin;
		}
		return nok(code$3);
	}
	function begin(code$3) {
		if (code$3 === marker) {
			effects.enter(markerType);
			effects.consume(code$3);
			effects.exit(markerType);
			effects.exit(type);
			return ok$2;
		}
		effects.enter(stringType);
		return atBreak(code$3);
	}
	function atBreak(code$3) {
		if (code$3 === marker) {
			effects.exit(stringType);
			return begin(marker);
		}
		if (code$3 === null) return nok(code$3);
		if (markdownLineEnding(code$3)) {
			effects.enter("lineEnding");
			effects.consume(code$3);
			effects.exit("lineEnding");
			return factorySpace(effects, atBreak, "linePrefix");
		}
		effects.enter("chunkString", { contentType: "string" });
		return inside(code$3);
	}
	function inside(code$3) {
		if (code$3 === marker || code$3 === null || markdownLineEnding(code$3)) {
			effects.exit("chunkString");
			return atBreak(code$3);
		}
		effects.consume(code$3);
		return code$3 === 92 ? escape$1 : inside;
	}
	function escape$1(code$3) {
		if (code$3 === marker || code$3 === 92) {
			effects.consume(code$3);
			return inside;
		}
		return inside(code$3);
	}
}
function factoryWhitespace(effects, ok$2) {
	let seen;
	return start;
	function start(code$3) {
		if (markdownLineEnding(code$3)) {
			effects.enter("lineEnding");
			effects.consume(code$3);
			effects.exit("lineEnding");
			seen = true;
			return start;
		}
		if (markdownSpace(code$3)) return factorySpace(effects, start, seen ? "linePrefix" : "lineSuffix")(code$3);
		return ok$2(code$3);
	}
}
const definition$1 = {
	name: "definition",
	tokenize: tokenizeDefinition
};
const titleBefore = {
	partial: true,
	tokenize: tokenizeTitleBefore
};
function tokenizeDefinition(effects, ok$2, nok) {
	const self$1 = this;
	let identifier;
	return start;
	function start(code$3) {
		effects.enter("definition");
		return before(code$3);
	}
	function before(code$3) {
		return factoryLabel.call(self$1, effects, labelAfter, nok, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(code$3);
	}
	function labelAfter(code$3) {
		identifier = normalizeIdentifier(self$1.sliceSerialize(self$1.events[self$1.events.length - 1][1]).slice(1, -1));
		if (code$3 === 58) {
			effects.enter("definitionMarker");
			effects.consume(code$3);
			effects.exit("definitionMarker");
			return markerAfter;
		}
		return nok(code$3);
	}
	function markerAfter(code$3) {
		return markdownLineEndingOrSpace(code$3) ? factoryWhitespace(effects, destinationBefore)(code$3) : destinationBefore(code$3);
	}
	function destinationBefore(code$3) {
		return factoryDestination(effects, destinationAfter, nok, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString")(code$3);
	}
	function destinationAfter(code$3) {
		return effects.attempt(titleBefore, after, after)(code$3);
	}
	function after(code$3) {
		return markdownSpace(code$3) ? factorySpace(effects, afterWhitespace, "whitespace")(code$3) : afterWhitespace(code$3);
	}
	function afterWhitespace(code$3) {
		if (code$3 === null || markdownLineEnding(code$3)) {
			effects.exit("definition");
			self$1.parser.defined.push(identifier);
			return ok$2(code$3);
		}
		return nok(code$3);
	}
}
function tokenizeTitleBefore(effects, ok$2, nok) {
	return titleBefore$1;
	function titleBefore$1(code$3) {
		return markdownLineEndingOrSpace(code$3) ? factoryWhitespace(effects, beforeMarker)(code$3) : nok(code$3);
	}
	function beforeMarker(code$3) {
		return factoryTitle(effects, titleAfter, nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code$3);
	}
	function titleAfter(code$3) {
		return markdownSpace(code$3) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code$3) : titleAfterOptionalWhitespace(code$3);
	}
	function titleAfterOptionalWhitespace(code$3) {
		return code$3 === null || markdownLineEnding(code$3) ? ok$2(code$3) : nok(code$3);
	}
}
const hardBreakEscape = {
	name: "hardBreakEscape",
	tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok$2, nok) {
	return start;
	function start(code$3) {
		effects.enter("hardBreakEscape");
		effects.consume(code$3);
		return after;
	}
	function after(code$3) {
		if (markdownLineEnding(code$3)) {
			effects.exit("hardBreakEscape");
			return ok$2(code$3);
		}
		return nok(code$3);
	}
}
const headingAtx = {
	name: "headingAtx",
	resolve: resolveHeadingAtx,
	tokenize: tokenizeHeadingAtx
};
function resolveHeadingAtx(events, context) {
	let contentEnd = events.length - 2;
	let contentStart = 3;
	let content$2;
	let text$8;
	if (events[contentStart][1].type === "whitespace") contentStart += 2;
	if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") contentEnd -= 2;
	if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
	if (contentEnd > contentStart) {
		content$2 = {
			type: "atxHeadingText",
			start: events[contentStart][1].start,
			end: events[contentEnd][1].end
		};
		text$8 = {
			type: "chunkText",
			start: events[contentStart][1].start,
			end: events[contentEnd][1].end,
			contentType: "text"
		};
		splice(events, contentStart, contentEnd - contentStart + 1, [
			[
				"enter",
				content$2,
				context
			],
			[
				"enter",
				text$8,
				context
			],
			[
				"exit",
				text$8,
				context
			],
			[
				"exit",
				content$2,
				context
			]
		]);
	}
	return events;
}
function tokenizeHeadingAtx(effects, ok$2, nok) {
	let size = 0;
	return start;
	function start(code$3) {
		effects.enter("atxHeading");
		return before(code$3);
	}
	function before(code$3) {
		effects.enter("atxHeadingSequence");
		return sequenceOpen(code$3);
	}
	function sequenceOpen(code$3) {
		if (code$3 === 35 && size++ < 6) {
			effects.consume(code$3);
			return sequenceOpen;
		}
		if (code$3 === null || markdownLineEndingOrSpace(code$3)) {
			effects.exit("atxHeadingSequence");
			return atBreak(code$3);
		}
		return nok(code$3);
	}
	function atBreak(code$3) {
		if (code$3 === 35) {
			effects.enter("atxHeadingSequence");
			return sequenceFurther(code$3);
		}
		if (code$3 === null || markdownLineEnding(code$3)) {
			effects.exit("atxHeading");
			return ok$2(code$3);
		}
		if (markdownSpace(code$3)) return factorySpace(effects, atBreak, "whitespace")(code$3);
		effects.enter("atxHeadingText");
		return data(code$3);
	}
	function sequenceFurther(code$3) {
		if (code$3 === 35) {
			effects.consume(code$3);
			return sequenceFurther;
		}
		effects.exit("atxHeadingSequence");
		return atBreak(code$3);
	}
	function data(code$3) {
		if (code$3 === null || code$3 === 35 || markdownLineEndingOrSpace(code$3)) {
			effects.exit("atxHeadingText");
			return atBreak(code$3);
		}
		effects.consume(code$3);
		return data;
	}
}
const htmlBlockNames = [
	"address",
	"article",
	"aside",
	"base",
	"basefont",
	"blockquote",
	"body",
	"caption",
	"center",
	"col",
	"colgroup",
	"dd",
	"details",
	"dialog",
	"dir",
	"div",
	"dl",
	"dt",
	"fieldset",
	"figcaption",
	"figure",
	"footer",
	"form",
	"frame",
	"frameset",
	"h1",
	"h2",
	"h3",
	"h4",
	"h5",
	"h6",
	"head",
	"header",
	"hr",
	"html",
	"iframe",
	"legend",
	"li",
	"link",
	"main",
	"menu",
	"menuitem",
	"nav",
	"noframes",
	"ol",
	"optgroup",
	"option",
	"p",
	"param",
	"search",
	"section",
	"summary",
	"table",
	"tbody",
	"td",
	"tfoot",
	"th",
	"thead",
	"title",
	"tr",
	"track",
	"ul"
];
const htmlRawNames = [
	"pre",
	"script",
	"style",
	"textarea"
];
const htmlFlow = {
	concrete: true,
	name: "htmlFlow",
	resolveTo: resolveToHtmlFlow,
	tokenize: tokenizeHtmlFlow
};
const blankLineBefore = {
	partial: true,
	tokenize: tokenizeBlankLineBefore
};
const nonLazyContinuationStart = {
	partial: true,
	tokenize: tokenizeNonLazyContinuationStart
};
function resolveToHtmlFlow(events) {
	let index$1 = events.length;
	while (index$1--) if (events[index$1][0] === "enter" && events[index$1][1].type === "htmlFlow") break;
	if (index$1 > 1 && events[index$1 - 2][1].type === "linePrefix") {
		events[index$1][1].start = events[index$1 - 2][1].start;
		events[index$1 + 1][1].start = events[index$1 - 2][1].start;
		events.splice(index$1 - 2, 2);
	}
	return events;
}
function tokenizeHtmlFlow(effects, ok$2, nok) {
	const self$1 = this;
	let marker;
	let closingTag;
	let buffer;
	let index$1;
	let markerB;
	return start;
	function start(code$3) {
		return before(code$3);
	}
	function before(code$3) {
		effects.enter("htmlFlow");
		effects.enter("htmlFlowData");
		effects.consume(code$3);
		return open;
	}
	function open(code$3) {
		if (code$3 === 33) {
			effects.consume(code$3);
			return declarationOpen;
		}
		if (code$3 === 47) {
			effects.consume(code$3);
			closingTag = true;
			return tagCloseStart;
		}
		if (code$3 === 63) {
			effects.consume(code$3);
			marker = 3;
			return self$1.interrupt ? ok$2 : continuationDeclarationInside;
		}
		if (asciiAlpha(code$3)) {
			effects.consume(code$3);
			buffer = String.fromCharCode(code$3);
			return tagName;
		}
		return nok(code$3);
	}
	function declarationOpen(code$3) {
		if (code$3 === 45) {
			effects.consume(code$3);
			marker = 2;
			return commentOpenInside;
		}
		if (code$3 === 91) {
			effects.consume(code$3);
			marker = 5;
			index$1 = 0;
			return cdataOpenInside;
		}
		if (asciiAlpha(code$3)) {
			effects.consume(code$3);
			marker = 4;
			return self$1.interrupt ? ok$2 : continuationDeclarationInside;
		}
		return nok(code$3);
	}
	function commentOpenInside(code$3) {
		if (code$3 === 45) {
			effects.consume(code$3);
			return self$1.interrupt ? ok$2 : continuationDeclarationInside;
		}
		return nok(code$3);
	}
	function cdataOpenInside(code$3) {
		const value = "CDATA[";
		if (code$3 === value.charCodeAt(index$1++)) {
			effects.consume(code$3);
			if (index$1 === 6) return self$1.interrupt ? ok$2 : continuation;
			return cdataOpenInside;
		}
		return nok(code$3);
	}
	function tagCloseStart(code$3) {
		if (asciiAlpha(code$3)) {
			effects.consume(code$3);
			buffer = String.fromCharCode(code$3);
			return tagName;
		}
		return nok(code$3);
	}
	function tagName(code$3) {
		if (code$3 === null || code$3 === 47 || code$3 === 62 || markdownLineEndingOrSpace(code$3)) {
			const slash = code$3 === 47;
			const name$2 = buffer.toLowerCase();
			if (!slash && !closingTag && htmlRawNames.includes(name$2)) {
				marker = 1;
				return self$1.interrupt ? ok$2(code$3) : continuation(code$3);
			}
			if (htmlBlockNames.includes(buffer.toLowerCase())) {
				marker = 6;
				if (slash) {
					effects.consume(code$3);
					return basicSelfClosing;
				}
				return self$1.interrupt ? ok$2(code$3) : continuation(code$3);
			}
			marker = 7;
			return self$1.interrupt && !self$1.parser.lazy[self$1.now().line] ? nok(code$3) : closingTag ? completeClosingTagAfter(code$3) : completeAttributeNameBefore(code$3);
		}
		if (code$3 === 45 || asciiAlphanumeric(code$3)) {
			effects.consume(code$3);
			buffer += String.fromCharCode(code$3);
			return tagName;
		}
		return nok(code$3);
	}
	function basicSelfClosing(code$3) {
		if (code$3 === 62) {
			effects.consume(code$3);
			return self$1.interrupt ? ok$2 : continuation;
		}
		return nok(code$3);
	}
	function completeClosingTagAfter(code$3) {
		if (markdownSpace(code$3)) {
			effects.consume(code$3);
			return completeClosingTagAfter;
		}
		return completeEnd(code$3);
	}
	function completeAttributeNameBefore(code$3) {
		if (code$3 === 47) {
			effects.consume(code$3);
			return completeEnd;
		}
		if (code$3 === 58 || code$3 === 95 || asciiAlpha(code$3)) {
			effects.consume(code$3);
			return completeAttributeName;
		}
		if (markdownSpace(code$3)) {
			effects.consume(code$3);
			return completeAttributeNameBefore;
		}
		return completeEnd(code$3);
	}
	function completeAttributeName(code$3) {
		if (code$3 === 45 || code$3 === 46 || code$3 === 58 || code$3 === 95 || asciiAlphanumeric(code$3)) {
			effects.consume(code$3);
			return completeAttributeName;
		}
		return completeAttributeNameAfter(code$3);
	}
	function completeAttributeNameAfter(code$3) {
		if (code$3 === 61) {
			effects.consume(code$3);
			return completeAttributeValueBefore;
		}
		if (markdownSpace(code$3)) {
			effects.consume(code$3);
			return completeAttributeNameAfter;
		}
		return completeAttributeNameBefore(code$3);
	}
	function completeAttributeValueBefore(code$3) {
		if (code$3 === null || code$3 === 60 || code$3 === 61 || code$3 === 62 || code$3 === 96) return nok(code$3);
		if (code$3 === 34 || code$3 === 39) {
			effects.consume(code$3);
			markerB = code$3;
			return completeAttributeValueQuoted;
		}
		if (markdownSpace(code$3)) {
			effects.consume(code$3);
			return completeAttributeValueBefore;
		}
		return completeAttributeValueUnquoted(code$3);
	}
	function completeAttributeValueQuoted(code$3) {
		if (code$3 === markerB) {
			effects.consume(code$3);
			markerB = null;
			return completeAttributeValueQuotedAfter;
		}
		if (code$3 === null || markdownLineEnding(code$3)) return nok(code$3);
		effects.consume(code$3);
		return completeAttributeValueQuoted;
	}
	function completeAttributeValueUnquoted(code$3) {
		if (code$3 === null || code$3 === 34 || code$3 === 39 || code$3 === 47 || code$3 === 60 || code$3 === 61 || code$3 === 62 || code$3 === 96 || markdownLineEndingOrSpace(code$3)) return completeAttributeNameAfter(code$3);
		effects.consume(code$3);
		return completeAttributeValueUnquoted;
	}
	function completeAttributeValueQuotedAfter(code$3) {
		if (code$3 === 47 || code$3 === 62 || markdownSpace(code$3)) return completeAttributeNameBefore(code$3);
		return nok(code$3);
	}
	function completeEnd(code$3) {
		if (code$3 === 62) {
			effects.consume(code$3);
			return completeAfter;
		}
		return nok(code$3);
	}
	function completeAfter(code$3) {
		if (code$3 === null || markdownLineEnding(code$3)) return continuation(code$3);
		if (markdownSpace(code$3)) {
			effects.consume(code$3);
			return completeAfter;
		}
		return nok(code$3);
	}
	function continuation(code$3) {
		if (code$3 === 45 && marker === 2) {
			effects.consume(code$3);
			return continuationCommentInside;
		}
		if (code$3 === 60 && marker === 1) {
			effects.consume(code$3);
			return continuationRawTagOpen;
		}
		if (code$3 === 62 && marker === 4) {
			effects.consume(code$3);
			return continuationClose;
		}
		if (code$3 === 63 && marker === 3) {
			effects.consume(code$3);
			return continuationDeclarationInside;
		}
		if (code$3 === 93 && marker === 5) {
			effects.consume(code$3);
			return continuationCdataInside;
		}
		if (markdownLineEnding(code$3) && (marker === 6 || marker === 7)) {
			effects.exit("htmlFlowData");
			return effects.check(blankLineBefore, continuationAfter, continuationStart)(code$3);
		}
		if (code$3 === null || markdownLineEnding(code$3)) {
			effects.exit("htmlFlowData");
			return continuationStart(code$3);
		}
		effects.consume(code$3);
		return continuation;
	}
	function continuationStart(code$3) {
		return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code$3);
	}
	function continuationStartNonLazy(code$3) {
		effects.enter("lineEnding");
		effects.consume(code$3);
		effects.exit("lineEnding");
		return continuationBefore;
	}
	function continuationBefore(code$3) {
		if (code$3 === null || markdownLineEnding(code$3)) return continuationStart(code$3);
		effects.enter("htmlFlowData");
		return continuation(code$3);
	}
	function continuationCommentInside(code$3) {
		if (code$3 === 45) {
			effects.consume(code$3);
			return continuationDeclarationInside;
		}
		return continuation(code$3);
	}
	function continuationRawTagOpen(code$3) {
		if (code$3 === 47) {
			effects.consume(code$3);
			buffer = "";
			return continuationRawEndTag;
		}
		return continuation(code$3);
	}
	function continuationRawEndTag(code$3) {
		if (code$3 === 62) {
			const name$2 = buffer.toLowerCase();
			if (htmlRawNames.includes(name$2)) {
				effects.consume(code$3);
				return continuationClose;
			}
			return continuation(code$3);
		}
		if (asciiAlpha(code$3) && buffer.length < 8) {
			effects.consume(code$3);
			buffer += String.fromCharCode(code$3);
			return continuationRawEndTag;
		}
		return continuation(code$3);
	}
	function continuationCdataInside(code$3) {
		if (code$3 === 93) {
			effects.consume(code$3);
			return continuationDeclarationInside;
		}
		return continuation(code$3);
	}
	function continuationDeclarationInside(code$3) {
		if (code$3 === 62) {
			effects.consume(code$3);
			return continuationClose;
		}
		if (code$3 === 45 && marker === 2) {
			effects.consume(code$3);
			return continuationDeclarationInside;
		}
		return continuation(code$3);
	}
	function continuationClose(code$3) {
		if (code$3 === null || markdownLineEnding(code$3)) {
			effects.exit("htmlFlowData");
			return continuationAfter(code$3);
		}
		effects.consume(code$3);
		return continuationClose;
	}
	function continuationAfter(code$3) {
		effects.exit("htmlFlow");
		return ok$2(code$3);
	}
}
function tokenizeNonLazyContinuationStart(effects, ok$2, nok) {
	const self$1 = this;
	return start;
	function start(code$3) {
		if (markdownLineEnding(code$3)) {
			effects.enter("lineEnding");
			effects.consume(code$3);
			effects.exit("lineEnding");
			return after;
		}
		return nok(code$3);
	}
	function after(code$3) {
		return self$1.parser.lazy[self$1.now().line] ? nok(code$3) : ok$2(code$3);
	}
}
function tokenizeBlankLineBefore(effects, ok$2, nok) {
	return start;
	function start(code$3) {
		effects.enter("lineEnding");
		effects.consume(code$3);
		effects.exit("lineEnding");
		return effects.attempt(blankLine, ok$2, nok);
	}
}
const htmlText = {
	name: "htmlText",
	tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok$2, nok) {
	const self$1 = this;
	let marker;
	let index$1;
	let returnState;
	return start;
	function start(code$3) {
		effects.enter("htmlText");
		effects.enter("htmlTextData");
		effects.consume(code$3);
		return open;
	}
	function open(code$3) {
		if (code$3 === 33) {
			effects.consume(code$3);
			return declarationOpen;
		}
		if (code$3 === 47) {
			effects.consume(code$3);
			return tagCloseStart;
		}
		if (code$3 === 63) {
			effects.consume(code$3);
			return instruction;
		}
		if (asciiAlpha(code$3)) {
			effects.consume(code$3);
			return tagOpen;
		}
		return nok(code$3);
	}
	function declarationOpen(code$3) {
		if (code$3 === 45) {
			effects.consume(code$3);
			return commentOpenInside;
		}
		if (code$3 === 91) {
			effects.consume(code$3);
			index$1 = 0;
			return cdataOpenInside;
		}
		if (asciiAlpha(code$3)) {
			effects.consume(code$3);
			return declaration;
		}
		return nok(code$3);
	}
	function commentOpenInside(code$3) {
		if (code$3 === 45) {
			effects.consume(code$3);
			return commentEnd;
		}
		return nok(code$3);
	}
	function comment$2(code$3) {
		if (code$3 === null) return nok(code$3);
		if (code$3 === 45) {
			effects.consume(code$3);
			return commentClose;
		}
		if (markdownLineEnding(code$3)) {
			returnState = comment$2;
			return lineEndingBefore(code$3);
		}
		effects.consume(code$3);
		return comment$2;
	}
	function commentClose(code$3) {
		if (code$3 === 45) {
			effects.consume(code$3);
			return commentEnd;
		}
		return comment$2(code$3);
	}
	function commentEnd(code$3) {
		return code$3 === 62 ? end(code$3) : code$3 === 45 ? commentClose(code$3) : comment$2(code$3);
	}
	function cdataOpenInside(code$3) {
		const value = "CDATA[";
		if (code$3 === value.charCodeAt(index$1++)) {
			effects.consume(code$3);
			return index$1 === 6 ? cdata : cdataOpenInside;
		}
		return nok(code$3);
	}
	function cdata(code$3) {
		if (code$3 === null) return nok(code$3);
		if (code$3 === 93) {
			effects.consume(code$3);
			return cdataClose;
		}
		if (markdownLineEnding(code$3)) {
			returnState = cdata;
			return lineEndingBefore(code$3);
		}
		effects.consume(code$3);
		return cdata;
	}
	function cdataClose(code$3) {
		if (code$3 === 93) {
			effects.consume(code$3);
			return cdataEnd;
		}
		return cdata(code$3);
	}
	function cdataEnd(code$3) {
		if (code$3 === 62) return end(code$3);
		if (code$3 === 93) {
			effects.consume(code$3);
			return cdataEnd;
		}
		return cdata(code$3);
	}
	function declaration(code$3) {
		if (code$3 === null || code$3 === 62) return end(code$3);
		if (markdownLineEnding(code$3)) {
			returnState = declaration;
			return lineEndingBefore(code$3);
		}
		effects.consume(code$3);
		return declaration;
	}
	function instruction(code$3) {
		if (code$3 === null) return nok(code$3);
		if (code$3 === 63) {
			effects.consume(code$3);
			return instructionClose;
		}
		if (markdownLineEnding(code$3)) {
			returnState = instruction;
			return lineEndingBefore(code$3);
		}
		effects.consume(code$3);
		return instruction;
	}
	function instructionClose(code$3) {
		return code$3 === 62 ? end(code$3) : instruction(code$3);
	}
	function tagCloseStart(code$3) {
		if (asciiAlpha(code$3)) {
			effects.consume(code$3);
			return tagClose;
		}
		return nok(code$3);
	}
	function tagClose(code$3) {
		if (code$3 === 45 || asciiAlphanumeric(code$3)) {
			effects.consume(code$3);
			return tagClose;
		}
		return tagCloseBetween(code$3);
	}
	function tagCloseBetween(code$3) {
		if (markdownLineEnding(code$3)) {
			returnState = tagCloseBetween;
			return lineEndingBefore(code$3);
		}
		if (markdownSpace(code$3)) {
			effects.consume(code$3);
			return tagCloseBetween;
		}
		return end(code$3);
	}
	function tagOpen(code$3) {
		if (code$3 === 45 || asciiAlphanumeric(code$3)) {
			effects.consume(code$3);
			return tagOpen;
		}
		if (code$3 === 47 || code$3 === 62 || markdownLineEndingOrSpace(code$3)) return tagOpenBetween(code$3);
		return nok(code$3);
	}
	function tagOpenBetween(code$3) {
		if (code$3 === 47) {
			effects.consume(code$3);
			return end;
		}
		if (code$3 === 58 || code$3 === 95 || asciiAlpha(code$3)) {
			effects.consume(code$3);
			return tagOpenAttributeName;
		}
		if (markdownLineEnding(code$3)) {
			returnState = tagOpenBetween;
			return lineEndingBefore(code$3);
		}
		if (markdownSpace(code$3)) {
			effects.consume(code$3);
			return tagOpenBetween;
		}
		return end(code$3);
	}
	function tagOpenAttributeName(code$3) {
		if (code$3 === 45 || code$3 === 46 || code$3 === 58 || code$3 === 95 || asciiAlphanumeric(code$3)) {
			effects.consume(code$3);
			return tagOpenAttributeName;
		}
		return tagOpenAttributeNameAfter(code$3);
	}
	function tagOpenAttributeNameAfter(code$3) {
		if (code$3 === 61) {
			effects.consume(code$3);
			return tagOpenAttributeValueBefore;
		}
		if (markdownLineEnding(code$3)) {
			returnState = tagOpenAttributeNameAfter;
			return lineEndingBefore(code$3);
		}
		if (markdownSpace(code$3)) {
			effects.consume(code$3);
			return tagOpenAttributeNameAfter;
		}
		return tagOpenBetween(code$3);
	}
	function tagOpenAttributeValueBefore(code$3) {
		if (code$3 === null || code$3 === 60 || code$3 === 61 || code$3 === 62 || code$3 === 96) return nok(code$3);
		if (code$3 === 34 || code$3 === 39) {
			effects.consume(code$3);
			marker = code$3;
			return tagOpenAttributeValueQuoted;
		}
		if (markdownLineEnding(code$3)) {
			returnState = tagOpenAttributeValueBefore;
			return lineEndingBefore(code$3);
		}
		if (markdownSpace(code$3)) {
			effects.consume(code$3);
			return tagOpenAttributeValueBefore;
		}
		effects.consume(code$3);
		return tagOpenAttributeValueUnquoted;
	}
	function tagOpenAttributeValueQuoted(code$3) {
		if (code$3 === marker) {
			effects.consume(code$3);
			marker = void 0;
			return tagOpenAttributeValueQuotedAfter;
		}
		if (code$3 === null) return nok(code$3);
		if (markdownLineEnding(code$3)) {
			returnState = tagOpenAttributeValueQuoted;
			return lineEndingBefore(code$3);
		}
		effects.consume(code$3);
		return tagOpenAttributeValueQuoted;
	}
	function tagOpenAttributeValueUnquoted(code$3) {
		if (code$3 === null || code$3 === 34 || code$3 === 39 || code$3 === 60 || code$3 === 61 || code$3 === 96) return nok(code$3);
		if (code$3 === 47 || code$3 === 62 || markdownLineEndingOrSpace(code$3)) return tagOpenBetween(code$3);
		effects.consume(code$3);
		return tagOpenAttributeValueUnquoted;
	}
	function tagOpenAttributeValueQuotedAfter(code$3) {
		if (code$3 === 47 || code$3 === 62 || markdownLineEndingOrSpace(code$3)) return tagOpenBetween(code$3);
		return nok(code$3);
	}
	function end(code$3) {
		if (code$3 === 62) {
			effects.consume(code$3);
			effects.exit("htmlTextData");
			effects.exit("htmlText");
			return ok$2;
		}
		return nok(code$3);
	}
	function lineEndingBefore(code$3) {
		effects.exit("htmlTextData");
		effects.enter("lineEnding");
		effects.consume(code$3);
		effects.exit("lineEnding");
		return lineEndingAfter;
	}
	function lineEndingAfter(code$3) {
		return markdownSpace(code$3) ? factorySpace(effects, lineEndingAfterPrefix, "linePrefix", self$1.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code$3) : lineEndingAfterPrefix(code$3);
	}
	function lineEndingAfterPrefix(code$3) {
		effects.enter("htmlTextData");
		return returnState(code$3);
	}
}
const labelEnd = {
	name: "labelEnd",
	resolveAll: resolveAllLabelEnd,
	resolveTo: resolveToLabelEnd,
	tokenize: tokenizeLabelEnd
};
const resourceConstruct = { tokenize: tokenizeResource };
const referenceFullConstruct = { tokenize: tokenizeReferenceFull };
const referenceCollapsedConstruct = { tokenize: tokenizeReferenceCollapsed };
function resolveAllLabelEnd(events) {
	let index$1 = -1;
	const newEvents = [];
	while (++index$1 < events.length) {
		const token = events[index$1][1];
		newEvents.push(events[index$1]);
		if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
			const offset = token.type === "labelImage" ? 4 : 2;
			token.type = "data";
			index$1 += offset;
		}
	}
	if (events.length !== newEvents.length) splice(events, 0, events.length, newEvents);
	return events;
}
function resolveToLabelEnd(events, context) {
	let index$1 = events.length;
	let offset = 0;
	let token;
	let open;
	let close;
	let media;
	while (index$1--) {
		token = events[index$1][1];
		if (open) {
			if (token.type === "link" || token.type === "labelLink" && token._inactive) break;
			if (events[index$1][0] === "enter" && token.type === "labelLink") token._inactive = true;
		} else if (close) {
			if (events[index$1][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
				open = index$1;
				if (token.type !== "labelLink") {
					offset = 2;
					break;
				}
			}
		} else if (token.type === "labelEnd") close = index$1;
	}
	const group = {
		type: events[open][1].type === "labelLink" ? "link" : "image",
		start: { ...events[open][1].start },
		end: { ...events[events.length - 1][1].end }
	};
	const label = {
		type: "label",
		start: { ...events[open][1].start },
		end: { ...events[close][1].end }
	};
	const text$8 = {
		type: "labelText",
		start: { ...events[open + offset + 2][1].end },
		end: { ...events[close - 2][1].start }
	};
	media = [[
		"enter",
		group,
		context
	], [
		"enter",
		label,
		context
	]];
	media = push(media, events.slice(open + 1, open + offset + 3));
	media = push(media, [[
		"enter",
		text$8,
		context
	]]);
	media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context));
	media = push(media, [
		[
			"exit",
			text$8,
			context
		],
		events[close - 2],
		events[close - 1],
		[
			"exit",
			label,
			context
		]
	]);
	media = push(media, events.slice(close + 1));
	media = push(media, [[
		"exit",
		group,
		context
	]]);
	splice(events, open, events.length, media);
	return events;
}
function tokenizeLabelEnd(effects, ok$2, nok) {
	const self$1 = this;
	let index$1 = self$1.events.length;
	let labelStart;
	let defined;
	while (index$1--) if ((self$1.events[index$1][1].type === "labelImage" || self$1.events[index$1][1].type === "labelLink") && !self$1.events[index$1][1]._balanced) {
		labelStart = self$1.events[index$1][1];
		break;
	}
	return start;
	function start(code$3) {
		if (!labelStart) return nok(code$3);
		if (labelStart._inactive) return labelEndNok(code$3);
		defined = self$1.parser.defined.includes(normalizeIdentifier(self$1.sliceSerialize({
			start: labelStart.end,
			end: self$1.now()
		})));
		effects.enter("labelEnd");
		effects.enter("labelMarker");
		effects.consume(code$3);
		effects.exit("labelMarker");
		effects.exit("labelEnd");
		return after;
	}
	function after(code$3) {
		if (code$3 === 40) return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code$3);
		if (code$3 === 91) return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code$3);
		return defined ? labelEndOk(code$3) : labelEndNok(code$3);
	}
	function referenceNotFull(code$3) {
		return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code$3);
	}
	function labelEndOk(code$3) {
		return ok$2(code$3);
	}
	function labelEndNok(code$3) {
		labelStart._balanced = true;
		return nok(code$3);
	}
}
function tokenizeResource(effects, ok$2, nok) {
	return resourceStart;
	function resourceStart(code$3) {
		effects.enter("resource");
		effects.enter("resourceMarker");
		effects.consume(code$3);
		effects.exit("resourceMarker");
		return resourceBefore;
	}
	function resourceBefore(code$3) {
		return markdownLineEndingOrSpace(code$3) ? factoryWhitespace(effects, resourceOpen)(code$3) : resourceOpen(code$3);
	}
	function resourceOpen(code$3) {
		if (code$3 === 41) return resourceEnd(code$3);
		return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code$3);
	}
	function resourceDestinationAfter(code$3) {
		return markdownLineEndingOrSpace(code$3) ? factoryWhitespace(effects, resourceBetween)(code$3) : resourceEnd(code$3);
	}
	function resourceDestinationMissing(code$3) {
		return nok(code$3);
	}
	function resourceBetween(code$3) {
		if (code$3 === 34 || code$3 === 39 || code$3 === 40) return factoryTitle(effects, resourceTitleAfter, nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code$3);
		return resourceEnd(code$3);
	}
	function resourceTitleAfter(code$3) {
		return markdownLineEndingOrSpace(code$3) ? factoryWhitespace(effects, resourceEnd)(code$3) : resourceEnd(code$3);
	}
	function resourceEnd(code$3) {
		if (code$3 === 41) {
			effects.enter("resourceMarker");
			effects.consume(code$3);
			effects.exit("resourceMarker");
			effects.exit("resource");
			return ok$2;
		}
		return nok(code$3);
	}
}
function tokenizeReferenceFull(effects, ok$2, nok) {
	const self$1 = this;
	return referenceFull;
	function referenceFull(code$3) {
		return factoryLabel.call(self$1, effects, referenceFullAfter, referenceFullMissing, "reference", "referenceMarker", "referenceString")(code$3);
	}
	function referenceFullAfter(code$3) {
		return self$1.parser.defined.includes(normalizeIdentifier(self$1.sliceSerialize(self$1.events[self$1.events.length - 1][1]).slice(1, -1))) ? ok$2(code$3) : nok(code$3);
	}
	function referenceFullMissing(code$3) {
		return nok(code$3);
	}
}
function tokenizeReferenceCollapsed(effects, ok$2, nok) {
	return referenceCollapsedStart;
	function referenceCollapsedStart(code$3) {
		effects.enter("reference");
		effects.enter("referenceMarker");
		effects.consume(code$3);
		effects.exit("referenceMarker");
		return referenceCollapsedOpen;
	}
	function referenceCollapsedOpen(code$3) {
		if (code$3 === 93) {
			effects.enter("referenceMarker");
			effects.consume(code$3);
			effects.exit("referenceMarker");
			effects.exit("reference");
			return ok$2;
		}
		return nok(code$3);
	}
}
const labelStartImage = {
	name: "labelStartImage",
	resolveAll: labelEnd.resolveAll,
	tokenize: tokenizeLabelStartImage
};
function tokenizeLabelStartImage(effects, ok$2, nok) {
	const self$1 = this;
	return start;
	function start(code$3) {
		effects.enter("labelImage");
		effects.enter("labelImageMarker");
		effects.consume(code$3);
		effects.exit("labelImageMarker");
		return open;
	}
	function open(code$3) {
		if (code$3 === 91) {
			effects.enter("labelMarker");
			effects.consume(code$3);
			effects.exit("labelMarker");
			effects.exit("labelImage");
			return after;
		}
		return nok(code$3);
	}
	function after(code$3) {
		return code$3 === 94 && "_hiddenFootnoteSupport" in self$1.parser.constructs ? nok(code$3) : ok$2(code$3);
	}
}
const labelStartLink = {
	name: "labelStartLink",
	resolveAll: labelEnd.resolveAll,
	tokenize: tokenizeLabelStartLink
};
function tokenizeLabelStartLink(effects, ok$2, nok) {
	const self$1 = this;
	return start;
	function start(code$3) {
		effects.enter("labelLink");
		effects.enter("labelMarker");
		effects.consume(code$3);
		effects.exit("labelMarker");
		effects.exit("labelLink");
		return after;
	}
	function after(code$3) {
		return code$3 === 94 && "_hiddenFootnoteSupport" in self$1.parser.constructs ? nok(code$3) : ok$2(code$3);
	}
}
const lineEnding = {
	name: "lineEnding",
	tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok$2) {
	return start;
	function start(code$3) {
		effects.enter("lineEnding");
		effects.consume(code$3);
		effects.exit("lineEnding");
		return factorySpace(effects, ok$2, "linePrefix");
	}
}
const thematicBreak$2 = {
	name: "thematicBreak",
	tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok$2, nok) {
	let size = 0;
	let marker;
	return start;
	function start(code$3) {
		effects.enter("thematicBreak");
		return before(code$3);
	}
	function before(code$3) {
		marker = code$3;
		return atBreak(code$3);
	}
	function atBreak(code$3) {
		if (code$3 === marker) {
			effects.enter("thematicBreakSequence");
			return sequence(code$3);
		}
		if (size >= 3 && (code$3 === null || markdownLineEnding(code$3))) {
			effects.exit("thematicBreak");
			return ok$2(code$3);
		}
		return nok(code$3);
	}
	function sequence(code$3) {
		if (code$3 === marker) {
			effects.consume(code$3);
			size++;
			return sequence;
		}
		effects.exit("thematicBreakSequence");
		return markdownSpace(code$3) ? factorySpace(effects, atBreak, "whitespace")(code$3) : atBreak(code$3);
	}
}
const list$2 = {
	continuation: { tokenize: tokenizeListContinuation },
	exit: tokenizeListEnd,
	name: "list",
	tokenize: tokenizeListStart
};
const listItemPrefixWhitespaceConstruct = {
	partial: true,
	tokenize: tokenizeListItemPrefixWhitespace
};
const indentConstruct = {
	partial: true,
	tokenize: tokenizeIndent$1
};
function tokenizeListStart(effects, ok$2, nok) {
	const self$1 = this;
	const tail = self$1.events[self$1.events.length - 1];
	let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
	let size = 0;
	return start;
	function start(code$3) {
		const kind = self$1.containerState.type || (code$3 === 42 || code$3 === 43 || code$3 === 45 ? "listUnordered" : "listOrdered");
		if (kind === "listUnordered" ? !self$1.containerState.marker || code$3 === self$1.containerState.marker : asciiDigit(code$3)) {
			if (!self$1.containerState.type) {
				self$1.containerState.type = kind;
				effects.enter(kind, { _container: true });
			}
			if (kind === "listUnordered") {
				effects.enter("listItemPrefix");
				return code$3 === 42 || code$3 === 45 ? effects.check(thematicBreak$2, nok, atMarker)(code$3) : atMarker(code$3);
			}
			if (!self$1.interrupt || code$3 === 49) {
				effects.enter("listItemPrefix");
				effects.enter("listItemValue");
				return inside(code$3);
			}
		}
		return nok(code$3);
	}
	function inside(code$3) {
		if (asciiDigit(code$3) && ++size < 10) {
			effects.consume(code$3);
			return inside;
		}
		if ((!self$1.interrupt || size < 2) && (self$1.containerState.marker ? code$3 === self$1.containerState.marker : code$3 === 41 || code$3 === 46)) {
			effects.exit("listItemValue");
			return atMarker(code$3);
		}
		return nok(code$3);
	}
	function atMarker(code$3) {
		effects.enter("listItemMarker");
		effects.consume(code$3);
		effects.exit("listItemMarker");
		self$1.containerState.marker = self$1.containerState.marker || code$3;
		return effects.check(blankLine, self$1.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));
	}
	function onBlank(code$3) {
		self$1.containerState.initialBlankLine = true;
		initialSize++;
		return endOfPrefix(code$3);
	}
	function otherPrefix(code$3) {
		if (markdownSpace(code$3)) {
			effects.enter("listItemPrefixWhitespace");
			effects.consume(code$3);
			effects.exit("listItemPrefixWhitespace");
			return endOfPrefix;
		}
		return nok(code$3);
	}
	function endOfPrefix(code$3) {
		self$1.containerState.size = initialSize + self$1.sliceSerialize(effects.exit("listItemPrefix"), true).length;
		return ok$2(code$3);
	}
}
function tokenizeListContinuation(effects, ok$2, nok) {
	const self$1 = this;
	self$1.containerState._closeFlow = void 0;
	return effects.check(blankLine, onBlank, notBlank);
	function onBlank(code$3) {
		self$1.containerState.furtherBlankLines = self$1.containerState.furtherBlankLines || self$1.containerState.initialBlankLine;
		return factorySpace(effects, ok$2, "listItemIndent", self$1.containerState.size + 1)(code$3);
	}
	function notBlank(code$3) {
		if (self$1.containerState.furtherBlankLines || !markdownSpace(code$3)) {
			self$1.containerState.furtherBlankLines = void 0;
			self$1.containerState.initialBlankLine = void 0;
			return notInCurrentItem(code$3);
		}
		self$1.containerState.furtherBlankLines = void 0;
		self$1.containerState.initialBlankLine = void 0;
		return effects.attempt(indentConstruct, ok$2, notInCurrentItem)(code$3);
	}
	function notInCurrentItem(code$3) {
		self$1.containerState._closeFlow = true;
		self$1.interrupt = void 0;
		return factorySpace(effects, effects.attempt(list$2, ok$2, nok), "linePrefix", self$1.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code$3);
	}
}
function tokenizeIndent$1(effects, ok$2, nok) {
	const self$1 = this;
	return factorySpace(effects, afterPrefix, "listItemIndent", self$1.containerState.size + 1);
	function afterPrefix(code$3) {
		const tail = self$1.events[self$1.events.length - 1];
		return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self$1.containerState.size ? ok$2(code$3) : nok(code$3);
	}
}
function tokenizeListEnd(effects) {
	effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok$2, nok) {
	const self$1 = this;
	return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self$1.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
	function afterPrefix(code$3) {
		const tail = self$1.events[self$1.events.length - 1];
		return !markdownSpace(code$3) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok$2(code$3) : nok(code$3);
	}
}
const setextUnderline = {
	name: "setextUnderline",
	resolveTo: resolveToSetextUnderline,
	tokenize: tokenizeSetextUnderline
};
function resolveToSetextUnderline(events, context) {
	let index$1 = events.length;
	let content$2;
	let text$8;
	let definition$2;
	while (index$1--) if (events[index$1][0] === "enter") {
		if (events[index$1][1].type === "content") {
			content$2 = index$1;
			break;
		}
		if (events[index$1][1].type === "paragraph") text$8 = index$1;
	} else {
		if (events[index$1][1].type === "content") events.splice(index$1, 1);
		if (!definition$2 && events[index$1][1].type === "definition") definition$2 = index$1;
	}
	const heading$2 = {
		type: "setextHeading",
		start: { ...events[content$2][1].start },
		end: { ...events[events.length - 1][1].end }
	};
	events[text$8][1].type = "setextHeadingText";
	if (definition$2) {
		events.splice(text$8, 0, [
			"enter",
			heading$2,
			context
		]);
		events.splice(definition$2 + 1, 0, [
			"exit",
			events[content$2][1],
			context
		]);
		events[content$2][1].end = { ...events[definition$2][1].end };
	} else events[content$2][1] = heading$2;
	events.push([
		"exit",
		heading$2,
		context
	]);
	return events;
}
function tokenizeSetextUnderline(effects, ok$2, nok) {
	const self$1 = this;
	let marker;
	return start;
	function start(code$3) {
		let index$1 = self$1.events.length;
		let paragraph$2;
		while (index$1--) if (self$1.events[index$1][1].type !== "lineEnding" && self$1.events[index$1][1].type !== "linePrefix" && self$1.events[index$1][1].type !== "content") {
			paragraph$2 = self$1.events[index$1][1].type === "paragraph";
			break;
		}
		if (!self$1.parser.lazy[self$1.now().line] && (self$1.interrupt || paragraph$2)) {
			effects.enter("setextHeadingLine");
			marker = code$3;
			return before(code$3);
		}
		return nok(code$3);
	}
	function before(code$3) {
		effects.enter("setextHeadingLineSequence");
		return inside(code$3);
	}
	function inside(code$3) {
		if (code$3 === marker) {
			effects.consume(code$3);
			return inside;
		}
		effects.exit("setextHeadingLineSequence");
		return markdownSpace(code$3) ? factorySpace(effects, after, "lineSuffix")(code$3) : after(code$3);
	}
	function after(code$3) {
		if (code$3 === null || markdownLineEnding(code$3)) {
			effects.exit("setextHeadingLine");
			return ok$2(code$3);
		}
		return nok(code$3);
	}
}
const flow = { tokenize: initializeFlow };
function initializeFlow(effects) {
	const self$1 = this;
	const initial = effects.attempt(blankLine, atBlankEnding, effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content$1, afterConstruct)), "linePrefix")));
	return initial;
	function atBlankEnding(code$3) {
		if (code$3 === null) {
			effects.consume(code$3);
			return;
		}
		effects.enter("lineEndingBlank");
		effects.consume(code$3);
		effects.exit("lineEndingBlank");
		self$1.currentConstruct = void 0;
		return initial;
	}
	function afterConstruct(code$3) {
		if (code$3 === null) {
			effects.consume(code$3);
			return;
		}
		effects.enter("lineEnding");
		effects.consume(code$3);
		effects.exit("lineEnding");
		self$1.currentConstruct = void 0;
		return initial;
	}
}
const resolver = { resolveAll: createResolver() };
const string = initializeFactory("string");
const text$3 = initializeFactory("text");
function initializeFactory(field) {
	return {
		resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0),
		tokenize: initializeText
	};
	function initializeText(effects) {
		const self$1 = this;
		const constructs$1 = this.parser.constructs[field];
		const text$8 = effects.attempt(constructs$1, start, notText);
		return start;
		function start(code$3) {
			return atBreak(code$3) ? text$8(code$3) : notText(code$3);
		}
		function notText(code$3) {
			if (code$3 === null) {
				effects.consume(code$3);
				return;
			}
			effects.enter("data");
			effects.consume(code$3);
			return data;
		}
		function data(code$3) {
			if (atBreak(code$3)) {
				effects.exit("data");
				return text$8(code$3);
			}
			effects.consume(code$3);
			return data;
		}
		function atBreak(code$3) {
			if (code$3 === null) return true;
			const list$3 = constructs$1[code$3];
			let index$1 = -1;
			if (list$3) while (++index$1 < list$3.length) {
				const item = list$3[index$1];
				if (!item.previous || item.previous.call(self$1, self$1.previous)) return true;
			}
			return false;
		}
	}
}
function createResolver(extraResolver) {
	return resolveAllText;
	function resolveAllText(events, context) {
		let index$1 = -1;
		let enter;
		while (++index$1 <= events.length) if (enter === void 0) {
			if (events[index$1] && events[index$1][1].type === "data") {
				enter = index$1;
				index$1++;
			}
		} else if (!events[index$1] || events[index$1][1].type !== "data") {
			if (index$1 !== enter + 2) {
				events[enter][1].end = events[index$1 - 1][1].end;
				events.splice(enter + 2, index$1 - enter - 2);
				index$1 = enter + 2;
			}
			enter = void 0;
		}
		return extraResolver ? extraResolver(events, context) : events;
	}
}
function resolveAllLineSuffixes(events, context) {
	let eventIndex = 0;
	while (++eventIndex <= events.length) if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
		const data = events[eventIndex - 1][1];
		const chunks = context.sliceStream(data);
		let index$1 = chunks.length;
		let bufferIndex = -1;
		let size = 0;
		let tabs;
		while (index$1--) {
			const chunk = chunks[index$1];
			if (typeof chunk === "string") {
				bufferIndex = chunk.length;
				while (chunk.charCodeAt(bufferIndex - 1) === 32) {
					size++;
					bufferIndex--;
				}
				if (bufferIndex) break;
				bufferIndex = -1;
			} else if (chunk === -2) {
				tabs = true;
				size++;
			} else if (chunk === -1) {} else {
				index$1++;
				break;
			}
		}
		if (context._contentTypeTextTrailing && eventIndex === events.length) size = 0;
		if (size) {
			const token = {
				type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
				start: {
					_bufferIndex: index$1 ? bufferIndex : data.start._bufferIndex + bufferIndex,
					_index: data.start._index + index$1,
					line: data.end.line,
					column: data.end.column - size,
					offset: data.end.offset - size
				},
				end: { ...data.end }
			};
			data.end = { ...token.start };
			if (data.start.offset === data.end.offset) Object.assign(data, token);
			else {
				events.splice(eventIndex, 0, [
					"enter",
					token,
					context
				], [
					"exit",
					token,
					context
				]);
				eventIndex += 2;
			}
		}
		eventIndex++;
	}
	return events;
}
var constructs_exports = {};
__export(constructs_exports, {
	attentionMarkers: () => attentionMarkers,
	contentInitial: () => contentInitial,
	disable: () => disable,
	document: () => document$2,
	flow: () => flow$1,
	flowInitial: () => flowInitial,
	insideSpan: () => insideSpan,
	string: () => string$1,
	text: () => text$4
});
const document$2 = {
	[42]: list$2,
	[43]: list$2,
	[45]: list$2,
	[48]: list$2,
	[49]: list$2,
	[50]: list$2,
	[51]: list$2,
	[52]: list$2,
	[53]: list$2,
	[54]: list$2,
	[55]: list$2,
	[56]: list$2,
	[57]: list$2,
	[62]: blockQuote
};
const contentInitial = { [91]: definition$1 };
const flowInitial = {
	[-2]: codeIndented,
	[-1]: codeIndented,
	[32]: codeIndented
};
const flow$1 = {
	[35]: headingAtx,
	[42]: thematicBreak$2,
	[45]: [setextUnderline, thematicBreak$2],
	[60]: htmlFlow,
	[61]: setextUnderline,
	[95]: thematicBreak$2,
	[96]: codeFenced,
	[126]: codeFenced
};
const string$1 = {
	[38]: characterReference,
	[92]: characterEscape
};
const text$4 = {
	[-5]: lineEnding,
	[-4]: lineEnding,
	[-3]: lineEnding,
	[33]: labelStartImage,
	[38]: characterReference,
	[42]: attention,
	[60]: [autolink, htmlText],
	[91]: labelStartLink,
	[92]: [hardBreakEscape, characterEscape],
	[93]: labelEnd,
	[95]: attention,
	[96]: codeText
};
const insideSpan = { null: [attention, resolver] };
const attentionMarkers = { null: [42, 95] };
const disable = { null: [] };
function createTokenizer(parser$1, initialize, from) {
	let point$4 = {
		_bufferIndex: -1,
		_index: 0,
		line: from && from.line || 1,
		column: from && from.column || 1,
		offset: from && from.offset || 0
	};
	const columnStart = {};
	const resolveAllConstructs = [];
	let chunks = [];
	let stack = [];
	let consumed = true;
	const effects = {
		attempt: constructFactory(onsuccessfulconstruct),
		check: constructFactory(onsuccessfulcheck),
		consume,
		enter,
		exit: exit$2,
		interrupt: constructFactory(onsuccessfulcheck, { interrupt: true })
	};
	const context = {
		code: null,
		containerState: {},
		defineSkip,
		events: [],
		now,
		parser: parser$1,
		previous: null,
		sliceSerialize,
		sliceStream,
		write
	};
	let state = initialize.tokenize.call(context, effects);
	let expectedCode;
	if (initialize.resolveAll) resolveAllConstructs.push(initialize);
	return context;
	function write(slice) {
		chunks = push(chunks, slice);
		main();
		if (chunks[chunks.length - 1] !== null) return [];
		addResult(initialize, 0);
		context.events = resolveAll(resolveAllConstructs, context.events, context);
		return context.events;
	}
	function sliceSerialize(token, expandTabs) {
		return serializeChunks(sliceStream(token), expandTabs);
	}
	function sliceStream(token) {
		return sliceChunks(chunks, token);
	}
	function now() {
		const { _bufferIndex, _index, line, column, offset } = point$4;
		return {
			_bufferIndex,
			_index,
			line,
			column,
			offset
		};
	}
	function defineSkip(value) {
		columnStart[value.line] = value.column;
		accountForPotentialSkip();
	}
	function main() {
		let chunkIndex;
		while (point$4._index < chunks.length) {
			const chunk = chunks[point$4._index];
			if (typeof chunk === "string") {
				chunkIndex = point$4._index;
				if (point$4._bufferIndex < 0) point$4._bufferIndex = 0;
				while (point$4._index === chunkIndex && point$4._bufferIndex < chunk.length) go$1(chunk.charCodeAt(point$4._bufferIndex));
			} else go$1(chunk);
		}
	}
	function go$1(code$3) {
		consumed = void 0;
		expectedCode = code$3;
		state = state(code$3);
	}
	function consume(code$3) {
		if (markdownLineEnding(code$3)) {
			point$4.line++;
			point$4.column = 1;
			point$4.offset += code$3 === -3 ? 2 : 1;
			accountForPotentialSkip();
		} else if (code$3 !== -1) {
			point$4.column++;
			point$4.offset++;
		}
		if (point$4._bufferIndex < 0) point$4._index++;
		else {
			point$4._bufferIndex++;
			if (point$4._bufferIndex === chunks[point$4._index].length) {
				point$4._bufferIndex = -1;
				point$4._index++;
			}
		}
		context.previous = code$3;
		consumed = true;
	}
	function enter(type, fields) {
		const token = fields || {};
		token.type = type;
		token.start = now();
		context.events.push([
			"enter",
			token,
			context
		]);
		stack.push(token);
		return token;
	}
	function exit$2(type) {
		const token = stack.pop();
		token.end = now();
		context.events.push([
			"exit",
			token,
			context
		]);
		return token;
	}
	function onsuccessfulconstruct(construct, info) {
		addResult(construct, info.from);
	}
	function onsuccessfulcheck(_$1, info) {
		info.restore();
	}
	function constructFactory(onreturn, fields) {
		return hook;
		function hook(constructs$1, returnState, bogusState) {
			let listOfConstructs;
			let constructIndex;
			let currentConstruct;
			let info;
			return Array.isArray(constructs$1) ? handleListOfConstructs(constructs$1) : "tokenize" in constructs$1 ? handleListOfConstructs([constructs$1]) : handleMapOfConstructs(constructs$1);
			function handleMapOfConstructs(map$2) {
				return start;
				function start(code$3) {
					const left = code$3 !== null && map$2[code$3];
					const all$6 = code$3 !== null && map$2.null;
					const list$3 = [...Array.isArray(left) ? left : left ? [left] : [], ...Array.isArray(all$6) ? all$6 : all$6 ? [all$6] : []];
					return handleListOfConstructs(list$3)(code$3);
				}
			}
			function handleListOfConstructs(list$3) {
				listOfConstructs = list$3;
				constructIndex = 0;
				if (list$3.length === 0) return bogusState;
				return handleConstruct(list$3[constructIndex]);
			}
			function handleConstruct(construct) {
				return start;
				function start(code$3) {
					info = store();
					currentConstruct = construct;
					if (!construct.partial) context.currentConstruct = construct;
					if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) return nok(code$3);
					return construct.tokenize.call(fields ? Object.assign(Object.create(context), fields) : context, effects, ok$2, nok)(code$3);
				}
			}
			function ok$2(code$3) {
				consumed = true;
				onreturn(currentConstruct, info);
				return returnState;
			}
			function nok(code$3) {
				consumed = true;
				info.restore();
				if (++constructIndex < listOfConstructs.length) return handleConstruct(listOfConstructs[constructIndex]);
				return bogusState;
			}
		}
	}
	function addResult(construct, from$1) {
		if (construct.resolveAll && !resolveAllConstructs.includes(construct)) resolveAllConstructs.push(construct);
		if (construct.resolve) splice(context.events, from$1, context.events.length - from$1, construct.resolve(context.events.slice(from$1), context));
		if (construct.resolveTo) context.events = construct.resolveTo(context.events, context);
	}
	function store() {
		const startPoint = now();
		const startPrevious = context.previous;
		const startCurrentConstruct = context.currentConstruct;
		const startEventsIndex = context.events.length;
		const startStack = Array.from(stack);
		return {
			from: startEventsIndex,
			restore
		};
		function restore() {
			point$4 = startPoint;
			context.previous = startPrevious;
			context.currentConstruct = startCurrentConstruct;
			context.events.length = startEventsIndex;
			stack = startStack;
			accountForPotentialSkip();
		}
	}
	function accountForPotentialSkip() {
		if (point$4.line in columnStart && point$4.column < 2) {
			point$4.column = columnStart[point$4.line];
			point$4.offset += columnStart[point$4.line] - 1;
		}
	}
}
function sliceChunks(chunks, token) {
	const startIndex = token.start._index;
	const startBufferIndex = token.start._bufferIndex;
	const endIndex = token.end._index;
	const endBufferIndex = token.end._bufferIndex;
	let view;
	if (startIndex === endIndex) view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
	else {
		view = chunks.slice(startIndex, endIndex);
		if (startBufferIndex > -1) {
			const head = view[0];
			if (typeof head === "string") view[0] = head.slice(startBufferIndex);
			else view.shift();
		}
		if (endBufferIndex > 0) view.push(chunks[endIndex].slice(0, endBufferIndex));
	}
	return view;
}
function serializeChunks(chunks, expandTabs) {
	let index$1 = -1;
	const result = [];
	let atTab;
	while (++index$1 < chunks.length) {
		const chunk = chunks[index$1];
		let value;
		if (typeof chunk === "string") value = chunk;
		else switch (chunk) {
			case -5: {
				value = "\r";
				break;
			}
			case -4: {
				value = "\n";
				break;
			}
			case -3: {
				value = "\r\n";
				break;
			}
			case -2: {
				value = expandTabs ? " " : "	";
				break;
			}
			case -1: {
				if (!expandTabs && atTab) continue;
				value = " ";
				break;
			}
			default: value = String.fromCharCode(chunk);
		}
		atTab = chunk === -2;
		result.push(value);
	}
	return result.join("");
}
function parse(options) {
	const settings = options || {};
	const constructs$1 = combineExtensions([constructs_exports, ...settings.extensions || []]);
	const parser$1 = {
		constructs: constructs$1,
		content: create$3(content),
		defined: [],
		document: create$3(document$1),
		flow: create$3(flow),
		lazy: {},
		string: create$3(string),
		text: create$3(text$3)
	};
	return parser$1;
	function create$3(initial) {
		return creator;
		function creator(from) {
			return createTokenizer(parser$1, initial, from);
		}
	}
}
function postprocess(events) {
	while (!subtokenize(events));
	return events;
}
const search = /[\0\t\n\r]/g;
function preprocess() {
	let column = 1;
	let buffer = "";
	let start = true;
	let atCarriageReturn;
	return preprocessor;
	function preprocessor(value, encoding, end) {
		const chunks = [];
		let match;
		let next$1;
		let startPosition;
		let endPosition;
		let code$3;
		value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
		startPosition = 0;
		buffer = "";
		if (start) {
			if (value.charCodeAt(0) === 65279) startPosition++;
			start = void 0;
		}
		while (startPosition < value.length) {
			search.lastIndex = startPosition;
			match = search.exec(value);
			endPosition = match && match.index !== void 0 ? match.index : value.length;
			code$3 = value.charCodeAt(endPosition);
			if (!match) {
				buffer = value.slice(startPosition);
				break;
			}
			if (code$3 === 10 && startPosition === endPosition && atCarriageReturn) {
				chunks.push(-3);
				atCarriageReturn = void 0;
			} else {
				if (atCarriageReturn) {
					chunks.push(-5);
					atCarriageReturn = void 0;
				}
				if (startPosition < endPosition) {
					chunks.push(value.slice(startPosition, endPosition));
					column += endPosition - startPosition;
				}
				switch (code$3) {
					case 0: {
						chunks.push(65533);
						column++;
						break;
					}
					case 9: {
						next$1 = Math.ceil(column / 4) * 4;
						chunks.push(-2);
						while (column++ < next$1) chunks.push(-1);
						break;
					}
					case 10: {
						chunks.push(-4);
						column = 1;
						break;
					}
					default: {
						atCarriageReturn = true;
						column = 1;
					}
				}
			}
			startPosition = endPosition + 1;
		}
		if (end) {
			if (atCarriageReturn) chunks.push(-5);
			if (buffer) chunks.push(buffer);
			chunks.push(null);
		}
		return chunks;
	}
}
const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
	return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
	if ($1) return $1;
	const head = $2.charCodeAt(0);
	if (head === 35) {
		const head$1 = $2.charCodeAt(1);
		const hex = head$1 === 120 || head$1 === 88;
		return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
	}
	return decodeNamedCharacterReference($2) || $0;
}
const own$3 = {}.hasOwnProperty;
function fromMarkdown(value, encoding, options) {
	if (typeof encoding !== "string") {
		options = encoding;
		encoding = void 0;
	}
	return compiler(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, true))));
}
function compiler(options) {
	const config = {
		transforms: [],
		canContainEols: [
			"emphasis",
			"fragment",
			"heading",
			"paragraph",
			"strong"
		],
		enter: {
			autolink: opener(link$2),
			autolinkProtocol: onenterdata,
			autolinkEmail: onenterdata,
			atxHeading: opener(heading$2),
			blockQuote: opener(blockQuote$1),
			characterEscape: onenterdata,
			characterReference: onenterdata,
			codeFenced: opener(codeFlow),
			codeFencedFenceInfo: buffer,
			codeFencedFenceMeta: buffer,
			codeIndented: opener(codeFlow, buffer),
			codeText: opener(codeText$1, buffer),
			codeTextData: onenterdata,
			data: onenterdata,
			codeFlowValue: onenterdata,
			definition: opener(definition$2),
			definitionDestinationString: buffer,
			definitionLabelString: buffer,
			definitionTitleString: buffer,
			emphasis: opener(emphasis$2),
			hardBreakEscape: opener(hardBreak$2),
			hardBreakTrailing: opener(hardBreak$2),
			htmlFlow: opener(html$6, buffer),
			htmlFlowData: onenterdata,
			htmlText: opener(html$6, buffer),
			htmlTextData: onenterdata,
			image: opener(image$2),
			label: buffer,
			link: opener(link$2),
			listItem: opener(listItem$2),
			listItemValue: onenterlistitemvalue,
			listOrdered: opener(list$3, onenterlistordered),
			listUnordered: opener(list$3),
			paragraph: opener(paragraph$2),
			reference: onenterreference,
			referenceString: buffer,
			resourceDestinationString: buffer,
			resourceTitleString: buffer,
			setextHeading: opener(heading$2),
			strong: opener(strong$2),
			thematicBreak: opener(thematicBreak$3)
		},
		exit: {
			atxHeading: closer(),
			atxHeadingSequence: onexitatxheadingsequence,
			autolink: closer(),
			autolinkEmail: onexitautolinkemail,
			autolinkProtocol: onexitautolinkprotocol,
			blockQuote: closer(),
			characterEscapeValue: onexitdata,
			characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
			characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
			characterReferenceValue: onexitcharacterreferencevalue,
			characterReference: onexitcharacterreference,
			codeFenced: closer(onexitcodefenced),
			codeFencedFence: onexitcodefencedfence,
			codeFencedFenceInfo: onexitcodefencedfenceinfo,
			codeFencedFenceMeta: onexitcodefencedfencemeta,
			codeFlowValue: onexitdata,
			codeIndented: closer(onexitcodeindented),
			codeText: closer(onexitcodetext),
			codeTextData: onexitdata,
			data: onexitdata,
			definition: closer(),
			definitionDestinationString: onexitdefinitiondestinationstring,
			definitionLabelString: onexitdefinitionlabelstring,
			definitionTitleString: onexitdefinitiontitlestring,
			emphasis: closer(),
			hardBreakEscape: closer(onexithardbreak),
			hardBreakTrailing: closer(onexithardbreak),
			htmlFlow: closer(onexithtmlflow),
			htmlFlowData: onexitdata,
			htmlText: closer(onexithtmltext),
			htmlTextData: onexitdata,
			image: closer(onexitimage),
			label: onexitlabel,
			labelText: onexitlabeltext,
			lineEnding: onexitlineending,
			link: closer(onexitlink),
			listItem: closer(),
			listOrdered: closer(),
			listUnordered: closer(),
			paragraph: closer(),
			referenceString: onexitreferencestring,
			resourceDestinationString: onexitresourcedestinationstring,
			resourceTitleString: onexitresourcetitlestring,
			resource: onexitresource,
			setextHeading: closer(onexitsetextheading),
			setextHeadingLineSequence: onexitsetextheadinglinesequence,
			setextHeadingText: onexitsetextheadingtext,
			strong: closer(),
			thematicBreak: closer()
		}
	};
	configure(config, (options || {}).mdastExtensions || []);
	const data = {};
	return compile$1;
	function compile$1(events) {
		let tree = {
			type: "root",
			children: []
		};
		const context = {
			stack: [tree],
			tokenStack: [],
			config,
			enter,
			exit: exit$2,
			buffer,
			resume,
			data
		};
		const listStack = [];
		let index$1 = -1;
		while (++index$1 < events.length) if (events[index$1][1].type === "listOrdered" || events[index$1][1].type === "listUnordered") if (events[index$1][0] === "enter") listStack.push(index$1);
		else {
			const tail = listStack.pop();
			index$1 = prepareList(events, tail, index$1);
		}
		index$1 = -1;
		while (++index$1 < events.length) {
			const handler = config[events[index$1][0]];
			if (own$3.call(handler, events[index$1][1].type)) handler[events[index$1][1].type].call(Object.assign({ sliceSerialize: events[index$1][2].sliceSerialize }, context), events[index$1][1]);
		}
		if (context.tokenStack.length > 0) {
			const tail = context.tokenStack[context.tokenStack.length - 1];
			const handler = tail[1] || defaultOnError;
			handler.call(context, void 0, tail[0]);
		}
		tree.position = {
			start: point(events.length > 0 ? events[0][1].start : {
				line: 1,
				column: 1,
				offset: 0
			}),
			end: point(events.length > 0 ? events[events.length - 2][1].end : {
				line: 1,
				column: 1,
				offset: 0
			})
		};
		index$1 = -1;
		while (++index$1 < config.transforms.length) tree = config.transforms[index$1](tree) || tree;
		return tree;
	}
	function prepareList(events, start, length) {
		let index$1 = start - 1;
		let containerBalance = -1;
		let listSpread = false;
		let listItem$3;
		let lineIndex;
		let firstBlankLineIndex;
		let atMarker;
		while (++index$1 <= length) {
			const event = events[index$1];
			switch (event[1].type) {
				case "listUnordered":
				case "listOrdered":
				case "blockQuote": {
					if (event[0] === "enter") containerBalance++;
					else containerBalance--;
					atMarker = void 0;
					break;
				}
				case "lineEndingBlank": {
					if (event[0] === "enter") {
						if (listItem$3 && !atMarker && !containerBalance && !firstBlankLineIndex) firstBlankLineIndex = index$1;
						atMarker = void 0;
					}
					break;
				}
				case "linePrefix":
				case "listItemValue":
				case "listItemMarker":
				case "listItemPrefix":
				case "listItemPrefixWhitespace": break;
				default: atMarker = void 0;
			}
			if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
				if (listItem$3) {
					let tailIndex = index$1;
					lineIndex = void 0;
					while (tailIndex--) {
						const tailEvent = events[tailIndex];
						if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
							if (tailEvent[0] === "exit") continue;
							if (lineIndex) {
								events[lineIndex][1].type = "lineEndingBlank";
								listSpread = true;
							}
							tailEvent[1].type = "lineEnding";
							lineIndex = tailIndex;
						} else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {} else break;
					}
					if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) listItem$3._spread = true;
					listItem$3.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
					events.splice(lineIndex || index$1, 0, [
						"exit",
						listItem$3,
						event[2]
					]);
					index$1++;
					length++;
				}
				if (event[1].type === "listItemPrefix") {
					const item = {
						type: "listItem",
						_spread: false,
						start: Object.assign({}, event[1].start),
						end: void 0
					};
					listItem$3 = item;
					events.splice(index$1, 0, [
						"enter",
						item,
						event[2]
					]);
					index$1++;
					length++;
					firstBlankLineIndex = void 0;
					atMarker = true;
				}
			}
		}
		events[start][1]._spread = listSpread;
		return length;
	}
	function opener(create$3, and) {
		return open;
		function open(token) {
			enter.call(this, create$3(token), token);
			if (and) and.call(this, token);
		}
	}
	function buffer() {
		this.stack.push({
			type: "fragment",
			children: []
		});
	}
	function enter(node$1, token, errorHandler) {
		const parent$1 = this.stack[this.stack.length - 1];
		const siblings = parent$1.children;
		siblings.push(node$1);
		this.stack.push(node$1);
		this.tokenStack.push([token, errorHandler || void 0]);
		node$1.position = {
			start: point(token.start),
			end: void 0
		};
	}
	function closer(and) {
		return close;
		function close(token) {
			if (and) and.call(this, token);
			exit$2.call(this, token);
		}
	}
	function exit$2(token, onExitError) {
		const node$1 = this.stack.pop();
		const open = this.tokenStack.pop();
		if (!open) throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({
			start: token.start,
			end: token.end
		}) + "): it’s not open");
		else if (open[0].type !== token.type) if (onExitError) onExitError.call(this, token, open[0]);
		else {
			const handler = open[1] || defaultOnError;
			handler.call(this, token, open[0]);
		}
		node$1.position.end = point(token.end);
	}
	function resume() {
		return toString$1(this.stack.pop());
	}
	function onenterlistordered() {
		this.data.expectingFirstListItemValue = true;
	}
	function onenterlistitemvalue(token) {
		if (this.data.expectingFirstListItemValue) {
			const ancestor = this.stack[this.stack.length - 2];
			ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
			this.data.expectingFirstListItemValue = void 0;
		}
	}
	function onexitcodefencedfenceinfo() {
		const data$1 = this.resume();
		const node$1 = this.stack[this.stack.length - 1];
		node$1.lang = data$1;
	}
	function onexitcodefencedfencemeta() {
		const data$1 = this.resume();
		const node$1 = this.stack[this.stack.length - 1];
		node$1.meta = data$1;
	}
	function onexitcodefencedfence() {
		if (this.data.flowCodeInside) return;
		this.buffer();
		this.data.flowCodeInside = true;
	}
	function onexitcodefenced() {
		const data$1 = this.resume();
		const node$1 = this.stack[this.stack.length - 1];
		node$1.value = data$1.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
		this.data.flowCodeInside = void 0;
	}
	function onexitcodeindented() {
		const data$1 = this.resume();
		const node$1 = this.stack[this.stack.length - 1];
		node$1.value = data$1.replace(/(\r?\n|\r)$/g, "");
	}
	function onexitdefinitionlabelstring(token) {
		const label = this.resume();
		const node$1 = this.stack[this.stack.length - 1];
		node$1.label = label;
		node$1.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
	}
	function onexitdefinitiontitlestring() {
		const data$1 = this.resume();
		const node$1 = this.stack[this.stack.length - 1];
		node$1.title = data$1;
	}
	function onexitdefinitiondestinationstring() {
		const data$1 = this.resume();
		const node$1 = this.stack[this.stack.length - 1];
		node$1.url = data$1;
	}
	function onexitatxheadingsequence(token) {
		const node$1 = this.stack[this.stack.length - 1];
		if (!node$1.depth) {
			const depth = this.sliceSerialize(token).length;
			node$1.depth = depth;
		}
	}
	function onexitsetextheadingtext() {
		this.data.setextHeadingSlurpLineEnding = true;
	}
	function onexitsetextheadinglinesequence(token) {
		const node$1 = this.stack[this.stack.length - 1];
		node$1.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;
	}
	function onexitsetextheading() {
		this.data.setextHeadingSlurpLineEnding = void 0;
	}
	function onenterdata(token) {
		const node$1 = this.stack[this.stack.length - 1];
		const siblings = node$1.children;
		let tail = siblings[siblings.length - 1];
		if (!tail || tail.type !== "text") {
			tail = text$8();
			tail.position = {
				start: point(token.start),
				end: void 0
			};
			siblings.push(tail);
		}
		this.stack.push(tail);
	}
	function onexitdata(token) {
		const tail = this.stack.pop();
		tail.value += this.sliceSerialize(token);
		tail.position.end = point(token.end);
	}
	function onexitlineending(token) {
		const context = this.stack[this.stack.length - 1];
		if (this.data.atHardBreak) {
			const tail = context.children[context.children.length - 1];
			tail.position.end = point(token.end);
			this.data.atHardBreak = void 0;
			return;
		}
		if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {
			onenterdata.call(this, token);
			onexitdata.call(this, token);
		}
	}
	function onexithardbreak() {
		this.data.atHardBreak = true;
	}
	function onexithtmlflow() {
		const data$1 = this.resume();
		const node$1 = this.stack[this.stack.length - 1];
		node$1.value = data$1;
	}
	function onexithtmltext() {
		const data$1 = this.resume();
		const node$1 = this.stack[this.stack.length - 1];
		node$1.value = data$1;
	}
	function onexitcodetext() {
		const data$1 = this.resume();
		const node$1 = this.stack[this.stack.length - 1];
		node$1.value = data$1;
	}
	function onexitlink() {
		const node$1 = this.stack[this.stack.length - 1];
		if (this.data.inReference) {
			const referenceType = this.data.referenceType || "shortcut";
			node$1.type += "Reference";
			node$1.referenceType = referenceType;
			delete node$1.url;
			delete node$1.title;
		} else {
			delete node$1.identifier;
			delete node$1.label;
		}
		this.data.referenceType = void 0;
	}
	function onexitimage() {
		const node$1 = this.stack[this.stack.length - 1];
		if (this.data.inReference) {
			const referenceType = this.data.referenceType || "shortcut";
			node$1.type += "Reference";
			node$1.referenceType = referenceType;
			delete node$1.url;
			delete node$1.title;
		} else {
			delete node$1.identifier;
			delete node$1.label;
		}
		this.data.referenceType = void 0;
	}
	function onexitlabeltext(token) {
		const string$2 = this.sliceSerialize(token);
		const ancestor = this.stack[this.stack.length - 2];
		ancestor.label = decodeString(string$2);
		ancestor.identifier = normalizeIdentifier(string$2).toLowerCase();
	}
	function onexitlabel() {
		const fragment$1 = this.stack[this.stack.length - 1];
		const value = this.resume();
		const node$1 = this.stack[this.stack.length - 1];
		this.data.inReference = true;
		if (node$1.type === "link") {
			const children = fragment$1.children;
			node$1.children = children;
		} else node$1.alt = value;
	}
	function onexitresourcedestinationstring() {
		const data$1 = this.resume();
		const node$1 = this.stack[this.stack.length - 1];
		node$1.url = data$1;
	}
	function onexitresourcetitlestring() {
		const data$1 = this.resume();
		const node$1 = this.stack[this.stack.length - 1];
		node$1.title = data$1;
	}
	function onexitresource() {
		this.data.inReference = void 0;
	}
	function onenterreference() {
		this.data.referenceType = "collapsed";
	}
	function onexitreferencestring(token) {
		const label = this.resume();
		const node$1 = this.stack[this.stack.length - 1];
		node$1.label = label;
		node$1.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
		this.data.referenceType = "full";
	}
	function onexitcharacterreferencemarker(token) {
		this.data.characterReferenceType = token.type;
	}
	function onexitcharacterreferencevalue(token) {
		const data$1 = this.sliceSerialize(token);
		const type = this.data.characterReferenceType;
		let value;
		if (type) {
			value = decodeNumericCharacterReference(data$1, type === "characterReferenceMarkerNumeric" ? 10 : 16);
			this.data.characterReferenceType = void 0;
		} else {
			const result = decodeNamedCharacterReference(data$1);
			value = result;
		}
		const tail = this.stack[this.stack.length - 1];
		tail.value += value;
	}
	function onexitcharacterreference(token) {
		const tail = this.stack.pop();
		tail.position.end = point(token.end);
	}
	function onexitautolinkprotocol(token) {
		onexitdata.call(this, token);
		const node$1 = this.stack[this.stack.length - 1];
		node$1.url = this.sliceSerialize(token);
	}
	function onexitautolinkemail(token) {
		onexitdata.call(this, token);
		const node$1 = this.stack[this.stack.length - 1];
		node$1.url = "mailto:" + this.sliceSerialize(token);
	}
	function blockQuote$1() {
		return {
			type: "blockquote",
			children: []
		};
	}
	function codeFlow() {
		return {
			type: "code",
			lang: null,
			meta: null,
			value: ""
		};
	}
	function codeText$1() {
		return {
			type: "inlineCode",
			value: ""
		};
	}
	function definition$2() {
		return {
			type: "definition",
			identifier: "",
			label: null,
			title: null,
			url: ""
		};
	}
	function emphasis$2() {
		return {
			type: "emphasis",
			children: []
		};
	}
	function heading$2() {
		return {
			type: "heading",
			depth: 0,
			children: []
		};
	}
	function hardBreak$2() {
		return { type: "break" };
	}
	function html$6() {
		return {
			type: "html",
			value: ""
		};
	}
	function image$2() {
		return {
			type: "image",
			title: null,
			url: "",
			alt: null
		};
	}
	function link$2() {
		return {
			type: "link",
			title: null,
			url: "",
			children: []
		};
	}
	function list$3(token) {
		return {
			type: "list",
			ordered: token.type === "listOrdered",
			start: null,
			spread: token._spread,
			children: []
		};
	}
	function listItem$2(token) {
		return {
			type: "listItem",
			spread: token._spread,
			checked: null,
			children: []
		};
	}
	function paragraph$2() {
		return {
			type: "paragraph",
			children: []
		};
	}
	function strong$2() {
		return {
			type: "strong",
			children: []
		};
	}
	function text$8() {
		return {
			type: "text",
			value: ""
		};
	}
	function thematicBreak$3() {
		return { type: "thematicBreak" };
	}
}
function point(d$1) {
	return {
		line: d$1.line,
		column: d$1.column,
		offset: d$1.offset
	};
}
function configure(combined, extensions) {
	let index$1 = -1;
	while (++index$1 < extensions.length) {
		const value = extensions[index$1];
		if (Array.isArray(value)) configure(combined, value);
		else extension(combined, value);
	}
}
function extension(combined, extension$1) {
	let key;
	for (key in extension$1) if (own$3.call(extension$1, key)) switch (key) {
		case "canContainEols": {
			const right = extension$1[key];
			if (right) combined[key].push(...right);
			break;
		}
		case "transforms": {
			const right = extension$1[key];
			if (right) combined[key].push(...right);
			break;
		}
		case "enter":
		case "exit": {
			const right = extension$1[key];
			if (right) Object.assign(combined[key], right);
			break;
		}
	}
}
function defaultOnError(left, right) {
	if (left) throw new Error("Cannot close `" + left.type + "` (" + stringifyPosition({
		start: left.start,
		end: left.end
	}) + "): a different token (`" + right.type + "`, " + stringifyPosition({
		start: right.start,
		end: right.end
	}) + ") is open");
	else throw new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
		start: right.start,
		end: right.end
	}) + ") is still open");
}
function remarkParse(options) {
	const self$1 = this;
	self$1.parser = parser$1;
	function parser$1(doc) {
		return fromMarkdown(doc, {
			...self$1.data("settings"),
			...options,
			extensions: self$1.data("micromarkExtensions") || [],
			mdastExtensions: self$1.data("fromMarkdownExtensions") || []
		});
	}
}
function blockquote$1(state, node$1) {
	const result = {
		type: "element",
		tagName: "blockquote",
		properties: {},
		children: state.wrap(state.all(node$1), true)
	};
	state.patch(node$1, result);
	return state.applyData(node$1, result);
}
function hardBreak$1(state, node$1) {
	const result = {
		type: "element",
		tagName: "br",
		properties: {},
		children: []
	};
	state.patch(node$1, result);
	return [state.applyData(node$1, result), {
		type: "text",
		value: "\n"
	}];
}
function code$2(state, node$1) {
	const value = node$1.value ? node$1.value + "\n" : "";
	const properties$1 = {};
	if (node$1.lang) properties$1.className = ["language-" + node$1.lang];
	let result = {
		type: "element",
		tagName: "code",
		properties: properties$1,
		children: [{
			type: "text",
			value
		}]
	};
	if (node$1.meta) result.data = { meta: node$1.meta };
	state.patch(node$1, result);
	result = state.applyData(node$1, result);
	result = {
		type: "element",
		tagName: "pre",
		properties: {},
		children: [result]
	};
	state.patch(node$1, result);
	return result;
}
function strikethrough(state, node$1) {
	const result = {
		type: "element",
		tagName: "del",
		properties: {},
		children: state.all(node$1)
	};
	state.patch(node$1, result);
	return state.applyData(node$1, result);
}
function emphasis$1(state, node$1) {
	const result = {
		type: "element",
		tagName: "em",
		properties: {},
		children: state.all(node$1)
	};
	state.patch(node$1, result);
	return state.applyData(node$1, result);
}
function footnoteReference$1(state, node$1) {
	const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
	const id$1 = String(node$1.identifier).toUpperCase();
	const safeId = normalizeUri(id$1.toLowerCase());
	const index$1 = state.footnoteOrder.indexOf(id$1);
	let counter;
	let reuseCounter = state.footnoteCounts.get(id$1);
	if (reuseCounter === void 0) {
		reuseCounter = 0;
		state.footnoteOrder.push(id$1);
		counter = state.footnoteOrder.length;
	} else counter = index$1 + 1;
	reuseCounter += 1;
	state.footnoteCounts.set(id$1, reuseCounter);
	const link$2 = {
		type: "element",
		tagName: "a",
		properties: {
			href: "#" + clobberPrefix + "fn-" + safeId,
			id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
			dataFootnoteRef: true,
			ariaDescribedBy: ["footnote-label"]
		},
		children: [{
			type: "text",
			value: String(counter)
		}]
	};
	state.patch(node$1, link$2);
	const sup = {
		type: "element",
		tagName: "sup",
		properties: {},
		children: [link$2]
	};
	state.patch(node$1, sup);
	return state.applyData(node$1, sup);
}
function heading$1(state, node$1) {
	const result = {
		type: "element",
		tagName: "h" + node$1.depth,
		properties: {},
		children: state.all(node$1)
	};
	state.patch(node$1, result);
	return state.applyData(node$1, result);
}
function html$1(state, node$1) {
	if (state.options.allowDangerousHtml) {
		const result = {
			type: "raw",
			value: node$1.value
		};
		state.patch(node$1, result);
		return state.applyData(node$1, result);
	}
	return void 0;
}
function revert(state, node$1) {
	const subtype = node$1.referenceType;
	let suffix = "]";
	if (subtype === "collapsed") suffix += "[]";
	else if (subtype === "full") suffix += "[" + (node$1.label || node$1.identifier) + "]";
	if (node$1.type === "imageReference") return [{
		type: "text",
		value: "![" + node$1.alt + suffix
	}];
	const contents = state.all(node$1);
	const head = contents[0];
	if (head && head.type === "text") head.value = "[" + head.value;
	else contents.unshift({
		type: "text",
		value: "["
	});
	const tail = contents[contents.length - 1];
	if (tail && tail.type === "text") tail.value += suffix;
	else contents.push({
		type: "text",
		value: suffix
	});
	return contents;
}
function imageReference$1(state, node$1) {
	const id$1 = String(node$1.identifier).toUpperCase();
	const definition$2 = state.definitionById.get(id$1);
	if (!definition$2) return revert(state, node$1);
	const properties$1 = {
		src: normalizeUri(definition$2.url || ""),
		alt: node$1.alt
	};
	if (definition$2.title !== null && definition$2.title !== void 0) properties$1.title = definition$2.title;
	const result = {
		type: "element",
		tagName: "img",
		properties: properties$1,
		children: []
	};
	state.patch(node$1, result);
	return state.applyData(node$1, result);
}
function image$1(state, node$1) {
	const properties$1 = { src: normalizeUri(node$1.url) };
	if (node$1.alt !== null && node$1.alt !== void 0) properties$1.alt = node$1.alt;
	if (node$1.title !== null && node$1.title !== void 0) properties$1.title = node$1.title;
	const result = {
		type: "element",
		tagName: "img",
		properties: properties$1,
		children: []
	};
	state.patch(node$1, result);
	return state.applyData(node$1, result);
}
function inlineCode$1(state, node$1) {
	const text$8 = {
		type: "text",
		value: node$1.value.replace(/\r?\n|\r/g, " ")
	};
	state.patch(node$1, text$8);
	const result = {
		type: "element",
		tagName: "code",
		properties: {},
		children: [text$8]
	};
	state.patch(node$1, result);
	return state.applyData(node$1, result);
}
function linkReference$1(state, node$1) {
	const id$1 = String(node$1.identifier).toUpperCase();
	const definition$2 = state.definitionById.get(id$1);
	if (!definition$2) return revert(state, node$1);
	const properties$1 = { href: normalizeUri(definition$2.url || "") };
	if (definition$2.title !== null && definition$2.title !== void 0) properties$1.title = definition$2.title;
	const result = {
		type: "element",
		tagName: "a",
		properties: properties$1,
		children: state.all(node$1)
	};
	state.patch(node$1, result);
	return state.applyData(node$1, result);
}
function link$1(state, node$1) {
	const properties$1 = { href: normalizeUri(node$1.url) };
	if (node$1.title !== null && node$1.title !== void 0) properties$1.title = node$1.title;
	const result = {
		type: "element",
		tagName: "a",
		properties: properties$1,
		children: state.all(node$1)
	};
	state.patch(node$1, result);
	return state.applyData(node$1, result);
}
function listItem$1(state, node$1, parent$1) {
	const results = state.all(node$1);
	const loose = parent$1 ? listLoose(parent$1) : listItemLoose(node$1);
	const properties$1 = {};
	const children = [];
	if (typeof node$1.checked === "boolean") {
		const head = results[0];
		let paragraph$2;
		if (head && head.type === "element" && head.tagName === "p") paragraph$2 = head;
		else {
			paragraph$2 = {
				type: "element",
				tagName: "p",
				properties: {},
				children: []
			};
			results.unshift(paragraph$2);
		}
		if (paragraph$2.children.length > 0) paragraph$2.children.unshift({
			type: "text",
			value: " "
		});
		paragraph$2.children.unshift({
			type: "element",
			tagName: "input",
			properties: {
				type: "checkbox",
				checked: node$1.checked,
				disabled: true
			},
			children: []
		});
		properties$1.className = ["task-list-item"];
	}
	let index$1 = -1;
	while (++index$1 < results.length) {
		const child = results[index$1];
		if (loose || index$1 !== 0 || child.type !== "element" || child.tagName !== "p") children.push({
			type: "text",
			value: "\n"
		});
		if (child.type === "element" && child.tagName === "p" && !loose) children.push(...child.children);
		else children.push(child);
	}
	const tail = results[results.length - 1];
	if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) children.push({
		type: "text",
		value: "\n"
	});
	const result = {
		type: "element",
		tagName: "li",
		properties: properties$1,
		children
	};
	state.patch(node$1, result);
	return state.applyData(node$1, result);
}
function listLoose(node$1) {
	let loose = false;
	if (node$1.type === "list") {
		loose = node$1.spread || false;
		const children = node$1.children;
		let index$1 = -1;
		while (!loose && ++index$1 < children.length) loose = listItemLoose(children[index$1]);
	}
	return loose;
}
function listItemLoose(node$1) {
	const spread = node$1.spread;
	return spread === null || spread === void 0 ? node$1.children.length > 1 : spread;
}
function list$1(state, node$1) {
	const properties$1 = {};
	const results = state.all(node$1);
	let index$1 = -1;
	if (typeof node$1.start === "number" && node$1.start !== 1) properties$1.start = node$1.start;
	while (++index$1 < results.length) {
		const child = results[index$1];
		if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
			properties$1.className = ["contains-task-list"];
			break;
		}
	}
	const result = {
		type: "element",
		tagName: node$1.ordered ? "ol" : "ul",
		properties: properties$1,
		children: state.wrap(results, true)
	};
	state.patch(node$1, result);
	return state.applyData(node$1, result);
}
function paragraph$1(state, node$1) {
	const result = {
		type: "element",
		tagName: "p",
		properties: {},
		children: state.all(node$1)
	};
	state.patch(node$1, result);
	return state.applyData(node$1, result);
}
function root$1(state, node$1) {
	const result = {
		type: "root",
		children: state.wrap(state.all(node$1))
	};
	state.patch(node$1, result);
	return state.applyData(node$1, result);
}
function strong$1(state, node$1) {
	const result = {
		type: "element",
		tagName: "strong",
		properties: {},
		children: state.all(node$1)
	};
	state.patch(node$1, result);
	return state.applyData(node$1, result);
}
function table(state, node$1) {
	const rows = state.all(node$1);
	const firstRow = rows.shift();
	const tableContent = [];
	if (firstRow) {
		const head = {
			type: "element",
			tagName: "thead",
			properties: {},
			children: state.wrap([firstRow], true)
		};
		state.patch(node$1.children[0], head);
		tableContent.push(head);
	}
	if (rows.length > 0) {
		const body = {
			type: "element",
			tagName: "tbody",
			properties: {},
			children: state.wrap(rows, true)
		};
		const start = pointStart(node$1.children[1]);
		const end = pointEnd(node$1.children[node$1.children.length - 1]);
		if (start && end) body.position = {
			start,
			end
		};
		tableContent.push(body);
	}
	const result = {
		type: "element",
		tagName: "table",
		properties: {},
		children: state.wrap(tableContent, true)
	};
	state.patch(node$1, result);
	return state.applyData(node$1, result);
}
function tableRow(state, node$1, parent$1) {
	const siblings = parent$1 ? parent$1.children : void 0;
	const rowIndex = siblings ? siblings.indexOf(node$1) : 1;
	const tagName = rowIndex === 0 ? "th" : "td";
	const align = parent$1 && parent$1.type === "table" ? parent$1.align : void 0;
	const length = align ? align.length : node$1.children.length;
	let cellIndex = -1;
	const cells = [];
	while (++cellIndex < length) {
		const cell = node$1.children[cellIndex];
		const properties$1 = {};
		const alignValue = align ? align[cellIndex] : void 0;
		if (alignValue) properties$1.align = alignValue;
		let result$1 = {
			type: "element",
			tagName,
			properties: properties$1,
			children: []
		};
		if (cell) {
			result$1.children = state.all(cell);
			state.patch(cell, result$1);
			result$1 = state.applyData(cell, result$1);
		}
		cells.push(result$1);
	}
	const result = {
		type: "element",
		tagName: "tr",
		properties: {},
		children: state.wrap(cells, true)
	};
	state.patch(node$1, result);
	return state.applyData(node$1, result);
}
function tableCell(state, node$1) {
	const result = {
		type: "element",
		tagName: "td",
		properties: {},
		children: state.all(node$1)
	};
	state.patch(node$1, result);
	return state.applyData(node$1, result);
}
const tab = 9;
const space = 32;
function trimLines(value) {
	const source = String(value);
	const search$3 = /\r?\n|\r/g;
	let match = search$3.exec(source);
	let last = 0;
	const lines = [];
	while (match) {
		lines.push(trimLine(source.slice(last, match.index), last > 0, true), match[0]);
		last = match.index + match[0].length;
		match = search$3.exec(source);
	}
	lines.push(trimLine(source.slice(last), last > 0, false));
	return lines.join("");
}
function trimLine(value, start, end) {
	let startIndex = 0;
	let endIndex = value.length;
	if (start) {
		let code$3 = value.codePointAt(startIndex);
		while (code$3 === tab || code$3 === space) {
			startIndex++;
			code$3 = value.codePointAt(startIndex);
		}
	}
	if (end) {
		let code$3 = value.codePointAt(endIndex - 1);
		while (code$3 === tab || code$3 === space) {
			endIndex--;
			code$3 = value.codePointAt(endIndex - 1);
		}
	}
	return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
}
function text$2(state, node$1) {
	const result = {
		type: "text",
		value: trimLines(String(node$1.value))
	};
	state.patch(node$1, result);
	return state.applyData(node$1, result);
}
function thematicBreak$1(state, node$1) {
	const result = {
		type: "element",
		tagName: "hr",
		properties: {},
		children: []
	};
	state.patch(node$1, result);
	return state.applyData(node$1, result);
}
const handlers = {
	blockquote: blockquote$1,
	break: hardBreak$1,
	code: code$2,
	delete: strikethrough,
	emphasis: emphasis$1,
	footnoteReference: footnoteReference$1,
	heading: heading$1,
	html: html$1,
	imageReference: imageReference$1,
	image: image$1,
	inlineCode: inlineCode$1,
	linkReference: linkReference$1,
	link: link$1,
	listItem: listItem$1,
	list: list$1,
	paragraph: paragraph$1,
	root: root$1,
	strong: strong$1,
	table,
	tableCell,
	tableRow,
	text: text$2,
	thematicBreak: thematicBreak$1,
	toml: ignore,
	yaml: ignore,
	definition: ignore,
	footnoteDefinition: ignore
};
function ignore() {
	return void 0;
}
function defaultFootnoteBackContent(_$1, rereferenceIndex) {
	const result = [{
		type: "text",
		value: "↩"
	}];
	if (rereferenceIndex > 1) result.push({
		type: "element",
		tagName: "sup",
		properties: {},
		children: [{
			type: "text",
			value: String(rereferenceIndex)
		}]
	});
	return result;
}
function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
	return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
}
function footer(state) {
	const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
	const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
	const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
	const footnoteLabel = state.options.footnoteLabel || "Footnotes";
	const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
	const footnoteLabelProperties = state.options.footnoteLabelProperties || { className: ["sr-only"] };
	const listItems = [];
	let referenceIndex = -1;
	while (++referenceIndex < state.footnoteOrder.length) {
		const definition$2 = state.footnoteById.get(state.footnoteOrder[referenceIndex]);
		if (!definition$2) continue;
		const content$2 = state.all(definition$2);
		const id$1 = String(definition$2.identifier).toUpperCase();
		const safeId = normalizeUri(id$1.toLowerCase());
		let rereferenceIndex = 0;
		const backReferences = [];
		const counts = state.footnoteCounts.get(id$1);
		while (counts !== void 0 && ++rereferenceIndex <= counts) {
			if (backReferences.length > 0) backReferences.push({
				type: "text",
				value: " "
			});
			let children = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
			if (typeof children === "string") children = {
				type: "text",
				value: children
			};
			backReferences.push({
				type: "element",
				tagName: "a",
				properties: {
					href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
					dataFootnoteBackref: "",
					ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
					className: ["data-footnote-backref"]
				},
				children: Array.isArray(children) ? children : [children]
			});
		}
		const tail = content$2[content$2.length - 1];
		if (tail && tail.type === "element" && tail.tagName === "p") {
			const tailTail = tail.children[tail.children.length - 1];
			if (tailTail && tailTail.type === "text") tailTail.value += " ";
			else tail.children.push({
				type: "text",
				value: " "
			});
			tail.children.push(...backReferences);
		} else content$2.push(...backReferences);
		const listItem$2 = {
			type: "element",
			tagName: "li",
			properties: { id: clobberPrefix + "fn-" + safeId },
			children: state.wrap(content$2, true)
		};
		state.patch(definition$2, listItem$2);
		listItems.push(listItem$2);
	}
	if (listItems.length === 0) return;
	return {
		type: "element",
		tagName: "section",
		properties: {
			dataFootnotes: true,
			className: ["footnotes"]
		},
		children: [
			{
				type: "element",
				tagName: footnoteLabelTagName,
				properties: {
					...esm_default$1(footnoteLabelProperties),
					id: "footnote-label"
				},
				children: [{
					type: "text",
					value: footnoteLabel
				}]
			},
			{
				type: "text",
				value: "\n"
			},
			{
				type: "element",
				tagName: "ol",
				properties: {},
				children: state.wrap(listItems, true)
			},
			{
				type: "text",
				value: "\n"
			}
		]
	};
}
const own$2 = {}.hasOwnProperty;
const emptyOptions$3 = {};
function createState(tree, options) {
	const settings = options || emptyOptions$3;
	const definitionById = new Map();
	const footnoteById = new Map();
	const footnoteCounts = new Map();
	const handlers$1 = {
		...handlers,
		...settings.handlers
	};
	const state = {
		all: all$6,
		applyData,
		definitionById,
		footnoteById,
		footnoteCounts,
		footnoteOrder: [],
		handlers: handlers$1,
		one: one$6,
		options: settings,
		patch,
		wrap: wrap$1
	};
	visit(tree, function(node$1) {
		if (node$1.type === "definition" || node$1.type === "footnoteDefinition") {
			const map$2 = node$1.type === "definition" ? definitionById : footnoteById;
			const id$1 = String(node$1.identifier).toUpperCase();
			if (!map$2.has(id$1)) map$2.set(id$1, node$1);
		}
	});
	return state;
	function one$6(node$1, parent$1) {
		const type = node$1.type;
		const handle$1 = state.handlers[type];
		if (own$2.call(state.handlers, type) && handle$1) return handle$1(state, node$1, parent$1);
		if (state.options.passThrough && state.options.passThrough.includes(type)) {
			if ("children" in node$1) {
				const { children,...shallow } = node$1;
				const result = esm_default$1(shallow);
				result.children = state.all(node$1);
				return result;
			}
			return esm_default$1(node$1);
		}
		const unknown$1 = state.options.unknownHandler || defaultUnknownHandler;
		return unknown$1(state, node$1, parent$1);
	}
	function all$6(parent$1) {
		const values = [];
		if ("children" in parent$1) {
			const nodes = parent$1.children;
			let index$1 = -1;
			while (++index$1 < nodes.length) {
				const result = state.one(nodes[index$1], parent$1);
				if (result) {
					if (index$1 && nodes[index$1 - 1].type === "break") {
						if (!Array.isArray(result) && result.type === "text") result.value = trimMarkdownSpaceStart(result.value);
						if (!Array.isArray(result) && result.type === "element") {
							const head = result.children[0];
							if (head && head.type === "text") head.value = trimMarkdownSpaceStart(head.value);
						}
					}
					if (Array.isArray(result)) values.push(...result);
					else values.push(result);
				}
			}
		}
		return values;
	}
}
function patch(from, to) {
	if (from.position) to.position = position(from);
}
function applyData(from, to) {
	let result = to;
	if (from && from.data) {
		const hName = from.data.hName;
		const hChildren = from.data.hChildren;
		const hProperties = from.data.hProperties;
		if (typeof hName === "string") if (result.type === "element") result.tagName = hName;
		else {
			const children = "children" in result ? result.children : [result];
			result = {
				type: "element",
				tagName: hName,
				properties: {},
				children
			};
		}
		if (result.type === "element" && hProperties) Object.assign(result.properties, esm_default$1(hProperties));
		if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) result.children = hChildren;
	}
	return result;
}
function defaultUnknownHandler(state, node$1) {
	const data = node$1.data || {};
	const result = "value" in node$1 && !(own$2.call(data, "hProperties") || own$2.call(data, "hChildren")) ? {
		type: "text",
		value: node$1.value
	} : {
		type: "element",
		tagName: "div",
		properties: {},
		children: state.all(node$1)
	};
	state.patch(node$1, result);
	return state.applyData(node$1, result);
}
function wrap$1(nodes, loose) {
	const result = [];
	let index$1 = -1;
	if (loose) result.push({
		type: "text",
		value: "\n"
	});
	while (++index$1 < nodes.length) {
		if (index$1) result.push({
			type: "text",
			value: "\n"
		});
		result.push(nodes[index$1]);
	}
	if (loose && nodes.length > 0) result.push({
		type: "text",
		value: "\n"
	});
	return result;
}
function trimMarkdownSpaceStart(value) {
	let index$1 = 0;
	let code$3 = value.charCodeAt(index$1);
	while (code$3 === 9 || code$3 === 32) {
		index$1++;
		code$3 = value.charCodeAt(index$1);
	}
	return value.slice(index$1);
}
function toHast(tree, options) {
	const state = createState(tree, options);
	const node$1 = state.one(tree, void 0);
	const foot = footer(state);
	const result = Array.isArray(node$1) ? {
		type: "root",
		children: node$1
	} : node$1 || {
		type: "root",
		children: []
	};
	if (foot) {
		ok("children" in result);
		result.children.push({
			type: "text",
			value: "\n"
		}, foot);
	}
	return result;
}
function remarkRehype(destination, options) {
	if (destination && "run" in destination) return async function(tree, file) {
		const hastTree = toHast(tree, {
			file,
			...options
		});
		await destination.run(hastTree, file);
	};
	return function(tree, file) {
		return toHast(tree, {
			file,
			...destination || options
		});
	};
}
function bail(error) {
	if (error) throw error;
}
var require_extend = __commonJSMin((exports, module) => {
	var hasOwn = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var defineProperty = Object.defineProperty;
	var gOPD = Object.getOwnPropertyDescriptor;
	var isArray = function isArray$1(arr) {
		if (typeof Array.isArray === "function") return Array.isArray(arr);
		return toStr.call(arr) === "[object Array]";
	};
	var isPlainObject$1 = function isPlainObject$2(obj) {
		if (!obj || toStr.call(obj) !== "[object Object]") return false;
		var hasOwnConstructor = hasOwn.call(obj, "constructor");
		var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
		if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) return false;
		var key;
		for (key in obj);
		return typeof key === "undefined" || hasOwn.call(obj, key);
	};
	var setProperty = function setProperty$1(target, options) {
		if (defineProperty && options.name === "__proto__") defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
		else target[options.name] = options.newValue;
	};
	var getProperty = function getProperty$1(obj, name$2) {
		if (name$2 === "__proto__") {
			if (!hasOwn.call(obj, name$2)) return void 0;
			else if (gOPD) return gOPD(obj, name$2).value;
		}
		return obj[name$2];
	};
	module.exports = function extend$1() {
		var options, name$2, src, copy, copyIsArray, clone$1;
		var target = arguments[0];
		var i = 1;
		var length = arguments.length;
		var deep = false;
		if (typeof target === "boolean") {
			deep = target;
			target = arguments[1] || {};
			i = 2;
		}
		if (target == null || typeof target !== "object" && typeof target !== "function") target = {};
		for (; i < length; ++i) {
			options = arguments[i];
			if (options != null) for (name$2 in options) {
				src = getProperty(target, name$2);
				copy = getProperty(options, name$2);
				if (target !== copy) {
					if (deep && copy && (isPlainObject$1(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone$1 = src && isArray(src) ? src : [];
						} else clone$1 = src && isPlainObject$1(src) ? src : {};
						setProperty(target, {
							name: name$2,
							newValue: extend$1(deep, clone$1, copy)
						});
					} else if (typeof copy !== "undefined") setProperty(target, {
						name: name$2,
						newValue: copy
					});
				}
			}
		}
		return target;
	};
});
function isPlainObject(value) {
	if (typeof value !== "object" || value === null) return false;
	const prototype = Object.getPrototypeOf(value);
	return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function trough() {
	const fns = [];
	const pipeline = {
		run,
		use
	};
	return pipeline;
	function run(...values) {
		let middlewareIndex = -1;
		const callback = values.pop();
		if (typeof callback !== "function") throw new TypeError("Expected function as last argument, not " + callback);
		next$1(null, ...values);
		function next$1(error, ...output) {
			const fn = fns[++middlewareIndex];
			let index$1 = -1;
			if (error) {
				callback(error);
				return;
			}
			while (++index$1 < values.length) if (output[index$1] === null || output[index$1] === void 0) output[index$1] = values[index$1];
			values = output;
			if (fn) wrap(fn, next$1)(...output);
			else callback(null, ...output);
		}
	}
	function use(middelware) {
		if (typeof middelware !== "function") throw new TypeError("Expected `middelware` to be a function, not " + middelware);
		fns.push(middelware);
		return pipeline;
	}
}
function wrap(middleware, callback) {
	let called;
	return wrapped;
	function wrapped(...parameters) {
		const fnExpectsCallback = middleware.length > parameters.length;
		let result;
		if (fnExpectsCallback) parameters.push(done);
		try {
			result = middleware.apply(this, parameters);
		} catch (error) {
			const exception = error;
			if (fnExpectsCallback && called) throw exception;
			return done(exception);
		}
		if (!fnExpectsCallback) if (result && result.then && typeof result.then === "function") result.then(then, done);
		else if (result instanceof Error) done(result);
		else then(result);
	}
	function done(error, ...output) {
		if (!called) {
			called = true;
			callback(error, ...output);
		}
	}
	function then(value) {
		done(null, value);
	}
}
function isUrl(fileUrlOrPath) {
	return Boolean(fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && fileUrlOrPath.auth === void 0);
}
const order = [
	"history",
	"path",
	"basename",
	"stem",
	"extname",
	"dirname"
];
var VFile = class {
	constructor(value) {
		let options;
		if (!value) options = {};
		else if (isUrl(value)) options = { path: value };
		else if (typeof value === "string" || isUint8Array$1(value)) options = { value };
		else options = value;
		this.cwd = "cwd" in options ? "" : minproc.cwd();
		this.data = {};
		this.history = [];
		this.messages = [];
		this.value;
		this.map;
		this.result;
		this.stored;
		let index$1 = -1;
		while (++index$1 < order.length) {
			const field$1 = order[index$1];
			if (field$1 in options && options[field$1] !== void 0 && options[field$1] !== null) this[field$1] = field$1 === "history" ? [...options[field$1]] : options[field$1];
		}
		let field;
		for (field in options) if (!order.includes(field)) this[field] = options[field];
	}
	get basename() {
		return typeof this.path === "string" ? minpath.basename(this.path) : void 0;
	}
	set basename(basename) {
		assertNonEmpty(basename, "basename");
		assertPart(basename, "basename");
		this.path = minpath.join(this.dirname || "", basename);
	}
	get dirname() {
		return typeof this.path === "string" ? minpath.dirname(this.path) : void 0;
	}
	set dirname(dirname) {
		assertPath(this.basename, "dirname");
		this.path = minpath.join(dirname || "", this.basename);
	}
	get extname() {
		return typeof this.path === "string" ? minpath.extname(this.path) : void 0;
	}
	set extname(extname) {
		assertPart(extname, "extname");
		assertPath(this.dirname, "extname");
		if (extname) {
			if (extname.codePointAt(0) !== 46) throw new Error("`extname` must start with `.`");
			if (extname.includes(".", 1)) throw new Error("`extname` cannot contain multiple dots");
		}
		this.path = minpath.join(this.dirname, this.stem + (extname || ""));
	}
	get path() {
		return this.history[this.history.length - 1];
	}
	set path(path$1) {
		if (isUrl(path$1)) path$1 = urlToPath(path$1);
		assertNonEmpty(path$1, "path");
		if (this.path !== path$1) this.history.push(path$1);
	}
	get stem() {
		return typeof this.path === "string" ? minpath.basename(this.path, this.extname) : void 0;
	}
	set stem(stem) {
		assertNonEmpty(stem, "stem");
		assertPart(stem, "stem");
		this.path = minpath.join(this.dirname || "", stem + (this.extname || ""));
	}
	fail(causeOrReason, optionsOrParentOrPlace, origin) {
		const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
		message.fatal = true;
		throw message;
	}
	info(causeOrReason, optionsOrParentOrPlace, origin) {
		const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
		message.fatal = void 0;
		return message;
	}
	message(causeOrReason, optionsOrParentOrPlace, origin) {
		const message = new VFileMessage(causeOrReason, optionsOrParentOrPlace, origin);
		if (this.path) {
			message.name = this.path + ":" + message.name;
			message.file = this.path;
		}
		message.fatal = false;
		this.messages.push(message);
		return message;
	}
	toString(encoding) {
		if (this.value === void 0) return "";
		if (typeof this.value === "string") return this.value;
		const decoder = new TextDecoder(encoding || void 0);
		return decoder.decode(this.value);
	}
};
function assertPart(part, name$2) {
	if (part && part.includes(minpath.sep)) throw new Error("`" + name$2 + "` cannot be a path: did not expect `" + minpath.sep + "`");
}
function assertNonEmpty(part, name$2) {
	if (!part) throw new Error("`" + name$2 + "` cannot be empty");
}
function assertPath(path$1, name$2) {
	if (!path$1) throw new Error("Setting `" + name$2 + "` requires `path` to be set too");
}
function isUint8Array$1(value) {
	return Boolean(value && typeof value === "object" && "byteLength" in value && "byteOffset" in value);
}
const CallableInstance = function(property) {
	const self$1 = this;
	const constr = self$1.constructor;
	const proto$1 = constr.prototype;
	const value = proto$1[property];
	const apply = function() {
		return value.apply(apply, arguments);
	};
	Object.setPrototypeOf(apply, proto$1);
	return apply;
};
var import_extend = __toESM(require_extend());
const own$1 = {}.hasOwnProperty;
var Processor = class Processor extends CallableInstance {
	constructor() {
		super("copy");
		this.Compiler = void 0;
		this.Parser = void 0;
		this.attachers = [];
		this.compiler = void 0;
		this.freezeIndex = -1;
		this.frozen = void 0;
		this.namespace = {};
		this.parser = void 0;
		this.transformers = trough();
	}
	copy() {
		const destination = new Processor();
		let index$1 = -1;
		while (++index$1 < this.attachers.length) {
			const attacher = this.attachers[index$1];
			destination.use(...attacher);
		}
		destination.data((0, import_extend.default)(true, {}, this.namespace));
		return destination;
	}
	data(key, value) {
		if (typeof key === "string") {
			if (arguments.length === 2) {
				assertUnfrozen("data", this.frozen);
				this.namespace[key] = value;
				return this;
			}
			return own$1.call(this.namespace, key) && this.namespace[key] || void 0;
		}
		if (key) {
			assertUnfrozen("data", this.frozen);
			this.namespace = key;
			return this;
		}
		return this.namespace;
	}
	freeze() {
		if (this.frozen) return this;
		const self$1 = this;
		while (++this.freezeIndex < this.attachers.length) {
			const [attacher, ...options] = this.attachers[this.freezeIndex];
			if (options[0] === false) continue;
			if (options[0] === true) options[0] = void 0;
			const transformer = attacher.call(self$1, ...options);
			if (typeof transformer === "function") this.transformers.use(transformer);
		}
		this.frozen = true;
		this.freezeIndex = Number.POSITIVE_INFINITY;
		return this;
	}
	parse(file) {
		this.freeze();
		const realFile = vfile(file);
		const parser$1 = this.parser || this.Parser;
		assertParser("parse", parser$1);
		return parser$1(String(realFile), realFile);
	}
	process(file, done) {
		const self$1 = this;
		this.freeze();
		assertParser("process", this.parser || this.Parser);
		assertCompiler("process", this.compiler || this.Compiler);
		return done ? executor(void 0, done) : new Promise(executor);
		function executor(resolve, reject) {
			const realFile = vfile(file);
			const parseTree = self$1.parse(realFile);
			self$1.run(parseTree, realFile, function(error, tree, file$1) {
				if (error || !tree || !file$1) return realDone(error);
				const compileTree = tree;
				const compileResult = self$1.stringify(compileTree, file$1);
				if (looksLikeAValue(compileResult)) file$1.value = compileResult;
				else file$1.result = compileResult;
				realDone(error, file$1);
			});
			function realDone(error, file$1) {
				if (error || !file$1) reject(error);
				else if (resolve) resolve(file$1);
				else {
					ok(done, "`done` is defined if `resolve` is not");
					done(void 0, file$1);
				}
			}
		}
	}
	processSync(file) {
		let complete = false;
		let result;
		this.freeze();
		assertParser("processSync", this.parser || this.Parser);
		assertCompiler("processSync", this.compiler || this.Compiler);
		this.process(file, realDone);
		assertDone("processSync", "process", complete);
		ok(result, "we either bailed on an error or have a tree");
		return result;
		function realDone(error, file$1) {
			complete = true;
			bail(error);
			result = file$1;
		}
	}
	run(tree, file, done) {
		assertNode(tree);
		this.freeze();
		const transformers = this.transformers;
		if (!done && typeof file === "function") {
			done = file;
			file = void 0;
		}
		return done ? executor(void 0, done) : new Promise(executor);
		function executor(resolve, reject) {
			ok(typeof file !== "function", "`file` can’t be a `done` anymore, we checked");
			const realFile = vfile(file);
			transformers.run(tree, realFile, realDone);
			function realDone(error, outputTree, file$1) {
				const resultingTree = outputTree || tree;
				if (error) reject(error);
				else if (resolve) resolve(resultingTree);
				else {
					ok(done, "`done` is defined if `resolve` is not");
					done(void 0, resultingTree, file$1);
				}
			}
		}
	}
	runSync(tree, file) {
		let complete = false;
		let result;
		this.run(tree, file, realDone);
		assertDone("runSync", "run", complete);
		ok(result, "we either bailed on an error or have a tree");
		return result;
		function realDone(error, tree$1) {
			bail(error);
			result = tree$1;
			complete = true;
		}
	}
	stringify(tree, file) {
		this.freeze();
		const realFile = vfile(file);
		const compiler$1 = this.compiler || this.Compiler;
		assertCompiler("stringify", compiler$1);
		assertNode(tree);
		return compiler$1(tree, realFile);
	}
	use(value, ...parameters) {
		const attachers = this.attachers;
		const namespace = this.namespace;
		assertUnfrozen("use", this.frozen);
		if (value === null || value === void 0) {} else if (typeof value === "function") addPlugin(value, parameters);
		else if (typeof value === "object") if (Array.isArray(value)) addList(value);
		else addPreset(value);
		else throw new TypeError("Expected usable value, not `" + value + "`");
		return this;
		function add$1(value$1) {
			if (typeof value$1 === "function") addPlugin(value$1, []);
			else if (typeof value$1 === "object") if (Array.isArray(value$1)) {
				const [plugin, ...parameters$1] = value$1;
				addPlugin(plugin, parameters$1);
			} else addPreset(value$1);
			else throw new TypeError("Expected usable value, not `" + value$1 + "`");
		}
		function addPreset(result) {
			if (!("plugins" in result) && !("settings" in result)) throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither");
			addList(result.plugins);
			if (result.settings) namespace.settings = (0, import_extend.default)(true, namespace.settings, result.settings);
		}
		function addList(plugins) {
			let index$1 = -1;
			if (plugins === null || plugins === void 0) {} else if (Array.isArray(plugins)) while (++index$1 < plugins.length) {
				const thing = plugins[index$1];
				add$1(thing);
			}
			else throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
		}
		function addPlugin(plugin, parameters$1) {
			let index$1 = -1;
			let entryIndex = -1;
			while (++index$1 < attachers.length) if (attachers[index$1][0] === plugin) {
				entryIndex = index$1;
				break;
			}
			if (entryIndex === -1) attachers.push([plugin, ...parameters$1]);
			else if (parameters$1.length > 0) {
				let [primary, ...rest$1] = parameters$1;
				const currentPrimary = attachers[entryIndex][1];
				if (isPlainObject(currentPrimary) && isPlainObject(primary)) primary = (0, import_extend.default)(true, currentPrimary, primary);
				attachers[entryIndex] = [
					plugin,
					primary,
					...rest$1
				];
			}
		}
	}
};
const unified = new Processor().freeze();
function assertParser(name$2, value) {
	if (typeof value !== "function") throw new TypeError("Cannot `" + name$2 + "` without `parser`");
}
function assertCompiler(name$2, value) {
	if (typeof value !== "function") throw new TypeError("Cannot `" + name$2 + "` without `compiler`");
}
function assertUnfrozen(name$2, frozen) {
	if (frozen) throw new Error("Cannot call `" + name$2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.");
}
function assertNode(node$1) {
	if (!isPlainObject(node$1) || typeof node$1.type !== "string") throw new TypeError("Expected node, got `" + node$1 + "`");
}
function assertDone(name$2, asyncName, complete) {
	if (!complete) throw new Error("`" + name$2 + "` finished async. Use `" + asyncName + "` instead");
}
function vfile(value) {
	return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
	return Boolean(value && typeof value === "object" && "message" in value && "messages" in value);
}
function looksLikeAValue(value) {
	return typeof value === "string" || isUint8Array(value);
}
function isUint8Array(value) {
	return Boolean(value && typeof value === "object" && "byteLength" in value && "byteOffset" in value);
}
const emptyPlugins = [];
const emptyRemarkRehypeOptions = { allowDangerousHtml: true };
const safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i;
const deprecations = [
	{
		from: "astPlugins",
		id: "remove-buggy-html-in-markdown-parser"
	},
	{
		from: "allowDangerousHtml",
		id: "remove-buggy-html-in-markdown-parser"
	},
	{
		from: "allowNode",
		id: "replace-allownode-allowedtypes-and-disallowedtypes",
		to: "allowElement"
	},
	{
		from: "allowedTypes",
		id: "replace-allownode-allowedtypes-and-disallowedtypes",
		to: "allowedElements"
	},
	{
		from: "disallowedTypes",
		id: "replace-allownode-allowedtypes-and-disallowedtypes",
		to: "disallowedElements"
	},
	{
		from: "escapeHtml",
		id: "remove-buggy-html-in-markdown-parser"
	},
	{
		from: "includeElementIndex",
		id: "#remove-includeelementindex"
	},
	{
		from: "includeNodeIndex",
		id: "change-includenodeindex-to-includeelementindex"
	},
	{
		from: "linkTarget",
		id: "remove-linktarget"
	},
	{
		from: "plugins",
		id: "change-plugins-to-remarkplugins",
		to: "remarkPlugins"
	},
	{
		from: "rawSourcePos",
		id: "#remove-rawsourcepos"
	},
	{
		from: "renderers",
		id: "change-renderers-to-components",
		to: "components"
	},
	{
		from: "source",
		id: "change-source-to-children",
		to: "children"
	},
	{
		from: "sourcePos",
		id: "#remove-sourcepos"
	},
	{
		from: "transformImageUri",
		id: "#add-urltransform",
		to: "urlTransform"
	},
	{
		from: "transformLinkUri",
		id: "#add-urltransform",
		to: "urlTransform"
	}
];
function Markdown(options) {
	const allowedElements = options.allowedElements;
	const allowElement = options.allowElement;
	const children = options.children || "";
	const className$1 = options.className;
	const components = options.components;
	const disallowedElements = options.disallowedElements;
	const rehypePlugins = options.rehypePlugins || emptyPlugins;
	const remarkPlugins = options.remarkPlugins || emptyPlugins;
	const remarkRehypeOptions = options.remarkRehypeOptions ? {
		...options.remarkRehypeOptions,
		...emptyRemarkRehypeOptions
	} : emptyRemarkRehypeOptions;
	const skipHtml = options.skipHtml;
	const unwrapDisallowed = options.unwrapDisallowed;
	const urlTransform = options.urlTransform || defaultUrlTransform$1;
	const processor = unified().use(remarkParse).use(remarkPlugins).use(remarkRehype, remarkRehypeOptions).use(rehypePlugins);
	const file = new VFile();
	if (typeof children === "string") file.value = children;
	else unreachable("Unexpected value `" + children + "` for `children` prop, expected `string`");
	if (allowedElements && disallowedElements) unreachable("Unexpected combined `allowedElements` and `disallowedElements`, expected one or the other");
	for (const deprecation of deprecations) if (Object.hasOwn(options, deprecation.from)) unreachable("Unexpected `" + deprecation.from + "` prop, " + (deprecation.to ? "use `" + deprecation.to + "` instead" : "remove it") + " (see <https://github.com/remarkjs/react-markdown/blob/main/changelog.md#" + deprecation.id + "> for more info)");
	const mdastTree = processor.parse(file);
	let hastTree = processor.runSync(mdastTree, file);
	if (className$1) hastTree = {
		type: "element",
		tagName: "div",
		properties: { className: className$1 },
		children: hastTree.type === "root" ? hastTree.children : [hastTree]
	};
	visit(hastTree, transform);
	return toJsxRuntime(hastTree, {
		Fragment,
		components,
		ignoreInvalidStyle: true,
		jsx,
		jsxs,
		passKeys: true,
		passNode: true
	});
	function transform(node$1, index$1, parent$1) {
		if (node$1.type === "raw" && parent$1 && typeof index$1 === "number") {
			if (skipHtml) parent$1.children.splice(index$1, 1);
			else parent$1.children[index$1] = {
				type: "text",
				value: node$1.value
			};
			return index$1;
		}
		if (node$1.type === "element") {
			let key;
			for (key in urlAttributes) if (Object.hasOwn(urlAttributes, key) && Object.hasOwn(node$1.properties, key)) {
				const value = node$1.properties[key];
				const test$1 = urlAttributes[key];
				if (test$1 === null || test$1.includes(node$1.tagName)) node$1.properties[key] = urlTransform(String(value || ""), key, node$1);
			}
		}
		if (node$1.type === "element") {
			let remove = allowedElements ? !allowedElements.includes(node$1.tagName) : disallowedElements ? disallowedElements.includes(node$1.tagName) : false;
			if (!remove && allowElement && typeof index$1 === "number") remove = !allowElement(node$1, index$1, parent$1);
			if (remove && parent$1 && typeof index$1 === "number") {
				if (unwrapDisallowed && node$1.children) parent$1.children.splice(index$1, 1, ...node$1.children);
				else parent$1.children.splice(index$1, 1);
				return index$1;
			}
		}
	}
}
function defaultUrlTransform$1(value) {
	const colon = value.indexOf(":");
	const questionMark = value.indexOf("?");
	const numberSign = value.indexOf("#");
	const slash = value.indexOf("/");
	if (colon === -1 || slash !== -1 && colon > slash || questionMark !== -1 && colon > questionMark || numberSign !== -1 && colon > numberSign || safeProtocol.test(value.slice(0, colon))) return value;
	return "";
}
function ccount(value, character) {
	const source = String(value);
	if (typeof character !== "string") throw new TypeError("Expected character");
	let count$1 = 0;
	let index$1 = source.indexOf(character);
	while (index$1 !== -1) {
		count$1++;
		index$1 = source.indexOf(character, index$1 + character.length);
	}
	return count$1;
}
function findAndReplace(tree, list$3, options) {
	const settings = options || {};
	const ignored = convert(settings.ignore || []);
	const pairs = toPairs(list$3);
	let pairIndex = -1;
	while (++pairIndex < pairs.length) visitParents(tree, "text", visitor);
	function visitor(node$1, parents) {
		let index$1 = -1;
		let grandparent;
		while (++index$1 < parents.length) {
			const parent$1 = parents[index$1];
			const siblings = grandparent ? grandparent.children : void 0;
			if (ignored(parent$1, siblings ? siblings.indexOf(parent$1) : void 0, grandparent)) return;
			grandparent = parent$1;
		}
		if (grandparent) return handler(node$1, parents);
	}
	function handler(node$1, parents) {
		const parent$1 = parents[parents.length - 1];
		const find$2 = pairs[pairIndex][0];
		const replace$1 = pairs[pairIndex][1];
		let start = 0;
		const siblings = parent$1.children;
		const index$1 = siblings.indexOf(node$1);
		let change = false;
		let nodes = [];
		find$2.lastIndex = 0;
		let match = find$2.exec(node$1.value);
		while (match) {
			const position$3 = match.index;
			const matchObject = {
				index: match.index,
				input: match.input,
				stack: [...parents, node$1]
			};
			let value = replace$1(...match, matchObject);
			if (typeof value === "string") value = value.length > 0 ? {
				type: "text",
				value
			} : void 0;
			if (value === false) find$2.lastIndex = position$3 + 1;
			else {
				if (start !== position$3) nodes.push({
					type: "text",
					value: node$1.value.slice(start, position$3)
				});
				if (Array.isArray(value)) nodes.push(...value);
				else if (value) nodes.push(value);
				start = position$3 + match[0].length;
				change = true;
			}
			if (!find$2.global) break;
			match = find$2.exec(node$1.value);
		}
		if (change) {
			if (start < node$1.value.length) nodes.push({
				type: "text",
				value: node$1.value.slice(start)
			});
			parent$1.children.splice(index$1, 1, ...nodes);
		} else nodes = [node$1];
		return index$1 + nodes.length;
	}
}
function toPairs(tupleOrList) {
	const result = [];
	if (!Array.isArray(tupleOrList)) throw new TypeError("Expected find and replace tuple or list of tuples");
	const list$3 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
	let index$1 = -1;
	while (++index$1 < list$3.length) {
		const tuple = list$3[index$1];
		result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
	}
	return result;
}
function toExpression(find$2) {
	return typeof find$2 === "string" ? new RegExp(escape(find$2), "g") : find$2;
}
function toFunction(replace$1) {
	return typeof replace$1 === "function" ? replace$1 : function() {
		return replace$1;
	};
}
const inConstruct = "phrasing";
const notInConstruct = [
	"autolink",
	"link",
	"image",
	"label"
];
function gfmAutolinkLiteralFromMarkdown() {
	return {
		transforms: [transformGfmAutolinkLiterals],
		enter: {
			literalAutolink: enterLiteralAutolink,
			literalAutolinkEmail: enterLiteralAutolinkValue,
			literalAutolinkHttp: enterLiteralAutolinkValue,
			literalAutolinkWww: enterLiteralAutolinkValue
		},
		exit: {
			literalAutolink: exitLiteralAutolink,
			literalAutolinkEmail: exitLiteralAutolinkEmail,
			literalAutolinkHttp: exitLiteralAutolinkHttp,
			literalAutolinkWww: exitLiteralAutolinkWww
		}
	};
}
function gfmAutolinkLiteralToMarkdown() {
	return { unsafe: [
		{
			character: "@",
			before: "[+\\-.\\w]",
			after: "[\\-.\\w]",
			inConstruct,
			notInConstruct
		},
		{
			character: ".",
			before: "[Ww]",
			after: "[\\-.\\w]",
			inConstruct,
			notInConstruct
		},
		{
			character: ":",
			before: "[ps]",
			after: "\\/",
			inConstruct,
			notInConstruct
		}
	] };
}
function enterLiteralAutolink(token) {
	this.enter({
		type: "link",
		title: null,
		url: "",
		children: []
	}, token);
}
function enterLiteralAutolinkValue(token) {
	this.config.enter.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkHttp(token) {
	this.config.exit.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkWww(token) {
	this.config.exit.data.call(this, token);
	const node$1 = this.stack[this.stack.length - 1];
	ok(node$1.type === "link");
	node$1.url = "http://" + this.sliceSerialize(token);
}
function exitLiteralAutolinkEmail(token) {
	this.config.exit.autolinkEmail.call(this, token);
}
function exitLiteralAutolink(token) {
	this.exit(token);
}
function transformGfmAutolinkLiterals(tree) {
	findAndReplace(tree, [[/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl], [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), findEmail]], { ignore: ["link", "linkReference"] });
}
function findUrl(_$1, protocol, domain$1, path$1, match) {
	let prefix = "";
	if (!previous(match)) return false;
	if (/^w/i.test(protocol)) {
		domain$1 = protocol + domain$1;
		protocol = "";
		prefix = "http://";
	}
	if (!isCorrectDomain(domain$1)) return false;
	const parts = splitUrl(domain$1 + path$1);
	if (!parts[0]) return false;
	const result = {
		type: "link",
		title: null,
		url: prefix + protocol + parts[0],
		children: [{
			type: "text",
			value: protocol + parts[0]
		}]
	};
	if (parts[1]) return [result, {
		type: "text",
		value: parts[1]
	}];
	return result;
}
function findEmail(_$1, atext, label, match) {
	if (!previous(match, true) || /[-\d_]$/.test(label)) return false;
	return {
		type: "link",
		title: null,
		url: "mailto:" + atext + "@" + label,
		children: [{
			type: "text",
			value: atext + "@" + label
		}]
	};
}
function isCorrectDomain(domain$1) {
	const parts = domain$1.split(".");
	if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) return false;
	return true;
}
function splitUrl(url) {
	const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
	if (!trailExec) return [url, void 0];
	url = url.slice(0, trailExec.index);
	let trail$1 = trailExec[0];
	let closingParenIndex = trail$1.indexOf(")");
	const openingParens = ccount(url, "(");
	let closingParens = ccount(url, ")");
	while (closingParenIndex !== -1 && openingParens > closingParens) {
		url += trail$1.slice(0, closingParenIndex + 1);
		trail$1 = trail$1.slice(closingParenIndex + 1);
		closingParenIndex = trail$1.indexOf(")");
		closingParens++;
	}
	return [url, trail$1];
}
function previous(match, email) {
	const code$3 = match.input.charCodeAt(match.index - 1);
	return (match.index === 0 || unicodeWhitespace(code$3) || unicodePunctuation(code$3)) && (!email || code$3 !== 47);
}
footnoteReference.peek = footnoteReferencePeek;
function enterFootnoteCallString() {
	this.buffer();
}
function enterFootnoteCall(token) {
	this.enter({
		type: "footnoteReference",
		identifier: "",
		label: ""
	}, token);
}
function enterFootnoteDefinitionLabelString() {
	this.buffer();
}
function enterFootnoteDefinition(token) {
	this.enter({
		type: "footnoteDefinition",
		identifier: "",
		label: "",
		children: []
	}, token);
}
function exitFootnoteCallString(token) {
	const label = this.resume();
	const node$1 = this.stack[this.stack.length - 1];
	ok(node$1.type === "footnoteReference");
	node$1.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
	node$1.label = label;
}
function exitFootnoteCall(token) {
	this.exit(token);
}
function exitFootnoteDefinitionLabelString(token) {
	const label = this.resume();
	const node$1 = this.stack[this.stack.length - 1];
	ok(node$1.type === "footnoteDefinition");
	node$1.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
	node$1.label = label;
}
function exitFootnoteDefinition(token) {
	this.exit(token);
}
function footnoteReferencePeek() {
	return "[";
}
function footnoteReference(node$1, _$1, state, info) {
	const tracker = state.createTracker(info);
	let value = tracker.move("[^");
	const exit$2 = state.enter("footnoteReference");
	const subexit = state.enter("reference");
	value += tracker.move(state.safe(state.associationId(node$1), {
		after: "]",
		before: value
	}));
	subexit();
	exit$2();
	value += tracker.move("]");
	return value;
}
function gfmFootnoteFromMarkdown() {
	return {
		enter: {
			gfmFootnoteCallString: enterFootnoteCallString,
			gfmFootnoteCall: enterFootnoteCall,
			gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
			gfmFootnoteDefinition: enterFootnoteDefinition
		},
		exit: {
			gfmFootnoteCallString: exitFootnoteCallString,
			gfmFootnoteCall: exitFootnoteCall,
			gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
			gfmFootnoteDefinition: exitFootnoteDefinition
		}
	};
}
function gfmFootnoteToMarkdown(options) {
	let firstLineBlank = false;
	if (options && options.firstLineBlank) firstLineBlank = true;
	return {
		handlers: {
			footnoteDefinition,
			footnoteReference
		},
		unsafe: [{
			character: "[",
			inConstruct: [
				"label",
				"phrasing",
				"reference"
			]
		}]
	};
	function footnoteDefinition(node$1, _$1, state, info) {
		const tracker = state.createTracker(info);
		let value = tracker.move("[^");
		const exit$2 = state.enter("footnoteDefinition");
		const subexit = state.enter("label");
		value += tracker.move(state.safe(state.associationId(node$1), {
			before: value,
			after: "]"
		}));
		subexit();
		value += tracker.move("]:");
		if (node$1.children && node$1.children.length > 0) {
			tracker.shift(4);
			value += tracker.move((firstLineBlank ? "\n" : " ") + state.indentLines(state.containerFlow(node$1, tracker.current()), firstLineBlank ? mapAll : mapExceptFirst));
		}
		exit$2();
		return value;
	}
}
function mapExceptFirst(line, index$1, blank$1) {
	return index$1 === 0 ? line : mapAll(line, index$1, blank$1);
}
function mapAll(line, index$1, blank$1) {
	return (blank$1 ? "" : "    ") + line;
}
const constructsWithoutStrikethrough = [
	"autolink",
	"destinationLiteral",
	"destinationRaw",
	"reference",
	"titleQuote",
	"titleApostrophe"
];
handleDelete.peek = peekDelete;
function gfmStrikethroughFromMarkdown() {
	return {
		canContainEols: ["delete"],
		enter: { strikethrough: enterStrikethrough },
		exit: { strikethrough: exitStrikethrough }
	};
}
function gfmStrikethroughToMarkdown() {
	return {
		unsafe: [{
			character: "~",
			inConstruct: "phrasing",
			notInConstruct: constructsWithoutStrikethrough
		}],
		handlers: { delete: handleDelete }
	};
}
function enterStrikethrough(token) {
	this.enter({
		type: "delete",
		children: []
	}, token);
}
function exitStrikethrough(token) {
	this.exit(token);
}
function handleDelete(node$1, _$1, state, info) {
	const tracker = state.createTracker(info);
	const exit$2 = state.enter("strikethrough");
	let value = tracker.move("~~");
	value += state.containerPhrasing(node$1, {
		...tracker.current(),
		before: value,
		after: "~"
	});
	value += tracker.move("~~");
	exit$2();
	return value;
}
function peekDelete() {
	return "~";
}
function defaultStringLength(value) {
	return value.length;
}
function markdownTable(table$1, options) {
	const settings = options || {};
	const align = (settings.align || []).concat();
	const stringLength = settings.stringLength || defaultStringLength;
	const alignments = [];
	const cellMatrix = [];
	const sizeMatrix = [];
	const longestCellByColumn = [];
	let mostCellsPerRow = 0;
	let rowIndex = -1;
	while (++rowIndex < table$1.length) {
		const row$1 = [];
		const sizes$1 = [];
		let columnIndex$1 = -1;
		if (table$1[rowIndex].length > mostCellsPerRow) mostCellsPerRow = table$1[rowIndex].length;
		while (++columnIndex$1 < table$1[rowIndex].length) {
			const cell = serialize(table$1[rowIndex][columnIndex$1]);
			if (settings.alignDelimiters !== false) {
				const size = stringLength(cell);
				sizes$1[columnIndex$1] = size;
				if (longestCellByColumn[columnIndex$1] === void 0 || size > longestCellByColumn[columnIndex$1]) longestCellByColumn[columnIndex$1] = size;
			}
			row$1.push(cell);
		}
		cellMatrix[rowIndex] = row$1;
		sizeMatrix[rowIndex] = sizes$1;
	}
	let columnIndex = -1;
	if (typeof align === "object" && "length" in align) while (++columnIndex < mostCellsPerRow) alignments[columnIndex] = toAlignment(align[columnIndex]);
	else {
		const code$3 = toAlignment(align);
		while (++columnIndex < mostCellsPerRow) alignments[columnIndex] = code$3;
	}
	columnIndex = -1;
	const row = [];
	const sizes = [];
	while (++columnIndex < mostCellsPerRow) {
		const code$3 = alignments[columnIndex];
		let before = "";
		let after = "";
		if (code$3 === 99) {
			before = ":";
			after = ":";
		} else if (code$3 === 108) before = ":";
		else if (code$3 === 114) after = ":";
		let size = settings.alignDelimiters === false ? 1 : Math.max(1, longestCellByColumn[columnIndex] - before.length - after.length);
		const cell = before + "-".repeat(size) + after;
		if (settings.alignDelimiters !== false) {
			size = before.length + size + after.length;
			if (size > longestCellByColumn[columnIndex]) longestCellByColumn[columnIndex] = size;
			sizes[columnIndex] = size;
		}
		row[columnIndex] = cell;
	}
	cellMatrix.splice(1, 0, row);
	sizeMatrix.splice(1, 0, sizes);
	rowIndex = -1;
	const lines = [];
	while (++rowIndex < cellMatrix.length) {
		const row$1 = cellMatrix[rowIndex];
		const sizes$1 = sizeMatrix[rowIndex];
		columnIndex = -1;
		const line = [];
		while (++columnIndex < mostCellsPerRow) {
			const cell = row$1[columnIndex] || "";
			let before = "";
			let after = "";
			if (settings.alignDelimiters !== false) {
				const size = longestCellByColumn[columnIndex] - (sizes$1[columnIndex] || 0);
				const code$3 = alignments[columnIndex];
				if (code$3 === 114) before = " ".repeat(size);
				else if (code$3 === 99) if (size % 2) {
					before = " ".repeat(size / 2 + .5);
					after = " ".repeat(size / 2 - .5);
				} else {
					before = " ".repeat(size / 2);
					after = before;
				}
				else after = " ".repeat(size);
			}
			if (settings.delimiterStart !== false && !columnIndex) line.push("|");
			if (settings.padding !== false && !(settings.alignDelimiters === false && cell === "") && (settings.delimiterStart !== false || columnIndex)) line.push(" ");
			if (settings.alignDelimiters !== false) line.push(before);
			line.push(cell);
			if (settings.alignDelimiters !== false) line.push(after);
			if (settings.padding !== false) line.push(" ");
			if (settings.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) line.push("|");
		}
		lines.push(settings.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join(""));
	}
	return lines.join("\n");
}
function serialize(value) {
	return value === null || value === void 0 ? "" : String(value);
}
function toAlignment(value) {
	const code$3 = typeof value === "string" ? value.codePointAt(0) : 0;
	return code$3 === 67 || code$3 === 99 ? 99 : code$3 === 76 || code$3 === 108 ? 108 : code$3 === 82 || code$3 === 114 ? 114 : 0;
}
function blockquote(node$1, _$1, state, info) {
	const exit$2 = state.enter("blockquote");
	const tracker = state.createTracker(info);
	tracker.move("> ");
	tracker.shift(2);
	const value = state.indentLines(state.containerFlow(node$1, tracker.current()), map$1);
	exit$2();
	return value;
}
function map$1(line, _$1, blank$1) {
	return ">" + (blank$1 ? "" : " ") + line;
}
function patternInScope(stack, pattern) {
	return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
}
function listInScope(stack, list$3, none) {
	if (typeof list$3 === "string") list$3 = [list$3];
	if (!list$3 || list$3.length === 0) return none;
	let index$1 = -1;
	while (++index$1 < list$3.length) if (stack.includes(list$3[index$1])) return true;
	return false;
}
function hardBreak(_$1, _1, state, info) {
	let index$1 = -1;
	while (++index$1 < state.unsafe.length) if (state.unsafe[index$1].character === "\n" && patternInScope(state.stack, state.unsafe[index$1])) return /[ \t]/.test(info.before) ? "" : " ";
	return "\\\n";
}
function longestStreak(value, substring) {
	const source = String(value);
	let index$1 = source.indexOf(substring);
	let expected = index$1;
	let count$1 = 0;
	let max = 0;
	if (typeof substring !== "string") throw new TypeError("Expected substring");
	while (index$1 !== -1) {
		if (index$1 === expected) {
			if (++count$1 > max) max = count$1;
		} else count$1 = 1;
		expected = index$1 + substring.length;
		index$1 = source.indexOf(substring, expected);
	}
	return max;
}
function formatCodeAsIndented(node$1, state) {
	return Boolean(state.options.fences === false && node$1.value && !node$1.lang && /[^ \r\n]/.test(node$1.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node$1.value));
}
function checkFence(state) {
	const marker = state.options.fence || "`";
	if (marker !== "`" && marker !== "~") throw new Error("Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`");
	return marker;
}
function code$1(node$1, _$1, state, info) {
	const marker = checkFence(state);
	const raw$1 = node$1.value || "";
	const suffix = marker === "`" ? "GraveAccent" : "Tilde";
	if (formatCodeAsIndented(node$1, state)) {
		const exit$3 = state.enter("codeIndented");
		const value$1 = state.indentLines(raw$1, map);
		exit$3();
		return value$1;
	}
	const tracker = state.createTracker(info);
	const sequence = marker.repeat(Math.max(longestStreak(raw$1, marker) + 1, 3));
	const exit$2 = state.enter("codeFenced");
	let value = tracker.move(sequence);
	if (node$1.lang) {
		const subexit = state.enter(`codeFencedLang${suffix}`);
		value += tracker.move(state.safe(node$1.lang, {
			before: value,
			after: " ",
			encode: ["`"],
			...tracker.current()
		}));
		subexit();
	}
	if (node$1.lang && node$1.meta) {
		const subexit = state.enter(`codeFencedMeta${suffix}`);
		value += tracker.move(" ");
		value += tracker.move(state.safe(node$1.meta, {
			before: value,
			after: "\n",
			encode: ["`"],
			...tracker.current()
		}));
		subexit();
	}
	value += tracker.move("\n");
	if (raw$1) value += tracker.move(raw$1 + "\n");
	value += tracker.move(sequence);
	exit$2();
	return value;
}
function map(line, _$1, blank$1) {
	return (blank$1 ? "" : "    ") + line;
}
function checkQuote(state) {
	const marker = state.options.quote || "\"";
	if (marker !== "\"" && marker !== "'") throw new Error("Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`");
	return marker;
}
function definition(node$1, _$1, state, info) {
	const quote = checkQuote(state);
	const suffix = quote === "\"" ? "Quote" : "Apostrophe";
	const exit$2 = state.enter("definition");
	let subexit = state.enter("label");
	const tracker = state.createTracker(info);
	let value = tracker.move("[");
	value += tracker.move(state.safe(state.associationId(node$1), {
		before: value,
		after: "]",
		...tracker.current()
	}));
	value += tracker.move("]: ");
	subexit();
	if (!node$1.url || /[\0- \u007F]/.test(node$1.url)) {
		subexit = state.enter("destinationLiteral");
		value += tracker.move("<");
		value += tracker.move(state.safe(node$1.url, {
			before: value,
			after: ">",
			...tracker.current()
		}));
		value += tracker.move(">");
	} else {
		subexit = state.enter("destinationRaw");
		value += tracker.move(state.safe(node$1.url, {
			before: value,
			after: node$1.title ? " " : "\n",
			...tracker.current()
		}));
	}
	subexit();
	if (node$1.title) {
		subexit = state.enter(`title${suffix}`);
		value += tracker.move(" " + quote);
		value += tracker.move(state.safe(node$1.title, {
			before: value,
			after: quote,
			...tracker.current()
		}));
		value += tracker.move(quote);
		subexit();
	}
	exit$2();
	return value;
}
function checkEmphasis(state) {
	const marker = state.options.emphasis || "*";
	if (marker !== "*" && marker !== "_") throw new Error("Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`");
	return marker;
}
function encodeCharacterReference(code$3) {
	return "&#x" + code$3.toString(16).toUpperCase() + ";";
}
function encodeInfo(outside, inside, marker) {
	const outsideKind = classifyCharacter(outside);
	const insideKind = classifyCharacter(inside);
	if (outsideKind === void 0) return insideKind === void 0 ? marker === "_" ? {
		inside: true,
		outside: true
	} : {
		inside: false,
		outside: false
	} : insideKind === 1 ? {
		inside: true,
		outside: true
	} : {
		inside: false,
		outside: true
	};
	if (outsideKind === 1) return insideKind === void 0 ? {
		inside: false,
		outside: false
	} : insideKind === 1 ? {
		inside: true,
		outside: true
	} : {
		inside: false,
		outside: false
	};
	return insideKind === void 0 ? {
		inside: false,
		outside: false
	} : insideKind === 1 ? {
		inside: true,
		outside: false
	} : {
		inside: false,
		outside: false
	};
}
emphasis.peek = emphasisPeek;
function emphasis(node$1, _$1, state, info) {
	const marker = checkEmphasis(state);
	const exit$2 = state.enter("emphasis");
	const tracker = state.createTracker(info);
	const before = tracker.move(marker);
	let between = tracker.move(state.containerPhrasing(node$1, {
		after: marker,
		before,
		...tracker.current()
	}));
	const betweenHead = between.charCodeAt(0);
	const open = encodeInfo(info.before.charCodeAt(info.before.length - 1), betweenHead, marker);
	if (open.inside) between = encodeCharacterReference(betweenHead) + between.slice(1);
	const betweenTail = between.charCodeAt(between.length - 1);
	const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
	if (close.inside) between = between.slice(0, -1) + encodeCharacterReference(betweenTail);
	const after = tracker.move(marker);
	exit$2();
	state.attentionEncodeSurroundingInfo = {
		after: close.outside,
		before: open.outside
	};
	return before + between + after;
}
function emphasisPeek(_$1, _1, state) {
	return state.options.emphasis || "*";
}
function formatHeadingAsSetext(node$1, state) {
	let literalWithBreak = false;
	visit(node$1, function(node$2) {
		if ("value" in node$2 && /\r?\n|\r/.test(node$2.value) || node$2.type === "break") {
			literalWithBreak = true;
			return EXIT;
		}
	});
	return Boolean((!node$1.depth || node$1.depth < 3) && toString$1(node$1) && (state.options.setext || literalWithBreak));
}
function heading(node$1, _$1, state, info) {
	const rank = Math.max(Math.min(6, node$1.depth || 1), 1);
	const tracker = state.createTracker(info);
	if (formatHeadingAsSetext(node$1, state)) {
		const exit$3 = state.enter("headingSetext");
		const subexit$1 = state.enter("phrasing");
		const value$1 = state.containerPhrasing(node$1, {
			...tracker.current(),
			before: "\n",
			after: "\n"
		});
		subexit$1();
		exit$3();
		return value$1 + "\n" + (rank === 1 ? "=" : "-").repeat(value$1.length - (Math.max(value$1.lastIndexOf("\r"), value$1.lastIndexOf("\n")) + 1));
	}
	const sequence = "#".repeat(rank);
	const exit$2 = state.enter("headingAtx");
	const subexit = state.enter("phrasing");
	tracker.move(sequence + " ");
	let value = state.containerPhrasing(node$1, {
		before: "# ",
		after: "\n",
		...tracker.current()
	});
	if (/^[\t ]/.test(value)) value = encodeCharacterReference(value.charCodeAt(0)) + value.slice(1);
	value = value ? sequence + " " + value : sequence;
	if (state.options.closeAtx) value += " " + sequence;
	subexit();
	exit$2();
	return value;
}
html.peek = htmlPeek;
function html(node$1) {
	return node$1.value || "";
}
function htmlPeek() {
	return "<";
}
image.peek = imagePeek;
function image(node$1, _$1, state, info) {
	const quote = checkQuote(state);
	const suffix = quote === "\"" ? "Quote" : "Apostrophe";
	const exit$2 = state.enter("image");
	let subexit = state.enter("label");
	const tracker = state.createTracker(info);
	let value = tracker.move("![");
	value += tracker.move(state.safe(node$1.alt, {
		before: value,
		after: "]",
		...tracker.current()
	}));
	value += tracker.move("](");
	subexit();
	if (!node$1.url && node$1.title || /[\0- \u007F]/.test(node$1.url)) {
		subexit = state.enter("destinationLiteral");
		value += tracker.move("<");
		value += tracker.move(state.safe(node$1.url, {
			before: value,
			after: ">",
			...tracker.current()
		}));
		value += tracker.move(">");
	} else {
		subexit = state.enter("destinationRaw");
		value += tracker.move(state.safe(node$1.url, {
			before: value,
			after: node$1.title ? " " : ")",
			...tracker.current()
		}));
	}
	subexit();
	if (node$1.title) {
		subexit = state.enter(`title${suffix}`);
		value += tracker.move(" " + quote);
		value += tracker.move(state.safe(node$1.title, {
			before: value,
			after: quote,
			...tracker.current()
		}));
		value += tracker.move(quote);
		subexit();
	}
	value += tracker.move(")");
	exit$2();
	return value;
}
function imagePeek() {
	return "!";
}
imageReference.peek = imageReferencePeek;
function imageReference(node$1, _$1, state, info) {
	const type = node$1.referenceType;
	const exit$2 = state.enter("imageReference");
	let subexit = state.enter("label");
	const tracker = state.createTracker(info);
	let value = tracker.move("![");
	const alt = state.safe(node$1.alt, {
		before: value,
		after: "]",
		...tracker.current()
	});
	value += tracker.move(alt + "][");
	subexit();
	const stack = state.stack;
	state.stack = [];
	subexit = state.enter("reference");
	const reference = state.safe(state.associationId(node$1), {
		before: value,
		after: "]",
		...tracker.current()
	});
	subexit();
	state.stack = stack;
	exit$2();
	if (type === "full" || !alt || alt !== reference) value += tracker.move(reference + "]");
	else if (type === "shortcut") value = value.slice(0, -1);
	else value += tracker.move("]");
	return value;
}
function imageReferencePeek() {
	return "!";
}
inlineCode.peek = inlineCodePeek;
function inlineCode(node$1, _$1, state) {
	let value = node$1.value || "";
	let sequence = "`";
	let index$1 = -1;
	while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) sequence += "`";
	if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) value = " " + value + " ";
	while (++index$1 < state.unsafe.length) {
		const pattern = state.unsafe[index$1];
		const expression = state.compilePattern(pattern);
		let match;
		if (!pattern.atBreak) continue;
		while (match = expression.exec(value)) {
			let position$3 = match.index;
			if (value.charCodeAt(position$3) === 10 && value.charCodeAt(position$3 - 1) === 13) position$3--;
			value = value.slice(0, position$3) + " " + value.slice(match.index + 1);
		}
	}
	return sequence + value + sequence;
}
function inlineCodePeek() {
	return "`";
}
function formatLinkAsAutolink(node$1, state) {
	const raw$1 = toString$1(node$1);
	return Boolean(!state.options.resourceLink && node$1.url && !node$1.title && node$1.children && node$1.children.length === 1 && node$1.children[0].type === "text" && (raw$1 === node$1.url || "mailto:" + raw$1 === node$1.url) && /^[a-z][a-z+.-]+:/i.test(node$1.url) && !/[\0- <>\u007F]/.test(node$1.url));
}
link.peek = linkPeek;
function link(node$1, _$1, state, info) {
	const quote = checkQuote(state);
	const suffix = quote === "\"" ? "Quote" : "Apostrophe";
	const tracker = state.createTracker(info);
	let exit$2;
	let subexit;
	if (formatLinkAsAutolink(node$1, state)) {
		const stack = state.stack;
		state.stack = [];
		exit$2 = state.enter("autolink");
		let value$1 = tracker.move("<");
		value$1 += tracker.move(state.containerPhrasing(node$1, {
			before: value$1,
			after: ">",
			...tracker.current()
		}));
		value$1 += tracker.move(">");
		exit$2();
		state.stack = stack;
		return value$1;
	}
	exit$2 = state.enter("link");
	subexit = state.enter("label");
	let value = tracker.move("[");
	value += tracker.move(state.containerPhrasing(node$1, {
		before: value,
		after: "](",
		...tracker.current()
	}));
	value += tracker.move("](");
	subexit();
	if (!node$1.url && node$1.title || /[\0- \u007F]/.test(node$1.url)) {
		subexit = state.enter("destinationLiteral");
		value += tracker.move("<");
		value += tracker.move(state.safe(node$1.url, {
			before: value,
			after: ">",
			...tracker.current()
		}));
		value += tracker.move(">");
	} else {
		subexit = state.enter("destinationRaw");
		value += tracker.move(state.safe(node$1.url, {
			before: value,
			after: node$1.title ? " " : ")",
			...tracker.current()
		}));
	}
	subexit();
	if (node$1.title) {
		subexit = state.enter(`title${suffix}`);
		value += tracker.move(" " + quote);
		value += tracker.move(state.safe(node$1.title, {
			before: value,
			after: quote,
			...tracker.current()
		}));
		value += tracker.move(quote);
		subexit();
	}
	value += tracker.move(")");
	exit$2();
	return value;
}
function linkPeek(node$1, _$1, state) {
	return formatLinkAsAutolink(node$1, state) ? "<" : "[";
}
linkReference.peek = linkReferencePeek;
function linkReference(node$1, _$1, state, info) {
	const type = node$1.referenceType;
	const exit$2 = state.enter("linkReference");
	let subexit = state.enter("label");
	const tracker = state.createTracker(info);
	let value = tracker.move("[");
	const text$8 = state.containerPhrasing(node$1, {
		before: value,
		after: "]",
		...tracker.current()
	});
	value += tracker.move(text$8 + "][");
	subexit();
	const stack = state.stack;
	state.stack = [];
	subexit = state.enter("reference");
	const reference = state.safe(state.associationId(node$1), {
		before: value,
		after: "]",
		...tracker.current()
	});
	subexit();
	state.stack = stack;
	exit$2();
	if (type === "full" || !text$8 || text$8 !== reference) value += tracker.move(reference + "]");
	else if (type === "shortcut") value = value.slice(0, -1);
	else value += tracker.move("]");
	return value;
}
function linkReferencePeek() {
	return "[";
}
function checkBullet(state) {
	const marker = state.options.bullet || "*";
	if (marker !== "*" && marker !== "+" && marker !== "-") throw new Error("Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`");
	return marker;
}
function checkBulletOther(state) {
	const bullet = checkBullet(state);
	const bulletOther = state.options.bulletOther;
	if (!bulletOther) return bullet === "*" ? "-" : "*";
	if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") throw new Error("Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`");
	if (bulletOther === bullet) throw new Error("Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different");
	return bulletOther;
}
function checkBulletOrdered(state) {
	const marker = state.options.bulletOrdered || ".";
	if (marker !== "." && marker !== ")") throw new Error("Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`");
	return marker;
}
function checkRule(state) {
	const marker = state.options.rule || "*";
	if (marker !== "*" && marker !== "-" && marker !== "_") throw new Error("Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`");
	return marker;
}
function list(node$1, parent$1, state, info) {
	const exit$2 = state.enter("list");
	const bulletCurrent = state.bulletCurrent;
	let bullet = node$1.ordered ? checkBulletOrdered(state) : checkBullet(state);
	const bulletOther = node$1.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
	let useDifferentMarker = parent$1 && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
	if (!node$1.ordered) {
		const firstListItem = node$1.children ? node$1.children[0] : void 0;
		if ((bullet === "*" || bullet === "-") && firstListItem && (!firstListItem.children || !firstListItem.children[0]) && state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0) useDifferentMarker = true;
		if (checkRule(state) === bullet && firstListItem) {
			let index$1 = -1;
			while (++index$1 < node$1.children.length) {
				const item = node$1.children[index$1];
				if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
					useDifferentMarker = true;
					break;
				}
			}
		}
	}
	if (useDifferentMarker) bullet = bulletOther;
	state.bulletCurrent = bullet;
	const value = state.containerFlow(node$1, info);
	state.bulletLastUsed = bullet;
	state.bulletCurrent = bulletCurrent;
	exit$2();
	return value;
}
function checkListItemIndent(state) {
	const style$2 = state.options.listItemIndent || "one";
	if (style$2 !== "tab" && style$2 !== "one" && style$2 !== "mixed") throw new Error("Cannot serialize items with `" + style$2 + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`");
	return style$2;
}
function listItem(node$1, parent$1, state, info) {
	const listItemIndent = checkListItemIndent(state);
	let bullet = state.bulletCurrent || checkBullet(state);
	if (parent$1 && parent$1.type === "list" && parent$1.ordered) bullet = (typeof parent$1.start === "number" && parent$1.start > -1 ? parent$1.start : 1) + (state.options.incrementListMarker === false ? 0 : parent$1.children.indexOf(node$1)) + bullet;
	let size = bullet.length + 1;
	if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent$1 && parent$1.type === "list" && parent$1.spread || node$1.spread)) size = Math.ceil(size / 4) * 4;
	const tracker = state.createTracker(info);
	tracker.move(bullet + " ".repeat(size - bullet.length));
	tracker.shift(size);
	const exit$2 = state.enter("listItem");
	const value = state.indentLines(state.containerFlow(node$1, tracker.current()), map$2);
	exit$2();
	return value;
	function map$2(line, index$1, blank$1) {
		if (index$1) return (blank$1 ? "" : " ".repeat(size)) + line;
		return (blank$1 ? bullet : bullet + " ".repeat(size - bullet.length)) + line;
	}
}
function paragraph(node$1, _$1, state, info) {
	const exit$2 = state.enter("paragraph");
	const subexit = state.enter("phrasing");
	const value = state.containerPhrasing(node$1, info);
	subexit();
	exit$2();
	return value;
}
const phrasing = convert([
	"break",
	"delete",
	"emphasis",
	"footnote",
	"footnoteReference",
	"image",
	"imageReference",
	"inlineCode",
	"inlineMath",
	"link",
	"linkReference",
	"mdxJsxTextElement",
	"mdxTextExpression",
	"strong",
	"text",
	"textDirective"
]);
function root(node$1, _$1, state, info) {
	const hasPhrasing = node$1.children.some(function(d$1) {
		return phrasing(d$1);
	});
	const container = hasPhrasing ? state.containerPhrasing : state.containerFlow;
	return container.call(state, node$1, info);
}
function checkStrong(state) {
	const marker = state.options.strong || "*";
	if (marker !== "*" && marker !== "_") throw new Error("Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`");
	return marker;
}
strong.peek = strongPeek;
function strong(node$1, _$1, state, info) {
	const marker = checkStrong(state);
	const exit$2 = state.enter("strong");
	const tracker = state.createTracker(info);
	const before = tracker.move(marker + marker);
	let between = tracker.move(state.containerPhrasing(node$1, {
		after: marker,
		before,
		...tracker.current()
	}));
	const betweenHead = between.charCodeAt(0);
	const open = encodeInfo(info.before.charCodeAt(info.before.length - 1), betweenHead, marker);
	if (open.inside) between = encodeCharacterReference(betweenHead) + between.slice(1);
	const betweenTail = between.charCodeAt(between.length - 1);
	const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
	if (close.inside) between = between.slice(0, -1) + encodeCharacterReference(betweenTail);
	const after = tracker.move(marker + marker);
	exit$2();
	state.attentionEncodeSurroundingInfo = {
		after: close.outside,
		before: open.outside
	};
	return before + between + after;
}
function strongPeek(_$1, _1, state) {
	return state.options.strong || "*";
}
function text$1(node$1, _$1, state, info) {
	return state.safe(node$1.value, info);
}
function checkRuleRepetition(state) {
	const repetition = state.options.ruleRepetition || 3;
	if (repetition < 3) throw new Error("Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more");
	return repetition;
}
function thematicBreak(_$1, _1, state) {
	const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
	return state.options.ruleSpaces ? value.slice(0, -1) : value;
}
const handle = {
	blockquote,
	break: hardBreak,
	code: code$1,
	definition,
	emphasis,
	hardBreak,
	heading,
	html,
	image,
	imageReference,
	inlineCode,
	link,
	linkReference,
	list,
	listItem,
	paragraph,
	root,
	strong,
	text: text$1,
	thematicBreak
};
function gfmTableFromMarkdown() {
	return {
		enter: {
			table: enterTable,
			tableData: enterCell,
			tableHeader: enterCell,
			tableRow: enterRow
		},
		exit: {
			codeText: exitCodeText,
			table: exitTable,
			tableData: exit,
			tableHeader: exit,
			tableRow: exit
		}
	};
}
function enterTable(token) {
	const align = token._align;
	ok(align, "expected `_align` on table");
	this.enter({
		type: "table",
		align: align.map(function(d$1) {
			return d$1 === "none" ? null : d$1;
		}),
		children: []
	}, token);
	this.data.inTable = true;
}
function exitTable(token) {
	this.exit(token);
	this.data.inTable = void 0;
}
function enterRow(token) {
	this.enter({
		type: "tableRow",
		children: []
	}, token);
}
function exit(token) {
	this.exit(token);
}
function enterCell(token) {
	this.enter({
		type: "tableCell",
		children: []
	}, token);
}
function exitCodeText(token) {
	let value = this.resume();
	if (this.data.inTable) value = value.replace(/\\([\\|])/g, replace);
	const node$1 = this.stack[this.stack.length - 1];
	ok(node$1.type === "inlineCode");
	node$1.value = value;
	this.exit(token);
}
function replace($0, $1) {
	return $1 === "|" ? $1 : $0;
}
function gfmTableToMarkdown(options) {
	const settings = options || {};
	const padding = settings.tableCellPadding;
	const alignDelimiters = settings.tablePipeAlign;
	const stringLength = settings.stringLength;
	const around = padding ? " " : "|";
	return {
		unsafe: [
			{
				character: "\r",
				inConstruct: "tableCell"
			},
			{
				character: "\n",
				inConstruct: "tableCell"
			},
			{
				atBreak: true,
				character: "|",
				after: "[	 :-]"
			},
			{
				character: "|",
				inConstruct: "tableCell"
			},
			{
				atBreak: true,
				character: ":",
				after: "-"
			},
			{
				atBreak: true,
				character: "-",
				after: "[:|-]"
			}
		],
		handlers: {
			inlineCode: inlineCodeWithTable,
			table: handleTable,
			tableCell: handleTableCell,
			tableRow: handleTableRow
		}
	};
	function handleTable(node$1, _$1, state, info) {
		return serializeData(handleTableAsData(node$1, state, info), node$1.align);
	}
	function handleTableRow(node$1, _$1, state, info) {
		const row = handleTableRowAsData(node$1, state, info);
		const value = serializeData([row]);
		return value.slice(0, value.indexOf("\n"));
	}
	function handleTableCell(node$1, _$1, state, info) {
		const exit$2 = state.enter("tableCell");
		const subexit = state.enter("phrasing");
		const value = state.containerPhrasing(node$1, {
			...info,
			before: around,
			after: around
		});
		subexit();
		exit$2();
		return value;
	}
	function serializeData(matrix, align) {
		return markdownTable(matrix, {
			align,
			alignDelimiters,
			padding,
			stringLength
		});
	}
	function handleTableAsData(node$1, state, info) {
		const children = node$1.children;
		let index$1 = -1;
		const result = [];
		const subexit = state.enter("table");
		while (++index$1 < children.length) result[index$1] = handleTableRowAsData(children[index$1], state, info);
		subexit();
		return result;
	}
	function handleTableRowAsData(node$1, state, info) {
		const children = node$1.children;
		let index$1 = -1;
		const result = [];
		const subexit = state.enter("tableRow");
		while (++index$1 < children.length) result[index$1] = handleTableCell(children[index$1], node$1, state, info);
		subexit();
		return result;
	}
	function inlineCodeWithTable(node$1, parent$1, state) {
		let value = handle.inlineCode(node$1, parent$1, state);
		if (state.stack.includes("tableCell")) value = value.replace(/\|/g, "\\$&");
		return value;
	}
}
function gfmTaskListItemFromMarkdown() {
	return { exit: {
		taskListCheckValueChecked: exitCheck,
		taskListCheckValueUnchecked: exitCheck,
		paragraph: exitParagraphWithTaskListItem
	} };
}
function gfmTaskListItemToMarkdown() {
	return {
		unsafe: [{
			atBreak: true,
			character: "-",
			after: "[:|-]"
		}],
		handlers: { listItem: listItemWithTaskListItem }
	};
}
function exitCheck(token) {
	const node$1 = this.stack[this.stack.length - 2];
	ok(node$1.type === "listItem");
	node$1.checked = token.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token) {
	const parent$1 = this.stack[this.stack.length - 2];
	if (parent$1 && parent$1.type === "listItem" && typeof parent$1.checked === "boolean") {
		const node$1 = this.stack[this.stack.length - 1];
		ok(node$1.type === "paragraph");
		const head = node$1.children[0];
		if (head && head.type === "text") {
			const siblings = parent$1.children;
			let index$1 = -1;
			let firstParaghraph;
			while (++index$1 < siblings.length) {
				const sibling = siblings[index$1];
				if (sibling.type === "paragraph") {
					firstParaghraph = sibling;
					break;
				}
			}
			if (firstParaghraph === node$1) {
				head.value = head.value.slice(1);
				if (head.value.length === 0) node$1.children.shift();
				else if (node$1.position && head.position && typeof head.position.start.offset === "number") {
					head.position.start.column++;
					head.position.start.offset++;
					node$1.position.start = Object.assign({}, head.position.start);
				}
			}
		}
	}
	this.exit(token);
}
function listItemWithTaskListItem(node$1, parent$1, state, info) {
	const head = node$1.children[0];
	const checkable = typeof node$1.checked === "boolean" && head && head.type === "paragraph";
	const checkbox = "[" + (node$1.checked ? "x" : " ") + "] ";
	const tracker = state.createTracker(info);
	if (checkable) tracker.move(checkbox);
	let value = handle.listItem(node$1, parent$1, state, {
		...info,
		...tracker.current()
	});
	if (checkable) value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
	return value;
	function check($0) {
		return $0 + checkbox;
	}
}
function gfmFromMarkdown() {
	return [
		gfmAutolinkLiteralFromMarkdown(),
		gfmFootnoteFromMarkdown(),
		gfmStrikethroughFromMarkdown(),
		gfmTableFromMarkdown(),
		gfmTaskListItemFromMarkdown()
	];
}
function gfmToMarkdown(options) {
	return { extensions: [
		gfmAutolinkLiteralToMarkdown(),
		gfmFootnoteToMarkdown(options),
		gfmStrikethroughToMarkdown(),
		gfmTableToMarkdown(options),
		gfmTaskListItemToMarkdown()
	] };
}
const wwwPrefix = {
	tokenize: tokenizeWwwPrefix,
	partial: true
};
const domain = {
	tokenize: tokenizeDomain,
	partial: true
};
const path = {
	tokenize: tokenizePath,
	partial: true
};
const trail = {
	tokenize: tokenizeTrail,
	partial: true
};
const emailDomainDotTrail = {
	tokenize: tokenizeEmailDomainDotTrail,
	partial: true
};
const wwwAutolink = {
	name: "wwwAutolink",
	tokenize: tokenizeWwwAutolink,
	previous: previousWww
};
const protocolAutolink = {
	name: "protocolAutolink",
	tokenize: tokenizeProtocolAutolink,
	previous: previousProtocol
};
const emailAutolink = {
	name: "emailAutolink",
	tokenize: tokenizeEmailAutolink,
	previous: previousEmail
};
const text = {};
function gfmAutolinkLiteral() {
	return { text };
}
let code = 48;
while (code < 123) {
	text[code] = emailAutolink;
	code++;
	if (code === 58) code = 65;
	else if (code === 91) code = 97;
}
text[43] = emailAutolink;
text[45] = emailAutolink;
text[46] = emailAutolink;
text[95] = emailAutolink;
text[72] = [emailAutolink, protocolAutolink];
text[104] = [emailAutolink, protocolAutolink];
text[87] = [emailAutolink, wwwAutolink];
text[119] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok$2, nok) {
	const self$1 = this;
	let dot$1;
	let data;
	return start;
	function start(code$3) {
		if (!gfmAtext(code$3) || !previousEmail.call(self$1, self$1.previous) || previousUnbalanced(self$1.events)) return nok(code$3);
		effects.enter("literalAutolink");
		effects.enter("literalAutolinkEmail");
		return atext(code$3);
	}
	function atext(code$3) {
		if (gfmAtext(code$3)) {
			effects.consume(code$3);
			return atext;
		}
		if (code$3 === 64) {
			effects.consume(code$3);
			return emailDomain;
		}
		return nok(code$3);
	}
	function emailDomain(code$3) {
		if (code$3 === 46) return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code$3);
		if (code$3 === 45 || code$3 === 95 || asciiAlphanumeric(code$3)) {
			data = true;
			effects.consume(code$3);
			return emailDomain;
		}
		return emailDomainAfter(code$3);
	}
	function emailDomainDot(code$3) {
		effects.consume(code$3);
		dot$1 = true;
		return emailDomain;
	}
	function emailDomainAfter(code$3) {
		if (data && dot$1 && asciiAlpha(self$1.previous)) {
			effects.exit("literalAutolinkEmail");
			effects.exit("literalAutolink");
			return ok$2(code$3);
		}
		return nok(code$3);
	}
}
function tokenizeWwwAutolink(effects, ok$2, nok) {
	const self$1 = this;
	return wwwStart;
	function wwwStart(code$3) {
		if (code$3 !== 87 && code$3 !== 119 || !previousWww.call(self$1, self$1.previous) || previousUnbalanced(self$1.events)) return nok(code$3);
		effects.enter("literalAutolink");
		effects.enter("literalAutolinkWww");
		return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code$3);
	}
	function wwwAfter(code$3) {
		effects.exit("literalAutolinkWww");
		effects.exit("literalAutolink");
		return ok$2(code$3);
	}
}
function tokenizeProtocolAutolink(effects, ok$2, nok) {
	const self$1 = this;
	let buffer = "";
	let seen = false;
	return protocolStart;
	function protocolStart(code$3) {
		if ((code$3 === 72 || code$3 === 104) && previousProtocol.call(self$1, self$1.previous) && !previousUnbalanced(self$1.events)) {
			effects.enter("literalAutolink");
			effects.enter("literalAutolinkHttp");
			buffer += String.fromCodePoint(code$3);
			effects.consume(code$3);
			return protocolPrefixInside;
		}
		return nok(code$3);
	}
	function protocolPrefixInside(code$3) {
		if (asciiAlpha(code$3) && buffer.length < 5) {
			buffer += String.fromCodePoint(code$3);
			effects.consume(code$3);
			return protocolPrefixInside;
		}
		if (code$3 === 58) {
			const protocol = buffer.toLowerCase();
			if (protocol === "http" || protocol === "https") {
				effects.consume(code$3);
				return protocolSlashesInside;
			}
		}
		return nok(code$3);
	}
	function protocolSlashesInside(code$3) {
		if (code$3 === 47) {
			effects.consume(code$3);
			if (seen) return afterProtocol;
			seen = true;
			return protocolSlashesInside;
		}
		return nok(code$3);
	}
	function afterProtocol(code$3) {
		return code$3 === null || asciiControl(code$3) || markdownLineEndingOrSpace(code$3) || unicodeWhitespace(code$3) || unicodePunctuation(code$3) ? nok(code$3) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code$3);
	}
	function protocolAfter(code$3) {
		effects.exit("literalAutolinkHttp");
		effects.exit("literalAutolink");
		return ok$2(code$3);
	}
}
function tokenizeWwwPrefix(effects, ok$2, nok) {
	let size = 0;
	return wwwPrefixInside;
	function wwwPrefixInside(code$3) {
		if ((code$3 === 87 || code$3 === 119) && size < 3) {
			size++;
			effects.consume(code$3);
			return wwwPrefixInside;
		}
		if (code$3 === 46 && size === 3) {
			effects.consume(code$3);
			return wwwPrefixAfter;
		}
		return nok(code$3);
	}
	function wwwPrefixAfter(code$3) {
		return code$3 === null ? nok(code$3) : ok$2(code$3);
	}
}
function tokenizeDomain(effects, ok$2, nok) {
	let underscoreInLastSegment;
	let underscoreInLastLastSegment;
	let seen;
	return domainInside;
	function domainInside(code$3) {
		if (code$3 === 46 || code$3 === 95) return effects.check(trail, domainAfter, domainAtPunctuation)(code$3);
		if (code$3 === null || markdownLineEndingOrSpace(code$3) || unicodeWhitespace(code$3) || code$3 !== 45 && unicodePunctuation(code$3)) return domainAfter(code$3);
		seen = true;
		effects.consume(code$3);
		return domainInside;
	}
	function domainAtPunctuation(code$3) {
		if (code$3 === 95) underscoreInLastSegment = true;
		else {
			underscoreInLastLastSegment = underscoreInLastSegment;
			underscoreInLastSegment = void 0;
		}
		effects.consume(code$3);
		return domainInside;
	}
	function domainAfter(code$3) {
		if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) return nok(code$3);
		return ok$2(code$3);
	}
}
function tokenizePath(effects, ok$2) {
	let sizeOpen = 0;
	let sizeClose = 0;
	return pathInside;
	function pathInside(code$3) {
		if (code$3 === 40) {
			sizeOpen++;
			effects.consume(code$3);
			return pathInside;
		}
		if (code$3 === 41 && sizeClose < sizeOpen) return pathAtPunctuation(code$3);
		if (code$3 === 33 || code$3 === 34 || code$3 === 38 || code$3 === 39 || code$3 === 41 || code$3 === 42 || code$3 === 44 || code$3 === 46 || code$3 === 58 || code$3 === 59 || code$3 === 60 || code$3 === 63 || code$3 === 93 || code$3 === 95 || code$3 === 126) return effects.check(trail, ok$2, pathAtPunctuation)(code$3);
		if (code$3 === null || markdownLineEndingOrSpace(code$3) || unicodeWhitespace(code$3)) return ok$2(code$3);
		effects.consume(code$3);
		return pathInside;
	}
	function pathAtPunctuation(code$3) {
		if (code$3 === 41) sizeClose++;
		effects.consume(code$3);
		return pathInside;
	}
}
function tokenizeTrail(effects, ok$2, nok) {
	return trail$1;
	function trail$1(code$3) {
		if (code$3 === 33 || code$3 === 34 || code$3 === 39 || code$3 === 41 || code$3 === 42 || code$3 === 44 || code$3 === 46 || code$3 === 58 || code$3 === 59 || code$3 === 63 || code$3 === 95 || code$3 === 126) {
			effects.consume(code$3);
			return trail$1;
		}
		if (code$3 === 38) {
			effects.consume(code$3);
			return trailCharacterReferenceStart;
		}
		if (code$3 === 93) {
			effects.consume(code$3);
			return trailBracketAfter;
		}
		if (code$3 === 60 || code$3 === null || markdownLineEndingOrSpace(code$3) || unicodeWhitespace(code$3)) return ok$2(code$3);
		return nok(code$3);
	}
	function trailBracketAfter(code$3) {
		if (code$3 === null || code$3 === 40 || code$3 === 91 || markdownLineEndingOrSpace(code$3) || unicodeWhitespace(code$3)) return ok$2(code$3);
		return trail$1(code$3);
	}
	function trailCharacterReferenceStart(code$3) {
		return asciiAlpha(code$3) ? trailCharacterReferenceInside(code$3) : nok(code$3);
	}
	function trailCharacterReferenceInside(code$3) {
		if (code$3 === 59) {
			effects.consume(code$3);
			return trail$1;
		}
		if (asciiAlpha(code$3)) {
			effects.consume(code$3);
			return trailCharacterReferenceInside;
		}
		return nok(code$3);
	}
}
function tokenizeEmailDomainDotTrail(effects, ok$2, nok) {
	return start;
	function start(code$3) {
		effects.consume(code$3);
		return after;
	}
	function after(code$3) {
		return asciiAlphanumeric(code$3) ? nok(code$3) : ok$2(code$3);
	}
}
function previousWww(code$3) {
	return code$3 === null || code$3 === 40 || code$3 === 42 || code$3 === 95 || code$3 === 91 || code$3 === 93 || code$3 === 126 || markdownLineEndingOrSpace(code$3);
}
function previousProtocol(code$3) {
	return !asciiAlpha(code$3);
}
function previousEmail(code$3) {
	return !(code$3 === 47 || gfmAtext(code$3));
}
function gfmAtext(code$3) {
	return code$3 === 43 || code$3 === 45 || code$3 === 46 || code$3 === 95 || asciiAlphanumeric(code$3);
}
function previousUnbalanced(events) {
	let index$1 = events.length;
	let result = false;
	while (index$1--) {
		const token = events[index$1][1];
		if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
			result = true;
			break;
		}
		if (token._gfmAutolinkLiteralWalkedInto) {
			result = false;
			break;
		}
	}
	if (events.length > 0 && !result) events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
	return result;
}
const indent = {
	tokenize: tokenizeIndent,
	partial: true
};
function gfmFootnote() {
	return {
		document: { [91]: {
			name: "gfmFootnoteDefinition",
			tokenize: tokenizeDefinitionStart,
			continuation: { tokenize: tokenizeDefinitionContinuation },
			exit: gfmFootnoteDefinitionEnd
		} },
		text: {
			[91]: {
				name: "gfmFootnoteCall",
				tokenize: tokenizeGfmFootnoteCall
			},
			[93]: {
				name: "gfmPotentialFootnoteCall",
				add: "after",
				tokenize: tokenizePotentialGfmFootnoteCall,
				resolveTo: resolveToPotentialGfmFootnoteCall
			}
		}
	};
}
function tokenizePotentialGfmFootnoteCall(effects, ok$2, nok) {
	const self$1 = this;
	let index$1 = self$1.events.length;
	const defined = self$1.parser.gfmFootnotes || (self$1.parser.gfmFootnotes = []);
	let labelStart;
	while (index$1--) {
		const token = self$1.events[index$1][1];
		if (token.type === "labelImage") {
			labelStart = token;
			break;
		}
		if (token.type === "gfmFootnoteCall" || token.type === "labelLink" || token.type === "label" || token.type === "image" || token.type === "link") break;
	}
	return start;
	function start(code$3) {
		if (!labelStart || !labelStart._balanced) return nok(code$3);
		const id$1 = normalizeIdentifier(self$1.sliceSerialize({
			start: labelStart.end,
			end: self$1.now()
		}));
		if (id$1.codePointAt(0) !== 94 || !defined.includes(id$1.slice(1))) return nok(code$3);
		effects.enter("gfmFootnoteCallLabelMarker");
		effects.consume(code$3);
		effects.exit("gfmFootnoteCallLabelMarker");
		return ok$2(code$3);
	}
}
function resolveToPotentialGfmFootnoteCall(events, context) {
	let index$1 = events.length;
	let labelStart;
	while (index$1--) if (events[index$1][1].type === "labelImage" && events[index$1][0] === "enter") {
		labelStart = events[index$1][1];
		break;
	}
	events[index$1 + 1][1].type = "data";
	events[index$1 + 3][1].type = "gfmFootnoteCallLabelMarker";
	const call = {
		type: "gfmFootnoteCall",
		start: Object.assign({}, events[index$1 + 3][1].start),
		end: Object.assign({}, events[events.length - 1][1].end)
	};
	const marker = {
		type: "gfmFootnoteCallMarker",
		start: Object.assign({}, events[index$1 + 3][1].end),
		end: Object.assign({}, events[index$1 + 3][1].end)
	};
	marker.end.column++;
	marker.end.offset++;
	marker.end._bufferIndex++;
	const string$2 = {
		type: "gfmFootnoteCallString",
		start: Object.assign({}, marker.end),
		end: Object.assign({}, events[events.length - 1][1].start)
	};
	const chunk = {
		type: "chunkString",
		contentType: "string",
		start: Object.assign({}, string$2.start),
		end: Object.assign({}, string$2.end)
	};
	const replacement = [
		events[index$1 + 1],
		events[index$1 + 2],
		[
			"enter",
			call,
			context
		],
		events[index$1 + 3],
		events[index$1 + 4],
		[
			"enter",
			marker,
			context
		],
		[
			"exit",
			marker,
			context
		],
		[
			"enter",
			string$2,
			context
		],
		[
			"enter",
			chunk,
			context
		],
		[
			"exit",
			chunk,
			context
		],
		[
			"exit",
			string$2,
			context
		],
		events[events.length - 2],
		events[events.length - 1],
		[
			"exit",
			call,
			context
		]
	];
	events.splice(index$1, events.length - index$1 + 1, ...replacement);
	return events;
}
function tokenizeGfmFootnoteCall(effects, ok$2, nok) {
	const self$1 = this;
	const defined = self$1.parser.gfmFootnotes || (self$1.parser.gfmFootnotes = []);
	let size = 0;
	let data;
	return start;
	function start(code$3) {
		effects.enter("gfmFootnoteCall");
		effects.enter("gfmFootnoteCallLabelMarker");
		effects.consume(code$3);
		effects.exit("gfmFootnoteCallLabelMarker");
		return callStart;
	}
	function callStart(code$3) {
		if (code$3 !== 94) return nok(code$3);
		effects.enter("gfmFootnoteCallMarker");
		effects.consume(code$3);
		effects.exit("gfmFootnoteCallMarker");
		effects.enter("gfmFootnoteCallString");
		effects.enter("chunkString").contentType = "string";
		return callData;
	}
	function callData(code$3) {
		if (size > 999 || code$3 === 93 && !data || code$3 === null || code$3 === 91 || markdownLineEndingOrSpace(code$3)) return nok(code$3);
		if (code$3 === 93) {
			effects.exit("chunkString");
			const token = effects.exit("gfmFootnoteCallString");
			if (!defined.includes(normalizeIdentifier(self$1.sliceSerialize(token)))) return nok(code$3);
			effects.enter("gfmFootnoteCallLabelMarker");
			effects.consume(code$3);
			effects.exit("gfmFootnoteCallLabelMarker");
			effects.exit("gfmFootnoteCall");
			return ok$2;
		}
		if (!markdownLineEndingOrSpace(code$3)) data = true;
		size++;
		effects.consume(code$3);
		return code$3 === 92 ? callEscape : callData;
	}
	function callEscape(code$3) {
		if (code$3 === 91 || code$3 === 92 || code$3 === 93) {
			effects.consume(code$3);
			size++;
			return callData;
		}
		return callData(code$3);
	}
}
function tokenizeDefinitionStart(effects, ok$2, nok) {
	const self$1 = this;
	const defined = self$1.parser.gfmFootnotes || (self$1.parser.gfmFootnotes = []);
	let identifier;
	let size = 0;
	let data;
	return start;
	function start(code$3) {
		effects.enter("gfmFootnoteDefinition")._container = true;
		effects.enter("gfmFootnoteDefinitionLabel");
		effects.enter("gfmFootnoteDefinitionLabelMarker");
		effects.consume(code$3);
		effects.exit("gfmFootnoteDefinitionLabelMarker");
		return labelAtMarker;
	}
	function labelAtMarker(code$3) {
		if (code$3 === 94) {
			effects.enter("gfmFootnoteDefinitionMarker");
			effects.consume(code$3);
			effects.exit("gfmFootnoteDefinitionMarker");
			effects.enter("gfmFootnoteDefinitionLabelString");
			effects.enter("chunkString").contentType = "string";
			return labelInside;
		}
		return nok(code$3);
	}
	function labelInside(code$3) {
		if (size > 999 || code$3 === 93 && !data || code$3 === null || code$3 === 91 || markdownLineEndingOrSpace(code$3)) return nok(code$3);
		if (code$3 === 93) {
			effects.exit("chunkString");
			const token = effects.exit("gfmFootnoteDefinitionLabelString");
			identifier = normalizeIdentifier(self$1.sliceSerialize(token));
			effects.enter("gfmFootnoteDefinitionLabelMarker");
			effects.consume(code$3);
			effects.exit("gfmFootnoteDefinitionLabelMarker");
			effects.exit("gfmFootnoteDefinitionLabel");
			return labelAfter;
		}
		if (!markdownLineEndingOrSpace(code$3)) data = true;
		size++;
		effects.consume(code$3);
		return code$3 === 92 ? labelEscape : labelInside;
	}
	function labelEscape(code$3) {
		if (code$3 === 91 || code$3 === 92 || code$3 === 93) {
			effects.consume(code$3);
			size++;
			return labelInside;
		}
		return labelInside(code$3);
	}
	function labelAfter(code$3) {
		if (code$3 === 58) {
			effects.enter("definitionMarker");
			effects.consume(code$3);
			effects.exit("definitionMarker");
			if (!defined.includes(identifier)) defined.push(identifier);
			return factorySpace(effects, whitespaceAfter, "gfmFootnoteDefinitionWhitespace");
		}
		return nok(code$3);
	}
	function whitespaceAfter(code$3) {
		return ok$2(code$3);
	}
}
function tokenizeDefinitionContinuation(effects, ok$2, nok) {
	return effects.check(blankLine, ok$2, effects.attempt(indent, ok$2, nok));
}
function gfmFootnoteDefinitionEnd(effects) {
	effects.exit("gfmFootnoteDefinition");
}
function tokenizeIndent(effects, ok$2, nok) {
	const self$1 = this;
	return factorySpace(effects, afterPrefix, "gfmFootnoteDefinitionIndent", 5);
	function afterPrefix(code$3) {
		const tail = self$1.events[self$1.events.length - 1];
		return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok$2(code$3) : nok(code$3);
	}
}
function gfmStrikethrough(options) {
	const options_ = options || {};
	let single = options_.singleTilde;
	const tokenizer = {
		name: "strikethrough",
		tokenize: tokenizeStrikethrough,
		resolveAll: resolveAllStrikethrough
	};
	if (single === null || single === void 0) single = true;
	return {
		text: { [126]: tokenizer },
		insideSpan: { null: [tokenizer] },
		attentionMarkers: { null: [126] }
	};
	function resolveAllStrikethrough(events, context) {
		let index$1 = -1;
		while (++index$1 < events.length) if (events[index$1][0] === "enter" && events[index$1][1].type === "strikethroughSequenceTemporary" && events[index$1][1]._close) {
			let open = index$1;
			while (open--) if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && events[index$1][1].end.offset - events[index$1][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
				events[index$1][1].type = "strikethroughSequence";
				events[open][1].type = "strikethroughSequence";
				const strikethrough$1 = {
					type: "strikethrough",
					start: Object.assign({}, events[open][1].start),
					end: Object.assign({}, events[index$1][1].end)
				};
				const text$8 = {
					type: "strikethroughText",
					start: Object.assign({}, events[open][1].end),
					end: Object.assign({}, events[index$1][1].start)
				};
				const nextEvents = [
					[
						"enter",
						strikethrough$1,
						context
					],
					[
						"enter",
						events[open][1],
						context
					],
					[
						"exit",
						events[open][1],
						context
					],
					[
						"enter",
						text$8,
						context
					]
				];
				const insideSpan$1 = context.parser.constructs.insideSpan.null;
				if (insideSpan$1) splice(nextEvents, nextEvents.length, 0, resolveAll(insideSpan$1, events.slice(open + 1, index$1), context));
				splice(nextEvents, nextEvents.length, 0, [
					[
						"exit",
						text$8,
						context
					],
					[
						"enter",
						events[index$1][1],
						context
					],
					[
						"exit",
						events[index$1][1],
						context
					],
					[
						"exit",
						strikethrough$1,
						context
					]
				]);
				splice(events, open - 1, index$1 - open + 3, nextEvents);
				index$1 = open + nextEvents.length - 2;
				break;
			}
		}
		index$1 = -1;
		while (++index$1 < events.length) if (events[index$1][1].type === "strikethroughSequenceTemporary") events[index$1][1].type = "data";
		return events;
	}
	function tokenizeStrikethrough(effects, ok$2, nok) {
		const previous$2 = this.previous;
		const events = this.events;
		let size = 0;
		return start;
		function start(code$3) {
			if (previous$2 === 126 && events[events.length - 1][1].type !== "characterEscape") return nok(code$3);
			effects.enter("strikethroughSequenceTemporary");
			return more(code$3);
		}
		function more(code$3) {
			const before = classifyCharacter(previous$2);
			if (code$3 === 126) {
				if (size > 1) return nok(code$3);
				effects.consume(code$3);
				size++;
				return more;
			}
			if (size < 2 && !single) return nok(code$3);
			const token = effects.exit("strikethroughSequenceTemporary");
			const after = classifyCharacter(code$3);
			token._open = !after || after === 2 && Boolean(before);
			token._close = !before || before === 2 && Boolean(after);
			return ok$2(code$3);
		}
	}
}
var EditMap = class {
	constructor() {
		this.map = [];
	}
	add(index$1, remove, add$1) {
		addImplementation(this, index$1, remove, add$1);
	}
	consume(events) {
		this.map.sort(function(a$1, b) {
			return a$1[0] - b[0];
		});
		if (this.map.length === 0) return;
		let index$1 = this.map.length;
		const vecs = [];
		while (index$1 > 0) {
			index$1 -= 1;
			vecs.push(events.slice(this.map[index$1][0] + this.map[index$1][1]), this.map[index$1][2]);
			events.length = this.map[index$1][0];
		}
		vecs.push(events.slice());
		events.length = 0;
		let slice = vecs.pop();
		while (slice) {
			for (const element$5 of slice) events.push(element$5);
			slice = vecs.pop();
		}
		this.map.length = 0;
	}
};
function addImplementation(editMap, at, remove, add$1) {
	let index$1 = 0;
	if (remove === 0 && add$1.length === 0) return;
	while (index$1 < editMap.map.length) {
		if (editMap.map[index$1][0] === at) {
			editMap.map[index$1][1] += remove;
			editMap.map[index$1][2].push(...add$1);
			return;
		}
		index$1 += 1;
	}
	editMap.map.push([
		at,
		remove,
		add$1
	]);
}
function gfmTableAlign(events, index$1) {
	let inDelimiterRow = false;
	const align = [];
	while (index$1 < events.length) {
		const event = events[index$1];
		if (inDelimiterRow) {
			if (event[0] === "enter") {
				if (event[1].type === "tableContent") align.push(events[index$1 + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
			} else if (event[1].type === "tableContent") {
				if (events[index$1 - 1][1].type === "tableDelimiterMarker") {
					const alignIndex = align.length - 1;
					align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
				}
			} else if (event[1].type === "tableDelimiterRow") break;
		} else if (event[0] === "enter" && event[1].type === "tableDelimiterRow") inDelimiterRow = true;
		index$1 += 1;
	}
	return align;
}
function gfmTable() {
	return { flow: { null: {
		name: "table",
		tokenize: tokenizeTable,
		resolveAll: resolveTable
	} } };
}
function tokenizeTable(effects, ok$2, nok) {
	const self$1 = this;
	let size = 0;
	let sizeB = 0;
	let seen;
	return start;
	function start(code$3) {
		let index$1 = self$1.events.length - 1;
		while (index$1 > -1) {
			const type = self$1.events[index$1][1].type;
			if (type === "lineEnding" || type === "linePrefix") index$1--;
			else break;
		}
		const tail = index$1 > -1 ? self$1.events[index$1][1].type : null;
		const next$1 = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
		if (next$1 === bodyRowStart && self$1.parser.lazy[self$1.now().line]) return nok(code$3);
		return next$1(code$3);
	}
	function headRowBefore(code$3) {
		effects.enter("tableHead");
		effects.enter("tableRow");
		return headRowStart(code$3);
	}
	function headRowStart(code$3) {
		if (code$3 === 124) return headRowBreak(code$3);
		seen = true;
		sizeB += 1;
		return headRowBreak(code$3);
	}
	function headRowBreak(code$3) {
		if (code$3 === null) return nok(code$3);
		if (markdownLineEnding(code$3)) {
			if (sizeB > 1) {
				sizeB = 0;
				self$1.interrupt = true;
				effects.exit("tableRow");
				effects.enter("lineEnding");
				effects.consume(code$3);
				effects.exit("lineEnding");
				return headDelimiterStart;
			}
			return nok(code$3);
		}
		if (markdownSpace(code$3)) return factorySpace(effects, headRowBreak, "whitespace")(code$3);
		sizeB += 1;
		if (seen) {
			seen = false;
			size += 1;
		}
		if (code$3 === 124) {
			effects.enter("tableCellDivider");
			effects.consume(code$3);
			effects.exit("tableCellDivider");
			seen = true;
			return headRowBreak;
		}
		effects.enter("data");
		return headRowData(code$3);
	}
	function headRowData(code$3) {
		if (code$3 === null || code$3 === 124 || markdownLineEndingOrSpace(code$3)) {
			effects.exit("data");
			return headRowBreak(code$3);
		}
		effects.consume(code$3);
		return code$3 === 92 ? headRowEscape : headRowData;
	}
	function headRowEscape(code$3) {
		if (code$3 === 92 || code$3 === 124) {
			effects.consume(code$3);
			return headRowData;
		}
		return headRowData(code$3);
	}
	function headDelimiterStart(code$3) {
		self$1.interrupt = false;
		if (self$1.parser.lazy[self$1.now().line]) return nok(code$3);
		effects.enter("tableDelimiterRow");
		seen = false;
		if (markdownSpace(code$3)) return factorySpace(effects, headDelimiterBefore, "linePrefix", self$1.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code$3);
		return headDelimiterBefore(code$3);
	}
	function headDelimiterBefore(code$3) {
		if (code$3 === 45 || code$3 === 58) return headDelimiterValueBefore(code$3);
		if (code$3 === 124) {
			seen = true;
			effects.enter("tableCellDivider");
			effects.consume(code$3);
			effects.exit("tableCellDivider");
			return headDelimiterCellBefore;
		}
		return headDelimiterNok(code$3);
	}
	function headDelimiterCellBefore(code$3) {
		if (markdownSpace(code$3)) return factorySpace(effects, headDelimiterValueBefore, "whitespace")(code$3);
		return headDelimiterValueBefore(code$3);
	}
	function headDelimiterValueBefore(code$3) {
		if (code$3 === 58) {
			sizeB += 1;
			seen = true;
			effects.enter("tableDelimiterMarker");
			effects.consume(code$3);
			effects.exit("tableDelimiterMarker");
			return headDelimiterLeftAlignmentAfter;
		}
		if (code$3 === 45) {
			sizeB += 1;
			return headDelimiterLeftAlignmentAfter(code$3);
		}
		if (code$3 === null || markdownLineEnding(code$3)) return headDelimiterCellAfter(code$3);
		return headDelimiterNok(code$3);
	}
	function headDelimiterLeftAlignmentAfter(code$3) {
		if (code$3 === 45) {
			effects.enter("tableDelimiterFiller");
			return headDelimiterFiller(code$3);
		}
		return headDelimiterNok(code$3);
	}
	function headDelimiterFiller(code$3) {
		if (code$3 === 45) {
			effects.consume(code$3);
			return headDelimiterFiller;
		}
		if (code$3 === 58) {
			seen = true;
			effects.exit("tableDelimiterFiller");
			effects.enter("tableDelimiterMarker");
			effects.consume(code$3);
			effects.exit("tableDelimiterMarker");
			return headDelimiterRightAlignmentAfter;
		}
		effects.exit("tableDelimiterFiller");
		return headDelimiterRightAlignmentAfter(code$3);
	}
	function headDelimiterRightAlignmentAfter(code$3) {
		if (markdownSpace(code$3)) return factorySpace(effects, headDelimiterCellAfter, "whitespace")(code$3);
		return headDelimiterCellAfter(code$3);
	}
	function headDelimiterCellAfter(code$3) {
		if (code$3 === 124) return headDelimiterBefore(code$3);
		if (code$3 === null || markdownLineEnding(code$3)) {
			if (!seen || size !== sizeB) return headDelimiterNok(code$3);
			effects.exit("tableDelimiterRow");
			effects.exit("tableHead");
			return ok$2(code$3);
		}
		return headDelimiterNok(code$3);
	}
	function headDelimiterNok(code$3) {
		return nok(code$3);
	}
	function bodyRowStart(code$3) {
		effects.enter("tableRow");
		return bodyRowBreak(code$3);
	}
	function bodyRowBreak(code$3) {
		if (code$3 === 124) {
			effects.enter("tableCellDivider");
			effects.consume(code$3);
			effects.exit("tableCellDivider");
			return bodyRowBreak;
		}
		if (code$3 === null || markdownLineEnding(code$3)) {
			effects.exit("tableRow");
			return ok$2(code$3);
		}
		if (markdownSpace(code$3)) return factorySpace(effects, bodyRowBreak, "whitespace")(code$3);
		effects.enter("data");
		return bodyRowData(code$3);
	}
	function bodyRowData(code$3) {
		if (code$3 === null || code$3 === 124 || markdownLineEndingOrSpace(code$3)) {
			effects.exit("data");
			return bodyRowBreak(code$3);
		}
		effects.consume(code$3);
		return code$3 === 92 ? bodyRowEscape : bodyRowData;
	}
	function bodyRowEscape(code$3) {
		if (code$3 === 92 || code$3 === 124) {
			effects.consume(code$3);
			return bodyRowData;
		}
		return bodyRowData(code$3);
	}
}
function resolveTable(events, context) {
	let index$1 = -1;
	let inFirstCellAwaitingPipe = true;
	let rowKind = 0;
	let lastCell = [
		0,
		0,
		0,
		0
	];
	let cell = [
		0,
		0,
		0,
		0
	];
	let afterHeadAwaitingFirstBodyRow = false;
	let lastTableEnd = 0;
	let currentTable;
	let currentBody;
	let currentCell;
	const map$2 = new EditMap();
	while (++index$1 < events.length) {
		const event = events[index$1];
		const token = event[1];
		if (event[0] === "enter") {
			if (token.type === "tableHead") {
				afterHeadAwaitingFirstBodyRow = false;
				if (lastTableEnd !== 0) {
					flushTableEnd(map$2, context, lastTableEnd, currentTable, currentBody);
					currentBody = void 0;
					lastTableEnd = 0;
				}
				currentTable = {
					type: "table",
					start: Object.assign({}, token.start),
					end: Object.assign({}, token.end)
				};
				map$2.add(index$1, 0, [[
					"enter",
					currentTable,
					context
				]]);
			} else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
				inFirstCellAwaitingPipe = true;
				currentCell = void 0;
				lastCell = [
					0,
					0,
					0,
					0
				];
				cell = [
					0,
					index$1 + 1,
					0,
					0
				];
				if (afterHeadAwaitingFirstBodyRow) {
					afterHeadAwaitingFirstBodyRow = false;
					currentBody = {
						type: "tableBody",
						start: Object.assign({}, token.start),
						end: Object.assign({}, token.end)
					};
					map$2.add(index$1, 0, [[
						"enter",
						currentBody,
						context
					]]);
				}
				rowKind = token.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
			} else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
				inFirstCellAwaitingPipe = false;
				if (cell[2] === 0) {
					if (lastCell[1] !== 0) {
						cell[0] = cell[1];
						currentCell = flushCell(map$2, context, lastCell, rowKind, void 0, currentCell);
						lastCell = [
							0,
							0,
							0,
							0
						];
					}
					cell[2] = index$1;
				}
			} else if (token.type === "tableCellDivider") if (inFirstCellAwaitingPipe) inFirstCellAwaitingPipe = false;
			else {
				if (lastCell[1] !== 0) {
					cell[0] = cell[1];
					currentCell = flushCell(map$2, context, lastCell, rowKind, void 0, currentCell);
				}
				lastCell = cell;
				cell = [
					lastCell[1],
					index$1,
					0,
					0
				];
			}
		} else if (token.type === "tableHead") {
			afterHeadAwaitingFirstBodyRow = true;
			lastTableEnd = index$1;
		} else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
			lastTableEnd = index$1;
			if (lastCell[1] !== 0) {
				cell[0] = cell[1];
				currentCell = flushCell(map$2, context, lastCell, rowKind, index$1, currentCell);
			} else if (cell[1] !== 0) currentCell = flushCell(map$2, context, cell, rowKind, index$1, currentCell);
			rowKind = 0;
		} else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) cell[3] = index$1;
	}
	if (lastTableEnd !== 0) flushTableEnd(map$2, context, lastTableEnd, currentTable, currentBody);
	map$2.consume(context.events);
	index$1 = -1;
	while (++index$1 < context.events.length) {
		const event = context.events[index$1];
		if (event[0] === "enter" && event[1].type === "table") event[1]._align = gfmTableAlign(context.events, index$1);
	}
	return events;
}
function flushCell(map$2, context, range, rowKind, rowEnd, previousCell) {
	const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
	const valueName = "tableContent";
	if (range[0] !== 0) {
		previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
		map$2.add(range[0], 0, [[
			"exit",
			previousCell,
			context
		]]);
	}
	const now = getPoint(context.events, range[1]);
	previousCell = {
		type: groupName,
		start: Object.assign({}, now),
		end: Object.assign({}, now)
	};
	map$2.add(range[1], 0, [[
		"enter",
		previousCell,
		context
	]]);
	if (range[2] !== 0) {
		const relatedStart = getPoint(context.events, range[2]);
		const relatedEnd = getPoint(context.events, range[3]);
		const valueToken = {
			type: valueName,
			start: Object.assign({}, relatedStart),
			end: Object.assign({}, relatedEnd)
		};
		map$2.add(range[2], 0, [[
			"enter",
			valueToken,
			context
		]]);
		if (rowKind !== 2) {
			const start = context.events[range[2]];
			const end = context.events[range[3]];
			start[1].end = Object.assign({}, end[1].end);
			start[1].type = "chunkText";
			start[1].contentType = "text";
			if (range[3] > range[2] + 1) {
				const a$1 = range[2] + 1;
				const b = range[3] - range[2] - 1;
				map$2.add(a$1, b, []);
			}
		}
		map$2.add(range[3] + 1, 0, [[
			"exit",
			valueToken,
			context
		]]);
	}
	if (rowEnd !== void 0) {
		previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
		map$2.add(rowEnd, 0, [[
			"exit",
			previousCell,
			context
		]]);
		previousCell = void 0;
	}
	return previousCell;
}
function flushTableEnd(map$2, context, index$1, table$1, tableBody) {
	const exits = [];
	const related = getPoint(context.events, index$1);
	if (tableBody) {
		tableBody.end = Object.assign({}, related);
		exits.push([
			"exit",
			tableBody,
			context
		]);
	}
	table$1.end = Object.assign({}, related);
	exits.push([
		"exit",
		table$1,
		context
	]);
	map$2.add(index$1 + 1, 0, exits);
}
function getPoint(events, index$1) {
	const event = events[index$1];
	const side = event[0] === "enter" ? "start" : "end";
	return event[1][side];
}
const tasklistCheck = {
	name: "tasklistCheck",
	tokenize: tokenizeTasklistCheck
};
function gfmTaskListItem() {
	return { text: { [91]: tasklistCheck } };
}
function tokenizeTasklistCheck(effects, ok$2, nok) {
	const self$1 = this;
	return open;
	function open(code$3) {
		if (self$1.previous !== null || !self$1._gfmTasklistFirstContentOfListItem) return nok(code$3);
		effects.enter("taskListCheck");
		effects.enter("taskListCheckMarker");
		effects.consume(code$3);
		effects.exit("taskListCheckMarker");
		return inside;
	}
	function inside(code$3) {
		if (markdownLineEndingOrSpace(code$3)) {
			effects.enter("taskListCheckValueUnchecked");
			effects.consume(code$3);
			effects.exit("taskListCheckValueUnchecked");
			return close;
		}
		if (code$3 === 88 || code$3 === 120) {
			effects.enter("taskListCheckValueChecked");
			effects.consume(code$3);
			effects.exit("taskListCheckValueChecked");
			return close;
		}
		return nok(code$3);
	}
	function close(code$3) {
		if (code$3 === 93) {
			effects.enter("taskListCheckMarker");
			effects.consume(code$3);
			effects.exit("taskListCheckMarker");
			effects.exit("taskListCheck");
			return after;
		}
		return nok(code$3);
	}
	function after(code$3) {
		if (markdownLineEnding(code$3)) return ok$2(code$3);
		if (markdownSpace(code$3)) return effects.check({ tokenize: spaceThenNonSpace }, ok$2, nok)(code$3);
		return nok(code$3);
	}
}
function spaceThenNonSpace(effects, ok$2, nok) {
	return factorySpace(effects, after, "whitespace");
	function after(code$3) {
		return code$3 === null ? nok(code$3) : ok$2(code$3);
	}
}
function gfm(options) {
	return combineExtensions([
		gfmAutolinkLiteral(),
		gfmFootnote(),
		gfmStrikethrough(options),
		gfmTable(),
		gfmTaskListItem()
	]);
}
const emptyOptions$2 = {};
function remarkGfm(options) {
	const self$1 = this;
	const settings = options || emptyOptions$2;
	const data = self$1.data();
	const micromarkExtensions = data.micromarkExtensions || (data.micromarkExtensions = []);
	const fromMarkdownExtensions = data.fromMarkdownExtensions || (data.fromMarkdownExtensions = []);
	const toMarkdownExtensions = data.toMarkdownExtensions || (data.toMarkdownExtensions = []);
	micromarkExtensions.push(gfm(settings));
	fromMarkdownExtensions.push(gfmFromMarkdown());
	toMarkdownExtensions.push(gfmToMarkdown(settings));
}
const alertRegex = /^\[!(NOTE|TIP|IMPORTANT|WARNING|CAUTION)\]/i;
const alertLegacyRegex = /^\[!(NOTE|TIP|IMPORTANT|WARNING|CAUTION)(\/.*)?\]/i;
const remarkAlert = ({ legacyTitle = false, tagName = "div" } = {}) => {
	return (tree) => {
		visit(tree, "blockquote", (node$1, index$1, parent$1) => {
			let alertType = "";
			let title = "";
			let isNext = true;
			let child = node$1.children.map((item) => {
				if (isNext && item.type === "paragraph") {
					const firstNode = item.children[0];
					const text$8 = firstNode.type === "text" ? firstNode.value : "";
					const reg = legacyTitle ? alertLegacyRegex : alertRegex;
					const match = text$8.match(reg);
					if (match) {
						isNext = false;
						alertType = match[1].toLocaleLowerCase();
						title = legacyTitle ? match[2] || alertType.toLocaleUpperCase() : alertType.toLocaleUpperCase();
						if (text$8.includes("\n")) item.children[0] = {
							type: "text",
							value: text$8.replace(reg, "").replace(/^\n+/, "")
						};
						if (!text$8.includes("\n")) {
							const itemChild = [];
							item.children.forEach((item$1, idx) => {
								if (idx == 0) return;
								if (idx == 1 && item$1.type === "break") return;
								itemChild.push(item$1);
							});
							item.children = [...itemChild];
						}
					}
				}
				return item;
			});
			if (!!alertType) {
				node$1.data = {
					hName: tagName,
					hProperties: {
						class: `markdown-alert markdown-alert-${alertType}`,
						dir: "auto"
					}
				};
				child.unshift({
					type: "paragraph",
					children: [getAlertIcon(alertType), {
						type: "text",
						value: title.replace(/^\//, "")
					}],
					data: { hProperties: {
						class: "markdown-alert-title",
						dir: "auto"
					} }
				});
			}
			node$1.children = [...child];
		});
	};
};
function getAlertIcon(type) {
	let pathD = pathData[type] ?? "";
	return {
		type: "emphasis",
		data: {
			hName: "svg",
			hProperties: {
				class: "octicon",
				viewBox: "0 0 16 16",
				width: "16",
				height: "16",
				ariaHidden: "true"
			}
		},
		children: [{
			type: "emphasis",
			data: {
				hName: "path",
				hProperties: { d: pathD }
			},
			children: []
		}]
	};
}
const pathData = {
	note: "M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z",
	tip: "M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z",
	important: "M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z",
	warning: "M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z",
	caution: "M4.47.22A.749.749 0 0 1 5 0h6c.199 0 .389.079.53.22l4.25 4.25c.141.14.22.331.22.53v6a.749.749 0 0 1-.22.53l-4.25 4.25A.749.749 0 0 1 11 16H5a.749.749 0 0 1-.53-.22L.22 11.53A.749.749 0 0 1 0 11V5c0-.199.079-.389.22-.53Zm.84 1.28L1.5 5.31v5.38l3.81 3.81h5.38l3.81-3.81V5.31L10.69 1.5ZM8 4a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5A.75.75 0 0 1 8 4Zm0 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"
};
function copyTextToClipboard(text$8, cb) {
	if (typeof document === "undefined") return;
	const el = document.createElement("textarea");
	el.value = text$8;
	el.setAttribute("readonly", "");
	el.style = {
		position: "absolute",
		left: "-9999px"
	};
	document.body.appendChild(el);
	const selected = document.getSelection().rangeCount > 0 ? document.getSelection().getRangeAt(0) : false;
	el.select();
	let isCopy = false;
	try {
		const successful = document.execCommand("copy");
		isCopy = !!successful;
	} catch (err) {
		isCopy = false;
	}
	document.body.removeChild(el);
	if (selected && document.getSelection) {
		document.getSelection().removeAllRanges();
		document.getSelection().addRange(selected);
	}
	cb && cb(isCopy);
}
function getParentElement(target) {
	if (!target) return null;
	var dom = target;
	if (dom.dataset.code && dom.classList.contains("copied")) return dom;
	if (dom.parentElement) return getParentElement(dom.parentElement);
	return null;
}
function useCopied(container) {
	var handle$1 = (event) => {
		var target = getParentElement(event.target);
		if (!target) return;
		target.classList.add("active");
		copyTextToClipboard(target.dataset.code, function() {
			setTimeout(() => {
				target.classList.remove("active");
			}, 2e3);
		});
	};
	useEffect(() => {
		var _container$current, _container$current2;
		(_container$current = container.current) == null || _container$current.removeEventListener("click", handle$1, false);
		(_container$current2 = container.current) == null || _container$current2.addEventListener("click", handle$1, false);
		return () => {
			var _container$current3;
			(_container$current3 = container.current) == null || _container$current3.removeEventListener("click", handle$1, false);
		};
	}, [container]);
}
var _excluded = [
	"prefixCls",
	"className",
	"source",
	"style",
	"disableCopy",
	"skipHtml",
	"onScroll",
	"onMouseOver",
	"pluginsFilter",
	"rehypeRewrite",
	"wrapperElement",
	"warpperElement",
	"urlTransform"
];
var defaultUrlTransform = (url) => url;
var preview_default = React.forwardRef((props, ref) => {
	var { prefixCls = "wmde-markdown wmde-markdown-color", className: className$1, source, style: style$2, disableCopy = false, skipHtml = true, onScroll, onMouseOver, pluginsFilter, wrapperElement = {}, warpperElement = {}, urlTransform } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
	var mdp = React.useRef(null);
	useImperativeHandle(ref, () => _extends({}, props, { mdp }), [mdp, props]);
	var cls = (prefixCls || "") + " " + (className$1 || "");
	useCopied(mdp);
	var rehypePlugins = [...other.rehypePlugins || []];
	var customProps = { allowElement: (element$5, index$1, parent$1) => {
		if (other.allowElement) return other.allowElement(element$5, index$1, parent$1);
		return /^[A-Za-z0-9]+$/.test(element$5.tagName);
	} };
	if (!skipHtml) rehypePlugins.push(rehypeRaw);
	var remarkPlugins = [
		remarkAlert,
		...other.remarkPlugins || [],
		remarkGfm
	];
	var wrapperProps = _extends({}, warpperElement, wrapperElement);
	return jsx("div", _extends({
		ref: mdp,
		onScroll,
		onMouseOver
	}, wrapperProps, {
		className: cls,
		style: style$2,
		children: jsx(Markdown, _extends({}, customProps, other, {
			skipHtml: !skipHtml,
			urlTransform: urlTransform || defaultUrlTransform,
			rehypePlugins: pluginsFilter ? pluginsFilter("rehype", rehypePlugins) : rehypePlugins,
			remarkPlugins: pluginsFilter ? pluginsFilter("remark", remarkPlugins) : remarkPlugins,
			children: source || ""
		}))
	}));
});
var reservedMeta = function reservedMeta$1(options) {
	if (options === void 0) options = {};
	return (tree) => {
		visit(tree, (node$1) => {
			if (node$1.type === "element" && node$1.tagName === "code" && node$1.data && node$1.data.meta) node$1.properties = _extends({}, node$1.properties, { "data-meta": String(node$1.data.meta) });
		});
	};
};
var retrieveMeta = function retrieveMeta$1(options) {
	if (options === void 0) options = {};
	return (tree) => {
		visit(tree, (node$1) => {
			if (node$1.type === "element" && node$1.tagName === "code" && node$1.properties && node$1.properties["dataMeta"]) {
				if (!node$1.data) node$1.data = {};
				var metaString = node$1.properties["dataMeta"];
				if (typeof metaString === "string") node$1.data.meta = metaString;
				delete node$1.properties["dataMeta"];
			}
		});
	};
};
const regex = /[\0-\x1F!-,\.\/:-@\[-\^`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482\u0530\u0557\u0558\u055A-\u055F\u0589-\u0590\u05BE\u05C0\u05C3\u05C6\u05C8-\u05CF\u05EB-\u05EE\u05F3-\u060F\u061B-\u061F\u066A-\u066D\u06D4\u06DD\u06DE\u06E9\u06FD\u06FE\u0700-\u070F\u074B\u074C\u07B2-\u07BF\u07F6-\u07F9\u07FB\u07FC\u07FE\u07FF\u082E-\u083F\u085C-\u085F\u086B-\u089F\u08B5\u08C8-\u08D2\u08E2\u0964\u0965\u0970\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09F2-\u09FB\u09FD\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF0-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B54\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B70\u0B72-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BF0-\u0BFF\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C7F\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D0D\u0D11\u0D45\u0D49\u0D4F-\u0D53\u0D58-\u0D5E\u0D64\u0D65\u0D70-\u0D79\u0D80\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF4-\u0E00\u0E3B-\u0E3F\u0E4F\u0E5A-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F01-\u0F17\u0F1A-\u0F1F\u0F2A-\u0F34\u0F36\u0F38\u0F3A-\u0F3D\u0F48\u0F6D-\u0F70\u0F85\u0F98\u0FBD-\u0FC5\u0FC7-\u0FFF\u104A-\u104F\u109E\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u1360-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16ED\u16F9-\u16FF\u170D\u1715-\u171F\u1735-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17D4-\u17D6\u17D8-\u17DB\u17DE\u17DF\u17EA-\u180A\u180E\u180F\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u1945\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DA-\u19FF\u1A1C-\u1A1F\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1AA6\u1AA8-\u1AAF\u1AC1-\u1AFF\u1B4C-\u1B4F\u1B5A-\u1B6A\u1B74-\u1B7F\u1BF4-\u1BFF\u1C38-\u1C3F\u1C4A-\u1C4C\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CCF\u1CD3\u1CFB-\u1CFF\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u203E\u2041-\u2053\u2055-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u20CF\u20F1-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u215F\u2189-\u24B5\u24EA-\u2BFF\u2C2F\u2C5F\u2CE5-\u2CEA\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E00-\u2E2E\u2E30-\u3004\u3008-\u3020\u3030\u3036\u3037\u303D-\u3040\u3097\u3098\u309B\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31C0-\u31EF\u3200-\u33FF\u4DC0-\u4DFF\u9FFD-\u9FFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA62C-\uA63F\uA673\uA67E\uA6F2-\uA716\uA720\uA721\uA789\uA78A\uA7C0\uA7C1\uA7CB-\uA7F4\uA828-\uA82B\uA82D-\uA83F\uA874-\uA87F\uA8C6-\uA8CF\uA8DA-\uA8DF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA954-\uA95F\uA97D-\uA97F\uA9C1-\uA9CE\uA9DA-\uA9DF\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A-\uAA5F\uAA77-\uAA79\uAAC3-\uAADA\uAADE\uAADF\uAAF0\uAAF1\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB6A-\uAB6F\uABEB\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFDFF\uFE10-\uFE1F\uFE30-\uFE32\uFE35-\uFE4C\uFE50-\uFE6F\uFE75\uFEFD-\uFF0F\uFF1A-\uFF20\uFF3B-\uFF3E\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDD3F\uDD75-\uDDFC\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEE1-\uDEFF\uDF20-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE40-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE7-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD28-\uDD2F\uDD3A-\uDE7F\uDEAA\uDEAD-\uDEAF\uDEB2-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF51-\uDFAF\uDFC5-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC47-\uDC65\uDC70-\uDC7E\uDCBB-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD40-\uDD43\uDD48-\uDD4F\uDD74\uDD75\uDD77-\uDD7F\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDFF\uDE12\uDE38-\uDE3D\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC4B-\uDC4F\uDC5A-\uDC5D\uDC62-\uDC7F\uDCC6\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDC1-\uDDD7\uDDDE-\uDDFF\uDE41-\uDE43\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB9-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF3A-\uDFFF]|\uD806[\uDC3B-\uDC9F\uDCEA-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD44-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE2\uDDE5-\uDDFF\uDE3F-\uDE46\uDE48-\uDE4F\uDE9A-\uDE9C\uDE9E-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC41-\uDC4F\uDC5A-\uDC71\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF7-\uDFAF\uDFB1-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD824-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83D\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDECF\uDEEE\uDEEF\uDEF5-\uDEFF\uDF37-\uDF3F\uDF44-\uDF4F\uDF5A-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE2\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82C[\uDD1F-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDC9C\uDC9F-\uDFFF]|\uD834[\uDC00-\uDD64\uDD6A-\uDD6C\uDD73-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDE41\uDE45-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC\uDFCD]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD4F-\uDEBF\uDEFA-\uDFFF]|\uD83A[\uDCC5-\uDCCF\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD83C[\uDC00-\uDD2F\uDD4A-\uDD4F\uDD6A-\uDD6F\uDD8A-\uDFFF]|\uD83E[\uDC00-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEDE-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]/g;
const own = Object.hasOwnProperty;
var BananaSlug = class {
	constructor() {
		this.occurrences;
		this.reset();
	}
	slug(value, maintainCase) {
		const self$1 = this;
		let result = slug(value, maintainCase === true);
		const originalSlug = result;
		while (own.call(self$1.occurrences, result)) {
			self$1.occurrences[originalSlug]++;
			result = originalSlug + "-" + self$1.occurrences[originalSlug];
		}
		self$1.occurrences[result] = 0;
		return result;
	}
	reset() {
		this.occurrences = Object.create(null);
	}
};
function slug(value, maintainCase) {
	if (typeof value !== "string") return "";
	if (!maintainCase) value = value.toLowerCase();
	return value.replace(regex, "").replace(/ /g, "-");
}
function headingRank(node$1) {
	const name$2 = node$1.type === "element" ? node$1.tagName.toLowerCase() : "";
	const code$3 = name$2.length === 2 && name$2.charCodeAt(0) === 104 ? name$2.charCodeAt(1) : 0;
	return code$3 > 48 && code$3 < 55 ? code$3 - 48 : void 0;
}
const emptyOptions$1 = {};
const slugs = new BananaSlug();
function rehypeSlug(options) {
	const settings = options || emptyOptions$1;
	const prefix = settings.prefix || "";
	return function(tree) {
		slugs.reset();
		visit(tree, "element", function(node$1) {
			if (headingRank(node$1) && !node$1.properties.id) node$1.properties.id = prefix + slugs.slug(toString(node$1));
		});
	};
}
const convertElement = function(test$1) {
	if (test$1 === null || test$1 === void 0) return element;
	if (typeof test$1 === "string") return tagNameFactory(test$1);
	if (typeof test$1 === "object") return anyFactory(test$1);
	if (typeof test$1 === "function") return castFactory(test$1);
	throw new Error("Expected function, string, or array as `test`");
};
function anyFactory(tests) {
	const checks$2 = [];
	let index$1 = -1;
	while (++index$1 < tests.length) checks$2[index$1] = convertElement(tests[index$1]);
	return castFactory(any);
	function any(...parameters) {
		let index$2 = -1;
		while (++index$2 < checks$2.length) if (checks$2[index$2].apply(this, parameters)) return true;
		return false;
	}
}
function tagNameFactory(check) {
	return castFactory(tagName);
	function tagName(element$5) {
		return element$5.tagName === check;
	}
}
function castFactory(testFunction) {
	return check;
	function check(value, index$1, parent$1) {
		return Boolean(looksLikeAnElement(value) && testFunction.call(this, value, typeof index$1 === "number" ? index$1 : void 0, parent$1 || void 0));
	}
}
function element(element$5) {
	return Boolean(element$5 && typeof element$5 === "object" && "type" in element$5 && element$5.type === "element" && "tagName" in element$5 && typeof element$5.tagName === "string");
}
function looksLikeAnElement(value) {
	return value !== null && typeof value === "object" && "type" in value && "tagName" in value;
}
const contentDefaults = {
	type: "element",
	tagName: "span",
	properties: { className: ["icon", "icon-link"] },
	children: []
};
const emptyOptions = {};
function rehypeAutolinkHeadings(options) {
	const settings = options || emptyOptions;
	let properties$1 = settings.properties;
	const headingOroperties = settings.headingProperties;
	const behavior = settings.behavior || "prepend";
	const content$2 = settings.content;
	const group = settings.group;
	const is$1 = convertElement(settings.test);
	let method;
	if (behavior === "after" || behavior === "before") method = around;
	else if (behavior === "wrap") method = wrap$2;
	else {
		method = inject;
		if (!properties$1) properties$1 = {
			ariaHidden: "true",
			tabIndex: -1
		};
	}
	return function(tree) {
		visit(tree, "element", function(node$1, index$1, parent$1) {
			if (headingRank(node$1) && node$1.properties.id && is$1(node$1, index$1, parent$1)) {
				Object.assign(node$1.properties, toProperties(headingOroperties, node$1));
				return method(node$1, index$1, parent$1);
			}
		});
	};
	function inject(node$1) {
		const children = toChildren(content$2 || contentDefaults, node$1);
		node$1.children[behavior === "prepend" ? "unshift" : "push"](create(node$1, toProperties(properties$1, node$1), children));
		return [SKIP];
	}
	function around(node$1, index$1, parent$1) {
		if (typeof index$1 !== "number" || !parent$1) return;
		const children = toChildren(content$2 || contentDefaults, node$1);
		const link$2 = create(node$1, toProperties(properties$1, node$1), children);
		let nodes = behavior === "before" ? [link$2, node$1] : [node$1, link$2];
		if (group) {
			const grouping = toNode(group, node$1);
			if (grouping && !Array.isArray(grouping) && grouping.type === "element") {
				grouping.children = nodes;
				nodes = [grouping];
			}
		}
		parent$1.children.splice(index$1, 1, ...nodes);
		return [SKIP, index$1 + nodes.length];
	}
	function wrap$2(node$1) {
		let before = node$1.children;
		let after = [];
		if (typeof content$2 === "function") {
			before = [];
			after = content$2(node$1);
		} else if (content$2) after = clone(content$2);
		node$1.children = [create(node$1, toProperties(properties$1, node$1), Array.isArray(after) ? [...before, ...after] : [...before, after])];
		return [SKIP];
	}
}
function clone(thing) {
	return esm_default$1(thing);
}
function create(node$1, properties$1, children) {
	return {
		type: "element",
		tagName: "a",
		properties: {
			...properties$1,
			href: "#" + node$1.properties.id
		},
		children
	};
}
function toChildren(value, node$1) {
	const result = toNode(value, node$1);
	return Array.isArray(result) ? result : [result];
}
function toNode(value, node$1) {
	if (typeof value === "function") return value(node$1);
	return clone(value);
}
function toProperties(value, node$1) {
	if (typeof value === "function") return value(node$1);
	return value ? clone(value) : {};
}
const rehypeIgnore = (options = {}) => {
	const { openDelimiter = "rehype:ignore:start", closeDelimiter = "rehype:ignore:end" } = options;
	return (tree) => {
		visit(tree, (node$1, index$1, parent$1) => {
			if (node$1.type === "element" || node$1.type === "root") {
				let start = false;
				node$1.children = node$1.children.filter((item) => {
					if (item.type === "raw" || item.type === "comment") {
						let str = (item.value || "").trim();
						str = str.replace(/^<!--(.*?)-->/, "$1");
						if (str === openDelimiter) {
							start = true;
							return false;
						}
						if (str === closeDelimiter) {
							start = false;
							return false;
						}
					}
					return !start;
				});
			}
		});
	};
};
var lib_default$2 = rehypeIgnore;
var octiconLink = {
	type: "element",
	tagName: "svg",
	properties: {
		className: "octicon octicon-link",
		viewBox: "0 0 16 16",
		version: "1.1",
		width: "16",
		height: "16",
		ariaHidden: "true"
	},
	children: [{
		type: "element",
		tagName: "path",
		children: [],
		properties: {
			fillRule: "evenodd",
			d: "M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"
		}
	}]
};
function copyElement(str) {
	if (str === void 0) str = "";
	return {
		type: "element",
		tagName: "div",
		properties: {
			class: "copied",
			"data-code": str
		},
		children: [{
			type: "element",
			tagName: "svg",
			properties: {
				className: "octicon-copy",
				ariaHidden: "true",
				viewBox: "0 0 16 16",
				fill: "currentColor",
				height: 12,
				width: 12
			},
			children: [{
				type: "element",
				tagName: "path",
				properties: {
					fillRule: "evenodd",
					d: "M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"
				},
				children: []
			}, {
				type: "element",
				tagName: "path",
				properties: {
					fillRule: "evenodd",
					d: "M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"
				},
				children: []
			}]
		}, {
			type: "element",
			tagName: "svg",
			properties: {
				className: "octicon-check",
				ariaHidden: "true",
				viewBox: "0 0 16 16",
				fill: "currentColor",
				height: 12,
				width: 12
			},
			children: [{
				type: "element",
				tagName: "path",
				properties: {
					fillRule: "evenodd",
					d: "M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"
				},
				children: []
			}]
		}]
	};
}
var rehypeRewriteHandle = (disableCopy, rewrite) => (node$1, index$1, parent$1) => {
	if (node$1.type === "element" && parent$1 && parent$1.type === "root" && /h(1|2|3|4|5|6)/.test(node$1.tagName)) {
		var child = node$1.children && node$1.children[0];
		if (child && child.properties && child.properties.ariaHidden === "true") {
			child.properties = _extends({ class: "anchor" }, child.properties);
			child.children = [octiconLink];
		}
	}
	if (node$1.type === "element" && node$1.tagName === "pre" && !disableCopy) {
		var code$3 = getCodeString(node$1.children);
		node$1.children.push(copyElement(code$3));
	}
	rewrite && rewrite(node$1, index$1 === null ? void 0 : index$1, parent$1 === null ? void 0 : parent$1);
};
var defaultRehypePlugins = [
	rehypeSlug,
	rehypeAutolinkHeadings,
	lib_default$2
];
var esm_default = React.forwardRef((props, ref) => {
	var _props$disableCopy;
	var rehypePlugins = [
		reservedMeta,
		rehypeRaw,
		retrieveMeta,
		...defaultRehypePlugins,
		[lib_default, { rewrite: rehypeRewriteHandle((_props$disableCopy = props.disableCopy) != null ? _props$disableCopy : false, props.rehypeRewrite) }],
		[lib_default$1, { properties: "attr" }],
		...props.rehypePlugins || [],
		[f, { ignoreMissing: true }]
	];
	return jsx(preview_default, _extends({}, props, {
		rehypePlugins,
		ref
	}));
});
const SvgIconGithub = (props) => React$1.createElement("svg", {
	xmlns: "http://www.w3.org/2000/svg",
	height: 32,
	"aria-hidden": "true",
	viewBox: "0 0 24 24",
	width: 32,
	fill: "current",
	...props
}, React$1.createElement("path", { d: "M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z" }));
var icon_github_default = SvgIconGithub;
const AssignmentDetailProvider = ({ children }) => {
	const { assignmentId = "" } = useParams();
	const userId = useUserIdByParam();
	const { data: assignment } = useAssignmentById(userId, assignmentId);
	const title = assignment ? jsxs(Fragment, { children: [
		jsxs(Link, {
			to: `/@${assignment.user.login}/`,
			children: [assignment.user.login, " 님의 상세페이지"]
		}),
		" ＞ ",
		assignment.title
	] }) : "과제 상세페이지";
	return jsx(PageProvider, {
		title,
		data: assignment,
		children
	});
};
const AssignmentDetail$1 = Object.assign(() => {
	const data = usePageData();
	const ref = useRef(null);
	useEffect(() => {
		const $el = ref.current;
		if (!$el) return void 0;
		const $script = document.createElement("script");
		$script.setAttribute("issue-term", "pathname");
		$script.setAttribute("theme", "github-light");
		$script.setAttribute("repo", `hanghae-plus/front_6th`);
		$script.type = "text/javascript";
		$script.async = true;
		$script.crossOrigin = "anonymous";
		$script.src = "https://utteranc.es/client.js";
		$el.appendChild($script);
	}, []);
	return jsxs("div", {
		ref,
		children: [jsx("div", {
			className: "card-wrap",
			children: jsx(Card, {
				className: "mb-6 p-6 border border-gray-700 bg-gray-800 rounded-lg",
				children: jsx("a", {
					href: data.url,
					target: "_blank",
					children: jsxs("div", {
						className: "flex items-start gap-4",
						children: [jsx("div", {
							className: "flex-shrink-0",
							children: jsx(icon_github_default, {
								fill: "white",
								className: "w-8 h-8"
							})
						}), jsxs("div", {
							className: "flex-1 min-w-0",
							children: [jsxs("div", {
								className: "flex items-center gap-2 mb-2",
								children: [jsx("h3", {
									className: "text-lg font-semibold text-white truncate",
									children: data.title
								}), jsx("span", {
									className: "px-2 py-1 text-xs bg-green-600 text-white rounded-full flex-shrink-0",
									children: "Open"
								})]
							}), jsxs("div", {
								className: "flex items-center gap-4 text-xs text-gray-500",
								children: [jsxs("span", { children: ["by ", data.user.login] }), jsx("span", { children: new Date(data.createdAt).toLocaleDateString("ko-KR") })]
							})]
						})]
					})
				})
			})
		}), jsx("div", {
			className: "overflow-auto",
			children: jsx(esm_default, {
				source: data.body,
				className: "p-6 max-w-full",
				wrapperElement: { "data-color-mode": "dark" },
				style: {
					wordWrap: "break-word",
					overflowWrap: "break-word"
				}
			})
		})]
	});
}, { Provider: AssignmentDetailProvider });
const BASE_URL = "/front_6th/";
const Home = withBaseLayout(Home$1);
const User = withBaseLayout(User$1);
const Assignments = withBaseLayout(() => jsx("div", {
	className: "p-6",
	children: "전체 과제 목록입니다"
}));
const NotFound = withBaseLayout(() => jsx("div", {
	className: "p-6",
	children: "404 - 페이지를 찾을 수 없습니다"
}));
const AssignmentDetail = withBaseLayout(AssignmentDetail$1);
const App = ({ url = "", ssr = false, initData = {} }) => {
	const Router = ssr ? StaticRouter : BrowserRouter;
	return jsx(AppDataProvider, {
		data: initData,
		children: jsx(QueryClientProvider, {
			client: queryClient,
			children: jsx(Router, {
				location: url,
				basename: BASE_URL,
				children: jsxs(Routes, { children: [
					jsx(Route, {
						path: "/",
						Component: Home
					}),
					jsx(Route, {
						path: "/assignments/",
						Component: Assignments
					}),
					jsx(Route, {
						path: "/:id/",
						Component: User
					}),
					jsx(Route, {
						path: "/:id/assignment/:assignmentId/",
						Component: AssignmentDetail
					}),
					jsx(Route, {
						path: "*",
						Component: NotFound
					})
				] })
			})
		})
	});
};
async function render(url) {
	const initData = await fetchUsersWithAssignments();
	const html$6 = renderToString(jsx(App, {
		url,
		initData,
		ssr: true
	}));
	return {
		html: html$6,
		initData
	};
}
export { render };
