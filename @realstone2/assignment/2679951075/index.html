<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="/front_6th/favicon.ico"/>
  
    <title>[3팀 여진석] Chapter 1-3. 프레임워크 없이 SPA 만들기 - 여진석 | 항해플러스 프론트엔드 6기</title>
    <meta name="description" content=" [항해플러스 프론트엔드 6기] 여진석님이 제출한 [3팀 여진석] Chapter 1-3. 프레임워크 없이 SPA 만들기 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="keywords" content="항해플러스, 프론트엔드, 개발자교육, React, TypeScript, JavaScript, 기술면접, 웹개발, 여진석, [3팀 여진석] Chapter 1-3. 프레임워크 없이 SPA 만들기, 과제상세, 코드리뷰, 피드백, Pull Request" />
    <meta property="og:title" content="[3팀 여진석] Chapter 1-3. 프레임워크 없이 SPA 만들기 - 여진석 | 항해플러스 프론트엔드 6기" />
    <meta property="og:description" content=" [항해플러스 프론트엔드 6기] 여진석님이 제출한 [3팀 여진석] Chapter 1-3. 프레임워크 없이 SPA 만들기 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta property="og:image" content="/defaultThumbnail.jpg" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="[3팀 여진석] Chapter 1-3. 프레임워크 없이 SPA 만들기 - 여진석 | 항해플러스 프론트엔드 6기" />
    <meta name="twitter:description" content=" [항해플러스 프론트엔드 6기] 여진석님이 제출한 [3팀 여진석] Chapter 1-3. 프레임워크 없이 SPA 만들기 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="twitter:image" content="/defaultThumbnail.jpg" />
  
  <script type="module" crossorigin src="/front_6th/assets/index-DtEqFcg_.js"></script>
  <link rel="stylesheet" crossorigin href="/front_6th/assets/index-BXO68frB.css">
</head>
<body>
<div id="root"><div data-slot="sidebar-wrapper" style="--sidebar-width:16rem;--sidebar-width-icon:3rem" class="group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full"><div class="min-h-screen flex w-full"><div class="group peer text-sidebar-foreground hidden md:block" data-state="expanded" data-collapsible="" data-variant="sidebar" data-side="left" data-slot="sidebar"><div data-slot="sidebar-gap" class="relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear group-data-[collapsible=offcanvas]:w-0 group-data-[side=right]:rotate-180 group-data-[collapsible=icon]:w-(--sidebar-width-icon)"></div><div data-slot="sidebar-container" class="fixed inset-y-0 z-10 hidden h-svh transition-[left,right,width] duration-200 ease-linear md:flex left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)] group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l w-64"><div data-sidebar="sidebar" data-slot="sidebar-inner" class="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"><div data-slot="sidebar-content" data-sidebar="content" class="flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden bg-card border-r border-border"><a class="p-4" href="/front_6th/" data-discover="true"><div class="flex items-center space-x-2 mb-6"><div class="w-8 h-8 bg-gradient-primary rounded-lg flex items-center justify-center"><span class="text-white font-bold text-sm">6기</span></div><h4 class="text-lg font-bold text-primary">항해플러스 프론트엔드</h4></div></a><div data-slot="sidebar-group" data-sidebar="group" class="relative flex w-full min-w-0 flex-col p-2"><div data-slot="sidebar-group-label" data-sidebar="group-label" class="ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0 text-muted-foreground px-4">학습 관리</div><div data-slot="sidebar-group-content" data-sidebar="group-content" class="w-full text-sm"><ul data-slot="sidebar-menu" data-sidebar="menu" class="flex w-full min-w-0 flex-col gap-1 px-2"><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_6th/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-users h-5 w-5" aria-hidden="true"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><path d="M16 3.128a4 4 0 0 1 0 7.744"></path><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><circle cx="9" cy="7" r="4"></circle></svg><span class="ml-3">수강생 목록</span></a></li><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_6th/assignments/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open h-5 w-5" aria-hidden="true"><path d="M12 7v14"></path><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"></path></svg><span class="ml-3">과제 목록</span></a></li></ul></div></div></div></div></div></div><div class="flex-1 min-w-0"><header class="h-12 flex items-center border-b border-border bg-card px-4"><button data-slot="sidebar-trigger" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-7 mr-4 text-white" data-sidebar="trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-panel-left" aria-hidden="true"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M9 3v18"></path></svg><span class="sr-only">Toggle Sidebar</span></button><h4 class="text-lg font-semibold "><a href="/front_6th/@realstone2/" data-discover="true">realstone2<!-- --> 님의 상세페이지</a> ＞ <!-- -->[3팀 여진석] Chapter 1-3. 프레임워크 없이 SPA 만들기</h4></header><main class="p-6"><div><div class="card-wrap"><div data-slot="card" class="card text-card-foreground flex flex-col gap-6 shadow-sm mb-6 p-6 border border-gray-700 bg-gray-800 rounded-lg"><a href="https://github.com/hanghae-plus/front_6th_chapter1-3/pull/29" target="_blank"><div class="flex items-start gap-4"><div class="flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" height="32" aria-hidden="true" viewBox="0 0 24 24" width="32" fill="white" class="w-8 h-8"><path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg></div><div class="flex-1 min-w-0"><div class="flex items-center gap-2 mb-2"><h3 class="text-lg font-semibold text-white truncate">[3팀 여진석] Chapter 1-3. 프레임워크 없이 SPA 만들기</h3></div><div class="flex items-center gap-4 text-xs text-gray-500"><span>by <!-- -->realstone2</span><span>2025. 7. 20.</span></div></div></div></a></div></div><div class="overflow-auto"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h1 id="react-렌더링-최적화-과제-pr"><a class="anchor" aria-hidden="true" tabindex="-1" href="#react-렌더링-최적화-과제-pr"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>React 렌더링 최적화 과제 PR</h1>
<h2 id="과제-체크포인트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-체크포인트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 체크포인트</h2>
<h3 id="배포-링크"><a class="anchor" aria-hidden="true" tabindex="-1" href="#배포-링크"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>배포 링크</h3>
<p><a href="https://realstone2.github.io/front_6th_chapter1-3/">https://realstone2.github.io/front_6th_chapter1-3/</a></p>
<h3 id="기본과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기본과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기본과제</h3>
<h4 id="equalities"><a class="anchor" aria-hidden="true" tabindex="-1" href="#equalities"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>equalities</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> shallowEquals 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> deepEquals 구현 완료</li>
</ul>
<h4 id="hooks"><a class="anchor" aria-hidden="true" tabindex="-1" href="#hooks"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>hooks</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useRef 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useMemo 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useCallback 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useDeepMemo 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useShallowState 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useAutoCallback 구현 완료</li>
</ul>
<h4 id="high-order-components"><a class="anchor" aria-hidden="true" tabindex="-1" href="#high-order-components"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>High Order Components</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> memo 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> deepMemo 구현 완료</li>
</ul>
<h3 id="심화-과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#심화-과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>심화 과제</h3>
<h4 id="hooks-1"><a class="anchor" aria-hidden="true" tabindex="-1" href="#hooks-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>hooks</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> createObserver를 useSyncExternalStore에 사용하기 적합한 코드로 개선</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useShallowSelector 구현</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useStore 구현</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useRouter 구현</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useStorage 구현</li>
</ul>
<h4 id="context"><a class="anchor" aria-hidden="true" tabindex="-1" href="#context"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>context</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> ToastContext, ModalContext 개선</li>
</ul>
<h2 id="과제-셀프회고"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-셀프회고"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 셀프회고</h2>
<p>이번 과제는 스스로 어느정도 이해하고 있는 파트여서 어렵지 않았다고 느꼈다.
그래서 그 안에서 세부 키워드들의 지식을 다듬고 정리해서 글을 잘 작성해보자라는 목표를 갖고 과제를 시작했다.</p>
<p>useSyncExternalStore과 context 등의 과제가 나왔을 때 환호했다.</p>
<p>늘 정리하고 싶었던 머리속 내용이 있었고, 해당 개념을 글도 작성해보고 스스로 정리할 수 있는 기회라고 느꼈다.</p>
<p>하지만 머리속에 있는 내용을 정리해서 글을 작성하는건 쉬운일이 아니었고,
내가 알고있는 개념에다가 살이 붙기 시작하면서 간단하게 작성하려고 했던 내용이 거대한 내용이 되기도 했다.</p>
<p>그러다보니 내가 원하는 만큼의 회고를 전부 작성하지 못해서 아쉽다.</p>
<p>과제를 끝낼때마다 항상 아쉽다. 더 잘할 수 있을거같은데...</p>
<h3 id="기술적-성장"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기술적-성장"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기술적 성장</h3>
<p>useSyncExternalStore 기반의 상태관리 라이브러리와 useEffect 기반의 상태관리 라이브러리들의 트레이드오프 부분을 이해하고 사용할 수 있게 되었습니다.</p>
<h3 id="자랑하고-싶은-코드"><a class="anchor" aria-hidden="true" tabindex="-1" href="#자랑하고-싶은-코드"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>자랑하고 싶은 코드</h3>
<p>PR을 자랑하고 싶습니다..</p>
<h3 id="개선이-필요하다고-생각하는-코드"><a class="anchor" aria-hidden="true" tabindex="-1" href="#개선이-필요하다고-생각하는-코드"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>개선이 필요하다고 생각하는 코드</h3>
<p>이번엔 어느정도 정답이 정해져있던 코드인 것 같아서, 주제에 대한 생각을 pr에 담아놨습니다!
제가 알고 있는 내용들이 올바르게 알고있는게 맞는지 점검 받고 싶습니다.</p>
<h3 id="학습-효과-분석"><a class="anchor" aria-hidden="true" tabindex="-1" href="#학습-효과-분석"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>학습 효과 분석</h3>
<p>리액트가 외부 스토어와 연결될 때 발생하는 문제들과 여러 외부 스토어들이 선택한 각각의 트레이드 오프에 대해서 명확히 이해할 수 있게 되었습니다.</p>
<p>리액트 Fiber에 대해서는 추가학습이 더 필요할 것 같다고 생각합니다.</p>
<h3 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h3>
<p>이번 과제는 과제 자체는 비교적 간단한 내용이었다고 생각합니다.
그치만 PR에서 정리하는 내용 자체가 스스로의 깊게 생각해볼 수 있는 시간이었고, 팀원들과 피드백도 받으며 얘기해볼 수 있는 과정이라 좋았던 것 같습니다.</p>
<h2 id="심화-학습-고찰"><a class="anchor" aria-hidden="true" tabindex="-1" href="#심화-학습-고찰"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>심화 학습 고찰</h2>
<h3 id="usesyncexternalstore-고찰"><a class="anchor" aria-hidden="true" tabindex="-1" href="#usesyncexternalstore-고찰"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>useSyncExternalStore 고찰</h3>
<p>이번에 외부 스토어를 직접 구현해보면서 useSyncExternalStore를 사용해보았다.
useSyncExternalStore 자체는 아주 간단하고 가벼운 내용이지만 왜 등장했는지부터, 어떤 문제를 해결하고자 했는지를 어떤 부작용이 있는지 깊게 학습해볼 수 있었다.</p>
<h4 id="왜-등장했는지"><a class="anchor" aria-hidden="true" tabindex="-1" href="#왜-등장했는지"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>왜 등장했는지</h4>
<p>react 18의 동시성 기능(Suspense, startTransition, streaming SSR)이 도입되면서, 렌더링 중에 일시 중지 하고 나중에 이어서 렌더링하는 기능이 생겨났다.</p>
<p>하지만 이 때 외부 상태관리와 함께 사용하면 tearing라고 말하는 렌더링 상태 불일치가 발생한다.</p>
<pre><code class="code-highlight"><span class="code-line">// 컴포넌트 A와 B가 같은 외부 store를 읽음
</span><span class="code-line">// React가 A만 먼저 렌더하다가 중간에 멈춤(yield)
</span><span class="code-line">// 그 사이 외부 store 값이 변경됨
</span><span class="code-line">// B는 최신값으로 렌더되지만 A는 이전값 → 불일치 발생
</span></code><div class="copied" data-code="// 컴포넌트 A와 B가 같은 외부 store를 읽음
// React가 A만 먼저 렌더하다가 중간에 멈춤(yield)
// 그 사이 외부 store 값이 변경됨
// B는 최신값으로 렌더되지만 A는 이전값 → 불일치 발생
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이 문제를 해결하기 위해 useSyncExternalStore 가 도입되었다.</p>
<h4 id="문제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#문제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>문제</h4>
<p>tearing문제는 해결되었지만 useSyncExternalStore는 동시성 렌더링과 올바르게 동작하지 않는다.</p>
<p>zustand는 useSyncExternalStore기반으로 구성되어있다.</p>
<p>zustand를 예시로 들어서 코드를 살펴보았다.
<a href="https://codesandbox.io/p/sandbox/zustand-suspense-demo-forked-psqczj?file=%2Fsrc%2FApp.js%3A41%2C38">https://codesandbox.io/p/sandbox/zustand-suspense-demo-forked-psqczj?file=%2Fsrc%2FApp.js%3A41%2C38</a></p>
<p>해당 코드를 보면 suspense 대기까지 isPending으로 동작했어야했지만 isPending이 노출되지 않는다.</p>
<p>useSyncExternalStore로부터 업데이트된 상태변경이 즉각반응하고 startTransition을 통해 업데이트 되었는지 알 수 없기 때문이다.</p>
<h4 id="대안-트레이드-오프"><a class="anchor" aria-hidden="true" tabindex="-1" href="#대안-트레이드-오프"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>대안? 트레이드 오프?</h4>
<p>반면에 jotai는 store를 useEffect로 구독하는 형태로 구성되어있다.
useSyncExternalStore를 사용하지 않고 React 상태에 의존성을 두었다.</p>
<p>zustand때와 거의 동일한 흐름의 코드이지만 isPending이 아주 잘 동작한다.
<a href="https://codesandbox.io/p/sandbox/zustand-suspense-demo-forked-t2pqlr">https://codesandbox.io/p/sandbox/zustand-suspense-demo-forked-t2pqlr</a></p>
<p>jotai는 react 상태 기반으로 state가 관리되기 때문에 startTransition을 통해서 의도된 렌더링 흐름이 흘러간다.</p>
<p>그러나 당연히 그러면 그냥 외부스토어를 구독한 상태가 되니 처음에 발생했던 tearing 문제가 다시 발생한다.
<a href="https://codesandbox.io/p/sandbox/react-tearing-jotai-wqwwqt?file=%2Fsrc%2FCounter.js%3A10%2C1">https://codesandbox.io/p/sandbox/react-tearing-jotai-wqwwqt?file=%2Fsrc%2FCounter.js%3A10%2C1</a></p>
<p><a href="https://blog.axlight.com/posts/why-use-sync-external-store-is-not-used-in-jotai/">https://blog.axlight.com/posts/why-use-sync-external-store-is-not-used-in-jotai/</a>
jotai 개발자 블로그글에 자세히 설명이 되어있다.
jotai에서는 tearing 현상이 발생하더라도 동시성 기능과 의도대로 동작하는 것을 선택한 것이다.</p>
<p>즉 useSyncExternalStore hook이 외부스토어와 리액트간의 모든 문제를 해결해주는 만능 hook이 아니고 트레이드오프의 선택지인 것이다.</p>
<p>모든 라이브러리마다 해결하고자 하는 방향이 있는거고 zustand와 jotai 모두 각각의 의도가 있는 것이다.</p>
<h3 id="shallow-compare-고찰"><a class="anchor" aria-hidden="true" tabindex="-1" href="#shallow-compare-고찰"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>shallow compare 고찰</h3>
<p>어쩌다보니 깃허브 이슈에 올리게 돼서 링크로 대체합니다!
<a href="https://github.com/hanghae-plus/front_6th_chapter1-3/issues/47">https://github.com/hanghae-plus/front_6th_chapter1-3/issues/47</a></p>
<h2 id="학습-갈무리"><a class="anchor" aria-hidden="true" tabindex="-1" href="#학습-갈무리"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>학습 갈무리</h2>
<h3 id="리액트의-렌더링이-어떻게-이루어지는지-정리해주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리액트의-렌더링이-어떻게-이루어지는지-정리해주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리액트의 렌더링이 어떻게 이루어지는지 정리해주세요.</h3>
<h4 id="리액트-렌더링"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리액트-렌더링"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리액트 렌더링</h4>
<p>리액트에서의 렌더링 과정을 간단하게 설명해보자면 4가지 단계로 설명할 수 있다.</p>
<pre><code class="code-highlight"><span class="code-line">Trigger =&gt; Render =&gt; Commit =&gt; Paint
</span></code><div class="copied" data-code="Trigger =&gt; Render =&gt; Commit =&gt; Paint
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>위에 흐름을 좀 더 살을 붙여서 정리하면</p>
<ul>
<li>
<p>Trigger
리액트에서 props, state 가 변경될 때 Trigger가 발생</p>
</li>
<li>
<p>Render
트리거가 발생하게 되면 Render 과정이 발생하게 된다.
Render 과정에서는 재귀적으로 prev VDom에 있는 내용과 새로 렌더링된 VDom을 비교하는 과정을 거친다.</p>
</li>
<li>
<p>Commit
변경된 사항이 있다면 Dom에 커밋</p>
</li>
<li>
<p>Paint
commit된 내용을 브라우저가 렌더링</p>
</li>
</ul>
<h4 id="렌더링은-문제인가"><a class="anchor" aria-hidden="true" tabindex="-1" href="#렌더링은-문제인가"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>렌더링은 문제인가?</h4>
<p><a href="https://kentcdodds.com/blog/fix-the-slow-render-before-you-fix-the-re-render">https://kentcdodds.com/blog/fix-the-slow-render-before-you-fix-the-re-render</a></p>
<p>렌더링은 문제일 수도 있고 문제가 아닐 수도 있다.
렌더링이 발생하더라도 Reconciliation 과정에서 변동된 사항이 없다면 commit은 발생하지 않는다.
commit이 발생하고 브라우저에서 repaint가 발생할 때가 잦아지는 경우가 문제이다.</p>
<p>물론 렌더링중 느린 렌더링이 발생할 경우는 문제이다.</p>
<p>이런 경우에는 렌더링을 최적화하는 방법들의 도입이 필요하다</p>
<h4 id="렌더링-최적화"><a class="anchor" aria-hidden="true" tabindex="-1" href="#렌더링-최적화"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>렌더링 최적화</h4>
<p>리액트에서 제공하는 렌더링 최적화 도구들은 React.useCallback React.useMemo React.memo 들이 있다.
각각 props, deps 들이 변경될 때 얕은비교 과정을 거쳐서 변경되었을 경우 재호출을 하는 방식이다.</p>
<h3 id="메모이제이션에-대한-나의-생각을-적어주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#메모이제이션에-대한-나의-생각을-적어주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>메모이제이션에 대한 나의 생각을 적어주세요.</h3>
<h4 id="메모이제이션"><a class="anchor" aria-hidden="true" tabindex="-1" href="#메모이제이션"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>메모이제이션?</h4>
<p>리액트에서는 state, props, context가 변경되면 해당 컴포넌트에서 리렌더링이 발생하고 컴포넌트 안에 있는 모든 값들은 다시 재계산 된다.</p>
<p>이 때 실제로 재계산이 필요한 경우에만 재계산하도록 하는 의도로 메모이제이션을 한다.</p>
<h4 id="사용하지-않았을-때-발생할-수-있는-문제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#사용하지-않았을-때-발생할-수-있는-문제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>사용하지 않았을 때 발생할 수 있는 문제</h4>
<p>만약에 props로 넘기는 변수가 object라면 리렌더링이 될 때 마다 재할당이 되고 당연히 메모리주소가 바뀌며 props가 변경되었다고 인식한다.</p>
<p>만약 성능이 좋지 않은 list 아이템 컴포넌트에 props를 넘겼다면, 렌더링이 발생할 때 마다 list 아이템 컴포넌트를 재계산하는데 아주 큰 성능이슈가 발생하게 될 것이다.</p>
<p>이 때 React.memo와 React.useMemo를 사용해서 불필요한 렌더링을 막을 수 있을 것이다.</p>
<h4 id="메모이제이션에-대한-장점-단점-나의-생각"><a class="anchor" aria-hidden="true" tabindex="-1" href="#메모이제이션에-대한-장점-단점-나의-생각"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>메모이제이션에 대한 장점, 단점, 나의 생각</h4>
<p>리액트에서 메모이제이션에 대한 논쟁은 핫하다.</p>
<p>회사에서만해도 우리는 의견이 갈리고 있다.
리드 개발자분의 의견은 어떤곳에는 쓰고 안쓰고 생각하는 고민 비용도 비싸고, 굳이 그럴 이유도 없다는 의견이다.
그 반대의 의견은 비싼 계산을 하는 곳도 없고 문제도 없는 코드들이라는게 뻔히 보이는데 왜 넣어야하는지 모르겠다는 의견이다.</p>
<p>양쪽 다 어떤 맥락인지는 이해가 된다. 아무리 고민해도 어려운 것 같다.</p>
<ul>
<li>극단적으로 예시를 든 코드</li>
</ul>
<pre class="language-jsx"><code class="language-jsx code-highlight"><span class="code-line"><span class="token comment">//메모를 해도 안해도 렌더링이 발생하는 곳에서 왜 항상 얕은 비교 코드를 불필요하게 실행시키는가!</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">const</span> memoizedValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword control-flow">return</span> state <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 예시로 상태의 두 배를 계산</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>state<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
</span><span class="code-line">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">    </span><span class="token punctuation">{</span>memoizedValue<span class="token punctuation">}</span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token function">setState</span><span class="token punctuation">(</span>state <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Increment</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</span><span class="code-line"><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="//메모를 해도 안해도 렌더링이 발생하는 곳에서 왜 항상 얕은 비교 코드를 불필요하게 실행시키는가!
const [state, setState] = React.useState(0);

const memoizedValue = useMemo(() =&gt; {
  return state * 2; // 예시로 상태의 두 배를 계산
}, [state]);
return (
  &lt;div&gt;
    {memoizedValue}
    &lt;button onClick={() =&gt; setState(state + 1)}&gt;Increment&lt;/button&gt;
  &lt;/div&gt;
);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>그래도 내가 생각하는 이상적인 메모이제이션은 느린 리렌더링이 발생하는 경우의 문제를 해결할 때 사용하면 된다고 생각한다.</p>
<h3 id="컨텍스트와-상태관리에-대한-나의-생각을-적어주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#컨텍스트와-상태관리에-대한-나의-생각을-적어주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>컨텍스트와 상태관리에 대한 나의 생각을 적어주세요.</h3>
<h4 id="전역상태관리-왜-필요할까"><a class="anchor" aria-hidden="true" tabindex="-1" href="#전역상태관리-왜-필요할까"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>전역상태관리 왜 필요할까</h4>
<p>최근에는 전역상태관리의 필요성 자체가 많이 줄어들고 있다.</p>
<p>tanstack-query 같은 서버 상태 관리 라이브러리가 없을 때는 서버 데이터 요청을 과도하게 하지 않기 위해서 전역적으로 데이터 저장소를 두어 관리하기도 하였다.
최근에는 서버 상태 관리 라이브러리가 이런 부분을 채워주고 있고, 전역상태라는게 필요한 경우가 없다라고 말할 정도로 필요성이 줄어들었다.</p>
<p>나의 생각도 비슷하다.
전역상태관리는 특수한 경우를 제외하고 앱 기능을 만들 때는 거의 불필요하다. ex) global snackbar?
게다가 웹에서는 searchParams라는 UI 정보를 보여주는 아주 좋은 요소도 있다.(심지어 지라에서는 모달을 띄워주는 요소로도 사용하고 있다)</p>
<p>하지만 전역상태관리는 필요없다해도 scope 단위의 상태관리는 매우 유용하다.
개발자의 의도를 담고 클린하게 코드를 관리하기 아주 좋은 방법이라 생각한다.</p>
<p>정리해보자면, 전역상태라이브러리라고 칭하고 있긴 하지만, 필요성이 줄었고 지금은 스코프 단위의 상태관리로써 접근하는게 좋다고 생각한다.
(앱 전역에서 사용해야된다면 앱 전체의 스코프 상태관리라고 접근한다)</p>
<h4 id="context-hook"><a class="anchor" aria-hidden="true" tabindex="-1" href="#context-hook"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Context Hook</h4>
<p><a href="https://ko.react.dev/reference/react/useContext">Context Hook</a>은 Context를 Provider 내부에 있는 자식 컴포넌트들에게 제공해주는 Hook이다. (Provider 내부가 스코프가 된다.)</p>
<p>동작 방식은 Provider에 제공된 context 값을 공유하게 되고 Object.is를 통해 변경되었는지 감지하여 리렌더링한다.
이 때 useContext를 통해 사용하는 자식 컴포넌트들은 모두 함께 리렌더링이 되는 흐름이다.</p>
<p>외부 라이브러리를 사용할필요 없이 React만 사용한다면 바로 사용할 수 있다.</p>
<p>그러나 단순히 그냥 상태관리로써 사용하기에는 렌더링 최적화하는 일련의 과정이 간편하지 않다.</p>
<p>그런데 여기서 하나 더 짚고가야될 점이 있다.
렌더링이 정말 문제인가도 생각해보자.</p>
<h4 id="렌더링"><a class="anchor" aria-hidden="true" tabindex="-1" href="#렌더링"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>렌더링</h4>
<p>렌더링은 문제일 수도 있는거지, 무조건 문제라고 말하기는 어렵다.</p>
<p>렌더링 과정을 간략하게 보면 아래와 비슷하다.</p>
<pre><code class="code-highlight"><span class="code-line">render → reconciliation → commit
</span><span class="code-line">      ↖                   ↙
</span><span class="code-line">           state change
</span></code><div class="copied" data-code="render → reconciliation → commit
      ↖                   ↙
           state change
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>기본적으로 렌더링이 발생해도 reconciliation과정에서 VDom과 Dom과 비교했을 때 변화가 없다면, 커밋이 일어나지 않는다.
Context Hook으로 상태관리할 때를 예로 들자면, 불필요하게 리렌더링이 발생하는 컴포넌트라고해도 실제로는 어차피 commit이 일어나지 않는다.
커밋이 없는 경우에는 dom이 바뀌지 않고, 사용자에게 영향을 주지 않을 것이다.</p>
<p>물론 렌더링 과정만으로 영향을 주는 경우도 있다.
렌더링중에 느린 렌더링이 발생하면 연산과정이 많아지면서 의도치 않게 버벅이는 현상을 마주하게 된다.</p>
<p>전달하고자 하는 말은 느린 렌더링만 발생하지 않는다면, 즉 앱을 내가 효율적으로 잘 관리하고만 있다면,
useContext는 간편하고 좋은 상태관리 수단이 될 수 있다는 말을 하고 싶다.</p>
<blockquote>
<ul>
<li>내가 생각하는 효율적인 관리
useMemo, useCallback, memo 등의 memoization hook을 사용해서 느린 렌더링을 관리해서 효율적으로 관리하는 것을 얘기함</li>
</ul>
</blockquote>
<h4 id="context-hook에-대한-나의-생각"><a class="anchor" aria-hidden="true" tabindex="-1" href="#context-hook에-대한-나의-생각"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>context hook에 대한 나의 생각</h4>
<p>위에서 말한거처럼 효율적으로 앱을 관리하고 있다면 context hook은 리액트 내부코드이기때문에 tearing 현상을 걱정할 필요도 없고, 쉽고 예측가능한 코드를 작성할 수 있다. 상태관리 수단으로도 괜찮은 방법일 수 있다.</p>
<p>하지만 이런 과정을 고민하고 적용하는 것 자체가 상당히 귀찮다고 생각한다.(애초에 상태관리하도록 제공해주는 메서드가 없으니..)
그리고 리액트 개발자는 리렌더링을 극도로 거부감 느끼도록 가스라이팅을 당했기 때문에 나도 거부감이 강하기도 하다.</p>
<p>그래서 context hook은 기본적으로 상태를 주입하는 용도로 사용할 때 좋다고 생각한다.(애초에 그러라고 만들어진 API)
데이터를 주입하는 용도로만 사용할 때 불필요한 렌더링 발생 걱정도 없고, 작성자의 의도를 명확히 파악할 수 있기도 하다.</p>
<h2 id="리뷰-받고-싶은-내용"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리뷰-받고-싶은-내용"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리뷰 받고 싶은 내용</h2>
<h3 id="1-context-외부-상태관리-라이브러리-선택-기준"><a class="anchor" aria-hidden="true" tabindex="-1" href="#1-context-외부-상태관리-라이브러리-선택-기준"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. Context, 외부 상태관리 라이브러리 선택 기준</h3>
<p>제가 정리한 Context Hook에 대한 관점이 실무적으로 적절한지 피드백을 받고 싶습니다</p>
<ul>
<li>&quot;효율적으로 앱을 관리하고 있다면 context hook도 좋은 상태관리 수단&quot;이라는 관점에 대해서 어떻게 생각하시나요?</li>
<li>저번 Q&amp;A 시간에는 전부다 memo를 사용한다고 하셨는데, tool쪽이라 렌더링에 민감한 부분이 영향이 크실까요? 그냥 단순한 웹, 앱 등에서도 전부다 memo하는게 효율적일까요?</li>
<li>코치님이 선호하시는 상태관리는 어떤 것인가요?</li>
<li>저는 서버상태관리 라이브러리들이 생겨나면서 flux 패턴으로 관리하는 패턴자체의 필요성이 많이 줄었다고 생각하여습니다. 그러다보니 jotai를 선호하게 되었는데, 이런 관점에서 코치님이 바라보시는 생각이 궁금합니다.</li>
</ul>
<h3 id="2-usesyncexternalstore-vs-useeffect-기반-구독의-트레이드오프"><a class="anchor" aria-hidden="true" tabindex="-1" href="#2-usesyncexternalstore-vs-useeffect-기반-구독의-트레이드오프"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. useSyncExternalStore vs useEffect 기반 구독의 트레이드오프</h3>
<p>제가 분석한 zustand(useSyncExternalStore) vs jotai(useEffect) 방식의 트레이드오프가 정확한지 확인하고 싶습니다</p>
<ul>
<li>tearing 방지 vs 동시성 기능 호환성</li>
<li>실제 프로덕션 환경에서 이런 트레이드오프가 의미있는 차이를 만드는지</li>
<li>라이브러리 선택 시 이런 요소들을 어느 정도 가중치로 고려해야 하는지</li>
</ul></div></div><div class="overflow-auto mt-9"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h2>
<p>안녕하세요 진석님! 굉장히 깊이있는 고찰을 해주셨네요 ㅎㅎ 재밌게 잘 읽었어요! 고생하셨습니다.</p>
<hr/>
<blockquote>
<p>&quot;효율적으로 앱을 관리하고 있다면 context hook도 좋은 상태관리 수단&quot;이라는 관점에 대해서 어떻게 생각하시나요?</p>
</blockquote>
<p>개인적으로 관리해야 하는 상태가 많아질수록 context를 통해 상태를 관리하는게 굉장히 어렵다고 생각해요. 무엇보다... 성능 최적화를 하는게 너무 어렵답니다 ㅋㅋ (해본사람의 이야기..)</p>
<blockquote>
<p>저번 Q&amp;A 시간에는 전부다 memo를 사용한다고 하셨는데, tool쪽이라 렌더링에 민감한 부분이 영향이 크실까요? 그냥 단순한 웹, 앱 등에서도 전부다 memo하는게 효율적일까요?</p>
</blockquote>
<p>렌더링에 민감해서 했다기보단... 언제 쓰는게 좋을지에 대한 판단을 매번 하는게 귀찮고 한 번 memo를 시작하면 그 여파가 계속 커져서 (메모로 인한 메모로인한 메모로인한 메모로인한, .... 메모) 이럴꺼면 그냥 다써~~ 라고 팀 내에서 합의를 했답니다 ㅎㅎ
커뮤니케이션 비용 때문인거죠</p>
<blockquote>
<p>코치님이 선호하시는 상태관리는 어떤 것인가요?</p>
</blockquote>
<p>저는 간단한 상태관리는 아마 zustand 사용할 것 같고 (사실 실무에서 제대로 사용해본적이 없어요), 복잡한 상태를 다룰 때에는 redux를 사용할 것 같습니다.
redux의 경우 action을 thunk로 쪼개서 조합할 수 있다보니 다루는 상태가 복잡할 때 편의성을 많이 제공해줘요 ㅎㅎ
zustand도 그런게 잇는지 모르겠네..</p>
<blockquote>
<p>저는 서버상태관리 라이브러리들이 생겨나면서 flux 패턴으로 관리하는 패턴자체의 필요성이 많이 줄었다고 생각하여습니다. 그러다보니 jotai를 선호하게 되었는데, 이런 관점에서 코치님이 바라보시는 생각이 궁금합니다.</p>
</blockquote>
<p>앞선 내용과 이어지는 부분인데요, flux가 중요한건 아니라고 생각해요. 대부분의 경우에는 아마 jotai만 사용해도 충분할 것 같네요 ㅎㅎ
제가 zustand나 redux를 선호하는 이유는 react에 종속적이지 않은 방식으로 만들 수 있기 때문인데요, jotai는 react와 강결합(?) 되는 부분이 없지않아 있어서... 그게 조금 거슬렸어요. 이건 선호도 차이도 있고 팀의 인식 차이도 있기 때문에 중요한 부분은 아니라고 생각합니다!</p>
<blockquote>
<p>제가 분석한 zustand(useSyncExternalStore) vs jotai(useEffect) 방식의 트레이드오프가 정확한지 확인하고 싶습니다.</p>
</blockquote>
<p>흠.. 일단 동시성에 대한 부분이 사용성에 얼마나 큰 영향을 주는가를 따져봤을 때... 아마 미미하지 않나? 라고 생각해요. 아마 저는 &quot;사용성&quot;보단 &quot;편의성&quot;을 더 중요하게 생각할 것 같아요. 개발자가 사용하기에 얼마나 더 편리한가! 라고 해야하나 ㅋㅋ</p>
<p>가령, 어플리케이션을 만들 때 사실 네이티브로 만드는게 제일 성능도 좋고 매끄러워요. 그런데 웹뷰를 많이 사용하는 이유는 생산성과 편의성 때문이 크다고 생각합니다.</p>
<p>빠르게 서비스를 만들어가야 하는 부분도 고려 대상이라는거죠.
그래서 저는 &quot;우리 팀이 익숙한 것&quot;도 고려해야 한다고 생각해요. 팀원 대부분이 zustand가 익숙하다면 저는 zustand가 좋은 대안이라고 생각하고, jotai가 익숙하다면 jotai가 좋은 대안이겠죠!?</p>
<p>혹은 개발자의 편의성을 확보해주는 여러가지 도구가 있는지 살펴보는 과정도 필요할 것 같아요.</p></div></div><div class="mt-9"></div></div></main></div></div></div></div>
<script src="https://www.googletagmanager.com/gtag/js?id=G-6J8QP7YK1E"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-6J8QP7YK1E');
</script>
</body>
</html>
