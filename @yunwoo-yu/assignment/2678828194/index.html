<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>항해플러스 프론트엔드 6기 기술블로그</title>
  <link rel="icon" href="/front_6th/favicon.ico"/>
  
  <script type="module" crossorigin src="/front_6th/assets/index-Drf7uASk.js"></script>
  <link rel="stylesheet" crossorigin href="/front_6th/assets/index-Dvjhel9t.css">
</head>
<body>
<div id="root"><link rel="preload" as="image" href="https://github.com/user-attachments/assets/68cab67b-c169-4649-81d1-65bd3f310786"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/e10592cb-be53-4125-9694-f3af3f391eb1"/><div data-slot="sidebar-wrapper" style="--sidebar-width:16rem;--sidebar-width-icon:3rem" class="group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full"><div class="min-h-screen flex w-full"><div class="group peer text-sidebar-foreground hidden md:block" data-state="expanded" data-collapsible="" data-variant="sidebar" data-side="left" data-slot="sidebar"><div data-slot="sidebar-gap" class="relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear group-data-[collapsible=offcanvas]:w-0 group-data-[side=right]:rotate-180 group-data-[collapsible=icon]:w-(--sidebar-width-icon)"></div><div data-slot="sidebar-container" class="fixed inset-y-0 z-10 hidden h-svh transition-[left,right,width] duration-200 ease-linear md:flex left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)] group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l w-64"><div data-sidebar="sidebar" data-slot="sidebar-inner" class="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"><div data-slot="sidebar-content" data-sidebar="content" class="flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden bg-card border-r border-border"><a class="p-4" href="/front_6th/" data-discover="true"><div class="flex items-center space-x-2 mb-6"><div class="w-8 h-8 bg-gradient-primary rounded-lg flex items-center justify-center"><span class="text-white font-bold text-sm">6기</span></div><h4 class="text-lg font-bold text-primary">항해플러스 프론트엔드</h4></div></a><div data-slot="sidebar-group" data-sidebar="group" class="relative flex w-full min-w-0 flex-col p-2"><div data-slot="sidebar-group-label" data-sidebar="group-label" class="ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0 text-muted-foreground px-4">학습 관리</div><div data-slot="sidebar-group-content" data-sidebar="group-content" class="w-full text-sm"><ul data-slot="sidebar-menu" data-sidebar="menu" class="flex w-full min-w-0 flex-col gap-1 px-2"><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_6th/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-users h-5 w-5" aria-hidden="true"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><path d="M16 3.128a4 4 0 0 1 0 7.744"></path><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><circle cx="9" cy="7" r="4"></circle></svg><span class="ml-3">수강생 목록</span></a></li><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_6th/assignments" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open h-5 w-5" aria-hidden="true"><path d="M12 7v14"></path><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"></path></svg><span class="ml-3">과제 목록</span></a></li></ul></div></div></div></div></div></div><div class="flex-1 min-w-0"><header class="h-12 flex items-center border-b border-border bg-card px-4"><button data-slot="sidebar-trigger" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-7 mr-4 text-white" data-sidebar="trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-panel-left" aria-hidden="true"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M9 3v18"></path></svg><span class="sr-only">Toggle Sidebar</span></button><h4 class="text-lg font-semibold "><a href="/front_6th/@yunwoo-yu/" data-discover="true">yunwoo-yu<!-- --> 님의 상세페이지</a> ＞ <!-- -->[2팀 유윤우] Chapter 1-3. 프레임워크 없이 SPA 만들기</h4></header><main class="p-6"><div><div class="card-wrap"><div data-slot="card" class="card text-card-foreground flex flex-col gap-6 shadow-sm mb-6 p-6 border border-gray-700 bg-gray-800 rounded-lg"><a href="https://github.com/hanghae-plus/front_6th_chapter1-3/pull/10" target="_blank"><div class="flex items-start gap-4"><div class="flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" height="32" aria-hidden="true" viewBox="0 0 24 24" width="32" fill="white" class="w-8 h-8"><path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg></div><div class="flex-1 min-w-0"><div class="flex items-center gap-2 mb-2"><h3 class="text-lg font-semibold text-white truncate">[2팀 유윤우] Chapter 1-3. 프레임워크 없이 SPA 만들기</h3></div><div class="flex items-center gap-4 text-xs text-gray-500"><span>by <!-- -->yunwoo-yu</span><span>2025. 7. 19.</span></div></div></div></a></div></div><div class="overflow-auto"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-체크포인트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-체크포인트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 체크포인트</h2>
<h3 id="배포-링크"><a class="anchor" aria-hidden="true" tabindex="-1" href="#배포-링크"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>배포 링크</h3>
<p><a href="https://hanghae-plus.github.io/front_6th_chapter1-3/">https://hanghae-plus.github.io/front_6th_chapter1-3/</a></p>
<h3 id="기본과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기본과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기본과제</h3>
<h4 id="equalities"><a class="anchor" aria-hidden="true" tabindex="-1" href="#equalities"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>equalities</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> shallowEquals 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> deepEquals 구현 완료</li>
</ul>
<h4 id="hooks"><a class="anchor" aria-hidden="true" tabindex="-1" href="#hooks"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>hooks</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useRef 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useMemo 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useCallback 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useDeepMemo 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useShallowState 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useAutoCallback 구현 완료</li>
</ul>
<h4 id="high-order-components"><a class="anchor" aria-hidden="true" tabindex="-1" href="#high-order-components"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>High Order Components</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> memo 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> deepMemo 구현 완료</li>
</ul>
<h3 id="심화-과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#심화-과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>심화 과제</h3>
<h4 id="hooks-1"><a class="anchor" aria-hidden="true" tabindex="-1" href="#hooks-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>hooks</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> createObserver를 useSyncExternalStore에 사용하기 적합한 코드로 개선</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useShallowSelector 구현</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useStore 구현</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useRouter 구현</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useStorage 구현</li>
</ul>
<h3 id="context"><a class="anchor" aria-hidden="true" tabindex="-1" href="#context"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>context</h3>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> ToastContext, ModalContext 개선</li>
</ul>
<h2 id="과제-셀프회고"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-셀프회고"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 셀프회고</h2>
<p>과제를 진행하며 기존에 알고있던 지식도 한번 더 다지고 새로 알게 된 메서드와 해당 훅을 제공하는 라이브러리에서는 어떻게, 왜 이렇게 구현했는지 한번 비교해보고 학습했습니다. 과제테스트를 통과한 후 다른 분들에게 도움을 드렸던 문제들을 정리해봤습니다. 예전에 눈으로만 보며 넘어가서 어렴풋이만 알고있던 지식들을 기록해보며 머릿속에 넣어보려 노력했습니다!</p>
<h3 id="기술적-성장"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기술적-성장"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기술적 성장</h3>
<details>
<summary>자바스크립트의 원시&amp;참조 타입</summary>
<br/>
JavaScript의 원시타입과 참조타입을 다룹니다. 타입을 정확히 이해하면 변수 할당, 함수 파라미터 전달, 상태 관리에서 예상치 못한 버그를 방지할 수 있습니다. 특히 React나 상태 관리 라이브러리를 사용할 때 얕은 비교 동작을 이해하는 데 핵심적인 지식이 됩니다.
<h3 id="원시타입"><a aria-hidden="true" tabindex="-1" href="#원시타입"><span class="icon icon-link"></span></a>원시타입</h3>
<p>원시타입은 JavaScript에서 값 자체가 변수에 직접 저장되는 가장 기본적인 데이터 타입입니다. 객체나 배열과 달리 메모리 주소가 아닌 실제 값이 저장되어, 변수 간 할당 시 값이 복사됩니다.</p>
<p><strong>7가지 원시타입</strong></p>
<p>JavaScript는 다음 7가지 원시타입을 제공합니다:</p>
<ul>
<li>number: 정수와 실수 (42, 3.14, Infinity)</li>
<li>string: 문자열 (&quot;hello&quot;, &#x27;world&#x27;, <code>template</code>)</li>
<li>boolean: 논리값 (true, false)</li>
<li>null: 의도적인 빈 값</li>
<li>undefined: 값이 할당되지 않은 상태</li>
</ul>
<p><strong>특수 원시타입</strong></p>
<ul>
<li>symbol: 유일한 식별자 생성 (ES6+)</li>
<li>bigint: 큰 정수 처리 (ES2020+)</li>
</ul>
<h3 id="symbol-타입-이해하기"><a aria-hidden="true" tabindex="-1" href="#symbol-타입-이해하기"><span class="icon icon-link"></span></a>Symbol 타입 이해하기</h3>
<p>Symbol은 <strong>변경 불가능(immutable)하고 유일함을 보장</strong>하는 원시타입입니다. 주로 객체 프로퍼티의 충돌 없는 키를 만들 때 사용합니다.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> id1 <span class="token operator">=</span> <span class="token known-class-name class-name">Symbol</span><span class="token punctuation">(</span><span class="token string">&#x27;id&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 인자의 문자열은 단지 description의 역할밖에 하지 않는다.</span>
</span><span class="code-line"><span class="token keyword">const</span> id2 <span class="token operator">=</span> <span class="token known-class-name class-name">Symbol</span><span class="token punctuation">(</span><span class="token string">&#x27;id&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">user<span class="token punctuation">[</span>id1<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#x27;user1&#x27;</span><span class="token punctuation">;</span>
</span><span class="code-line">user<span class="token punctuation">[</span>id2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#x27;user2&#x27;</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>user<span class="token punctuation">[</span>id1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#x27;user1&#x27;</span>
</span><span class="code-line"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>user<span class="token punctuation">[</span>id2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#x27;user2&#x27;</span>
</span><span class="code-line"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>id1 <span class="token operator">===</span> id2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false (같은 설명이어도 다른 값)</span>
</span></code><div class="copied" data-code="const user = {};
const id1 = Symbol(&#x27;id&#x27;); // 인자의 문자열은 단지 description의 역할밖에 하지 않는다.
const id2 = Symbol(&#x27;id&#x27;);

user[id1] = &#x27;user1&#x27;;
user[id2] = &#x27;user2&#x27;;

console.log(user[id1]); // &#x27;user1&#x27;
console.log(user[id2]); // &#x27;user2&#x27;
console.log(id1 === id2); // false (같은 설명이어도 다른 값)
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ul>
<li>같은 문자열로 생성해도 항상 다른 값</li>
<li>열거되지 않는다.</li>
<li>문자열 인자는 디버깅 용도일 뿐, 값에 영향이 없다.</li>
</ul>
<p>Symbol 함수의 정적 프로퍼티 중 <strong>Well-Known Symbol</strong>이라 불리는 특별한 심볼들이 있습니다. 이 Well-Known Symbol은 자바스크립트 엔진에 상수로 존재해 이 값을 참조해 일정한 처리를 진행합니다.</p>
<p>일정한 처리라 함은 어떠한 객체가 Symbol.iterator를 프로퍼티 key로 하는 메소드를 가지고 있다면 자바스크립트 엔진은 이 객체가 <strong>이터레이션 프로토콜</strong>을 따른다고 생각하고 이터레이터하게 동작하게 합니다.</p>
<p>저희가 사용하는 빌트인 객체 Array, String 등 순회 가능한 객체는 모두 내부에 Symbol.iterator를 가지고 있기에 이터레이션 프로토콜을 따라 반복문, 스프레드 연산자의 사용이 가능합니다.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token comment">// Symbol.iterator를 키로 사용한 메소드</span>
</span><span class="code-line"><span class="token keyword">const</span> iterableObj <span class="token operator">=</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token punctuation">[</span><span class="token known-class-name class-name">Symbol</span><span class="token punctuation">.</span><span class="token property-access">iterator</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">data</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 일반 함수 사용</span>
</span><span class="code-line">        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> data<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">          <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> data<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token punctuation">}</span>
</span><span class="code-line">        <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">      <span class="token punctuation">}</span>
</span><span class="code-line">    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> value <span class="token keyword">of</span> iterableObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1, 2, 3</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// Symbol.iterator를 키로 사용한 메소드
const iterableObj = {
  data: [1, 2, 3],
  [Symbol.iterator]() {
    let index = 0;
    const data = this.data;
    return {
      next() { // 일반 함수 사용
        if (index &lt; data.length) {
          return { value: data[index++], done: false };
        }
        return { done: true };
      }
    };
  }
};

for (const value of iterableObj) {
  console.log(value); // 1, 2, 3
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<img width="600" height="514" alt="image" src="https://github.com/user-attachments/assets/68cab67b-c169-4649-81d1-65bd3f310786"/>
<h3 id="bigint"><a aria-hidden="true" tabindex="-1" href="#bigint"><span class="icon icon-link"></span></a>bigint</h3>
<p>bigint는 <strong>임의의 정밀도로 정수를 나타낼 수 있는</strong> 원시 타입입니다. Number 타입의 안전한 정수 범위(2^53 - 1)를 넘어서는 큰 정수를 다룰 때 사용됩니다.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token comment">// Number의 한계</span>
</span><span class="code-line"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token known-class-name class-name">Number</span><span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 9007199254740991</span>
</span><span class="code-line"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token known-class-name class-name">Number</span><span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">===</span> <span class="token known-class-name class-name">Number</span><span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true (정밀도 손실)</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// BigInt 사용</span>
</span><span class="code-line"><span class="token keyword">const</span> bigNum1 <span class="token operator">=</span> <span class="token known-class-name class-name">BigInt</span><span class="token punctuation">(</span><span class="token known-class-name class-name">Number</span><span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1n</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> bigNum2 <span class="token operator">=</span> <span class="token known-class-name class-name">BigInt</span><span class="token punctuation">(</span><span class="token known-class-name class-name">Number</span><span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2n</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>bigNum1 <span class="token operator">===</span> bigNum2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false (정확한 계산)</span>
</span><span class="code-line"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bigNum1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;bigint&quot;</span>
</span></code><div class="copied" data-code="// Number의 한계
console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991
console.log(Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2); // true (정밀도 손실)

// BigInt 사용
const bigNum1 = BigInt(Number.MAX_SAFE_INTEGER) + 1n;
const bigNum2 = BigInt(Number.MAX_SAFE_INTEGER) + 2n;

console.log(bigNum1 === bigNum2); // false (정확한 계산)
console.log(typeof bigNum1); // &quot;bigint&quot;
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="원시타입과-참조타입의-차이"><a aria-hidden="true" tabindex="-1" href="#원시타입과-참조타입의-차이"><span class="icon icon-link"></span></a>원시타입과 참조타입의 차이</h3>
<p>참조 타입은 위에서 설명한 타입 외에 모든 객체, 배열 등이 참조 타입으로 분류됩니다. JavaScript의 데이터 타입을 이해하려면 원시타입과 참조타입의 근본적인 차이를 알아야 합니다. 이 차이는 변수 할당, 함수 인자 전달, 비교 연산에서 완전히 다른 동작을 보입니다.</p>
<p><strong>값 저장 방식의 차이</strong></p>
<p>원시타입: 변수에 실제 값이 직접 저장됩니다.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">let</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token comment">// 값 10이 복사되어 저장</span>
</span><span class="code-line">a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>       <span class="token comment">// a만 변경됨</span>
</span><span class="code-line"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span>
</span><span class="code-line"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10 (영향받지 않음)</span>
</span></code><div class="copied" data-code="let a = 10;
let b = a;    // 값 10이 복사되어 저장
a = 20;       // a만 변경됨
console.log(a); // 20
console.log(b); // 10 (영향받지 않음)
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>참조타입: 변수에 **메모리 주소(참조)**가 저장됩니다.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">let</span> obj2 <span class="token operator">=</span> obj1<span class="token punctuation">;</span>  <span class="token comment">// 메모리 주소가 복사되어 같은 객체를 참조</span>
</span><span class="code-line">obj1<span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>  <span class="token comment">// 같은 객체를 수정</span>
</span><span class="code-line"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span>
</span><span class="code-line"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20 (같은 객체이므로 함께 변경)</span>
</span></code><div class="copied" data-code="let obj1 = { value: 10 };
let obj2 = obj1;  // 메모리 주소가 복사되어 같은 객체를 참조
obj1.value = 20;  // 같은 객체를 수정
console.log(obj1.value); // 20
console.log(obj2.value); // 20 (같은 객체이므로 함께 변경)
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>비교 연산의 차이</strong></p>
<p>원시타입: 값 자체를 비교합니다.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>a <span class="token operator">===</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true (같은 값)</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">let</span> str1 <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">let</span> str2 <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>str1 <span class="token operator">===</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true (같은 값)</span>
</span></code><div class="copied" data-code="let a = 5;
let b = 5;
console.log(a === b); // true (같은 값)

let str1 = &quot;hello&quot;;
let str2 = &quot;hello&quot;;
console.log(str1 === str2); // true (같은 값)
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>참조타입: 메모리 주소를 비교합니다.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>obj1 <span class="token operator">===</span> obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false (다른 메모리 주소)</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">let</span> obj3 <span class="token operator">=</span> obj1<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>obj1 <span class="token operator">===</span> obj3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true (같은 메모리 주소)</span>
</span></code><div class="copied" data-code="let obj1 = { value: 5 };
let obj2 = { value: 5 };
console.log(obj1 === obj2); // false (다른 메모리 주소)

let obj3 = obj1;
console.log(obj1 === obj3); // true (같은 메모리 주소)
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>함수 인자 전달의 차이</strong></p>
<p>원시타입: Call by Value (값에 의한 전달)</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword">function</span> <span class="token function">changeValue</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment">// 복사된 값만 변경</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token function">changeValue</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 50 (원본 변수는 변경되지 않음)</span>
</span></code><div class="copied" data-code="function changeValue(x) {
  x = 100;  // 복사된 값만 변경
}

let num = 50;
changeValue(num);
console.log(num); // 50 (원본 변수는 변경되지 않음)
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>참조타입: Call by Reference (참조에 의한 전달)</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword">function</span> <span class="token function">changeObject</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  obj<span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment">// 같은 객체를 수정</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">let</span> myObj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">50</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token function">changeObject</span><span class="token punctuation">(</span>myObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>myObj<span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 100 (원본 객체가 변경됨)</span>
</span></code><div class="copied" data-code="function changeObject(obj) {
  obj.value = 100;  // 같은 객체를 수정
}

let myObj = { value: 50 };
changeObject(myObj);
console.log(myObj.value); // 100 (원본 객체가 변경됨)
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>💡 이러한 차이점은 React 사용 시 알아야 하는 불변성 개념과 직결됩니다. 특히 참조타입을 다룰 때 의도치 않게 원본 객체나 배열을 변경하여 예상과 다른 동작을 일으킬 수 있으므로, 두 타입의 차이점을 명확히 이해하고 코드를 작성하는 것이 중요합니다.</p>
</details>
<details>
<summary>얕은 비교, 깊은 비교</summary>
<h3 id="자바스크립트에서의-비교"><a aria-hidden="true" tabindex="-1" href="#자바스크립트에서의-비교"><span class="icon icon-link"></span></a>자바스크립트에서의 비교</h3>
<p>자바스크립트에서 값을 비교하는 연산자는 두 가지입니다.</p>
<ul>
<li>동등연산자(==): 값만 비교하고 타입은 무시합니다.</li>
<li>일치연산자(===): 값과 타입을 모두 비교합니다.</li>
</ul>
<p>대부분의 경우 일치연산자로 충분하지만, 다음과 같은 특수한 경우에는 예상과 다른 결과가 나올 수 있습니다.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token comment">// 일치 연산자의 경우</span>
</span><span class="code-line"><span class="token number">NaN</span> <span class="token operator">===</span> <span class="token number">NaN</span>  <span class="token comment">// false</span>
</span><span class="code-line"><span class="token operator">+</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">0</span>    <span class="token comment">// true</span>
</span></code><div class="copied" data-code="// 일치 연산자의 경우
NaN === NaN  // false
+0 === -0    // true
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>정확한 비교가 필요하다면 Object.is() 메서드를 사용 해야합니다.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">is</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">,</span> <span class="token number">NaN</span><span class="token punctuation">)</span>  <span class="token comment">// true</span>
</span><span class="code-line"><span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">is</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment">// false</span>
</span></code><div class="copied" data-code="Object.is(NaN, NaN)  // true
Object.is(+0, -0)    // false
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>Object.is()는 일치연산자와 거의 동일하지만, NaN과 ±0을 올바르게 구분합니다.</p>
<h3 id="얕은-비교-shallowequal"><a aria-hidden="true" tabindex="-1" href="#얕은-비교-shallowequal"><span class="icon icon-link"></span></a>얕은 비교 (shallowEqual)</h3>
<p><strong>얕은 비교(Shallow Comparison)</strong> 는 다음과 같이 동작한다고 알려져 있습니다.</p>
<blockquote>
<p>원시 타입: 값 자체를 비교
참조 타입: 참조(메모리 주소)만 비교</p>
</blockquote>
<p>하지만 React와 Zustand에서의 얕은 비교는 다르게 동작합니다.</p>
<p>Zustand의 얕은 비교 코드:</p>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token comment">// src/react/shallow.ts</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">shallow</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>valueA<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> valueB<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">{</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token keyword">is</span><span class="token punctuation">(</span>valueA<span class="token punctuation">,</span> valueB<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 값을 비교</span>
</span><span class="code-line">    <span class="token keyword">return</span> <span class="token boolean">true</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token keyword">typeof</span> valueA <span class="token operator">!==</span> <span class="token string">&#x27;object&#x27;</span> <span class="token operator">||</span>
</span><span class="code-line">    valueA <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span>
</span><span class="code-line">    <span class="token keyword">typeof</span> valueB <span class="token operator">!==</span> <span class="token string">&#x27;object&#x27;</span> <span class="token operator">||</span>
</span><span class="code-line">    valueB <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token comment">// null 체크 및 타입 검사</span>
</span><span class="code-line">  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">return</span> <span class="token boolean">false</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>valueA<span class="token punctuation">)</span> <span class="token operator">!==</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>valueB<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// prototype을 검사 Array.prototype, Object.prototype ....etc</span>
</span><span class="code-line">    <span class="token keyword">return</span> <span class="token boolean">false</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isIterable</span><span class="token punctuation">(</span>valueA<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isIterable</span><span class="token punctuation">(</span>valueB<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// isIterable은 해당 value에 Symbol.iterator 가 존재하는지 확인한다.</span>
</span><span class="code-line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasIterableEntries</span><span class="token punctuation">(</span>valueA<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">hasIterableEntries</span><span class="token punctuation">(</span>valueB<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// hasIterableEntries은 entries 메서드가 존재하는지 확인한다. Map, Set의 경우</span>
</span><span class="code-line">      <span class="token keyword">return</span> <span class="token function">compareEntries</span><span class="token punctuation">(</span>valueA<span class="token punctuation">,</span> valueB<span class="token punctuation">)</span> <span class="token comment">// 이미 entries 메서드가 존재하면 실행</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">    <span class="token keyword">return</span> <span class="token function">compareIterables</span><span class="token punctuation">(</span>valueA<span class="token punctuation">,</span> valueB<span class="token punctuation">)</span> <span class="token comment">// entries가 존재하지 않으면 실행</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token comment">// assume plain objects 일반 객체 처리</span>
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token function">compareEntries</span><span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token punctuation">{</span> <span class="token function-variable function">entries</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>valueA<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line">    <span class="token punctuation">{</span> <span class="token function-variable function">entries</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>valueB<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token punctuation">)</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// src/react/shallow.ts
export function shallow&lt;T&gt;(valueA: T, valueB: T): boolean {

  if (Object.is(valueA, valueB)) { // 값을 비교
    return true
  }
  if (
    typeof valueA !== &#x27;object&#x27; ||
    valueA === null ||
    typeof valueB !== &#x27;object&#x27; ||
    valueB === null // null 체크 및 타입 검사
  ) {
    return false
  }
  if (Object.getPrototypeOf(valueA) !== Object.getPrototypeOf(valueB)) { // prototype을 검사 Array.prototype, Object.prototype ....etc
    return false
  }
  if (isIterable(valueA) &amp;&amp; isIterable(valueB)) { // isIterable은 해당 value에 Symbol.iterator 가 존재하는지 확인한다.
    if (hasIterableEntries(valueA) &amp;&amp; hasIterableEntries(valueB)) { // hasIterableEntries은 entries 메서드가 존재하는지 확인한다. Map, Set의 경우
      return compareEntries(valueA, valueB) // 이미 entries 메서드가 존재하면 실행
    }
    return compareIterables(valueA, valueB) // entries가 존재하지 않으면 실행
  }
  // assume plain objects 일반 객체 처리
  return compareEntries(
    { entries: () =&gt; Object.entries(valueA) },
    { entries: () =&gt; Object.entries(valueB) },
  )
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>Zustand의 얕은 비교는 객체와 배열의 최상위 레벨 값까지 비교합니다. compareEntries와 compareIterables 함수가 객체를 순회하며 값을 비교합니다.</p>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token comment">// src/react/shallow.ts</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">compareEntries</span> <span class="token operator">=</span> <span class="token punctuation">(</span>
</span><span class="code-line">  valueA<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Iterable<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token builtin">unknown</span><span class="token punctuation">,</span> <span class="token builtin">unknown</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line">  valueB<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Iterable<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token builtin">unknown</span><span class="token punctuation">,</span> <span class="token builtin">unknown</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line"><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> mapA <span class="token operator">=</span> valueA <span class="token keyword">instanceof</span> <span class="token class-name">Map</span> <span class="token operator">?</span> valueA <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span>valueA<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</span><span class="code-line">  <span class="token keyword">const</span> mapB <span class="token operator">=</span> valueB <span class="token keyword">instanceof</span> <span class="token class-name">Map</span> <span class="token operator">?</span> valueB <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span>valueB<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>mapA<span class="token punctuation">.</span>size <span class="token operator">!==</span> mapB<span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">return</span> <span class="token boolean">false</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> mapA<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Object<span class="token punctuation">.</span><span class="token keyword">is</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> mapB<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token keyword">return</span> <span class="token boolean">false</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token boolean">true</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">compareIterables</span> <span class="token operator">=</span> <span class="token punctuation">(</span>
</span><span class="code-line">  valueA<span class="token operator">:</span> Iterable<span class="token operator">&lt;</span><span class="token builtin">unknown</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
</span><span class="code-line">  valueB<span class="token operator">:</span> Iterable<span class="token operator">&lt;</span><span class="token builtin">unknown</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
</span><span class="code-line"><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> iteratorA <span class="token operator">=</span> valueA<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</span><span class="code-line">  <span class="token keyword">const</span> iteratorB <span class="token operator">=</span> valueB<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</span><span class="code-line">  <span class="token keyword">let</span> nextA <span class="token operator">=</span> iteratorA<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</span><span class="code-line">  <span class="token keyword">let</span> nextB <span class="token operator">=</span> iteratorB<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</span><span class="code-line">  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>nextA<span class="token punctuation">.</span>done <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>nextB<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Object<span class="token punctuation">.</span><span class="token keyword">is</span><span class="token punctuation">(</span>nextA<span class="token punctuation">.</span>value<span class="token punctuation">,</span> nextB<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token keyword">return</span> <span class="token boolean">false</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">    nextA <span class="token operator">=</span> iteratorA<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</span><span class="code-line">    nextB <span class="token operator">=</span> iteratorB<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token operator">!</span><span class="token operator">!</span>nextA<span class="token punctuation">.</span>done <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token operator">!</span>nextB<span class="token punctuation">.</span>done
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// src/react/shallow.ts
const compareEntries = (
  valueA: { entries(): Iterable&lt;[unknown, unknown]&gt; },
  valueB: { entries(): Iterable&lt;[unknown, unknown]&gt; },
) =&gt; {
  const mapA = valueA instanceof Map ? valueA : new Map(valueA.entries())
  const mapB = valueB instanceof Map ? valueB : new Map(valueB.entries())
  if (mapA.size !== mapB.size) {
    return false
  }
  for (const [key, value] of mapA) {
    if (!Object.is(value, mapB.get(key))) {
      return false
    }
  }
  return true
}

const compareIterables = (
  valueA: Iterable&lt;unknown&gt;,
  valueB: Iterable&lt;unknown&gt;,
) =&gt; {
  const iteratorA = valueA[Symbol.iterator]()
  const iteratorB = valueB[Symbol.iterator]()
  let nextA = iteratorA.next()
  let nextB = iteratorB.next()
  while (!nextA.done &amp;&amp; !nextB.done) {
    if (!Object.is(nextA.value, nextB.value)) {
      return false
    }
    nextA = iteratorA.next()
    nextB = iteratorB.next()
  }
  return !!nextA.done &amp;&amp; !!nextB.done
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>compareEntries 함수는 어댑터 패턴을 통해 Map, Set, 일반객체를 순회하며 값을 비교합니다. compareIterables 함수는 entries 메서드가 없는 Array, String 등의 데이터를 순회하며 비교합니다.</p>
<p>React의 shallowEqual도 유사한 방식으로 동작합니다:</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token comment">// react/packages/shared/shallowEqual.js</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">function</span> <span class="token function">shallowEqual</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">objA</span><span class="token operator">:</span> mixed<span class="token punctuation">,</span> <span class="token literal-property property">objB</span><span class="token operator">:</span> mixed</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">is</span><span class="token punctuation">(</span>objA<span class="token punctuation">,</span> objB<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// is 함수는 단지 Object.is() 함수를 분리해놓은 함수입니다.</span>
</span><span class="code-line">    <span class="token keyword control-flow">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token keyword">typeof</span> objA <span class="token operator">!==</span> <span class="token string">&#x27;object&#x27;</span> <span class="token operator">||</span>
</span><span class="code-line">    objA <span class="token operator">===</span> <span class="token keyword null nil">null</span> <span class="token operator">||</span>
</span><span class="code-line">    <span class="token keyword">typeof</span> objB <span class="token operator">!==</span> <span class="token string">&#x27;object&#x27;</span> <span class="token operator">||</span>
</span><span class="code-line">    objB <span class="token operator">===</span> <span class="token keyword null nil">null</span>
</span><span class="code-line">  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword control-flow">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">const</span> keysA <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>objA<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> keysB <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>objB<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>keysA<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">!==</span> keysB<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword control-flow">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// Test for A&#x27;s keys different from B.</span>
</span><span class="code-line">  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keysA<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">const</span> currentKey <span class="token operator">=</span> keysA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>
</span><span class="code-line">      <span class="token operator">!</span>hasOwnProperty<span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span>objB<span class="token punctuation">,</span> currentKey<span class="token punctuation">)</span> <span class="token operator">||</span>
</span><span class="code-line">      <span class="token comment">// $FlowFixMe[incompatible-use] lost refinement of `objB`</span>
</span><span class="code-line">      <span class="token operator">!</span><span class="token function">is</span><span class="token punctuation">(</span>objA<span class="token punctuation">[</span>currentKey<span class="token punctuation">]</span><span class="token punctuation">,</span> objB<span class="token punctuation">[</span>currentKey<span class="token punctuation">]</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token keyword control-flow">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword control-flow">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// react/packages/shared/shallowEqual.js

function shallowEqual(objA: mixed, objB: mixed): boolean {
  if (is(objA, objB)) { // is 함수는 단지 Object.is() 함수를 분리해놓은 함수입니다.
    return true;
  }

  if (
    typeof objA !== &#x27;object&#x27; ||
    objA === null ||
    typeof objB !== &#x27;object&#x27; ||
    objB === null
  ) {
    return false;
  }

  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A&#x27;s keys different from B.
  for (let i = 0; i &lt; keysA.length; i++) {
    const currentKey = keysA[i];
    if (
      !hasOwnProperty.call(objB, currentKey) ||
      // $FlowFixMe[incompatible-use] lost refinement of `objB`
      !is(objA[currentKey], objB[currentKey])
    ) {
      return false;
    }
  }

  return true;
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>실제로 얕은 비교 코드를 구현할 때는 일반적으로 알려진 얕은 비교(메모리 주소만 참조)와 달리, 객체의 최상위 레벨 속성까지 비교하는 방식을 사용해야 합니다.</p>
<h3 id="깊은-비교"><a aria-hidden="true" tabindex="-1" href="#깊은-비교"><span class="icon icon-link"></span></a>깊은 비교</h3>
<p>깊은 비교는 객체나 배열의 중첩된 모든 속성을 재귀적으로 비교하는 방식입니다. React나 Zustand 같은 라이브러리에서는 성능상의 이유로 일반적으로 사용하지 않으며, 객체 크기에 따라 비용이 기하급수적으로 증가합니다.</p>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">deepEquals</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// 1. 값이 같으면 바로 true 반환 참조 타입의 경우 주소 비교</span>
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token keyword">is</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// 2. 원시 값 처리</span>
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> a <span class="token operator">!==</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> b <span class="token operator">!==</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">||</span> a <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> b <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token keyword">is</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// 3. 배열 깊은비교 재귀</span>
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">!==</span> b<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">deepEquals</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// 4. 객체 깊은비교 재귀</span>
</span><span class="code-line">  <span class="token keyword">const</span> keysA <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> keysB <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>keysA<span class="token punctuation">.</span>length <span class="token operator">!==</span> keysB<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">of</span> keysA<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">deepEquals</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>key <span class="token keyword">as</span> <span class="token keyword">keyof</span> <span class="token keyword">typeof</span> a<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>key <span class="token keyword">as</span> <span class="token keyword">keyof</span> <span class="token keyword">typeof</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="export const deepEquals = (a: unknown, b: unknown) =&gt; {
  // 1. 값이 같으면 바로 true 반환 참조 타입의 경우 주소 비교
  if (Object.is(a, b)) {
    return true;
  }

  // 2. 원시 값 처리
  if (typeof a !== &quot;object&quot; || typeof b !== &quot;object&quot; || a === null || b === null) {
    return Object.is(a, b);
  }

  // 3. 배열 깊은비교 재귀
  if (Array.isArray(a) &amp;&amp; Array.isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }

    for (let i = 0; i &lt; a.length; i++) {
      if (!deepEquals(a[i], b[i])) return false;
    }

    return true;
  }

  // 4. 객체 깊은비교 재귀
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);

  if (keysA.length !== keysB.length) {
    return false;
  }

  for (const key of keysA) {
    if (!deepEquals(a[key as keyof typeof a], b[key as keyof typeof b])) return false;
  }

  return true;
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>얕은 비교와 달리 배열이나 객체의 중첩된 구조를 만날 때마다 즉시 재귀 호출을 통해 더 깊은 레벨(DFS)로 들어가 끝까지 파고들어 비교를 완료합니다.</p>
<p><strong>JSON.stringify() 방식</strong></p>
<p>간혹 JSON.stringify()를 통한 비교를 사용하는 경우가 있지만, 여러 문제점이 존재합니다:</p>
<ol>
<li>속성 순서 의존성</li>
</ol>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token known-class-name class-name">JSON</span><span class="token punctuation">.</span><span class="token method function property-access">stringify</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#x27;{&quot;a&quot;:1,&quot;b&quot;:2}&#x27;</span>
</span><span class="code-line"><span class="token known-class-name class-name">JSON</span><span class="token punctuation">.</span><span class="token method function property-access">stringify</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#x27;{&quot;b&quot;:2,&quot;a&quot;:1}&#x27;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 같은 내용이지만 false!</span>
</span><span class="code-line"><span class="token function">deepEqualsJSON</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span> obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</span></code><div class="copied" data-code="const obj1 = { a: 1, b: 2 };
const obj2 = { b: 2, a: 1 };

JSON.stringify(obj1); // &#x27;{&quot;a&quot;:1,&quot;b&quot;:2}&#x27;
JSON.stringify(obj2); // &#x27;{&quot;b&quot;:2,&quot;a&quot;:1}&#x27;

// 같은 내용이지만 false!
deepEqualsJSON(obj1, obj2); // false
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ol start="2">
<li>성능 문제</li>
</ol>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword">const</span> largeObj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token comment">/* 매우 큰 객체 */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// JSON.stringify는 전체 객체를 문자열로 변환</span>
</span><span class="code-line"><span class="token comment">// 메모리 사용량이 2배가 됨 (원본 + 문자열)</span>
</span><span class="code-line"><span class="token comment">// 불필요한 문자열 생성 비용 및 문자열 비교의 비용은 작지 않다.</span>
</span></code><div class="copied" data-code="const largeObj = { /* 매우 큰 객체 */ };

// JSON.stringify는 전체 객체를 문자열로 변환
// 메모리 사용량이 2배가 됨 (원본 + 문자열)
// 불필요한 문자열 생성 비용 및 문자열 비교의 비용은 작지 않다.
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이외에도 NaN, Infinity 같은 특수 값 처리 불가, 데이터 손실 가능성, 함수나 undefined 값 무시 같은 문제가 있습니다. 다음과 같은 제한적인 상황에서는 고려해볼 수 있습니다:</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token comment">// 1. 간단한 plain object만 비교</span>
</span><span class="code-line"><span class="token keyword">const</span> config1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">timeout</span><span class="token operator">:</span> <span class="token number">5000</span><span class="token punctuation">,</span> <span class="token literal-property property">retries</span><span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> config2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">timeout</span><span class="token operator">:</span> <span class="token number">5000</span><span class="token punctuation">,</span> <span class="token literal-property property">retries</span><span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 2. 속성 순서가 보장되는 경우 (같은 소스에서 생성)</span>
</span><span class="code-line"><span class="token keyword">const</span> response1 <span class="token operator">=</span> <span class="token known-class-name class-name">JSON</span><span class="token punctuation">.</span><span class="token method function property-access">parse</span><span class="token punctuation">(</span>apiResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> response2 <span class="token operator">=</span> <span class="token known-class-name class-name">JSON</span><span class="token punctuation">.</span><span class="token method function property-access">parse</span><span class="token punctuation">(</span>apiResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 3. 프로토타이핑이나 간단한 테스트</span>
</span></code><div class="copied" data-code="// 1. 간단한 plain object만 비교
const config1 = { timeout: 5000, retries: 3 };
const config2 = { timeout: 5000, retries: 3 };

// 2. 속성 순서가 보장되는 경우 (같은 소스에서 생성)
const response1 = JSON.parse(apiResponse);
const response2 = JSON.parse(apiResponse);

// 3. 프로토타이핑이나 간단한 테스트
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="react에서의-실용적-활용"><a aria-hidden="true" tabindex="-1" href="#react에서의-실용적-활용"><span class="icon icon-link"></span></a>React에서의 실용적 활용</h3>
<p>React와 연계해서 사용하기에는 memo의 두 번째 인자에 직접 비교 함수를 제공하는 방식이 더 적합합니다:</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword">const</span> <span class="token maybe-class-name">MemoizedComponent</span> <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token maybe-class-name">SomeComponent</span><span class="token punctuation">,</span> arePropsEqual<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token comment">// arePropsEqual은 콜백 함수로 prevProps와 currentProps를 받습니다</span>
</span></code><div class="copied" data-code="const MemoizedComponent = memo(SomeComponent, arePropsEqual);
// arePropsEqual은 콜백 함수로 prevProps와 currentProps를 받습니다
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>추가 팁</strong></p>
<p>💡 React의 불변성을 지키기 위해 깊은 복사가 필요하다면 <a href="https://github.com/lodash/lodash">lodash-es</a>의 cloneDeep 함수를 이용하면 간편하게 깊은 복사를 통해 새로운 객체를 얻을 수 있습니다.</p>
</details>
<details>
<summary>트러블슈팅 지원 사례</summary>
<h3 id="q1-useref에-왜-함수를-넣어줘야-하나요"><a aria-hidden="true" tabindex="-1" href="#q1-useref에-왜-함수를-넣어줘야-하나요"><span class="icon icon-link"></span></a>Q1. useRef에 왜 함수를 넣어줘야 하나요?</h3>
<p>이 useRef 구현에서 useState에 함수를 전달하는 이유는 <strong>불필요한 객체 생성을 방지</strong>하기 위해서입니다.</p>
<pre class="language-jsx"><code class="language-jsx code-highlight"><span class="code-line"><span class="token keyword">const</span> <span class="token punctuation">[</span>ref<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">current</span><span class="token operator">:</span> initialValue <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 매번 새 객체 생성</span>
</span></code><div class="copied" data-code="const [ref] = useState({ current: initialValue }); // 매번 새 객체 생성
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>위처럼 작성하면 컴포넌트가 리렌더링될 때마다 { current: initialValue } 객체가 새로 생성됩니다. useState는 초기값을 한 번만 사용하지만, 객체 생성 자체는 매번 발생합니다.</p>
<p>이를 해결하는 방법이 지연 초기화(lazy initialization)입니다.</p>
<pre class="language-jsx"><code class="language-jsx code-highlight"><span class="code-line"><span class="token keyword">const</span> <span class="token punctuation">[</span>ref<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">current</span><span class="token operator">:</span> initialValue <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 최초 한 번만 실행</span>
</span></code><div class="copied" data-code="const [ref] = useState(() =&gt; ({ current: initialValue })); // 최초 한 번만 실행
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>함수를 전달하면 useState가 최초 렌더링 시에만 함수를 실행하여 객체를 생성합니다. 이후 리렌더링에서는 함수가 실행되지 않아 불필요한 객체 생성을 방지합니다.</p>
<p>React의 실제 구현에서 이를 확인할 수 있습니다:</p>
<pre class="language-jsx"><code class="language-jsx code-highlight"><span class="code-line"><span class="token comment">// react/packages/react-reconciler/src/ReactFiberHooks.js</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 최초 렌더링 시 실행</span>
</span><span class="code-line"><span class="token keyword">function</span> mountStateImpl<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">S</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">(initialState: (() =&gt; S) | S): Hook </span><span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token function">mountWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  
</span><span class="code-line">  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> initialState <span class="token operator">===</span> <span class="token string">&#x27;function&#x27;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">const</span> initialStateInitializer <span class="token operator">=</span> initialState<span class="token punctuation">;</span>
</span><span class="code-line">    initialState <span class="token operator">=</span> <span class="token function">initialStateInitializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 함수 실행</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token comment">// ... 생략</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">// 업데이트 시 실행
</span></span><span class="code-line"><span class="token plain-text">function updateReducerImpl&lt;S, A&gt;(
</span></span><span class="code-line"><span class="token plain-text">  hook: Hook,
</span></span><span class="code-line"><span class="token plain-text">  current: Hook,
</span></span><span class="code-line"><span class="token plain-text">  reducer: (S, A) =&gt; S,
</span></span><span class="code-line"><span class="token plain-text">): [S, Dispatch</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">A</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">] </span><span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> queue <span class="token operator">=</span> hook<span class="token punctuation">.</span><span class="token property-access">queue</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token comment">// 초기값 재실행 없이 큐에서 상태 처리</span>
</span><span class="code-line">  queue<span class="token punctuation">.</span><span class="token property-access">lastRenderedReducer</span> <span class="token operator">=</span> reducer<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">// mountWorkInProgressHook, updateWorkInProgressHook부터 살펴봐야 하지만 너무 길어져 넘기겠습니다.😅
</span></span></code><div class="copied" data-code="// react/packages/react-reconciler/src/ReactFiberHooks.js

// 최초 렌더링 시 실행
function mountStateImpl&lt;S&gt;(initialState: (() =&gt; S) | S): Hook {
  const hook = mountWorkInProgressHook();
  
  if (typeof initialState === &#x27;function&#x27;) {
    const initialStateInitializer = initialState;
    initialState = initialStateInitializer(); // 함수 실행
  }
  // ... 생략
}

// 업데이트 시 실행
function updateReducerImpl&lt;S, A&gt;(
  hook: Hook,
  current: Hook,
  reducer: (S, A) =&gt; S,
): [S, Dispatch&lt;A&gt;] {
  const queue = hook.queue;
  // 초기값 재실행 없이 큐에서 상태 처리
  queue.lastRenderedReducer = reducer;
}

// mountWorkInProgressHook, updateWorkInProgressHook부터 살펴봐야 하지만 너무 길어져 넘기겠습니다.😅
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ul>
<li>마운트 시: mountStateImpl에서 typeof initialState === &#x27;function&#x27; 검사 후 함수 실행</li>
<li>업데이트 시: updateReducerImpl에서 배치 업데이트를 위해 fiber의 큐에 변경사항만 저장, 초기값 함수는 재실행하지 않음</li>
</ul>
<p>이는 React에서 인라인 스타일을 권장하지 않는 이유와 동일합니다. 렌더링 과정에서 객체 리터럴은 항상 새로운 참조를 생성하기 때문입니다.
이번과제 ToastContext 구축 시 value 부분에도 적용되는 개념입니다.👀</p>
<p>참고문서</p>
<ul>
<li><a href="https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.js#L1891-L1917">React Github Code</a></li>
</ul>
<h3 id="q2-usememo에-return에-왜-에러가-뜨는지-모르겠어요"><a aria-hidden="true" tabindex="-1" href="#q2-usememo에-return에-왜-에러가-뜨는지-모르겠어요"><span class="icon icon-link"></span></a>Q2. useMemo에 return에 왜 에러가 뜨는지 모르겠어요</h3>
<p>문제 코드</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">useMemo</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token function-variable function">factory</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">,</span> _deps<span class="token operator">:</span> <span class="token maybe-class-name">DependencyList</span><span class="token punctuation">,</span> _equals <span class="token operator">=</span> shallowEquals<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> valueRef <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> depsRef <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span>DependencyList<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">_equals</span><span class="token punctuation">(</span>depsRef<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">,</span> _deps<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    valueRef<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    depsRef<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> _deps<span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> valueRef<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">;</span> <span class="token comment">// error : &#x27;T | undefined&#x27; 형식은 &#x27;T&#x27; 형식에 할당할 수 없습니다.</span>
</span></code><div class="copied" data-code="export function useMemo&lt;T&gt;(factory: () =&gt; T, _deps: DependencyList, _equals = shallowEquals): T {
  const valueRef = useRef&lt;T | undefined&gt;(undefined);
  const depsRef = useRef&lt;DependencyList&gt;([]);

  if (!_equals(depsRef.current, _deps)) {
    valueRef.current = factory();
    depsRef.current = _deps;
  }

  return valueRef.current; // error : &#x27;T | undefined&#x27; 형식은 &#x27;T&#x27; 형식에 할당할 수 없습니다.
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>TypeScript 에러입니다. useMemo 훅의 반환 타입은 T로 정의했지만, valueRef.current는 undefined일 가능성이 있어 타입 불일치가 발생합니다.</p>
<p>해결 방법: 초기 상태 처리 추가</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">useMemo</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token function-variable function">factory</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">,</span> _deps<span class="token operator">:</span> <span class="token maybe-class-name">DependencyList</span><span class="token punctuation">,</span> _equals <span class="token operator">=</span> shallowEquals<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> valueRef <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> depsRef <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span>DependencyList<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"> <span class="token comment">// 초기 렌더링이거나 의존성이 변경된 경우</span>
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>valueRef<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">_equals</span><span class="token punctuation">(</span>depsRef<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">,</span> _deps<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    valueRef<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    depsRef<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> _deps<span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> valueRef<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">;</span> <span class="token comment">// 이제 T 타입으로 추론됨</span>
</span></code><div class="copied" data-code="export function useMemo&lt;T&gt;(factory: () =&gt; T, _deps: DependencyList, _equals = shallowEquals): T {
  const valueRef = useRef&lt;T | undefined&gt;(undefined);
  const depsRef = useRef&lt;DependencyList&gt;([]);

 // 초기 렌더링이거나 의존성이 변경된 경우
  if (valueRef.current === undefined || !_equals(depsRef.current, _deps)) {
    valueRef.current = factory();
    depsRef.current = _deps;
  }

  return valueRef.current; // 이제 T 타입으로 추론됨
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>valueRef.current === undefined 조건을 추가하여 초기 렌더링 시 undefined 상태를 처리합니다. 이제 반환 시점에는 항상 T 타입이 보장됩니다.</p>
</details>
<h3 id="학습-효과-분석"><a class="anchor" aria-hidden="true" tabindex="-1" href="#학습-효과-분석"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>학습 효과 분석</h3>
<p>이번 과제를 통해 일반적인 얕은 비교와 React의 얕은 비교 방식이 다르다는 점을 파악했습니다.
기초적인 타입별 특징과 메모리 할당 방식을 다시 학습했고, 참조 타입 사용 시 React의 불변성 원칙을 지키는 방법을 정리했습니다.</p>
<p>Zustand와 React의 얕은 비교 구현 코드를 분석한 결과, Zustand는 Symbol.iterator 활용, Map과 Set 객체 처리, Object.is 메서드 사용 등 더 정교한 비교 로직을 구현하고 있음을 확인했습니다.</p>
<p>과제를 빠르게 진행하여 다른분들의 문제를 파악해보며 설명하는 과정에서 왜? 를 납득시키기 위한 좀 더 논리적인 원리를 파고드는 경험도 했습니다.</p>
<p>현재 과제는 Preact의 방식과 유사한 패턴이지만 좀 더 대규모 환경인 React의 코드를 헤집어보며 hook 실행 시점과 지연초기화가 어떻게 가능한지 학습했습니다. (몇천줄 속에서 코드 찾는 요령이 늘은 것 같아요 👍)</p>
<h3 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h3>
<p>useAutoCallback 구현 시 인자를 전달하지 않아도 테스트가 통과하는 부분이 있었습니다. (E2E 제외)
UnitTest가 추가되어도 괜찮겠다! 생각이 들었습니다.</p>
<p>현 React의 구조는 너무 복잡한데 Preact로 접근해서 풀어보는 방식이 새롭고 좋았습니다!! 쉽게 배우고 -&gt; 깊게 들어가는 느낌</p>
<h2 id="학습-갈무리"><a class="anchor" aria-hidden="true" tabindex="-1" href="#학습-갈무리"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>학습 갈무리</h2>
<h3 id="리액트의-렌더링이-어떻게-이루어지는지-정리해주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리액트의-렌더링이-어떻게-이루어지는지-정리해주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리액트의 렌더링이 어떻게 이루어지는지 정리해주세요.</h3>
<p>저는 React 내부적으로 렌더링이 일어나는 순서에 대해 딥다이브하며 한번 작성해봤습니다.</p>
<p><strong>Fiber 아키텍처</strong></p>
<p>Fiber는 React 16부터 도입된 <strong>재조정(Reconciliation) 엔진</strong>입니다. 각 컴포넌트나 요소를 객체로 표현합니다. 이하 설명은 Fiber 아키텍처의 렌더링 과정입니다.</p>
<p>Fiber 노드의 구조:</p>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token comment">// Fiber 노드</span>
</span><span class="code-line"><span class="token punctuation">{</span>
</span><span class="code-line">  type<span class="token operator">:</span> <span class="token string">&#x27;div&#x27;</span> <span class="token operator">|</span> Component<span class="token punctuation">,</span>
</span><span class="code-line">  props<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line">  child<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
</span><span class="code-line">  sibling<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token keyword">return</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
</span><span class="code-line">  alternate<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
</span><span class="code-line">  effectTag<span class="token operator">:</span> NoEffect<span class="token punctuation">,</span>
</span><span class="code-line">  stateNode<span class="token operator">:</span> DOMElement 
</span><span class="code-line">  <span class="token comment">// ... 생략</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// Fiber 노드
{
  type: &#x27;div&#x27; | Component,
  props: {...},
  child: null,
  sibling: null,
  return: null,
  alternate: null,
  effectTag: NoEffect,
  stateNode: DOMElement 
  // ... 생략
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>두 단계의 렌더링 과정</strong></p>
<p>React의 렌더링은 두 단계로 나누어 집니다.</p>
<img width="1116" height="659" alt="image" src="https://github.com/user-attachments/assets/e10592cb-be53-4125-9694-f3af3f391eb1"/>
<p>Render Phase (렌더 단계)</p>
<ul>
<li>Virtual DOM을 조작하여 변경점을 계산하는 단계입니다</li>
<li>Fiber 아키텍처를 통해 작업을 중단, 재시작할 수 있습니다</li>
<li>동시성 모드에서 비동기적으로 실행됩니다</li>
<li>컴포넌트 함수를 호출하고 Virtual DOM에만 반영하며, 실제 DOM은 변경하지 않습니다</li>
</ul>
<p>Commit Phase (커밋 단계)</p>
<ul>
<li>Render Phase에서 계산된 변경사항을 실제 DOM에 적용합니다</li>
<li>라이프사이클 메서드와 훅을 실행합니다</li>
<li>일관된 화면 업데이트를 위해 동기적으로 실행됩니다</li>
<li><strong>모든 작업 완료 후</strong> 브라우저가 화면을 다시 그립니다 (Paint)</li>
</ul>
<p><strong>이중 트리 구조</strong></p>
<p>React는 두 개의 트리를 동시에 관리합니다.</p>
<ul>
<li>Current Tree: 현재 화면에 표시된 상태 트리</li>
<li>Work-in-Progress Tree: 업데이트가 적용되는 새로운 상태 트리</li>
</ul>
<p>이 구조는 더블 버퍼링 방식으로 작동합니다. 백그라운드에서 새로운 트리를 구성하고, 완료되면 포인터를 교체하여 새 트리를 활성화합니다. 이를 통해 작업 중단과 재시작, 우선순위 기반 업데이트가 가능합니다.</p>
<blockquote>
<p>한줄로 표현해보자면 React의 렌더링은 **Render Phase(Virtual DOM 조작 및 비교) → Commit Phase(실제 DOM 반영)**의 두 단계를 반복하며(loop) Fiber 아키텍처기반으로 현재 보여지는 currentTree, 변경사항에 대한 업데이트를 진행중인 Work-in-Progress Tree 통해 효율적이게 렌더링을 진행합니다.</p>
</blockquote>
<p>현재의 동작이 마운트냐, 업데이트냐에 따라 달라지는 WorkLoop 부분도 확인했지만 스케쥴러부터 관련 함수들까지의 양이 너무 방대해 아직 완벽하게 흐름을 이해하지 못했습니다.😅</p>
<p>관련 아티클
<a href="https://goidle.github.io/react/in-depth-react-intro">React 톺아보기 -2</a></p>
<h3 id="메모이제이션에-대한-나의-생각을-적어주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#메모이제이션에-대한-나의-생각을-적어주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>메모이제이션에 대한 나의 생각을 적어주세요.</h3>
<p>개인적인 생각으로는 메모이제이션 훅은 예기치 못한 동작들을 원하는 방향으로 돌아갈 수 있게 도와주는 훅에 더 가깝다고 느꼈습니다.</p>
<p>물론 대규모 프로젝트나 빅 데이터를 다루지 못했기에 이런 결론에 도달했을 수 있지만, 조금 더 근본적인 생각으로 돌아가보자면 이 메모이제이션 훅들은 렌더링을 개선해주고 큰 계산의 결과값을 캐싱하는 용도로 나온 훅으로 알고있습니다.</p>
<p>그런데 이 훅들을 사용하지 않았을 때 버벅임이나 성능적인 문제가 아니라 기술적인 오류가 발생한다면 가장 먼저 <strong>내가 컴포넌트의 구조를 잘못 잡았나?</strong> 부터 생각해보고 이 훅들을 사용하지 않아도 &quot;정상적&quot;으로 돌아가는 방향으로 개선하는걸 우선해볼 것 같습니다.</p>
<p>분명 이 메모이제이션 훅들은 필요한 훅이지만 비용이 적지 않은 만큼 내가 설계한 방향이 맞았나? 더 나은 방법은 없을까? 라고 리팩토링의 고민을 하게 해줄 수 있는 훅이라고 생각해봤습니다 🙇‍♂️</p>
<h3 id="컨텍스트와-상태관리에-대한-나의-생각을-적어주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#컨텍스트와-상태관리에-대한-나의-생각을-적어주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>컨텍스트와 상태관리에 대한 나의 생각을 적어주세요.</h3>
<p><strong>왜 컨텍스트와 상태관리가 필요한가?</strong></p>
<p>Props Drilling의 한계</p>
<p>컴포넌트 트리가 깊어질수록 props 전달 체인이 길어집니다. 특히 중간 컴포넌트들이 자신은 사용하지 않는 데이터를 단순히 하위 컴포넌트로 전달하기 위해서만 존재하게 되는 상황이 발생합니다. 이는 변경점 발생 시 모든 중간 단계 컴포넌트를 수정해야 하는 문제로 이어집니다.</p>
<p>형제 컴포넌트 간 데이터 공유의 복잡성</p>
<p>React의 단방향 데이터 흐름에서 형제 컴포넌트끼리 직접 소통할 방법이 없습니다. 데이터를 공유하려면 가장 가까운 공통 부모 컴포넌트까지 상태를 끌어올려야 하는데, 이는 상위 컴포넌트의 책임을 무겁게 만들고 컴포넌트 간 결합도를 높입니다.</p>
<p>전역 상태 관리의 필요성</p>
<p>애플리케이션 전반에서 사용되는 데이터(인증 상태, 설정 값 등)는 컴포넌트 계층과 상관없이 접근할 수 있어야 합니다. props로 이런 데이터를 전달하면 모든 컴포넌트가 이 데이터에 의존하게 되어 결합도가 높아집니다.
결국 컨텍스트와 상태관리는 <strong>&quot;데이터가 필요한 곳에서 바로 접근할 수 있게 해주는 도구&quot;</strong> 라는 생각이 들었습니다.</p>
<p><strong>컨텍스트와 상태관리를 사용하지 않으면 어떤 문제가 발생할까?</strong></p>
<p>인터페이스 변경 시 수정 범위 확산</p>
<p>props로 전달되는 데이터의 타입이나 구조가 변경되면, 해당 데이터를 전달하는 모든 중간 컴포넌트의 props 인터페이스를 수정해야 합니다. 이는 변경의 영향 범위를 예측하기 어렵게 만들고, 실수로 누락되는 부분이 생길 가능성을 높입니다.</p>
<p>컴포넌트의 독립성 저하</p>
<p>특정 props에 의존하는 컴포넌트는 해당 props를 제공하는 상위 컴포넌트 없이는 동작할 수 없습니다. 이는 컴포넌트의 재사용성을 제한합니다.</p>
<p>상태 일관성 관리의 어려움</p>
<p>동일한 데이터를 여러 컴포넌트에서 각각 관리하면 데이터 동기화 문제가 발생합니다. 한 곳에서 데이터가 업데이트되어도 다른 곳의 데이터는 이전 상태를 유지하는 불일치가 생길 수 있습니다.</p>
<p>중복 연산과 메모리 비효율성</p>
<p>같은 데이터 가공 로직이 여러 컴포넌트에 분산되어 있으면 동일한 계산이 중복으로 수행됩니다. 또한 비슷한 상태를 여러 곳에서 관리하면 메모리 사용량이 불필요하게 증가할 수 있습니다.</p>
<p><strong>컨텍스트의 다양한 활용법</strong></p>
<p>컴파운드 컴포넌트 패턴으로 제한된 범위의 Context 활용</p>
<p>전역 Context의 리렌더링 문제를 피하면서도 관련 컴포넌트들끼리는 상태를 공유할 수 있는 절충안입니다. 특정 기능 단위로 Context 범위를 제한하여 해당 영역 내에서만 상태를 공유합니다.
이 패턴은 Modal, Accordion, Tab 등 UI 컴포넌트에서 내부 상태를 공유해야 할 때 특히 유용합니다. 컴포넌트의 내부 구현은 Context를 사용하지만 외부에서는 일반적인 props 인터페이스로 사용할 수 있어 캡슐화가 잘 됩니다.</p>
<p>Custom Hooks를 통한 상태 로직 재사용</p>
<p>상태 관리 로직을 훅으로 분리하면 여러 컴포넌트에서 동일한 상태 패턴을 재사용할 수 있습니다. 전역 상태 없이도 비슷한 상태 로직이 필요한 컴포넌트들에서 일관된 동작을 구현할 수 있습니다.
localStorage나 sessionStorage와의 동기화, API 호출 상태 관리, 폼 validation 등의 로직을 훅으로 만들어 재사용하는 방식입니다.</p>
<p>서버 상태 관리 라이브러리 활용</p>
<p>React Query, SWR 같은 라이브러리를 사용하면 서버에서 가져오는 데이터는 별도로 관리할 수 있습니다. 캐싱, 동기화, 백그라운드 업데이트를 자동으로 처리해주므로 클라이언트 상태와 서버 상태를 분리하여 복잡성을 줄일 수 있습니다.</p>
<h2 id="리뷰-받고-싶은-내용"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리뷰-받고-싶은-내용"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리뷰 받고 싶은 내용</h2>
<p><strong>ToastProvider</strong></p>
<ul>
<li>hideAfter에 useMemo를 사용하지 않을 방법은 없었을까요? useAutoCallback을 사용하면 내부 디바운싱에서 타이머가 초기화되지 않는 문제가 있었습니다. 함수를 메모이제이션 하는거니까 useCallback쪽이 더 어울린다고 생각이 들어서요!</li>
</ul>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token keyword">const</span> hideAfter <span class="token operator">=</span> <span class="token function">useAutoCallback</span><span class="token punctuation">(</span><span class="token function">debounce</span><span class="token punctuation">(</span>hide<span class="token punctuation">,</span> <span class="token constant">DEFAULT_DELAY</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// ⚠️타이머가 비정상으로 동작해서 Toast가 꺼지지않음</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> debounce <span class="token operator">=</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">T</span></span> <span class="token attr-name">extends</span> <span class="token attr-name">AnyFunction</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">(callback: T, delay: number) =&gt; </span><span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">let</span> timeoutId<span class="token operator">:</span> <span class="token maybe-class-name">ReturnType</span><span class="token operator">&lt;</span><span class="token keyword">typeof</span> <span class="token dom variable">window</span><span class="token punctuation">.</span><span class="token property-access">setTimeout</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token operator">:</span> <span class="token maybe-class-name">Parameters</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeoutId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeoutId<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">    timeoutId <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token function">callback</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">      timeoutId <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token plain-text">;
</span></span></code><div class="copied" data-code="const hideAfter = useAutoCallback(debounce(hide, DEFAULT_DELAY));

// ⚠️타이머가 비정상으로 동작해서 Toast가 꺼지지않음
export const debounce = &lt;T extends AnyFunction&gt;(callback: T, delay: number) =&gt; {
  let timeoutId: ReturnType&lt;typeof window.setTimeout&gt; | null = null;

  return (...args: Parameters&lt;T&gt;) =&gt; {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() =&gt; {
      callback(...args);
      timeoutId = null;
    }, delay);
  };
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ul>
<li>이런 Provider 구현 시 useReducer가 더 좋을까요? 저는 useState로 상태값을 두고 handle함수를 Provider 내부에 둔 상태가 한눈에 보여 파악하기 쉽다고 생각했습니다! 코치님은 useReducer를 선호하시나요?? 이유도 궁금합니다!</li>
</ul>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token comment">/* eslint-disable react-refresh/only-export-components */</span>
</span><span class="code-line"><span class="token keyword">import</span> <span class="token imports"><span class="token punctuation">{</span> useAutoCallback <span class="token punctuation">}</span></span> <span class="token keyword">from</span> <span class="token string">&quot;@hanghae-plus/lib&quot;</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">import</span> <span class="token punctuation">{</span> createContext<span class="token punctuation">,</span> memo<span class="token punctuation">,</span> <span class="token keyword">type</span> <span class="token class-name">PropsWithChildren</span><span class="token punctuation">,</span> useContext<span class="token punctuation">,</span> useMemo<span class="token punctuation">,</span> useReducer <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">import</span> <span class="token imports"><span class="token punctuation">{</span> createPortal <span class="token punctuation">}</span></span> <span class="token keyword">from</span> <span class="token string">&quot;react-dom&quot;</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">import</span> <span class="token imports"><span class="token punctuation">{</span> debounce <span class="token punctuation">}</span></span> <span class="token keyword">from</span> <span class="token string">&quot;../../utils&quot;</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">Toast</span> <span class="token punctuation">}</span></span> <span class="token keyword">from</span> <span class="token string">&quot;./Toast&quot;</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">import</span> <span class="token punctuation">{</span> createActions<span class="token punctuation">,</span> initialState<span class="token punctuation">,</span> toastReducer<span class="token punctuation">,</span> <span class="token keyword">type</span> <span class="token class-name">ToastType</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./toastReducer&quot;</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">type</span> <span class="token class-name">ShowToast</span> <span class="token operator">=</span> <span class="token punctuation">(</span>message<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> type<span class="token operator">:</span> <span class="token maybe-class-name">ToastType</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">type</span> <span class="token class-name">Hide</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">const</span> <span class="token maybe-class-name">ToastContext</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">createContext</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token punctuation">{</span>
</span></span></span><span class="code-line"><span class="token generic-function"><span class="token generic class-name">  message<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
</span></span></span><span class="code-line"><span class="token generic-function"><span class="token generic class-name">  type<span class="token operator">:</span> ToastType<span class="token punctuation">;</span>
</span></span></span><span class="code-line"><span class="token generic-function"><span class="token generic class-name"><span class="token punctuation">}</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token spread operator">...</span>initialState<span class="token punctuation">,</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">const</span> <span class="token maybe-class-name">ToastCommandContext</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">createContext</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token punctuation">{</span>
</span></span></span><span class="code-line"><span class="token generic-function"><span class="token generic class-name">  show<span class="token operator">:</span> ShowToast<span class="token punctuation">;</span>
</span></span></span><span class="code-line"><span class="token generic-function"><span class="token generic class-name">  hide<span class="token operator">:</span> Hide<span class="token punctuation">;</span>
</span></span></span><span class="code-line"><span class="token generic-function"><span class="token generic class-name"><span class="token punctuation">}</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token function-variable function">show</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token function-variable function">hide</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">const</span> <span class="token constant">DEFAULT_DELAY</span> <span class="token operator">=</span> <span class="token number">3000</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">useToastContext</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token function">useContext</span><span class="token punctuation">(</span><span class="token maybe-class-name">ToastContext</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">useToastCommandContext</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token function">useContext</span><span class="token punctuation">(</span><span class="token maybe-class-name">ToastCommandContext</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">useToastCommand</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">{</span> show<span class="token punctuation">,</span> hide <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useToastCommandContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">{</span> show<span class="token punctuation">,</span> hide <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">useToastState</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">{</span> message<span class="token punctuation">,</span> type <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useToastContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">{</span> message<span class="token punctuation">,</span> type <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token maybe-class-name">ToastProvider</span> <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> children <span class="token punctuation">}</span><span class="token operator">:</span> <span class="token maybe-class-name">PropsWithChildren</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>toastReducer<span class="token punctuation">,</span> initialState<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">{</span> show<span class="token punctuation">,</span> hide <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token function">createActions</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>dispatch<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ⚠️ 어떻게 동작하는지 확인하려면 별도 파일 확인이 필요함</span>
</span><span class="code-line">  <span class="token keyword">const</span> visible <span class="token operator">=</span> state<span class="token punctuation">.</span><span class="token property-access">message</span> <span class="token operator">!==</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">const</span> hideAfter <span class="token operator">=</span> <span class="token function">useAutoCallback</span><span class="token punctuation">(</span><span class="token function">debounce</span><span class="token punctuation">(</span>hide<span class="token punctuation">,</span> <span class="token constant">DEFAULT_DELAY</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">const</span> showWithHide<span class="token operator">:</span> <span class="token maybe-class-name">ShowToast</span> <span class="token operator">=</span> <span class="token function">useAutoCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token function">show</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token function">hideAfter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">const</span> command <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> show<span class="token operator">:</span> showWithHide<span class="token punctuation">,</span> hide <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>showWithHide<span class="token punctuation">,</span> hide<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ToastCommandContext.Provider</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>command<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ToastContext.Provider</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>state<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">        </span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">        </span><span class="token punctuation">{</span>visible <span class="token operator">&amp;&amp;</span> <span class="token function">createPortal</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Toast</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">,</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">body</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ToastContext.Provider</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ToastCommandContext.Provider</span></span><span class="token punctuation">&gt;</span></span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="/* eslint-disable react-refresh/only-export-components */
import { useAutoCallback } from &quot;@hanghae-plus/lib&quot;;
import { createContext, memo, type PropsWithChildren, useContext, useMemo, useReducer } from &quot;react&quot;;
import { createPortal } from &quot;react-dom&quot;;
import { debounce } from &quot;../../utils&quot;;
import { Toast } from &quot;./Toast&quot;;
import { createActions, initialState, toastReducer, type ToastType } from &quot;./toastReducer&quot;;

type ShowToast = (message: string, type: ToastType) =&gt; void;
type Hide = () =&gt; void;

const ToastContext = createContext&lt;{
  message: string;
  type: ToastType;
}&gt;({
  ...initialState,
});

const ToastCommandContext = createContext&lt;{
  show: ShowToast;
  hide: Hide;
}&gt;({
  show: () =&gt; null,
  hide: () =&gt; null,
});

const DEFAULT_DELAY = 3000;

const useToastContext = () =&gt; useContext(ToastContext);
const useToastCommandContext = () =&gt; useContext(ToastCommandContext);

export const useToastCommand = () =&gt; {
  const { show, hide } = useToastCommandContext();
  return { show, hide };
};
export const useToastState = () =&gt; {
  const { message, type } = useToastContext();
  return { message, type };
};

export const ToastProvider = memo(({ children }: PropsWithChildren) =&gt; {
  const [state, dispatch] = useReducer(toastReducer, initialState);
  const { show, hide } = useMemo(() =&gt; createActions(dispatch), [dispatch]); // ⚠️ 어떻게 동작하는지 확인하려면 별도 파일 확인이 필요함
  const visible = state.message !== &quot;&quot;;

  const hideAfter = useAutoCallback(debounce(hide, DEFAULT_DELAY));

  const showWithHide: ShowToast = useAutoCallback((...args) =&gt; {
    show(...args);
    hideAfter();
  });

  const command = useMemo(() =&gt; ({ show: showWithHide, hide }), [showWithHide, hide]);

  return (
    &lt;ToastCommandContext.Provider value={command}&gt;
      &lt;ToastContext.Provider value={state}&gt;
        {children}
        {visible &amp;&amp; createPortal(&lt;Toast /&gt;, document.body)}
      &lt;/ToastContext.Provider&gt;
    &lt;/ToastCommandContext.Provider&gt;
  );
});
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ul>
<li>얕은 비교 함수를 구현하고나서 <a href="https://github.com/pmndrs/zustand/blob/main/src/vanilla/shallow.ts">Zustand 코드</a>를 살펴보았는데 Map과 Set, Symbol.iterator, 일반 객체를 분리해서 순회하는 부분을 보았습니다. 저는 따로 분리하여 처리하지 않았는데 처리하지 않았을 때 문제가 될 부분이 있을까요?</li>
</ul>
<p>번외: 준일 코치님 멘토링 세션을 진행하며 제가 왜 빅테크를 가고 싶어하는지, 업무를 해당 회사들에 어울리는 인재처럼 진행하고 있었는지 다시 한번 돌아보게 되었습니다 감사합니다🙇‍♂️</p>
</div></div><div class="overflow-auto mt-9"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h2>
<p>안녕하세요 윤우님!
정리를 너무 잘 해주셨네요 ㅎㅎ
고생하셨습니다!!</p>
<blockquote>
<p>hideAfter에 useMemo를 사용하지 않을 방법은 없었을까요? useAutoCallback을 사용하면 내부 디바운싱에서 타이머가 초기화되지 않는 문제가 있었습니다. 함수를 메모이제이션 하는거니까 useCallback쪽이 더 어울린다고 생각이 들어서요!</p>
</blockquote>
<p>이 때는 useCallback이 아니라 useMemo를 사용해야 한다고 생각해요!
debounce로 만든 함수 자체를 메모해야 하기 때문이죠! 그래서 솔루션도 살펴보시면 debounce를 useMemo로 만들어서 사용하고 있답니다 ㅎㅎ</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token keyword">const</span> hideAfter <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token function">debounce</span><span class="token punctuation">(</span>hide<span class="token punctuation">,</span> <span class="token constant">DEFAULT_DELAY</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>hide<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="const hideAfter = useMemo(() =&gt; debounce(hide, DEFAULT_DELAY), [hide]);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>요로코롬...</p>
<p>근데 생각해보면 useCallback으로 써도 괜찮을 것 같네요!</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line">  <span class="token keyword">const</span> hideAfter <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token function">debounce</span><span class="token punctuation">(</span>hide<span class="token punctuation">,</span> <span class="token constant">DEFAULT_DELAY</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>hide<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="  const hideAfter = useCallback(debounce(hide, DEFAULT_DELAY), [hide]);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<blockquote>
<p>이런 Provider 구현 시 useReducer가 더 좋을까요? 저는 useState로 상태값을 두고 handle함수를 Provider 내부에 둔 상태가 한눈에 보여 파악하기 쉽다고 생각했습니다! 코치님은 useReducer를 선호하시나요?? 이유도 궁금합니다!</p>
</blockquote>
<p>복잡한 상태를 다룰수록 reducer가 좋다고 생각합니다 ㅎㅎ
물론 state로 구현해도 충분하지만요!
reducer로 만들면 순수함수가 되고, 순수함수는 테스트하기가 용이해지는 장점도 있답니다!</p>
<p>다만 이건 팀 컨벤션이 제일 중요하다고 생각해요. 제가 reducer를 쓴 이유는 학습에 대한 이유도 있답니다! 아마 useReducer 자체가 익숙하지 않은 사람들도 많을 것 같아서, 이렇게도 사용할 수 있다는걸 보여주고 싶었어요.</p>
<blockquote>
<p>얕은 비교 함수를 구현하고나서 Zustand 코드를 살펴보았는데 Map과 Set, Symbol.iterator, 일반 객체를 분리해서 순회하는 부분을 보았습니다. 저는 따로 분리하여 처리하지 않았는데 처리하지 않았을 때 문제가 될 부분이 있을까요?</p>
</blockquote>
<p>Map, Set 등을 처리할 때 문제되겠죠!? 사실 실무에서는 대부분 만들어진 것들을 사용하기 때문에, 내부가 어떻게 동작하는구나 정도만 알고 있어도 충분하다고 생각해요 ㅎㅎ</p>
<p>deppEqual도 fast-deep-equal 같은 라이브러리를 사용한답니다 ㅋㅋ</p></div></div><div class="mt-9"></div></div></main></div></div></div></div>
</body>
</html>
