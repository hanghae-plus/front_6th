export const MOCK_PR = {
  url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/pulls/77",
  id: 2660823347,
  node_id: "PR_kwDOO_cYE86emPEz",
  html_url: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/77",
  diff_url: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/77.diff",
  patch_url: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/77.patch",
  issue_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/issues/77",
  number: 77,
  state: "open",
  locked: false,
  title: "[9팀 신홍준] Chapter 1-1. 프레임워크 없이 SPA 만들기 ",
  user: {
    login: "jun17183",
    id: 64164782,
    node_id: "MDQ6VXNlcjY0MTY0Nzgy",
    avatar_url: "https://avatars.githubusercontent.com/u/64164782?v=4",
    gravatar_id: "",
    url: "https://api.github.com/users/jun17183",
    html_url: "https://github.com/jun17183",
    followers_url: "https://api.github.com/users/jun17183/followers",
    following_url: "https://api.github.com/users/jun17183/following{/other_user}",
    gists_url: "https://api.github.com/users/jun17183/gists{/gist_id}",
    starred_url: "https://api.github.com/users/jun17183/starred{/owner}{/repo}",
    subscriptions_url: "https://api.github.com/users/jun17183/subscriptions",
    organizations_url: "https://api.github.com/users/jun17183/orgs",
    repos_url: "https://api.github.com/users/jun17183/repos",
    events_url: "https://api.github.com/users/jun17183/events{/privacy}",
    received_events_url: "https://api.github.com/users/jun17183/received_events",
    type: "User",
    user_view_type: "public",
    site_admin: false,
  },
  body: '## 과제 체크포인트\r\n\r\n### 배포 링크\r\n\r\nhttps://jun17183.github.io/front_6th_chapter1-1/\r\n\r\n### 기본과제\r\n\r\n#### 상품목록\r\n\r\n**상품 목록 로딩**\r\n\r\n- [x] 페이지 접속 시 로딩 상태가 표시된다\r\n- [x] 데이터 로드 완료 후 상품 목록이 렌더링된다\r\n- [x] 로딩 실패 시 에러 상태가 표시된다\r\n- [x] 에러 발생 시 재시도 버튼이 제공된다\r\n\r\n**상품 목록 조회**\r\n\r\n- [x] 각 상품의 기본 정보(이미지, 상품명, 가격)가 카드 형태로 표시된다\r\n\r\n**한 페이지에 보여질 상품 수 선택**\r\n\r\n- [x] 드롭다운에서 10, 20, 50, 100개 중 선택할 수 있으며 기본 값은 20개 이다.\r\n- [x] 선택 변경 시 즉시 목록에 반영된다\r\n\r\n**상품 정렬 기능**\r\n\r\n- [x] 상품을 가격순/인기순으로 오름차순/내림차순 정렬을 할 수 있다.\r\n- [x] 드롭다운을 통해 정렬 기준을 선택할 수 있다\r\n- [x] 정렬 변경 시 즉시 목록에 반영된다\r\n\r\n**무한 스크롤 페이지네이션**\r\n\r\n- [x] 페이지 하단 근처 도달 시 다음 페이지 데이터가 자동 로드된다\r\n- [x] 스크롤에 따라 계속해서 새로운 상품들이 목록에 추가된다\r\n- [x] 새 데이터 로드 중일 때 로딩 인디케이터와 스켈레톤 UI가 표시된다\r\n- [x] 홈 페이지에서만 무한 스크롤이 활성화된다\r\n\r\n**상품을 장바구니에 담기**\r\n\r\n- [x] 각 상품에 장바구니 추가 버튼이 있다\r\n- [x] 버튼 클릭 시 해당 상품이 장바구니에 추가된다\r\n- [x] 추가 완료 시 사용자에게 알림이 표시된다\r\n\r\n**상품 검색**\r\n\r\n- [x] 상품명 기반 검색을 위한 텍스트 입력 필드가 있다\r\n- [x] 검색 버튼 클릭으로 검색이 수행된다\r\n- [x] Enter 키로 검색이 수행된다\r\n- [x] 검색어와 일치하는 상품들만 목록에 표시된다\r\n\r\n**카테고리 선택**\r\n\r\n- [x] 사용 가능한 카테고리들을 선택할 수 있는 UI가 제공된다\r\n- [x] 선택된 카테고리에 해당하는 상품들만 표시된다\r\n- [x] 전체 상품 보기로 돌아갈 수 있다\r\n- [x] 2단계 카테고리 구조를 지원한다 (1depth, 2depth)\r\n\r\n**카테고리 네비게이션**\r\n\r\n- [x] 현재 선택된 카테고리 경로가 브레드크럼으로 표시된다\r\n- [x] 브레드크럼의 각 단계를 클릭하여 상위 카테고리로 이동할 수 있다\r\n- [x] "전체" > "1depth 카테고리" > "2depth 카테고리" 형태로 표시된다\r\n\r\n**현재 상품 수 표시**\r\n\r\n- [x] 현재 조건에서 조회된 총 상품 수가 화면에 표시된다\r\n- [x] 검색이나 필터 적용 시 상품 수가 실시간으로 업데이트된다\r\n\r\n#### 장바구니\r\n\r\n**장바구니 모달**\r\n\r\n- [] 장바구니 아이콘 클릭 시 모달 형태로 장바구니가 열린다\r\n- [] X 버튼이나 배경 클릭으로 모달을 닫을 수 있다\r\n- [] ESC 키로 모달을 닫을 수 있다\r\n- [] 모달에서 장바구니의 모든 기능을 사용할 수 있다\r\n\r\n**장바구니 수량 조절**\r\n\r\n- [] 각 장바구니 상품의 수량을 증가할 수 있다\r\n- [] 각 장바구니 상품의 수량을 감소할 수 있다\r\n- [] 수량 변경 시 총 금액이 실시간으로 업데이트된다\r\n\r\n**장바구니 삭제**\r\n\r\n- [] 각 상품에 삭제 버튼이 배치되어 있다\r\n- [] 삭제 버튼 클릭 시 해당 상품이 장바구니에서 제거된다\r\n\r\n**장바구니 선택 삭제**\r\n\r\n- [] 각 상품에 선택을 위한 체크박스가 제공된다\r\n- [] 선택 삭제 버튼이 있다\r\n- [] 체크된 상품들만 일괄 삭제된다\r\n\r\n**장바구니 전체 선택**\r\n\r\n- [] 모든 상품을 한 번에 선택할 수 있는 마스터 체크박스가 있다\r\n- [] 전체 선택 시 모든 상품의 체크박스가 선택된다\r\n- [] 전체 해제 시 모든 상품의 체크박스가 해제된다\r\n\r\n**장바구니 비우기**\r\n\r\n- [] 장바구니에 있는 모든 상품을 한 번에 삭제할 수 있다\r\n\r\n#### 상품 상세\r\n\r\n**상품 클릭시 상세 페이지 이동**\r\n\r\n- [x] 상품 목록에서 상품 이미지나 상품 정보 클릭 시 상세 페이지로 이동한다\r\n- [x] URL이 `/product/{productId}` 형태로 변경된다\r\n- [x] 상품의 자세한 정보가 전용 페이지에서 표시된다\r\n\r\n**상품 상세 페이지 기능**\r\n\r\n- [x] 상품 이미지, 설명, 가격 등의 상세 정보가 표시된다\r\n- [x] 전체 화면을 활용한 상세 정보 레이아웃이 제공된다\r\n\r\n**상품 상세 - 장바구니 담기**\r\n\r\n- [x] 상품 상세 페이지에서 해당 상품을 장바구니에 추가할 수 있다\r\n- [x] 페이지 내에서 수량을 선택하여 장바구니에 추가할 수 있다\r\n- [x] 수량 증가/감소 버튼이 제공된다\r\n\r\n**관련 상품 기능**\r\n\r\n- [x] 상품 상세 페이지에서 관련 상품들이 표시된다\r\n- [x] 같은 카테고리(category2)의 다른 상품들이 관련 상품으로 표시된다\r\n- [x] 관련 상품 클릭 시 해당 상품의 상세 페이지로 이동한다\r\n- [x] 현재 보고 있는 상품은 관련 상품에서 제외된다\r\n\r\n**상품 상세 페이지 내 네비게이션**\r\n\r\n- [x] 상품 상세에서 상품 목록으로 돌아가는 버튼이 제공된다\r\n- [x] 브레드크럼을 통해 카테고리별 상품 목록으로 이동할 수 있다\r\n- [x] SPA 방식으로 페이지 간 이동이 부드럽게 처리된다\r\n\r\n#### 사용자 피드백 시스템\r\n\r\n**토스트 메시지**\r\n\r\n- [x] 장바구니 추가 시 성공 메시지가 토스트로 표시된다\r\n- [] 장바구니 삭제, 선택 삭제, 전체 삭제 시 알림 메시지가 표시된다\r\n- [x] 토스트는 3초 후 자동으로 사라진다\r\n- [x] 토스트에 닫기 버튼이 제공된다\r\n- [x] 토스트 타입별로 다른 스타일이 적용된다 (success, info, error)\r\n\r\n### 심화과제\r\n\r\n#### SPA 네비게이션 및 URL 관리\r\n\r\n**페이지 이동**\r\n\r\n- [x] 어플리케이션 내의 모든 페이지 이동(뒤로가기/앞으로가기를 포함)은 하여 새로고침이 발생하지 않아야 한다.\r\n\r\n**상품 목록 - URL 쿼리 반영**\r\n\r\n- [x] 검색어가 URL 쿼리 파라미터에 저장된다\r\n- [x] 카테고리 선택이 URL 쿼리 파라미터에 저장된다\r\n- [x] 상품 옵션이 URL 쿼리 파라미터에 저장된다\r\n- [x] 정렬 조건이 URL 쿼리 파라미터에 저장된다\r\n- [x] 조건 변경 시 URL이 자동으로 업데이트된다\r\n- [x] URL을 통해 현재 검색/필터 상태를 공유할 수 있다\r\n\r\n**상품 목록 - 새로고침 시 상태 유지**\r\n\r\n- [x] 새로고침 후 URL 쿼리에서 검색어가 복원된다\r\n- [x] 새로고침 후 URL 쿼리에서 카테고리가 복원된다\r\n- [x] 새로고침 후 URL 쿼리에서 옵션 설정이 복원된다\r\n- [x] 새로고침 후 URL 쿼리에서 정렬 조건이 복원된다\r\n- [x] 복원된 조건에 맞는 상품 데이터가 다시 로드된다\r\n\r\n**장바구니 - 새로고침 시 데이터 유지**\r\n\r\n- [x] 장바구니 내용이 브라우저에 저장된다\r\n- [x] 새로고침 후에도 이전 장바구니 내용이 유지된다\r\n- [] 장바구니의 선택 상태도 함께 유지된다\r\n\r\n**상품 상세 - URL에 ID 반영**\r\n\r\n- [x] 상품 상세 페이지 이동 시 상품 ID가 URL 경로에 포함된다 (`/product/{productId}`)\r\n- [x] URL로 직접 접근 시 해당 상품의 상세 페이지가 자동으로 로드된다\r\n\r\n**상품 상세 - 새로고침시 유지**\r\n\r\n- [x] 새로고침 후에도 URL의 상품 ID를 읽어서 해당 상품 상세 페이지가 유지된다\r\n\r\n**404 페이지**\r\n\r\n- [x] 존재하지 않는 경로 접근 시 404 에러 페이지가 표시된다\r\n- [x] 홈으로 돌아가기 버튼이 제공된다\r\n\r\n#### AI로 한 번 더 구현하기\r\n\r\n- [] 기존에 구현한 기능을 AI로 다시 구현한다.\r\n- [] 이 과정에서 직접 가공하는 것은 최대한 지양한다.\r\n\r\n\r\n## 테스트 코드 수정\r\n- \'총 개의 상품\' 을 \'총 n개의 상품\' 과 같은 형태로 변경\r\n- 테스트 후 state 초기화\r\n- 너무 빠른 속도로 뒤로가기/앞으로가기 시 생기던 렌더링 문제를 해결하기 위해 속도 지연 추가 (이 부분이 문제가 될 수도 있음을 인지하고 있습니다...)\r\n\r\n\r\n## 과제 셀프회고\r\n\r\n<!-- 과제에 대한 회고를 작성해주세요 -->\r\n실무에서는 AI는 커녕 인터넷도 안 되는 환경에서도 종종 일했던 터라 최대한 AI를 활용해 보는 것이 목표였습니다. 하지만 고기도 먹어 본 사람이 더 잘 먹는다는 것처럼 막상 사용하려니 AI와 스스로의 작업 비중이나 역할을 분명하게 나누지 못했습니다.\r\n\r\n처음엔 한꺼번에 너무 많은 내용을 주문했습니다. \r\n"순수 JS로 SPA를 구현하는 과제를 진행 중이야. 최대한 리액트처럼 구현했으면 해.\r\n옵저버 패턴을 활용하여 state를 관리하고 이를 각 페이지나 컴포넌트에서 구독한 뒤\r\n이에 따라 페이지 렌더링이 이루어졌으면 해. 라우터도 조건에 맞게 구현해줘.\r\n..."\r\n\r\n그래서 첫째날 바로 한 사이트가 뚝딱 만들어 졌습니다.\r\n그러고 테스트를 돌리자 죄다 통과하지 못했습니다.\r\n되돌아보면 /총 개의 상품/ 부분이 /총 n개의 상품/ 과 같이 구현되어서 매치가 되지 않았던 것 뿐인데 직접 작성한 코드가 아니다 보니 파악 자체가 힘들었습니다.\r\n\r\n새로 과제를 진행하기로 했습니다. 작업 순서를 정하고 단위를 작게 나누어 이에 따라 AI에게 주문했습니다.\r\n\r\n"우선 State Manager의 상위 클래스부터 제작하려 해. 구독과 감지 메서드는 필수로 있어야 하고 이 외 기능은 바로 코드 적용하지 말고 먼저 설명 부탁해."\r\n\r\n이렇게 진행하다 보니 나름 순탄하게 흘러갔습니다. 코드 이해도도 높고 버그도 많이 줄었습니다. 하지만 이 과정에서 이미 꽤 많은 시간이 흐른 상태였습니다.\r\n\r\n이때 AI 사용량이 바닥이 나고 맙니다. cursor claude 4.0을 사용 중이었는데 그동안 너무 많은 코드 작업을 맡겼던 것 같습니다. 그래서 다른 AI를 사용하려 하니 성능이 현저히 떨어지고, 그동안의 맥락을 따라가지 못하였습니다.\r\n\r\n이후로는 거의 직접 작업을 하게 되었습니다. 이 과정에서 시간도 쫓기고 버그도 많이 생겨 필수 과제만 통과하는 것을 목표로 하였고 어찌저찌 완성은 했지만 아쉬움이 많이 남습니다.\r\n\r\n그럼에도 고무적인 부분이 있습니다. 과제를 진행하는 동안 AI와 스스로 개발하는 비율이 8:2, 6:4, 3:7과 같이 바뀌는 과정을 겪으며 어떻게 AI를 사용해야 하는지 많이 깨달을 수 있었습니다.\r\n\r\n\r\n### 기술적 성장\r\n\r\n<!-- 예시\r\n- 새로 학습한 개념\r\n- 기존 지식의 재발견/심화\r\n- 구현 과정에서의 기술적 도전과 해결\r\n-->\r\n옵저버 패턴에 대해 대충은 알고 있었지만 정확히 어떤 식으로 동작하는지, 어떤 형태를 띄는지는 잘 몰랐기에 이번 기회에 꼭 한번 사용해 보고 싶었습니다.\r\n\r\n덕분에 어느 정도 옵저버 패턴과 좀 더 친숙해 질 수 있는 시간이었고 더하여 렌더링이나 State 관리에 대해서도 조금 더 시야가 넓어졌지 않나 생각합니다.\r\n\r\n### 자랑하고 싶은 코드\r\n\r\n<!-- 예시\r\n- 특히 만족스러운 구현\r\n- 리팩토링이 필요한 부분\r\n- 코드 설계 관련 고민과 결정\r\n-->\r\n\r\n아무래도 옵저버 패턴을 자랑하고 싶습니다. 아무래도 어떤 디자인 패턴을 인지하고 적극적으로 사용해 본 적은 처음이라 스스로 뿌듯한 부분입니다.\r\n\r\n```js\r\nclass StateManager {\r\n  ...\r\n\r\n  subscribe(keys, observer) {\r\n    const keyArray = Array.isArray(keys) ? keys : [keys];\r\n\r\n    // 각 키에 대해 옵저버 등록\r\n    keyArray.forEach((key) => {\r\n      if (!this.observers[key]) this.observers[key] = [];\r\n      this.observers[key].push(observer);\r\n    });\r\n\r\n    // 구독 해제 함수 반환\r\n    return () => {\r\n      keyArray.forEach((key) => {\r\n        if (this.observers[key]) {\r\n          const index = this.observers[key].indexOf(observer);\r\n          if (index > -1) this.observers[key].splice(index, 1);\r\n        }\r\n      });\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 특정 키를 구독한 모든 옵저버에게 상태 변경 알림\r\n   *\r\n   * @param {string} key - 변경된 상태 키\r\n   * @param {*} value - 새로운 값\r\n   */\r\n  notify(key, value) {\r\n    if (this.observers[key]) {\r\n      this.observers[key].forEach((observer) => observer(value, key, this.state));\r\n    }\r\n  }\r\n\r\n  ...\r\n}\r\n```\r\n\r\n```js\r\nclass ProductListPage {\r\n  ...\r\n\r\n  /**\r\n   * 상태 구독 설정\r\n   */\r\n  setupSubscriptions() {\r\n    // 로딩 상태 구독 (메인 로딩)\r\n    stateManager.productList.subscribe(["loading"], () => {\r\n      this.renderLoading();\r\n    });\r\n\r\n    // 추가 로딩 상태 구독 (무한 스크롤용)\r\n    stateManager.productList.subscribe(["isLoadingMore"], () => {\r\n      this.renderInfiniteScrollLoading();\r\n    });\r\n\r\n    // 상품 목록 구독\r\n    stateManager.productList.subscribe(["products"], () => {\r\n      this.renderProducts();\r\n    });\r\n\r\n    // 총 상품 수 구독\r\n    stateManager.productList.subscribe(["totalProducts"], () => {\r\n      this.updateProductCount();\r\n    });\r\n\r\n    // 필터(정렬, 카테고리, 검색어, 페이지 크기) 구독\r\n    stateManager.productList.subscribe(["sort", "category", "searchQuery", "pageSize"], () => {\r\n      stateManager.productList.loadProducts();\r\n    });\r\n  }\r\n\r\n  ...\r\n}\r\n```\r\n\r\n### 개선이 필요하다고 생각하는 코드\r\n\r\n<!-- 예시\r\n- 특히 만족스러운 구현\r\n- 리팩토링이 필요한 부분\r\n- 코드 설계 관련 고민과 결정\r\n-->\r\n\r\n1. 렌더링 방식\r\nurl 이동 -> 초기 렌더링 -> state 변화 감지 -> state에 따른 렌더링\r\n과 같은 형태로 구현해 보았는데, 이 과정에서 동기화 문제라던가 렌더링이 되기 전 페이지 이동 등 생명주기(라고 표현하는 것이 맞는지 의문) 관리가 제대로 되지 못하였지 않나 생각합니다.\r\n\r\n2. 검색조건 state와 url 동기화\r\n검색조건을 state에 담아 사용하고 있지만 결국 url과도 동기화해야 하기 때문에 검색조건 정보가 두 군데서 관리되는 느낌이었습니다.\r\n\r\n사용자가 직접 url을 치고 들어올 수도 있기에 url이 정보의 근원이라는 원칙을 정하긴 했지만 그럼에도 결국 state 값에 따라 구독 콜백 함수가 실행되는 형태이기에 주객전도가 된 것 같았습니다.\r\n\r\nstate와 url 간의 동기화 및 관리 방식이 궁금합니다.\r\n\r\n3. 단일 책임 원칙\r\n이번에 최대한 단일 책임 원칙을 지키며 작업하려 했습니다.\r\n하지만 많은 부분에서 이를 놓친 것 같습니다. 과제 제출 후에도 리팩토링을 진행하며 살펴볼 계획입니다.\r\n\r\n### 학습 효과 분석\r\n\r\n<!-- 예시\r\n- 가장 큰 배움이 있었던 부분\r\n- 추가 학습이 필요한 영역\r\n- 실무 적용 가능성\r\n-->\r\n가장 큰 배움은 AI 활용입니다. AI에게 어떻게 일을 맡겨야 하는지, AI가 작업한 코드를 어떻게 관리해야 할지 등 많은 것을 느낀 시간이었습니다.\r\n\r\n상태 관리와 렌더링 방식에 대해서도 시야가 넓어진 느낌입니다.\r\n직접 구현해 보니 어떤 이슈가 발생할 수 있는지, 어떤 코드가 확장성이 좋은지 등을 알게 되었습니다.\r\n\r\n그렇기에 오히려 이 부분에 대해 추가 학습이 필요하다고 느꼈습니다.\r\n올바른 렌더링 방식은 무엇인지, 실제 router는 어떻게 동작하는지,\r\n전역 상태는 어디까지 관리해야 하는지 등 공부하고 싶은 것이 많아진 과제였습니다.\r\n\r\n### 과제 피드백\r\n\r\n<!-- 예시\r\n- 과제에서 모호하거나 애매했던 부분\r\n- 과제에서 좋았던 부분\r\n-->\r\n\r\n우선 주제 자체가 마음에 들었습니다. 한번쯤은 직접 해보려고 했지만 선뜻 발걸음이 떼지지 않았는데 이렇게 하게 되어 좋았습니다. 어떻게 보면 짧은 시간, 적은 내용일 수도 있지만 이 안에서도 프론트엔드 개발자로 마주할 수 있는 고민을 미리 느껴볼 수 있었지 않았나 생각합니다.\r\n\r\n테스트코드를 활용한 과제 통과 여부 확인도 좋았습니다.\r\n물론 기능은 잘 돌아가는데 왜 테스트가 통과하지 않는지 등과 같은 의문이 있었지만, 모두 실무에서도 충분히 겪을 법한 상황이라 짜증이 나는 한편 웃음이 나오기도 했습니다.\r\n\r\n### AI 활용 경험 공유하기\r\n\r\n<!-- 예시\r\n- 사용한 AI 도구 (예: ChatGPT, Copilot, Claude, Cursor, ...)\r\n- 프롬프트를 작성한 과정\r\n- AI가 일을 더 잘 하게 만든 방법\r\n- 내가 작성한 코드와 비교하기\r\n-->\r\n\r\n우선 진행하려는 작업을 정의하고 이에 대해 AI와 충분히 대화를 하는 편이 좋았습니다. 필요 작업을 명세하고 이를 문서로 만든 뒤, 이 문서를 기준으로 작업을 진행하면 속도도 빠르고 코드 이해도도 많이 챙길 수 있었습니다.\r\n\r\nAI에게 맡길 작업의 단위도 되도록이면 작게 작게, 단위테스트와 비슷한 단위로 가져가는 것이 좋았습니다. \r\n\r\n다만 테스트 파일을 직접 읽고 이에 맡게 처리하라는 방식은 좋지 못하였습니다. 어떻게든 테스트를 통과하기 위해 작업하다 보니 코드가 어그러졌습니다.\r\n\r\n가장 크게 느낀 부분은, 확실히 성능 좋은 최신 버전의 AI가 그렇지 못한 AI보다 월등히 일을 잘한다는 겁니다...ㅎㅎ\r\n\r\n## 리뷰 받고 싶은 내용\r\n\r\n<!--\r\n피드백 받고 싶은 내용을 구체적으로 남겨주세요\r\n모호한 요청은 피드백을 남기기 어렵습니다.\r\n\r\n참고링크: https://chatgpt.com/share/675b6129-515c-8001-ba72-39d0fa4c7b62\r\n\r\n모호한 질문의 예시)\r\n- 무엇을 질문해야 할지 몰라서 코치님이 보시기에 고쳐야할것들 전반적으로 피드백 부탁드립니다.\r\n- 코드 스타일에 대한 피드백 부탁드립니다.\r\n- 코드 구조에 대한 피드백 부탁드립니다.\r\n- 개념적인 오류에 대한 피드백 부탁드립니다.\r\n- 추가 구현이 필요한 부분에 대한 피드백 부탁드립니다.\r\n\r\n구체적인 질문의 예시)\r\n- 파일A의 함수B와 그 안의 변수명을 보면 직관성이 떨어지는 것 같습니다. 함수와 변수 이름을 더 명확하게 지을 방법에 대해 조언해 주실 수 있나요?\r\n- 현재 파일 단위로 코드를 분리했지만, 이번 주차 발제를 기준으로 봤을 때 모듈화나 계층화에서 부족함이 있는 것 같습니다. 특히 A와 B 부분에서 모듈화를 더 진행할지 그대로 둘지 고민하였습니다. (...구체적인 고민 사항 적기...). 코치님의 의견이 궁금합니다.\r\n- 옵저버 패턴을 사용해 상태 관리 로직을 구현해 보려 했습니다. 제가 구현한 코드가 옵저버 패턴에 맞게 잘 구성되었는지 검토해 주시고, 보완할 부분을 제안해 주실 수 있을까요?\r\n- 컴포넌트 A를 테스트 할 때 B와의 의존성 때문에 테스트 코드를 작성하려다 포기했습니다. A와 B의 의존성을 낮추고 테스트 가능성을 높이는 구조 개선 방안이 있을까요?\r\n-->\r\n\r\n- 질문에 앞서 코드 구조\r\nrouter.js는 각 페이지의 render 메서드를 호출한 뒤 렌더링이 완료되면 mounted 메서드를 호출하고 있습니다. 그리고 각 페이지의 mounted 메서드에선 상태 구독 설멍 메서드를 호출하고 있습니다.\r\n\r\n(render -> 완료 -> mounted -> 상태 구독 -> 상태에 따른 rerender)\r\n\r\n1.\r\n목록 페이지에서 상품 목록을 불러오기 전 url에서 검색 조건을 읽어 이를 state와 맞추는 작업을 합니다. 그럼 state가 변경될 것이고 이 state를 구독하고 있는 컴포넌트, 페이지들은 리렌더링이 됩니다.\r\n\r\n여기서 의문이 생기는 것이, 결국 모든 기능의 중심은 state인데 정보의 원천이 url인 것이 어색합니다. 보통 실무에선 state와 url의 동기화 문제를 어떻게 해결하나요?\r\n\r\n2.\r\n위와 같은 렌더링 방식에서 unmount 함수는 어떻게 관리해야 할지 모르겠습니다. \r\n\r\ninnerHTML을 사용하고 있기에 window 이벤트 같은 것을 제외하면 굳이 unmount 함수를 구현할 필요가 없나 싶기도 하지만, advanced.spec 테스트 "브라우저 뒤로가기/앞으로가기가 올바르게 작동한다" 항목에서\r\n너무 빠르게 페이지 이동이 발생하다 보니 url은 목록 페이지인데 뒤늦게 상품 페이지가 렌더링이 된 것 같아 결국 테스트 코드를 손보게 되었습니다.\r\n\r\nunmount는 언제 사용하는지, 위와 같은 문제를 unmount 함수로 어떻게 해결할 수 있을지 궁금합니다.\r\n\r\n3.\r\n옵저버 패턴을 사용해 상태 관리 로직을 구현해 보려 했습니다. 제가 구현한 코드가 옵저버 패턴에 맞게 잘 구성되었는지 검토해 주시고, 보완할 부분을 제안해 주실 수 있을까요? (예시 질문에 있던 항목이지만 제 생각과 너무 일치하여 가져왔습니다!)\r\n\r\n\r\n## 팀원들과 코드 리뷰\r\n\r\n리뷰 받고 싶은 내용 \r\n검색 조건을 state와 url 두 군데서 관리하는 형식이 옳은 방향인가 의문이 듭니다. \r\n\r\n사용자가 직접 url을 치고 들어올 수 있는 가능성도 있기에 url을 정보의 근원이지만 렌더링이나 상품 조회 등은 모두 state를 기준으로 동작하기에 뭔가 이상하게 느껴집니다.\r\n\r\n그렇다고 검색 조건만 url에서 담당, 나머지 상품 정보 등은 state에서 관리하는 방식은 통일성이 없는 거 같다는 생각이 듭니다.\r\n\r\n현재 코드는 url을 정보의 근원으로 두고 state를 url에 맞게 동기화 하는 방식인데, 의견 여쭤보고 싶네요.\r\n\r\n\r\n```js\r\n// state/ProductListManager.js\r\nclass ProductListManager extends StateManager {\r\n  constructor() {\r\n    super();\r\n    /** 상품 관련 상태 정의 */\r\n    this.state = {\r\n      /* 중략 */\r\n      searchQuery: "",\r\n      category: "",\r\n      sort: DEFAULT_SORT,\r\n      pageSize: DEFAULT_LIMIT,\r\n    };\r\n  }\r\n\r\n  /* 중략 */\r\n\r\n  /**\r\n   * URL에서 검색 조건을 읽어와 현재 state와 비교하여 업데이트합니다\r\n   * @returns {boolean} 상태가 변경되었는지 여부\r\n   */\r\n  syncFromUrl() {\r\n    const urlFilters = this.parseFiltersFromUrl();\r\n\r\n    // URL에서 파싱된 조건들을 기본값과 비교하여 최종 필터 생성\r\n    const finalFilters = {\r\n      searchQuery: urlFilters.searchQuery || "",\r\n      category: urlFilters.category || "",\r\n      sort: urlFilters.sort || DEFAULT_SORT,\r\n      pageSize: urlFilters.pageSize || DEFAULT_LIMIT,\r\n    };\r\n\r\n    // 현재 state와 비교하여 변경된 부분만 확인\r\n    const hasChanged = Object.keys(finalFilters).some((key) => this.state[key] !== finalFilters[key]);\r\n\r\n    if (hasChanged) {\r\n      // 변경된 부분만 업데이트 (페이지는 1로 리셋)\r\n      this.setState({\r\n        ...finalFilters,\r\n        currentPage: 1,\r\n      });\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n\r\nclass ProductListPage {\r\n  constructor() { /* ... */ }\r\n\r\n  mounted() {\r\n    /* 중략 */\r\n    \r\n    this.initializeFromUrl();\r\n  }\r\n\r\n  /**\r\n   * URL에서 검색 조건을 동기화하고 초기 상품을 로드합니다\r\n   */\r\n  initializeFromUrl() {\r\n    // URL에서 검색 조건을 동기화\r\n    const hasChanged = stateManager.productList.syncFromUrl();\r\n\r\n    // 조건이 변경되지 않은 경우에만 직접 로딩 (변경된 경우 구독에서 자동 로딩됨)\r\n    if (!hasChanged) {\r\n      stateManager.productList.loadProducts();\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n',
  created_at: "2025-07-12T04:09:02Z",
  updated_at: "2025-07-12T05:18:54Z",
  closed_at: null,
  merged_at: null,
  merge_commit_sha: "98313070895a128d1bd4753480beec9888a11eea",
  assignee: null,
  assignees: [],
  requested_reviewers: [],
  requested_teams: [],
  labels: [],
  milestone: null,
  draft: false,
  commits_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/pulls/77/commits",
  review_comments_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/pulls/77/comments",
  review_comment_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/pulls/comments{/number}",
  comments_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/issues/77/comments",
  statuses_url:
    "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/statuses/d375e10342739b716cb7ddceb62b3485e94645e4",
  head: {
    label: "jun17183:main",
    ref: "main",
    sha: "d375e10342739b716cb7ddceb62b3485e94645e4",
    user: {
      login: "jun17183",
      id: 64164782,
      node_id: "MDQ6VXNlcjY0MTY0Nzgy",
      avatar_url: "https://avatars.githubusercontent.com/u/64164782?v=4",
      gravatar_id: "",
      url: "https://api.github.com/users/jun17183",
      html_url: "https://github.com/jun17183",
      followers_url: "https://api.github.com/users/jun17183/followers",
      following_url: "https://api.github.com/users/jun17183/following{/other_user}",
      gists_url: "https://api.github.com/users/jun17183/gists{/gist_id}",
      starred_url: "https://api.github.com/users/jun17183/starred{/owner}{/repo}",
      subscriptions_url: "https://api.github.com/users/jun17183/subscriptions",
      organizations_url: "https://api.github.com/users/jun17183/orgs",
      repos_url: "https://api.github.com/users/jun17183/repos",
      events_url: "https://api.github.com/users/jun17183/events{/privacy}",
      received_events_url: "https://api.github.com/users/jun17183/received_events",
      type: "User",
      user_view_type: "public",
      site_admin: false,
    },
    repo: {
      id: 1014146705,
      node_id: "R_kgDOPHKmkQ",
      name: "front_6th_chapter1-1",
      full_name: "jun17183/front_6th_chapter1-1",
      private: false,
      owner: {
        login: "jun17183",
        id: 64164782,
        node_id: "MDQ6VXNlcjY0MTY0Nzgy",
        avatar_url: "https://avatars.githubusercontent.com/u/64164782?v=4",
        gravatar_id: "",
        url: "https://api.github.com/users/jun17183",
        html_url: "https://github.com/jun17183",
        followers_url: "https://api.github.com/users/jun17183/followers",
        following_url: "https://api.github.com/users/jun17183/following{/other_user}",
        gists_url: "https://api.github.com/users/jun17183/gists{/gist_id}",
        starred_url: "https://api.github.com/users/jun17183/starred{/owner}{/repo}",
        subscriptions_url: "https://api.github.com/users/jun17183/subscriptions",
        organizations_url: "https://api.github.com/users/jun17183/orgs",
        repos_url: "https://api.github.com/users/jun17183/repos",
        events_url: "https://api.github.com/users/jun17183/events{/privacy}",
        received_events_url: "https://api.github.com/users/jun17183/received_events",
        type: "User",
        user_view_type: "public",
        site_admin: false,
      },
      html_url: "https://github.com/jun17183/front_6th_chapter1-1",
      description: "항해플러스 프론트엔드 6기 > 챕터 1-1 과제: 프레임워크 없이 만드는 SPA with 쇼핑몰",
      fork: true,
      url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1",
      forks_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/forks",
      keys_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/keys{/key_id}",
      collaborators_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/collaborators{/collaborator}",
      teams_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/teams",
      hooks_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/hooks",
      issue_events_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/issues/events{/number}",
      events_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/events",
      assignees_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/assignees{/user}",
      branches_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/branches{/branch}",
      tags_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/tags",
      blobs_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/git/blobs{/sha}",
      git_tags_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/git/tags{/sha}",
      git_refs_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/git/refs{/sha}",
      trees_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/git/trees{/sha}",
      statuses_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/statuses/{sha}",
      languages_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/languages",
      stargazers_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/stargazers",
      contributors_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/contributors",
      subscribers_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/subscribers",
      subscription_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/subscription",
      commits_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/commits{/sha}",
      git_commits_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/git/commits{/sha}",
      comments_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/comments{/number}",
      issue_comment_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/issues/comments{/number}",
      contents_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/contents/{+path}",
      compare_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/compare/{base}...{head}",
      merges_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/merges",
      archive_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/{archive_format}{/ref}",
      downloads_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/downloads",
      issues_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/issues{/number}",
      pulls_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/pulls{/number}",
      milestones_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/milestones{/number}",
      notifications_url:
        "https://api.github.com/repos/jun17183/front_6th_chapter1-1/notifications{?since,all,participating}",
      labels_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/labels{/name}",
      releases_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/releases{/id}",
      deployments_url: "https://api.github.com/repos/jun17183/front_6th_chapter1-1/deployments",
      created_at: "2025-07-05T06:23:42Z",
      updated_at: "2025-07-11T10:54:03Z",
      pushed_at: "2025-07-11T10:54:00Z",
      git_url: "git://github.com/jun17183/front_6th_chapter1-1.git",
      ssh_url: "git@github.com:jun17183/front_6th_chapter1-1.git",
      clone_url: "https://github.com/jun17183/front_6th_chapter1-1.git",
      svn_url: "https://github.com/jun17183/front_6th_chapter1-1",
      homepage: null,
      size: 148,
      stargazers_count: 0,
      watchers_count: 0,
      language: "JavaScript",
      has_issues: false,
      has_projects: true,
      has_downloads: true,
      has_wiki: false,
      has_pages: true,
      has_discussions: false,
      forks_count: 0,
      mirror_url: null,
      archived: false,
      disabled: false,
      open_issues_count: 0,
      license: null,
      allow_forking: true,
      is_template: false,
      web_commit_signoff_required: false,
      topics: [],
      visibility: "public",
      forks: 0,
      open_issues: 0,
      watchers: 0,
      default_branch: "main",
    },
  },
  base: {
    label: "hanghae-plus:main",
    ref: "main",
    sha: "ae35e2b2c58872d65f83b05a0dcb79a78d6da9b1",
    user: {
      login: "hanghae-plus",
      id: 144507192,
      node_id: "O_kgDOCJ0BOA",
      avatar_url: "https://avatars.githubusercontent.com/u/144507192?v=4",
      gravatar_id: "",
      url: "https://api.github.com/users/hanghae-plus",
      html_url: "https://github.com/hanghae-plus",
      followers_url: "https://api.github.com/users/hanghae-plus/followers",
      following_url: "https://api.github.com/users/hanghae-plus/following{/other_user}",
      gists_url: "https://api.github.com/users/hanghae-plus/gists{/gist_id}",
      starred_url: "https://api.github.com/users/hanghae-plus/starred{/owner}{/repo}",
      subscriptions_url: "https://api.github.com/users/hanghae-plus/subscriptions",
      organizations_url: "https://api.github.com/users/hanghae-plus/orgs",
      repos_url: "https://api.github.com/users/hanghae-plus/repos",
      events_url: "https://api.github.com/users/hanghae-plus/events{/privacy}",
      received_events_url: "https://api.github.com/users/hanghae-plus/received_events",
      type: "Organization",
      user_view_type: "public",
      site_admin: false,
    },
    repo: {
      id: 1006049299,
      node_id: "R_kgDOO_cYEw",
      name: "front_6th_chapter1-1",
      full_name: "hanghae-plus/front_6th_chapter1-1",
      private: false,
      owner: {
        login: "hanghae-plus",
        id: 144507192,
        node_id: "O_kgDOCJ0BOA",
        avatar_url: "https://avatars.githubusercontent.com/u/144507192?v=4",
        gravatar_id: "",
        url: "https://api.github.com/users/hanghae-plus",
        html_url: "https://github.com/hanghae-plus",
        followers_url: "https://api.github.com/users/hanghae-plus/followers",
        following_url: "https://api.github.com/users/hanghae-plus/following{/other_user}",
        gists_url: "https://api.github.com/users/hanghae-plus/gists{/gist_id}",
        starred_url: "https://api.github.com/users/hanghae-plus/starred{/owner}{/repo}",
        subscriptions_url: "https://api.github.com/users/hanghae-plus/subscriptions",
        organizations_url: "https://api.github.com/users/hanghae-plus/orgs",
        repos_url: "https://api.github.com/users/hanghae-plus/repos",
        events_url: "https://api.github.com/users/hanghae-plus/events{/privacy}",
        received_events_url: "https://api.github.com/users/hanghae-plus/received_events",
        type: "Organization",
        user_view_type: "public",
        site_admin: false,
      },
      html_url: "https://github.com/hanghae-plus/front_6th_chapter1-1",
      description: "항해플러스 프론트엔드 6기 > 챕터 1-1 과제: 프레임워크 없이 만드는 SPA with 쇼핑몰",
      fork: false,
      url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1",
      forks_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/forks",
      keys_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/keys{/key_id}",
      collaborators_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/collaborators{/collaborator}",
      teams_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/teams",
      hooks_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/hooks",
      issue_events_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/issues/events{/number}",
      events_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/events",
      assignees_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/assignees{/user}",
      branches_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/branches{/branch}",
      tags_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/tags",
      blobs_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/git/blobs{/sha}",
      git_tags_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/git/tags{/sha}",
      git_refs_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/git/refs{/sha}",
      trees_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/git/trees{/sha}",
      statuses_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/statuses/{sha}",
      languages_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/languages",
      stargazers_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/stargazers",
      contributors_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/contributors",
      subscribers_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/subscribers",
      subscription_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/subscription",
      commits_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/commits{/sha}",
      git_commits_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/git/commits{/sha}",
      comments_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/comments{/number}",
      issue_comment_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/issues/comments{/number}",
      contents_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/contents/{+path}",
      compare_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/compare/{base}...{head}",
      merges_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/merges",
      archive_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/{archive_format}{/ref}",
      downloads_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/downloads",
      issues_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/issues{/number}",
      pulls_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/pulls{/number}",
      milestones_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/milestones{/number}",
      notifications_url:
        "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/notifications{?since,all,participating}",
      labels_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/labels{/name}",
      releases_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/releases{/id}",
      deployments_url: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/deployments",
      created_at: "2025-06-21T11:29:40Z",
      updated_at: "2025-07-15T14:52:32Z",
      pushed_at: "2025-07-12T02:54:15Z",
      git_url: "git://github.com/hanghae-plus/front_6th_chapter1-1.git",
      ssh_url: "git@github.com:hanghae-plus/front_6th_chapter1-1.git",
      clone_url: "https://github.com/hanghae-plus/front_6th_chapter1-1.git",
      svn_url: "https://github.com/hanghae-plus/front_6th_chapter1-1",
      homepage: "https://hanghae-plus.github.io/front_6th_chapter1-1/",
      size: 432,
      stargazers_count: 4,
      watchers_count: 4,
      language: "JavaScript",
      has_issues: true,
      has_projects: true,
      has_downloads: true,
      has_wiki: false,
      has_pages: true,
      has_discussions: false,
      forks_count: 67,
      mirror_url: null,
      archived: false,
      disabled: false,
      open_issues_count: 61,
      license: null,
      allow_forking: true,
      is_template: false,
      web_commit_signoff_required: false,
      topics: [],
      visibility: "public",
      forks: 67,
      open_issues: 61,
      watchers: 4,
      default_branch: "main",
    },
  },
  _links: {
    self: {
      href: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/pulls/77",
    },
    html: {
      href: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/77",
    },
    issue: {
      href: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/issues/77",
    },
    comments: {
      href: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/issues/77/comments",
    },
    review_comments: {
      href: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/pulls/77/comments",
    },
    review_comment: {
      href: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/pulls/comments{/number}",
    },
    commits: {
      href: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/pulls/77/commits",
    },
    statuses: {
      href: "https://api.github.com/repos/hanghae-plus/front_6th_chapter1-1/statuses/d375e10342739b716cb7ddceb62b3485e94645e4",
    },
  },
  author_association: "NONE",
  auto_merge: null,
  active_lock_reason: null,
};

export const ASSIGNMENT_MOCK = {
  success: true,
  data: [
    {
      assignmentId: "6868a341a8a052ad61454293",
      name: "STEP01 JS & React 딥다이브 기본과제",
      submittedRate: 94.91525423728814,
      notSubmittedRate: 5.084745762711865,
      passedRate: 72.88135593220339,
    },
    {
      assignmentId: "6868a341a8a052ad6145429a",
      name: "STEP02 JS & React 딥다이브 심화과제",
      submittedRate: 93.22033898305084,
      notSubmittedRate: 6.779661016949152,
      passedRate: 62.71186440677966,
    },
    {
      assignmentId: "6871ddc329b801fa62a8ae00",
      name: "STEP03 JS & React 딥다이브 기본과제",
      submittedRate: 94.73684210526315,
      notSubmittedRate: 5.263157894736842,
      passedRate: 92.98245614035088,
    },
    {
      assignmentId: "6871ddc329b801fa62a8ae0e",
      name: "STEP04 JS & React 딥다이브 심화과제",
      submittedRate: 94.73684210526315,
      notSubmittedRate: 5.263157894736842,
      passedRate: 77.19298245614034,
    },
    {
      assignmentId: "687b184281fa7a3b62b27177",
      name: "STEP05 JS & React 딥다이브 기본과제",
      submittedRate: 91.07142857142857,
      notSubmittedRate: 8.928571428571429,
      passedRate: 89.28571428571429,
    },
    {
      assignmentId: "687b184281fa7a3b62b27189",
      name: "STEP06 JS & React 딥다이브 심화과제",
      submittedRate: 91.07142857142857,
      notSubmittedRate: 8.928571428571429,
      passedRate: 89.28571428571429,
    },
    {
      assignmentId: "688452c320b6a864e1c47b6b",
      name: "STEP07 클린 코드 기본과제",
      submittedRate: 94.54545454545455,
      notSubmittedRate: 5.454545454545454,
      passedRate: 65.45454545454545,
    },
    {
      assignmentId: "688452c320b6a864e1c47b79",
      name: "STEP08 클린 코드 심화과제",
      submittedRate: 94.54545454545455,
      notSubmittedRate: 5.454545454545454,
      passedRate: 54.54545454545454,
    },
  ],
};

export const ASSIGNMENT_USERS_TOTAL_STATUS_MOCK = {
  success: true,
  data: [
    {
      _id: "6868a343a8a052ad614543cb",
      result: "PASS",
      isBestPractice: false,
      name: "권지호",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/29",
        },
      ],
      feedback:
        '안녕하세요 지호님!\n1주차 과제 잘 진행해주셨군요 ㅎㅎ 너무 고생 많으셨어요!!\n\n> 서론이 길었지만, 결론은 완주(과제 통과)를 목표로 하고, "ai를 최대한 다루면서 ai가 짠 코드에 의문이 있다면 하나라도 그냥 넘어가지 않고 많이 물어보자" 를 경험하기로 했습니다. 어떻게든 만들어 내야된다는 집착(?)으로 ai로 점점 원하는 결과를 내는 정확도가 올라갔습니다. 활용능력 + 10..\n\n이 또한 이 시대에 살아남는 혹은 성장하는 방법이라고 생각합니다 ㅋㅋ\nAI를 활용하는 능력도 이제 무척 중요하니까요!\n다만 AI를 잘 활용하려면 기본기도 중요하기 때문에 잘 소화하는 시간도 꼭 가져주세요!\n\n> 상태관리와 이벤트버스\n\n직접 이벤트 버스를 구현해주셨군요 ㅎㅎ\n다만 이벤트 버스의 경우 어디서 어떻게 무슨 이유 때문에 트리거가 되었는지 추적하기가 어렵달까... 이런 부분만 조심해주시면 무척 좋답니다!\n실제로 저희 팀에서도 잘 쓰이고 있는 방식 중에 하나랍니다.\n\n> 라우팅 설계에 대해 코멘트 들어보고 싶습니다! 다른 분들은 어떻게 구현하셨을지, 혹은 코치님이 생각하시는 best practice가 무엇인지 궁금합니다. SPA에 적절한 설계를 한 것인지 잘 모르겠습니다(?)\n\n좋은 코드는 내가 만든 프로젝트 뿐만 아니라 다른 사람이 만든 프로젝트에서도 잘 동작하고 결합할 수 있어야 한다고 생각합니다 ㅎㅎ\n\n이런 측면에서 생각해보면 나쁘지 않은 방식이라고 생각해요!\nNotFoundComponent의 경우 이걸 지금 처럼 내제화 하는 방법이 있고, 혹은 외부에 위임하는 방법도 있는데 이 또한 잘 만들어주신 것 같네요!\n\nSPA에 적합한 방식은... 무엇으로 판단해야 좋을지에 대해 먼저 생각해봐야 합니다.\n\n**핵심 기능**\n- 클라이언트 사이드 라우팅 지원\n- 브라우저 히스토리 API 활용 (pushState/popState)\n- 페이지 새로고침 없는 네비게이션\n\n**라우팅 기능**\n- 동적 라우트 매칭 (파라미터, 쿼리스트링)\n- 중첩 라우팅 지원\n- 프로그래매틱 네비게이션 (코드로 라우트 이동)\n- 라우트 가드/보호 기능 (인증, 권한)\n\n**성능 최적화**\n- 지연 로딩 (Lazy Loading) 지원\n- 코드 스플리팅 호환성\n- 가벼운 번들 사이즈\n\n**개발 편의성**\n- 선언적 라우팅 구문\n- TypeScript 지원\n- 개발 도구 지원\n- 에러 바운더리 처리\n\n**호환성**\n- SSR/SSG 지원\n- 메타 태그 관리 (SEO)\n- 404 에러 처리\n- 뒤로가기/앞으로가기 정상 동작\n\n위와 같은 조건들이 있는데, 저는 여기서 제일 중요한게 \n뒤로가기/앞으로가기/동적라우팅/라우트가드 등이라고 생각해요 ㅎㅎ\n\n다만 지금 요구사항에서 라우트가드나 중첩 라우팅 같은건 이야기 해놓질 않기 때문에 고려하지 못했을 것 같네요..!\n\n---\n\n고생하셨습니다 지호님!',
      enrolledId: "686387e2c85f37c52555fc22",
    },
    {
      _id: "6868a343a8a052ad614543cd",
      result: "PASS",
      isBestPractice: false,
      name: "차현빈",
      badge: "화이트",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: ["PASS", "PASS", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/75",
        },
      ],
      feedback:
        "ㅋㅋㅋ 매니저님 피드백은 PR에 남겨놓을게요~\nPR을 확인해주세요!\n\n1주차 너무 고생 많으셨습니다!! 부디 주말엔 푹 쉬셨길...",
      enrolledId: "68678936c85f37c52506d1fc",
    },
    {
      _id: "6868a343a8a052ad614543cf",
      result: "PASS",
      isBestPractice: true,
      name: "윤영서",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/2",
        },
      ],
      feedback:
        "안녕하세요 영서님!!!\n이번 주에 제일 고생하신 영서님.... ㅠㅠ 정말 너무너무 감사합니다. 말로 다 표현하기가 어렵네요 ㅋㅋ\n\n> 배포를 진행하면서 다른분들을 도와드리고 gh-pages를 통한 spa 배포에 대한 이해가 높아진 것 같습니다...ㅎㅎ;; 이렇게 다양한 에러를 접하게 될 줄은...\n\n\"배포 오류, 어디까지 경험해봤니?\" 이런 주제로 하나 글을 작성해주셔도 좋겠네요 ㅋㅋ\n\n> 요컨데 지금은 카테고리와 상품을 동시에 불러야한다는 요구사항이 없고, 테스트 코드상에서 다음과 같이 상품은 findByText를 통해 찾고 카테고리는 getByText를 통해서 찾게되어 '동시에 불러야한다는'의미가 조금 모호하지 않나라는 생각이 들었습니다. 그리고 RTL의 내장함수들을 사용하는것이 아닌 querySelector를 사용하는 코드가 많았는데 테스트가 불안정하고, 디버깅도 어렵다는 생각이 들었습니다. 요 부분도 다음 기수에 반영이 되면 어떨까...하는 생각이 들었습니다 ㅎㅎ...\n\n저도 이번에 많이 느낀 부분인데요, 다음에는 아예 1주차에는 단위테스트를 없애버릴 생각입니다. 모호한 부분도 많고, 정확하게 테스트 하지 못하는 부분도 많아서요.\n좋은 의견 너무 감사합니다 영서님!\n\n> 사실 AI를 사용함에 있어서 그렇게까지 잘 사용하고있는지는 모르겠고, 좀 더 제가 처해있는 상황을 설명하려고 하면 말을 잘 알아듣는 느낌이었습니다. (요건 프롬프트 엔지니어링을 잘 몰라 그럴 수도 있겠습니다만) 빠르게 컴포넌트를 분리하는 과정에서 디자인등이 누락되는것들이 있었는데, 그 이전에 디자인을 누락하지 않고 그대로 분리해달라고 좀 더 자세히 명세를 하면 제가 의도한 바와 동일하게 작성해주는것 같았습니다.\n\n어떤 방식으로 명령했는지 기억나는게 있으면 같이 명시해주셔도 좋답니다!\n\n> 한계점이 있다면 전체적인 아키텍처 설계나 근본적인 문제 해결은 여전히 사람이 판단해야 했습니다. AI가 제안한 코드도 결국 테스트를 통해 검증하는 과정이 필요했습니다\n\n이에 대한 내용도 동의합니다 ㅎㅎ 다만 요즘엔 역으로, AI에게 테스트를 작성하게 하는 것 같네요 ㅋㅋ\n\n> 이렇게 로컬스토리지를 명시적으로 초기화하는경우에 어떻게하면 클라이언트에서도 상태가 비워짐을 알 수 있을까요?\n\n사실 이번에 저도 솔루션 만들면서 겪어던 문제인데요,\n\n제가 해결한 방법은, 값을 조회할 때 무조건 localStorage 를 통해 조회하도록 만들었어요. 근데.. 이게 좋은 방법이라는 생각은 안 들어요 ㅋㅋ\n\n정석은 storage 이벤트를 통해 관리하는 방법이 이라고 생각해요.\n\n성호 코치님의 아티클: https://blog.shiren.dev/ko/post/2023-04-18\n공식문서: https://developer.mozilla.org/en-US/docs/Web/API/Window/storage_event\n\n아마 react에서 storage를 관리할 때도 똑같은 문제를 겪는 경우가 많으리라 생각합니다 ㅋㅋ",
      enrolledId: "68623210c85f37c525712305",
    },
    {
      _id: "6868a343a8a052ad614543d1",
      result: "FAIL",
      isBestPractice: false,
      name: "김유현",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "FAIL",
        "FAIL",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/yuhyeon99/front_6th_chapter1-1",
        },
      ],
      feedback:
        '안녕하세요 유현님!\n\n다음에는 과제 제출하실 때 PR 링크를 올려주시면 좋을 것 같아요!\n지금은 저장소 링크를 올려주셨네요 ㅎㅎ\n\n---\n\n과제 진행해주신 내용 보니까 \n라우터 기능과 정렬, 장바구니 등의 기능이 누락되어있네요 ㅠㅠ\n그래도 끝까지 포기하지 않고 잘 진행해주셔서 감사해요!\n\n---\n\n> SPA 구조/라우터 설계가 더 깔끔하게 개선될 여지가 있는지\n\n저는 이럴 때 "요구사항"을 확장해서 생각해보면 좋다고 생각합니다!\n가령 지금은 유현님의 어플리케이션에 강하게 종속된 라우터인데요(pages 폴더에 있는 코드를 가져와 사용하고 있음),\n\n이걸 다른 사람이 만들어놓은 어플리케이션에 적용한다고 했을 때 정상적으로 동작하도록 만들 수 있는 방법을 고민해보시면 좋답니다!\n\n> 현재 구현된 옵저버 기반 상태 관리의 한계점과 개선 방안\n\n무척 세심하게 설계해주셨네요 ㅎㅎ\n이건 제가 선호하는 방식이긴 한데, observer와 상태를 분리해주는 방식이면 좋겠어요! 옵저버는 어디서는 쓰일 수 있는 개념이니까요. 라우터랑도 결합할 수 있고?\n\n그리고 notify를 할 때, 항상 notify를 할 것인지 아닌지에 대한 판단이 필요해요 ㅎㅎ\n가령 state가 변경된게 없는지 깊은 비교를 통해 검사하여, 실제로 변경된 경우에만 notify를 실행하는거죠.\n\n> 현재 테스트코드가 안전하게 작동하도록 설계된 구조인지에 대한 피드백\n\n프론트엔드에서 테스트가 안전하게 동작하기 위한 조건은 이벤트 관리라고 생각합니다. 이벤트를 잘 초기화 해준다거나, 이미 등록된 이벤트를 다시 등록하지 않도록 해준다거나?\n\n다만 이번 기본과제에서 제공하는 단위 테스트의 경우 제가 적절하게 작성하질 못한 것 같아요 ㅠㅠ\n그래서 코드의 문제라기보단 테스트의 문제가 많아서 발생했던 것들이 많았으리라 생각해요. ',
      enrolledId: "685f3badc85f37c5250804fa",
    },
    {
      _id: "6868a343a8a052ad614543d3",
      result: "PASS",
      isBestPractice: false,
      name: "이정우",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "FAIL",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/55",
        },
      ],
      feedback:
        '안녕하세요 이정우님, 수고하셨습니다. 이번 과제는 프레임워크 없이 SPA를 구현하면서 라이브러리와 프레임워크가 해결해온 문제들을 직접 경험해보는 의도를 가진 과제였어요. 특히 라우팅, 상태 관리, 컴포넌트 구조화 등의 핵심 개념들을 바닐라 자바스크립트로 구현하면서 깊이 있는 학습을 하셨기를 바랍니다.\n\n과제를 보면서 특히 폴더 구조를 역할에 맞게 체계적으로 정리하신 점이 인상적이었습니다. controllers, services, pages로 명확하게 분리하여 MVC 패턴에 가까운 구조를 만드셨네요. 또한 Router 클래스를 직접 구현하여 SPA 네비게이션을 처리하신 부분도 잘하셨습니다.\n\n아직은 데이터와 DOM 렌더링이 완전히 분리되지 않은 혼합된 형태가 보이네요. HomePage.js에서 HTML 문자열을 직접 반환하고, HomePageController에서 상태 변경 후 전체를 다시 렌더링하는 구조라거나 이벤트 처리시에 state는 값으로 변경하고 this.render()를 수동으로 실행하는 코드도 보이고, DOM 조작을 직접하는 코드도 종종 섞여있네요.\n\n이렇게 만들게 되면 작은 변경사항에도 큰 DOM 조작이 필요하고, 상태와 뷰의 동기화를 수동으로 관리해야 합니다. 이런 구조가 왜 개발을 어렵게 만드는지를 몸소 체험하는 소중한 경험이 되었을거에요.\n\n앞으로도 이런 low-level 구현 경험이 프레임워크를 더 깊이 이해하는 데 큰 도움이 될 거예요. 2주차도 화이팅입니다! :)\n\nps\n테스트 실패를 보니 **"총 ㅇㅇ개의 상품"** 텍스트를 찾지 못하는 문제가 반복적으로 발생하고 있네요. HomePage.js에서 `<span>총 </span><span>${total}</span><span>개의 상품</span>` 형태로 분리되어 있는데, 테스트가 이를 하나의 텍스트로 인식하지 못하는 것 같습니다. `총 ${total}개의 상품`처럼 하나의 문자열로 만들어보세요.\n',
      enrolledId: "685e5710c85f37c5258cd6b6",
    },
    {
      _id: "6868a343a8a052ad614543d5",
      result: "PASS",
      isBestPractice: false,
      name: "한재원",
      badge: "화이트",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/30",
        },
      ],
      feedback:
        "안녕하세요 한재원님, 수고하셨습니다. 이번 과제는 프레임워크 없이 순수 JavaScript로 SPA를 구현하면서 프레임워크가 내부적으로 처리해주는 복잡한 작업들을 직접 경험해보는 것이 목표였습니다. 라우팅, 상태 관리, 렌더링 최적화 등을 직접 구현하면서 React나 Vue 같은 프레임워크의 가치를 더 깊이 이해하셨기를 바랍니다.\n\n특히 이벤트 위임 패턴을 활용하여 동적으로 생성되는 요소들의 이벤트를 효율적으로 처리하신 점과 URL 상태 관리를 통해 새로고침 시에도 상태가 유지되도록 구현하신 점이 잘하셨습니다. Cart.js에서 클래스 기반 싱글톤 패턴을 사용하여 장바구니 상태를 관리한 것도 좋은 접근이었습니다.\n\n아직 컴포넌트 개념을 도입하지 않아서 지금 모든 화면이 main.js에 1500줄이 넘는 코드가 집중되어 있는 점은 개선이 필요하겠지요. 아마 스스로도 답답했을텐데 코드의 크키가 너무 크다면 코드를 잘게 분리를 하는 연습도 해보시면 좋겠습니다.\n\n아무래도 라우터의 책임과 컴포넌트의 책임이 하나의 코드에 다 모여있다보니 코드가 커질 수 밖에 없으므로 단일책임의 원칙은 항상 기억해보면 좋겠습니다.\n\n이제 새롭게 시작하는데 앞으로도 함께 성장해나가길 바랍니다. 화이팅입니다!\n\n다음은 질문 주신 내용에 대한 구체적인 답변입니다.\n\n---\n\nQ) 이벤트 핸들링 로직 분리와 유지보수성 개선 방법\n\n=> 현재의 렌더링 구조가 html 방식이다보니 어쩔 수 없이 선택자 방식으로 만들어져야 하겠지만 state.js / events.js / render.js / router.js / main.js 이런식으로 역할별 분리만으로는 다 달성하기가 어렵습니다.\n\n위와 같이 수평적으로 잘라내어 계층을 만들었다면 이제 각각의 목적에 따라 해당 계층을 쌓아서 만든 모듈적 분리가 필요하죠. 지금 main.js가 거대해진 이유는 레이어는 분리를 했지만 모듈적 분리가 되지 못해서 입니다.\n\nProductDetail.js를 보면 그러한 모듈적 분리가 되어 있는데 라우터의 분기의 책임과 라우터의 렌더링의 책임도 분리하면서 이거 하나만으로도 가치가 있는 코드 특정 코드가 다 지워져도 괜찮은 코드등을 생각하면서 모듈적 분리의 생각으로 나아가보면 좋겠습니다.\n\n\nQ) state 변경 + render() + updateURL 반복 패턴 개선\n\n=> 상태 변경을 중앙화하는 setState 함수를 만들어 사용하면 좋습니다:\n\n```javascript\nfunction setState(updates) {\n  Object.assign(state, updates);\n  updateURL();\n  render();\n}\n\n// 사용 예\nsetState({ sort: newSort, page: 1, loading: true });\n```\n\nQ) 클래스 vs 함수 기반 모듈 구성\n\n=> js는 둘다 할 수 있는 멀티 패러다임의 언어죠. 두 방법은 모두 일장일단이 있습니다. 아무래도 클래스 기반의 언어가 문법적으로 더 복잡함을 요구하므로 대개 클래스 보다는 함수 기반을 우선적으로 선호하게 됩니다.\n\n=> 그렇지만 인스턴스의 생성이 많고 타입의 상속과 확장을 중심으로 해야하는 구성이라면 ex) Node -> Element -> HTMLElement -> HTMLDivElement 등 이러한 경우는 함수형 프로그래밍 방법으로 접근하기 어려운 방식이므로 객체지향을 써야만 합니다.\n\n=> 보편적으로 함수형 방식을 근간으로 하나 타입추론이 어렵다거나 다양한 타입이 필요한 경우 ex) figma API등 클래스로 많이 활용되니 각 특징을 잘 알고 써보시면 좋겠네요.\n\n=> 어쩄든 본인의 체험과 경험이 중요하니 이것 저것 다양하게 시도하면서 그 느낌을 이해보길 바랍니다.\n\n```javascript\n// 함수형 방식\nexport const createCart = () => {\n  let items = [];\n  \n  return {\n    addItem: (item) => { items.push(item); },\n    getItems: () => [...items],\n    // ...\n  };\n};\n```\n\n근데 사실은 팀의 코딩 컨벤션과 프로젝트 특성에 따라 선택하시면 됩니다. ㅋㅋ\n\n수고하셨습니다. 2주차도 화이팅입니다! :)",
      enrolledId: "685e1e58c85f37c52567068f",
    },
    {
      _id: "6868a343a8a052ad614543d7",
      result: "FAIL",
      isBestPractice: false,
      name: "정용준",
      badge: "화이트",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "FAIL",
        "FAIL",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/34",
        },
      ],
      feedback:
        '안녕하세요 용준님~\n1주차 과제 잘 진행해주셨네요!! 너무 고생 많으셨습니다 ㅠㅠ\n\n다만 테스트를 통과하지 못해서, 과제는 불합격으로 남겨놓을게요..!\n\n---\n\n>   View 또한 외부의 영역이고 View와 Service를 이어주는 Adapter 계층이 필요한 것 같습니다. 이 Adapter를 만들 때 사용할 로직이 상태나 이벤트 리스너 바인딩처럼 보이는데 맞을까요?? 이벤트 바인딩과 상태가 저 구조에서 어떻게 들어가야할지 잘 모르겠습니다.\n\n말씀하시는 Adapter가 아마 MVC 로 따지면 Controller 같은 계층일 것 같네요 ㅎㅎ\n리액트는 이 영역을 ViewModel 라고 정의하고 있답니다. \n\nhttps://junilhwang.github.io/TIL/CodeSpitz/Object-Oriented-Javascript/02-MVVM/\n\n저도 이런 글을 작성했었는데, 한 번 참고해주세요!\n\n> 아직 순수 js로 프론트엔드를 작성할 때 계층을 어떻게 나눌지, 각 계층에 책임과 역할은 어느정도로 부여할건지가 명확하게 머리 속에 잡히지 않네요. 프로덕트와 팀의 상황에 따라 달라지는 것이고 지금 상황에서는 오버엔지니어링이지만 비즈니스, 엔티티와 외부를 분리하고 객체지향적으로 프론트엔드를 작성한다는 것을 알아보고 싶어 고민을 남겨봅니다.\n\nhttps://junilhwang.github.io/TIL/Javascript/Design/Vanilla-JS-Server-Side-Rendering/\n\n제가 이전에 이런 글을 작성했는데요, SSR을 위해 어떤 방식으로 코드를 설계할 수 있는지에 대한 글입니다. SSR에 대해 다루는 글이지만 설계에 대한 측면도 다루고 있기 때문에 참고해보셔도 좋을 것 같아요!\n\n저는 "런타임"을 기반으로 생각했는데요,\n브라우저에서만 실행 가능한 코드와, \n브라우저에 종속적이지 않은 코드로 구분해서 사용한답니다.\n\n이벤트와 돔은 브라우저에 종속적이고\n데이터와 비즈니스 로직은 브라우저에 종속적이지 않겠죠?\n이 사이에 API 호출 같은것도 있을 것이고...\n\n이를 토대로 구성해보시면 좋을 것 같아요!',
      enrolledId: "685e1202c85f37c525604396",
    },
    {
      _id: "6868a343a8a052ad614543d9",
      result: "PASS",
      isBestPractice: false,
      name: "여진석",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "FAIL",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/50",
        },
      ],
      feedback:
        "안녕하세요 여진석님, 수고하셨습니다. 이번 과제는 프레임워크 없이 SPA의 핵심 기능들을 직접 구현하면서 React가 해결해온 문제들을 깊이 이해하는 것이 목표였습니다. 일부 코드들은 TypeScript로 마이그레이션하면서 완성도 높은 구조를 만들어주신 점이 인상적이네요.\n\ncommon쪽 설계구조를 참 탄탄하게 잘 고민해서 구성한 것 같아요. Component 추상 클래스의 생명주기 관리와 EventDelegator의 타입 안전한 이벤트 위임 구현이 잘 되어있습니다. MVC 구조로 관심사를 분리하고 옵저버 패턴으로 상태 관리를 구현한 접근도 좋았습니다.\n\n아쉬운 점이 있다면 구조는 잘 잡아두었는데 상태 변경 -> 렌더링 -> 이벤트 연동 -> 이벤트 -> 상태 변경 ... 등의 사이클이 내재화되어 동작하지 못하고 계층을 넘나들며 호출을 하고 있는 부분입니다.\n\n그리고 코드 전반적으로 이벤트를 연동하는 방식이나 상태를 업데이트를 하는 방법,  DOM을 사용하는 방식들에서 일관성이 부족하다 느껴졌습니다. \n\n1주차인만큼 그렇게 여러가지 시도를 하게 되면서 이런 방법은 이런게 좋구나 혹은 이건 분명 여기에 안 써도 될 코드인걸 알겠는데 어떻게 하면 좋을까? 하는 고민들로 하여금 성장의 발판이 되어 주었기를 바랍니다.\n\n앞으로도 함께 성장해나가요. 2주차도 화이팅입니다! :)\n\n---\n\nQ) MVC 구조가 잘 구성되었는지\n=> 전반적으로 잘 구성되었습니다. Store(Model), Component(View), Controller(API 핸들링) 분리가 명확합니다. 다만 시간 부족으로 일관성을 지키지 못하고 구조가 지켜지지 않거나 DOM이 추가가 된다거나 render나 subsctibe를 수동으로 작업하고 있는 부분들이 아쉽습니다.\n\n\nQ) 옵저버 패턴 구현\n=> SearchParams → Controller → Store → Component 흐름이 잘 구성되어 있습니다. 단방향 데이터 흐름이 명확해서 디버깅과 유지보수가 용이할 것 같네요. 다만 구독 해제 로직이 누락되기 쉬운 구조라 메모리 누수 위험이 있어 보입니다.\n\n**Q) mount/unmount 보일러플레이트 개선**\n=> 컴포넌트 트리 구조를 만들어 자식 컴포넌트를 자동으로 관리하면 어떨까요? 부모 컴포넌트가 mount/unmount될 때 자식들도 자동으로 처리되도록 하면 보일러플레이트를 크게 줄일 수 있습니다.\n\n```javascript\nabstract class Component {\n  children: Component[] = [];\n  \n  addChild(child: Component) {\n    this.children.push(child);\n  }\n  \n  mount(target: HTMLElement) {\n    // ...기존 로직\n    this.children.forEach(child => child.mount(this.el));\n  }\n}\n```\n\n**Q) 구현 방식의 완성도**\n=> 핵심 개념(라우터, 컴포넌트, 이벤트 위임)은 80% 정도 잘 구현되었습니다. 심화 과제 실패는 주로 라우터의 쿼리 파라미터 처리와 새로고침 시 상태 복원 로직 때문으로 보입니다. History API 사용 시 `pushState`와 `replaceState`의 차이를 명확히 하고, URL 파싱/생성 로직을 더 견고하게 만들면 해결될 것 같습니다.",
      enrolledId: "685aa4a8c85f37c52555e223",
    },
    {
      _id: "6868a343a8a052ad614543db",
      result: "FAIL",
      isBestPractice: false,
      name: "정건휘",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "FAIL",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/65",
        },
      ],
      feedback:
        "안녕하세요 정건휘님, 수고하셨습니다. 이번 과제는 프레임워크 없이 순수 JavaScript로 SPA를 구현하며, 상태 관리와 라우팅의 본질을 이해하는 것이 목표였습니다. 바닐라 JS 개발이 익숙하지 않으셨다고 하셨는데, 이런 경험을 통해 프레임워크가 해결하는 문제들을 더 깊이 이해하셨기를 바랍니다.\n\n코드를 살펴보니 특히 라우터 구현(`src/routes/router.js`)이 인상적이네요. 전반적인 구조나 설계 측면에서 상당히 모던하게 잘 구현이 된것 같아 좋습니다. `popstate` 이벤트 처리와 `navigate` 메서드 구현이 체계적이고, production 환경을 고려한 BASE_PATH 처리도 잘 되어있네요. 서비스 레이어를 분리한 아키텍처도 좋은 접근입니다.\n\n코드 전반적으로 폴더 구조나 코드의 폴더구조면에서 실제 역할과 계층구조가 잘 못지켜지고 있어요. utils인데 events-handlers에서 주요 비즈니스 로직을 처리한다거나 라우터가 DOM을 조작하고 있다거나 등등이요.\n\nAI를 이용해서 검증을 할때 이러한 역할과 구조적인 측면으로 많이 물어보고 작성을 해보시기를 권해드립니다\n\n또한 DOM을 직접 건들지 않고 모델과 렌더링을 분리해달라는 조건을 넣어가면서 AI에게 어떻게 하는지를 배워가며 익혀가 보면 더 좋을 것같네요.\n\n---\n\nQ) userEvent.click과 element.click()의 차이는?\n\n=> `userEvent.click()`은 테스트 도구에서 실제 사용자의 클릭을 더 정확히 시뮬레이션합니다. 마우스 이벤트(mousedown, mouseup, click) 순서대로 발생시키고, 포커스 이동, disabled 상태 체크 등을 처리합니다. 반면 `element.click()`은 단순히 click 이벤트를 호출시키는 것이죠. 다른 이유들로 하여금 click이 발생되지 않더라도 강제로 함수 호출을 시킨거라고 생각해주세요.\n\n이번 테스트에는 실제클릭이 동작하지 않을 이유가 없기에 함수호출이나 실제 클릭이나 다를게 없기 때문입니다. 하지만 실제 사용자 인터랙션을 정확히 테스트하려면 `userEvent`를 사용하는 것이 좋습니다.\n\n수고하셨습니다. 2주차도 화이팅입니다! :)",
      enrolledId: "6859f165c85f37c525cd8f44",
    },
    {
      _id: "6868a344a8a052ad614543dd",
      result: "PASS",
      isBestPractice: false,
      name: "현지수",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/51",
        },
      ],
      feedback:
        "지수님 고생하셨어요~\n상태관리 설계에 있어서 특히 잘 고민해주신 것 같은데요.\n과제에서 기대했던 여러가지 학습 부분을 잘 고민해주셨던 것 같아서 좋네요.\n\n질문 주신거 답변을 드려볼게요.\n\n> 현재 Redux 패턴을 모방해서 Store-Reducer-Action 구조로 상태관리를 구현했습니다. 이런 방식으로 구현한 것이 바닐라 JavaScript 환경에서 적절한 선택이었는지 궁금합니다. 특히 매번 전체 렌더링이 발생하는 부분이 성능상 문제가 될 것 같아 고민입니다.\n\n맞아요! 지금의 단계에서는 사실 브라우저 성능으로 충분할 것 같지만,, 결국 상태를 바라보는 해당 지점에 대해서만 명확하게 DOM이 업데이트 되는 로직이 필요하게 될 것 같아요. 이런 로직들을 실수 없이 빠르게 제어하기 위해 리액트에서는 명확한 구조가 있는데요! 어떤 구조가 있는지 찾아보고 한번 적용해보는 것도 큰 공부가 될 것 같아요. \n\n> 현재 렌더링 시마다 이벤트 리스너를 재등록하는 구조로 되어 있습니다. 이 방식이 메모리 누수를 유발할 수 있다고 생각되는데, 바닐라 JavaScript 환경에서는 어떤 식으로 이벤트 생명주기를 관리하는 것이 좋을까요?\n\n넵 좋은 고민이네요! 위임패턴을 통해 구현을 하고 있지만, 아직 좀 처리가 필요한게 필요한것 같아요 ㅎㅎ 클로저로 참조를 물고 있으면 해제가 되지 않는 문제가 발생할 수 있고, 중복 이벤트가 등록되거나 할 수 있는 구조인것 같아요. 별도의 이벤트 생명주기를 관리하는 것들 보다는 WeakRef 같은것들을 활용해서 더 이상 쓸모가 없어지면 명시적이게 참조를 정리한다! 라고 생각하고 바라봐도 충분할 것 같아요.\n\n> JavaScript로 SPA를 구현할 때 실무에서 자주 사용하는 패턴이나 베스트 프랙티스가 있는지 궁금합니다!\n\n지금의 방식과 대부분 유사한 것 같아요! 관통하는 공통 컴포넌트로 로직을 모으고 렌더링 로직과 라이프사이클 등을 관리하는 거죠. 어떻게 보면 베스트 프랙티스가 리액트와 뷰가 될 수 있지 않을까요? ㅎㅎ \n\n내가 알고 있는 지식의 범위를 넘어서는 추상화나 최적화가 필요할 때는 AI한테 물어보는 것도 방법일 수 있겠지만, 제 개인적으로는 결국 비슷한 문제를 풀고있는 다른 라이브러리를 벤치마킹 하는게 가장 쉬운 방법인것 같아요. \n라이브러리 구현체들을 보면 내가 해야 하는 고민들이 미리 다 이뤄져 있다보니 (그것도 훨씬 더 복잡한 수준으로) 이런 추상화, 구현이 필요하겠구나 쉽게 알아차릴수 있는거죠. 실제 구현도 확인할 수 있고요.\n지금 과제에 있어서는 상태 관리에 있어서는 가벼운 반응형 상태 라이브러리를 참고하거나 (jotai나 zustand가 될 수 있고, 구현을 가볍게 한 바닐라 자바스크립트도 있죠!) 라우터에 대해서는 말해주신 react-router-dom나 tanstack router를 참고해 구현하기도 하구요. \n\n각각의 주제들이 명확하게 나눠지면 Pubsub 패턴이라던지, 이벤트 버스 패턴이라던지 모듈 패턴이라던지 구현에 대한 패턴을 고민하게 될 수 있지 않을까 싶어요~~\n\n> 현재 코드가 많이 꼬여있고 리팩토링을 진행하고 싶은데, 어떤 순서로 진행하는게 좋을까요?\n\n이 과제 뿐만 아니라 앞으로 개발을 진행해가는 방향에도 동일한 것 같은데요!\n우선은 리팩토링이라는 것의 핵심 전제로써는 작은 범위의 수정 -> 명확한 검증이 반복되어야 하죠! 전면적인 재설계 보다는 지금 현재의 구조에서 맘에 들지 않는 부분에 대해서 개선 방향을 명확하게 잡고 점진적으로 개선해나가는게 실무 관점이든 내 개발 연습 관점이든 좋지 않을까 싶어요! \n\n고생하셨고 다음 주도 화이팅입니다!",
      enrolledId: "68542193851b4a7da8a3a270",
    },
    {
      _id: "6868a344a8a052ad614543df",
      result: "PASS",
      isBestPractice: false,
      name: "장희진",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/68",
        },
      ],
      feedback:
        '안녕하세요 희진님!\n1주차 과제 잘 진행해주셨네요!! 너무 고생 많으셨습니다 ㅠㅠ\n\n> 특히 테스트 코드 수정이 여러 번 필요했고, 한 테스트가 다른 테스트에도 영향을 주는 문제가 발생해 혼란스러웠습니다. 이런 점에 대한 사전 안내나 테스트 격리 방법에 대한 가이드가 있으면 좋겠습니다.\n\n이 부분은 저도 많이 느껴서요. 혼란을 드려 죄송합니다..! 나머지 2~3주차 과제는 이런 일이 없도록 주의해볼게요..!\n\n> 현재 정규표현식을 활용한 라우팅 매칭 방식이 간단한 경로에는 적합하지만, 복잡한 동적 라우팅(예: 쿼리파라미터, 중첩 라우트 등)에도 확장 가능할지 궁금합니다.\n\n그럼요 ㅎㅎ 충분히 가능하답니다! 사실 지금 코드를 그대로 사용한다면 어렵겠죠..? 코드는 수정해야할 것 같아요.\n특히 중첩 라우터의 경우 지금과 같은 구조를 그대로 사용하긴 어렵고, 라우터가 다시 라우터를 만드는? 그런 과정이 필요해요.\n라우터 하위에 서브 라우터 같은게 있는거죠 ㅎㅎ\n\n쿼리 파라미터는 쉽게 다룰 수 있을 것 같아요! 이건 지금 라우터랑은 딱히 관련 없고.. 그냥 쿼리 파라미터에 대한 관리 시스템을 추가해주면 된답니다.\n\n> window.onpopstate 이벤트 핸들러로 라우트 재실행을 구현했는데, 향후 복잡한 상태 관리가 필요할 때 더 좋은 설계 방안이나 패턴이 있을지 알고 싶습니다.\n\n"향후 복잡한 상태관리"의 상황을 먼저 가정해보면 좋겠죠?\n지금은 뒤로가기/앞으로가기 그리고 직접적으로 실행하기 등에 대한 대응이 되어있는데요,\n이 외에 또 무엇이 있을지 고민해보시면 좋겠어요 ㅎㅎ\n\n> 전반적으로 이 라우터 구조가 규모가 커졌을 때 유지보수나 기능 확장에 유리한지, 아니면 리팩토링이 필요할지 조언을 받고 싶습니다\n\n위에 언급한 내용들을 종합해보시면 좋겠어요.\n이럴 때 희진님께선 "확장에 유리한 이유" 등을 다루는게 중요해요. 이를 기반으로 이야기를 전개해야 저희가 더 디테일한 소통이 가능하답니다.\n\n일단 유지보수 상황을 먼저 가정해주세요.\n어떤 상황에 대응을 할 수 있을지 랄까..\n엣지케이스를 정의해보는거죠.\n이 과정 없이 "대응 가능해?" 라고 하는건 이야기 하기에 어렵다고 생각해요.',
      enrolledId: "6853f85d851b4a7da883412b",
    },
    {
      _id: "6868a344a8a052ad614543e1",
      result: "PASS",
      isBestPractice: false,
      name: "김휘린",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/13",
        },
      ],
      feedback:
        "휘린님 수고하셨습니다!\n\n* 저는 작은 컴포넌트 단위에서 해당 컴포넌트만 다시 렌더링을 시킬 수 있는지 궁금합니다.\n\n지금은 렌더링을 컨트롤할 수 있는 방법이 없기때문에 부분렌더링을 할 수 없는 것이 맞습니다.\n향후 과제를 진행하면서는 좀 더 리액트에 가까운 과제로 진행되는데요 그때 해결될 수 있을 것 같아욥!\n\n* 제가 현재 이해한 바로는 리액트는 가상돔이 있어서 돔트리를 비교해서 반영하지만, 가상돔이 없는 제 코드에서는 그게 불가능 하다고 생각하는데, 혹시 가상돔이 없어도 구현할만한 방법이 있는지 궁금합니다.\n\n현재 제출해주신 과제를 기반으로는 불가능하고요.\n가상돔이 없이 선언적으로 구현한다고 하면 컴포넌트가 개별적으로 렌더링을 할 수 있는 방법이 일단 마련되어야할 것 같아요.\n즉 컴포넌트가 렌더링되면 부분적으로 업데이트가 가능해야겠죠\n그러려면 컴포넌트가 어떤 엘리먼트에 속해있는지를 알아야합니다. 현재로는 고려할 것이 많네요 ㅎㅎ\n만약 그런 구조가 만들어졌다면\n만들어주신 스토어를 조금 개선해서\n특정 관심사가 업데이트될때 해당 컴포넌트를 재실행하는 옵저버패턴을 구현하면 될 것 같아요~\n어차피 과제가 진행되면서 해당부분들을 배워나갈 것이라서 지금은 일단 이정도만 생각하셔도 되지 않을까 싶습니다 :)\n\n나중에 추가로 확인하시기 좋게 말씀드리면 react는 해당문제를 리컨실레이션(vdom)을 활용해서 해결했고요 뷰는 반응형 시스템을 활용해서 해결했습니다!\n",
      enrolledId: "6853a924851b4a7da8357a5c",
    },
    {
      _id: "6868a344a8a052ad614543e3",
      result: "PASS",
      isBestPractice: false,
      name: "김효진",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/53",
        },
      ],
      feedback:
        "안녕하세요 김효진님, 수고하셨습니다. 이번 과제는 프레임워크 없이 순수 JavaScript로 SPA를 구현하면서 현대 프레임워크들이 해결하는 문제들을 직접 경험해보는 것이 목표였습니다. 옵저버 패턴을 적용한 상태 관리와 라우터 구현, 이벤트 핸들러 분리 등 중요한 개념들을 잘 적용해주셨네요.\n\n특히 `src/store/productStore.js`에서 구현한 옵저버 패턴 기반 스토어가 인상적입니다. \n\nconst subscribe = (callback) => {\n  subscribers.push(callback);\n  return () => {\n    const idx = subscribers.indexOf(callback);\n    if (idx > -1) subscribers.splice(idx, 1);\n  };\n};\n```\n\n특히나 return값을 통해서 구독 해제 함수를 반환하는 패턴으로 메모리 누수를 방지한 점이 좋습니다.\n\n아쉽지만 심화과정이 기대요건을 충족하지 못해서 코드의 완성도와 무관하게 심화 과정은 불합격을 드리도록 하겠습니다. 개발자에게 있어서 좋은 코드와 구조는 중요하지만 그 이유가 버그가 없이 요구사항을 만족하는 가치를 전달하는데 있는 것인만큼 우선 완성을 제일 먼저 생각해주기를 발바니다.\n\nAI 도구를 활용하면서도 핵심 개념을 이해하려 노력하신 점이 좋습니다. 다음 과제에서는 꼭 완성부터 하고 나서 테스트를 먼저 확인하며 진행하시면 더 좋은 결과를 얻으실 수 있을 것입니다.\n\n2주차도 화이팅입니다! 😊",
      enrolledId: "6852955b851b4a7da86f237b",
    },
    {
      _id: "6868a344a8a052ad614543e5",
      result: "PASS",
      isBestPractice: true,
      name: "이지훈",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/58",
        },
      ],
      feedback:
        '안녕하세요 지훈님!\n1주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 바닐라 자바스크립트로 컴포넌트를 작성한 예시들을 보면 이벤트리스너를 document가 아닌 컴포넌트 요소에 할당하는 예시를 많이 볼 수 있었다.\n\n리액트의 경우 정확히는 root component 에 등록하고 있답니다.\n대신 컴포넌트가 언마운트 될 때 현재 등록된 이벤트를 해제하는? 그런 로직을 수행하고 있을꺼에요!\n\n> queueMicrotask 를 사용하는 것을 추천 받았는데, 알맞게 사용되고 있는지 궁금합니다.\n\n지금은 그냥 실행을 지연할 뿐 모아서 처리되거나 하고 있진 않은 것 같아요!\n즉, queueMicrotask의 실행이 시작될 때 이후에 실행될 함수는 실행하지 않는 방식으로 처리되어야 하지 않을까요!? 이건 솔루션을 참고해보면 좋을 것 같아요!\n\n> observable 내부 observerMap 의 메모리를 최적화 할 수 있는 더 좋은 방법이 있는지 궁긍합니다.\n\n이미지 잘 최적화 해주신 것 같아요 ㅎㅎ\n다만 어차피 map에서 제거하면 set은 자연스럽게 제거되지 않을까!? 라고 추측이 되네요.\n\n아니면 Set 대신에 WeakSet을 사용한다거나!?\nhttps://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/WeakSet\n\n> src/pages/products.js 를 진입점으로 홈 화면 컴포넌트들을 보았을 때 코치님이 해당 src/core/Component.js 컴포넌트를 사용해야 한다면 어떤 점을 개선하고 싶으신가요?\n\n너무 포괄적인 질문이라서요, 지훈님이 문제라고 생각하는 지점을 이야기 해주시면 제가 이에 대한 답변은 드릴 수 있을 것 같아요 ㅎㅎ\n\nhttps://github.com/JunilHwang/black-coffee-study-lv3/blob/main/step3/frontend/src/_core/Component.ts\nhttps://github.com/JunilHwang/black-coffee-study-lv3/blob/main/step3/frontend/src/pages/LinesPage.ts\n\n저는 옛날에 이런식으로 만들었답니다!\n지금은 클래스를 쓰지 않아도 충분히 잘 추상화 할 수 있다고 생각해서 아예 클래스를 쓰고 있지 않아요.\n\nComponent가 쓰이는 모습을 토대로 판단해보면 지금 지훈님께서 만들어주신 모습이 더 직관적이라고 생각해요!\n\n> 생명주기를 관리할 때 꼼꼼하게 봐야할 부분은 어떤게 있을까요?\n\n이 또한 너무 포괄적인 질문이라... 지훈님의 생각을 먼저 이야기 해주시면 좋았을 것 같아요 ㅎㅎ\n저는 "정확하게 실행되는 것"이 무엇보다 중요하다고 생각합니다.\nmount 는 정말 마운트를 할 때 실행이 되는가 같은..?\n어떤 생명주기를 만들 것이고 각각의 생명주기마다 어떤 일이 일어나는지 명시하는 문서 같은게 일단 있어야 한다고 생각합니다.\n\n그리고 특히 컴포넌트가 사라지게 되면 없애야할 정보를 꼼꼼하게 없애는 과정이 필요하겠죠?\n이벤트나 상태 같은 것들이요!',
      enrolledId: "6852337e851b4a7da82175ff",
    },
    {
      _id: "6868a344a8a052ad614543e7",
      result: "FAIL",
      isBestPractice: false,
      name: "정민기",
      badge: "화이트",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "FAIL",
        "FAIL",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "FAIL",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/33",
        },
      ],
      feedback:
        "안녕하세요 정민기님, 수고하셨습니다. 이번 과제는 프레임워크 없이 순수 JavaScript로 SPA를 구현하면서 상태 관리, 라우팅, 컴포넌트 시스템의 핵심 개념을 직접 경험해보는 것이 목표였습니다. \n\n코드를 보니 컴포넌트 분리와 라우터 구현을 시도해보려고 한건 보이지만 현재의 코드만 가지고는 채점도 피드백도 드리기가 어렵네요.\n\n비록 이번에는 통과하지 못했지만, 바닐라 JS로 SPA를 만들어보신 경험 자체가 큰 자산이 될 것입니다. 2주차도 화이팅입니다! 😊\n\n---\n\nQ) state와 handler를 어떤식으로 나눠서 관리를 해야할지\n\n=> 우선 state를 변경하는 함수를 만들고 그 함수에서 값이 변경이 되면 화면을 업데이트를 하는 가장 단순한 경로를 만들어 봅시다. 그리고 모든 상태 변경시 화면을 업데이트하는 로직을 만들고 값을 변경시켜보는 로직까지 먼저 만들어봐요.\n\n위 멘트를 기준으로 AI와 함께 조금 놀아보시면 무슨 말인지 감을 잡아가기를 바래요.\n\n\nQ) 컴포넌트 단위를 어떤식으로 잘게 쪼개서 관리를 해야할지\n\n=> 컴포넌트는 상태 -> 화면 -> 이벤트 -> 상태 변화 -> 화면 변화 라는 사이클을 돌게 되어 있는데 우선 필요한 화면을 먼저 만들고 화면에서 변해야 하는 데이터를 상태로 분리하고 사용자가 할 수 있는 행동을 이벤트로 만드는 순서대로  진행해보면 됩니다.\n\n우선은 화면을 기준으로 먼저 생각하고 나중에는 상태(데이터)를 기준으로 생각할 수 있도록 발전할 수 있습니다.\n\n과제와 질문이 너무 피상적이어서 답변을 이정도 밖에 못하겠네요. 다음 번 과제는 훨씬 더 구체적인 상황에 대한 질문이길 기대할게요. 수고하셨습니다.",
      enrolledId: "684cd08584ed0f3459eb21b9",
    },
    {
      _id: "6868a344a8a052ad614543e9",
      result: "FAIL",
      isBestPractice: false,
      name: "강병준",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "FAIL",
        "FAIL",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/76",
        },
      ],
      feedback:
        "안녕하세요 강병준님, 제출해주신 과제를 검토했습니다. \n\n이번 과제는 프레임워크 없이 순수 JavaScript로 SPA를 구현하면서, 현대 프레임워크들이 해결하고자 하는 문제들을 직접 경험해보는 것이 목적이었습니다. 상태 관리, 라우팅, 렌더링 최적화 등의 핵심 개념을 직접 구현하면서 깊이 있는 학습이 이루어지길 기대했습니다.\n\n이번 과제의 코드 구현이 이루어지지 않아 아쉽게도 이번 과제는 불합격처리됩니다.\n\n혹시 기술적인 어려움이나 시간 부족 등의 문제가 있으셨다면, 다음 과제 진행 시에는 미리 질문 채널을 통해 도움을 요청하시는 것을 권장드립니다. 또한 부분적으로라도 구현한 내용이 있다면 제출하시는 것이 학습 측면에서 더 도움이 될 것입니다.\n\n다음 기회에는 꼭 완성된 과제를 만나뵐 수 있기를 기대합니다. 화이팅입니다!",
      enrolledId: "684abe3784ed0f345985eaaf",
    },
    {
      _id: "6868a344a8a052ad614543eb",
      result: "FAIL",
      isBestPractice: false,
      name: "박상수",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "FAIL",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "FAIL",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/66",
        },
      ],
      feedback:
        "안녕하세요 상수님! 1주차 과제 잘 진행해주셨네요 ㅎㅎ\n다만 배포는 해주셨는데, 배포된 페이지가 정상적으로 동작하지 않고 있어요..!\n배포 후 정상동작까지가 심화과제의 채점 범위이다보니.. 이 부분은 아쉽지만 불합격으로 남겨놓겠습니다 ㅠㅠ\n\n그리고 과제 제출 후에도 PR의 내용은 수정해도 무방하기 때문에,\n꼭 PR에 질문이 있으면 남겨주세요!\n\n고생하셨씁니다~",
      enrolledId: "684aad6b84ed0f3459763b8d",
    },
    {
      _id: "6868a344a8a052ad614543ed",
      result: "FAIL",
      isBestPractice: false,
      name: "조영민",
      badge: "화이트",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "FAIL",
        "FAIL",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/45",
        },
      ],
      feedback:
        '안녕하세요 영민님!\n1주차 과제 잘 진힝해주셨군요! 고생하셨습니다 ㅎㅎ\n다만 과제를 아직 다 마무리하질 못했군요 ㅠㅠ \n2주차는 잘 마무리할 수 있기를 바랍니다!!\n\n---\n\n현재 특별한 질문이 없는 상태군요..!\n\n> 초기 설계해놓은 코드에 문제가 있으면 기능 구현 중에 코드를 엎어버려서 시간이 오래걸리는데 일단 기능 구현부터 끝내야할지 이게 맞는지 항상 고민임\n\n저는 기능 구현부터 끝내야 한다고 생각해요.\n저희가 실무에서 만들어가는 제품도 어쨌든 "완성된 상태"가 중요하고,\n완성된 상태를 유지하면서 리팩토링을 하는게 안전한 방법이라고 생각합니다.',
      enrolledId: "684a92b384ed0f34596009d9",
    },
    {
      _id: "6868a344a8a052ad614543ef",
      result: "PASS",
      isBestPractice: false,
      name: "여찬규",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/20",
        },
      ],
      feedback:
        "안녕하세요 찬규님! 1주차 과제 잘 진행해주셨네요 ㅎㅎ 너무 고생하셨어요!\n\n> 회사 제품 특성상 요구사항이 빠르게 변경되기 때문에 실무에서 사용하기는 다소 어려울 것 같다는 생각도 들지만, 테스트라는 것 자체가 어떻게 보면 제품의 히스토리와 경험을 쌓는 과정이기 때문에 시도해볼 만하다고 생각합니다.\n\n요구사항이 빠르게 변할수록 오히려 테스트가 더 필요하다고 생각합니다 ㅎㅎ\n이에 대한 부분은 아마 7주차~8주차 때 알게되리라 생각해요.\n꼭 지금처럼 단위테스트 방식으로 작성하지 않아도 e2e 테스트 방식으로 작성되어있다면 요구사항에도 더 빠르게 더 정확하게 대응할 수 있다고 생각해요.\n\nplaywright autogen 같은 기능을 이용해보시면 알 수 있답니다 ㅋㅋ\n\n> 빠르게 변경되는 요구사항이 문제라면 런타임이나 완전한 서비스 비즈니스 로직을 테스트하는 것이 아닌, 코어 레벨의 코드만 테스트해봐도 충분히 의미가 있을 것 같아요.\n\n이에해 완전히 동의합니다! 코어로직에 대한 테스트는 필수라고 생각해요!\n\n> 이벤트 관리 관련\n\n바닐라로 작성한다고 했을 때, 사실 지금이 최선의 방식이지 않을까? 라는 생각이 들어요 ㅎㅎ\n\n다만 이벤트 위임에 대한 코드를 추상화해서 관리하면 좋답니다.\n제가 만들어놓은 솔루션을 토대로 참고해보세요!\n저는 이벤트를 하나의 파일에 만들어서 관리했는데, 사실 각각의 컴포넌트에 만들어서 관리하는게 더 좋다고 생각해요. ",
      enrolledId: "684a8d6184ed0f34595bafbf",
    },
    {
      _id: "6868a344a8a052ad614543f1",
      result: "PASS",
      isBestPractice: false,
      name: "김수민",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/69",
        },
      ],
      feedback:
        "수민님 수고많으셨습니다!\n\n* (리뷰는 아닌데 궁금한 점) MVC 패턴이랑 SPA가 궁합이 맞지 않는 것인지 아니면 해결할 방법이 있었는데 제가 잘 몰랐던 것인지 궁금합니다!\n\nSPA와 MVC 패턴은 궁합이 딱히 안맞다고는 할 수 없을 것 같아요.\nMVC보다 나은 것들이 나왔다고 보는 편이 좋을 것 같습니다 :)\n사실 무엇이 궁금한것인지 좀더 자세히 질문을 해주시면 좋을 것 같아요!\n제가 알고 있는 MVC패턴으로 구현한 SPA 프레임웍으로는 백본이라는 녀석이 있어요! 그 프레임웍의 코드 모양세를 조금 살펴보시면 조금 힌트가 되실 것 같습니다!\n\n* 제가 구현한 라우터와 Component class가 과한 렌더링을 유발하지는 않는지 궁금합니다. 코드만으로 몇 회 불필요한 렌더링이 일어나는지 이런 걸 생각하는 게 어려운데 잘하고 싶어요..!\n\n이런건 사실 코드만으로는 측정하기가 힘들 수 있어요. 이럴때 사용하기 좋은 것아 바로 크롬 개발자 도구인 것 같아요. 퍼포먼스탭을 활용해보세요!\nhttps://developer.chrome.com/docs/devtools/performance/reference?hl=ko\n처음에는 익숙하지 않은데 막상 보시면 금세 익숙해지실 것 같아요!\n저도 코드로 예측한대로 동작하지 않아 이런 도구를 활용해서 실제로 어떻게 실행되는지 의도한 대로 동작하는지 아닌지 확인해봅니다.\n\n* 디스코드로 질문 드렸던 내용인데, 단위 테스트 환경에서 query가 {}로 인식되어 통과하지 못하는 문제가 있었어요. 테스트 환경에서 window 객체가 없는데 window에 바인딩한 router를 사용해서 그런 걸까요? 근데.. 테스트 환경에서 window 객체 없는 거 맞..나..?\n\n아마 jsdom 때문인 것 같은데요. 이상하네요 jsdom에도 window는 있을텐데요. 아무래도 모킹이다보니 실제 브라우저의 동작과 달라서 그럴수도 있는데요.\n움 해당 코드에 준하는 솔루션 코드의 조각을 살펴보시면 좋을 것 같습니다!",
      enrolledId: "68497d2484ed0f3459b09aca",
    },
    {
      _id: "6868a344a8a052ad614543f3",
      result: "PASS",
      isBestPractice: true,
      name: "박준형",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "FAIL",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/38",
        },
      ],
      feedback:
        "안녕하세요 준형님, 수고하셨습니다. 이번 과제는 프레임워크 없이 SPA를 구현하면서 React와 같은 프레임워크가 해결하는 문제들을 직접 경험해보는 것이 목표였어요. \n\n코드의 구현이 초창기 React의 클래스 컴포넌트의 모습을 보는 것 같아서 인상깊었습니다. 컴포넌트 베이스를 바닐라 자바스크립트로 구현하고, Pub-Sub 패턴 기반의 전역 상태 관리 시스템까지 만들어내셨네요. 특히 메모리 누수 방지를 위한 이벤트 핸들러 관리와 미들웨어 시스템 구현이 인상적입니다.\n\nAI와의 바이브코딩 경험도 흥미롭게 읽었습니다. 단순히 코드를 생성하는 것이 아니라 아키텍처 설계부터 디버깅 미들웨어까지 함께 고민하며 개발하신 과정이 잘 드러나네요.\n\n너무 너무 잘하셨습니다. :)\n\n---\n\nQ) 상속 대신 합성을 어떻게 활용할 수 있을까요?\n\n=> 전통적으로 객체에서 합성을 한다는 건 아래처럼 공통 기능을 만든다음에 this를 넘겨주는 것입니다. this는 baseComponent의 공통 메소드를 가지고 있으니 로직을 분리할수가 있죠.\n\n// 공통 기능을 별도 클래스로 분리\nclass SearchHandler {\n  constructor(component) {\n    this.component = component;  // this를 통째로 받음\n  }\n  \n  handleSearch(query) {\n    this.component.setState({ search: query });\n    this.component.loadProducts();  // component의 메서드 호출\n  }\n}\n```\n\n그렇지만 이런 방식으로 만들면 재사용을 하기 위해 분리를 했는데 Search기능을 활용하기 위한 method들을 각자 만들어줘야 하는 문제가 발생합니다. 내부 구조를 모른채로 재사용을 하고 싶지만 객체지향은 내부 구조의 약속(=인터페이스)를 기준으로 소통하도록 되어 있으니까요.\n\n이러한 이유가 클래스 컴포넌트를 포기하고 hook으로 넘어간 이유이죠. 합성 자체가 잘못된 방식은 아니구요. 명시적으로 좋은 구조를 유지할 수 있다는 장점과 개발자 경험이 더 복잡해진다는 단점을 포기하고 FE 특성상 견고한 구조보다는 단순하고 수정하기 좋은 코드를 만들기 위한 선택이라고 생각해주세요.\n\n수고하셨습니다. 2주차도 화이팅입니다! :)",
      enrolledId: "6847a79c614fe33053fc070a",
    },
    {
      _id: "6868a344a8a052ad614543f5",
      result: "PASS",
      isBestPractice: true,
      name: "정유열",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/28",
        },
      ],
      feedback:
        "유열님 과제 퀄리티가 엄청 높네요 ㅎㅎ 고생하셨습니다.\n과제의 목표를 명확하게 하고 잘 접근해주신 것 같아요.\n함께 했으면 하는 여러 고민들을 매우 잘 진행해주신 것 같습니다\nAI에 대한 활용도 이상적으로 잘 하신 것 같아 따로 이야기 할 게 없네요 ㅎㅎ \n\n> 페이지 모듈과 컴포넌트 모듈의 역할 분리를 했으나 만족스러운 구조가 나오지 못한것 같습니다. 어떻게 하면 더 나은 구조를 만들 수 있었을까요?\n\n여기서 이제 디자인 패턴이 필요해지는 시점이 아닐까 싶네요!\n실제로 바닐라 자바스크립트만으로 과거에 구현을 진행했었을 시기에는 여러 패턴들을 사용해서 함수를 추상화 하고 제어를 했거든요.\n이벤트에 대해서는 이벤트 버스를 구현해두고 제어를 하기도 했고, 모듈패턴 이나 프로토타입을 사용해 각각의 동작하게 하기도하구요. 요즘은 class 컴포넌트를 명확하게 사용할 수도 있죠.\n공통적으로 수행해야 하는 여러 작업들을 리액트 프레임워크에서 컴포넌트가 해당 작업들을 수행하는 것처럼 작업을 숨기는 것도 좋은 방법일 것 같아요!\n\n> 외부 상태관리 스토어로써 적절한 기능을 하도록 잘 구성하였는지 궁금합니다.\n\n넵 적절하게 구현해주신것 같아요! 쉽게 잘 정리해주신 것 같아요. \n이미 아시겠지만, 바닐라를 통한 다양한 구현 방법이 있는 만큼 여러 방법으로도 구현을 해보시는 것도 재밌을 것 같네요 ㅎㅎ\n\n> 비즈니스로직과 렌더링 로직이 강결합되어 의도한 만큼 깔끔한 코드를 작성하지는 못했는데 어떻게하면 더 좋은 코드를 작성할 수 있었을까요?\n\n말씀해주신대로 지금 컴포넌트는 꽤 많은 작업을 한곳에서 진행중인것 같아요. 일단은 컴포넌트의 단위 단위를 조금 더 작게 잡고 구현을 하는게 필요해 보이구요. 조금 유행이 지났을지 몰라도 MVC와 유사하게 뷰의 영역과 모델의 영역을 제어하도록 분리를 하는 것도 방법일 것 같구요. \n1번 질문과 유사한 답변이겠지만, 컴포넌트 패턴 그리고 사용하는 라이브러리의 패턴을 따라 구현해보고 각각의 동작을 구분하는게 제일 좋은 해결 방법이자 공부가 되지 않을까 싶네요 ㅎㅎ\n\n> 토스트(@/components/toast/index.ts)와 모달(@/components/modal/index.ts) 위치에 대한 고민\n\n이 부분에 있어서 사실 유저 사용성이 가장 중요한 고민이 되는 것 같지만,  공통된 위치를 만드는게 좋을 것 같아요. (크게 중요하진 않은 것 같아서) 공통으로 포털의 위치를 잡고 해당 토스트와 모달에 대한 상태들은 별도 provider 처럼 상태를 다르게 줘 관리하는게 이상적일 것 같아요! 하지만, 별도로 위치가 달라져야 하는 사용성이라면 위치를 주입받을 수 있는 형태의 공통 컴포넌트로 관리하는게 좋지 않을까 싶네요!\n\n고생하셨고 다음 주도 화이팅입니다~~",
      enrolledId: "6847a18a614fe33053f85c23",
    },
    {
      _id: "6868a344a8a052ad614543f7",
      result: "PASS",
      isBestPractice: false,
      name: "허정석",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/19",
        },
      ],
      feedback:
        "안녕하세요 정석님!\n\nhttps://velog.io/@jungseokheo/hanghaeplus1stweek\n회고도 너무 잘 봤어요 ㅎㅎ\nPR에도 정석님의 문제해결 과정이 잘 드러나서 재밌게 잘 읽었어요!\n\n> 과제가 상세하게 테스트 코드가 있어서 좋았으나, 해당 페이지가 랜더링 됐을 때의 스냅샷을 비교 하는거여서 숨은 그림 찾기 같은 느낌이 강했다. 그리고 테스트 코드를 처음 접해봐서 감을 잡는데 시간이 오래 걸렸다. 발제 시간에 테스트 설명을 좀 더 진행했으면 좋겠다.\n\n참고해서 잘 개선해보겠습니다!!! 좋은 의견 감사드려요!\n\n> 이벤트 핸들링에 대해서 고민을 하지 않았었는데, 이번 과제를 통해 핸들링에 대해 관심이 생겼습니다. 개발하면서 거의 처음으로 핸들링을 구현 했어서 보완할 부분을 듣고싶습니다. 또 코치님이라면 어떤 기준과 방식으로 이벤트 핸들링을 했을지 궁금합니다.\n\n지금 보니까 document 이벤트를 등록하고 이벤트 핸들러 내부에 내용이 다 들어있네요!\n\n여기서 \"정의하는 부분\"과 \"실행하는 부분\"으로 코드를 나누어서 관리해주면 좋답니다 ㅎㅎ\n\n가령,\n\naddEvent('change', '.selector', callback)\n\naddEvent라는 함수가 정의하는 과정이 추상화되어있고, 실행 코드를 callback 을 주입하는거죠.\n\n이건 솔루션 코드를 참고해주시면 될 것 같아요!\n\n고생하셨습니다 정석님~!\n\n---\n\n구현한 내용과는 별개로, 현재 테스트가 통과하고 있지 못해서... 아쉽지만 불통으로 남겨놓겠습니다 ㅠㅠ",
      enrolledId: "68479c49614fe33053f4b25d",
    },
    {
      _id: "6868a344a8a052ad614543f9",
      result: "FAIL",
      isBestPractice: false,
      name: "이가은",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "FAIL",
        "FAIL",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/54",
        },
      ],
      feedback:
        "안녕하세요 가은, 수고하셨습니다. 이번 과제는 프레임워크 없이 SPA를 구현하면서 바닐라 자바스크립트의 핵심 개념들을 깊이 이해하는 것이 목표였습니다. 특히 상태 관리, 라우팅, 이벤트 처리 등 프레임워크가 해결해주던 문제들을 직접 경험해보셨기를 바랍니다.\n\n분명 과제를 하는 동안 여러가지 경험들을 했었지만 결과가 저희가 제시했던 기준을 만족시키지 못했기에 불합격을 드립니다. 개발자에게는 좋은 코드 이전에 요구사항의 완성과 딜리버리가 제일 중요한 만큼 최선을 다해 우선 되는 코드를 먼저 만들고 좋은 코드로 만들자고 계속해서 다짐해주세요. 과제에 주어지는 시간이 많지 않은 만큼 좋은 코드보다 완성을 목표로 삼아주기를 바랍니다.\n\n그리고 모르면 물어보고 함께 하는 경험또한 저희가 꼭 배워가고 익혀하고 경험했으면 하는 부분입니다. 이제 1주차에 깨달음(!)을 얻었으니 완성을 위해서 뭐든 시도해보는 그런 문제해결사적인 개발자의 면모를 남은 주차동안 연습해가기를 바랍니다.\n\n---\n\nQ) 너무 테스트코드에 의존해서 UI를 만드는게 아닐까의 고민\n\n=> 테스트는 요구사항을 명확히 하는 가이드입니다. TDD라는 테스트 주도 개발이라는 방법도 있지만 일반적인 방식인 요구사항을 이해한채로 만들어가면서 놓치는 부분을 테스트를 통해 주도해가면 되죠. \n\n=> 아직 익숙지 않고 테스트의 빨간 경고등에게 계속 주의(?)를 뺴았길 수도 있겠지만 차자 적응해 나갈거라 기대합니다. 화이팅입니다\n\n수고하셨습니다. 2주차도 화이팅입니다! :)",
      enrolledId: "68479688614fe33053f10a5f",
    },
    {
      _id: "6868a344a8a052ad614543fb",
      result: "PASS",
      isBestPractice: true,
      name: "임두현",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/31",
        },
      ],
      feedback:
        "안녕하세요 두현님!\n1주차 과제 무척 잘 진행해주셨네요 ㅎㅎ 너무 고생하셨어요!\n\n> Claude와 Cursor를 사용했습니다. AI는 세션을 적절하게 관리하는 것이 중요합니다. 그래서 진행사항 및 프로젝트의 방향성을 이야기하는 문서들을 docs 폴더에 저장했습니다. 이를 통해 세션을 높은 빈도로 비우면서도 docs의 문서들을 읽음으로써 대화의 연속성을 이어갈 수 있었습니다.\n\n저도 문서가 제일 중요하다고 생각해요! 진행에 필요한 컨텍스트를 docs로 잘 정리해주신게 무척 인상적이네요 ㅎㅎ\n\n> main.js에서 렌더링을 하는 생애주기간 데이터 및 이벤트 핸들러 구독 셋업과 클린업 처리 흐름이 정리가 안되어 그 때 그 때 돌아가게끔 되어있어서 관련하여 리뷰받고자 합니다.\n\nmain 자체에 대한 클린업은.. 사실지금 불필요하다고 생각해요.\n제가 테스트를 잘못작성해서 이런 고민을 하게 되는 것 같네요 ㅠㅠ\n\n대신 컴포넌트에 대한 클린업, 페이지에 대한 클린업은 필요하다고 생각합니다!\n\n> spa에 적합한 구조인지 이야기를 나눠보고 싶습니다.\n\n지금 구조는 충분히 SPA에 적합한 구조라고 생각해요!\n다만 이벤트 관리하는게 아마 제일 마음에 들지 않는 부분이라고 생각될 것 같은데요, 이 또한 2주차 과제를 진행하면서 어느정도는 해소되리라 생각합니다 ㅎㅎ",
      enrolledId: "684149af4e1c73fff27b2528",
    },
    {
      _id: "6868a344a8a052ad614543fd",
      result: "FAIL",
      isBestPractice: false,
      name: "양성진",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "FAIL",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/60",
        },
      ],
      feedback:
        "안녕하세요 성진님~\n1주차 과제 잘 진행해주셨네요 ㅎㅎ \nAI 활용에 대한 복잡 미묘한 감정을 느끼신것 같군요 ㅋㅋ\n지금은 소화할 시간이 부족해써 그랬으리라 생각해요.\n1주일이라는 시간이 짧기도 했고..!?\n다만 내가 혼자서 할 수 없는 일을 AI와 팀의 도움을 받아서 함께 해결하는 경험도 무척 중요하다고 생각합니다! 우리가 할 수 있는 일의 범위를 넓혀주는거니까요! 대신 소화하는 과정도 꼭 챙겨주세요!\n\n---\n\n> store을 만들때 옵저버 패턴을 이용해서 만들었는데 store를 두가지로 나눠서 작업을했는데 보완할 내용이 있는지 구성은 잘한건지 잘모르겠습니다.\n\n나눠서 하는건 큰 문제되가 되지 않는다고 생각해요! 다만 공통으로 사용할 수 있는 로직이 있을 것 같은데, 지금은 이런게 추상화 되지 않았은 상태라서 아쉽네요!\n옵저버 같은걸 store가 공통으로 사용할 수 있게 하면 어떨까요?\n\n> Home.js에서 기본과제 1-1 테스트 때문에 원래 Store을 썻다가 loading하는 부분만 모듈 스코프를 이용했는데.. 왜 store을 사용하면 테스트가 통과가 안되는지 알수가 있을까요..\n\n이 부분은 AS-IS와 TO-BE의 코드를 보여주셔야 이해할 수 있을 것 같아요 ㅎㅎ; 텍스트만 보고는 뭘 어떻게 하려고 했다는 뜻인지 이해하기가 어렵네요 ㅠㅠ\n\n아니면 커밋 링크라도 주셨으면 좋았을 것 같아요.\n\n> infinitescroll.js) 무한스크롤을 구현할때, e2e테스트에서 추가상품대기 부분에서 20개씩 카드가 40개가 나오면 되는 부분에서 다음페이지로 추가로 api호출이 안됐습니다. 로컬환경에서는 잘되었는데, 테스트에서는 왜 안되는지 궁금합니다.\n\n성진님..!\n이건 테스트를 통과하는게 이상한 것 같아요.\n지금 배포된 페이지에서도, 로컬에서도, 로컬 테스트에서도 저는 다 실패하네요 ㅎㅎ ㅠㅠ",
      enrolledId: "68417c4a4e1c73fff2a66073",
    },
    {
      _id: "6868a344a8a052ad614543ff",
      result: "PASS",
      isBestPractice: false,
      name: "김상수",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/40",
        },
      ],
      feedback:
        "고생하셨습니다 상수님ㅎㅎㅎ\n근본없는 괴물이라뇨 잘하셨습니다 ㅋㅋㅋ\n개인적으로 이번 과제를 통해 명확하게 사용하는 기술들이 해결하려고 했던 문제들은 무엇이고, 어떤 식으로 해결했는지 고민해볼수 있으셨던 것 같아서 훌륭한 경험이 되지 않았을까 싶네요 :+1\nAI 활용도 작성해주신 것처럼 만들고자 하는 목표와 참고할 수 있는 명확한 자료를 넣어서 구현을 잘 해주셨네요.\n\n질문 주신거 답변드려보면, 라이프 사이클과 렌더링에 대해서는 명시적인 함수를 컴포넌트에서 만들어서 사용하는 것이 필요해보여요. 라이프 사이클 함수가 있다면 결국 명확한 제어와 사용자의 행동을 주입받아 실행시킨다는 의미이기 때문에 명시적인 구현이 필요할 것 같구요! 상태 관리에 대한 리렌더링 관련해서는 이미 알고 계신것처럼 상태를 클로저로 물고 있으면서 setState를 할 때 명시적으로 렌더링을 발생시키거나, 좀 더 우아하게 처리하고 싶다면 쉽게 인터넷에서 확인할 수 있는 여러 반응형 상태 라이브러리를 구현해 사용해보는 거도 방법일 것 같아요! 사실 구현해보면 어렵지 않거든요.\n꼭 도전해볼법한 주제들이니, 상태를 모니터링 하는 곳들에서 변화가 발생할 때 어떤 동작을 할 지 등등 고민들을 해보시면 좋겠네요.\n\n고생하셨습니다!",
      enrolledId: "683fa08b4e1c73fff25b6b7e",
    },
    {
      _id: "6868a344a8a052ad61454401",
      result: "FAIL",
      isBestPractice: false,
      name: "이진희",
      badge: "화이트",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "FAIL",
        "FAIL",
        "PASS",
        "FAIL",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/41",
        },
      ],
      feedback:
        "안녕하세요 이진희님, 수고하셨습니다. 이번 과제는 프레임워크 없이 SPA를 구현하면서 React와 같은 프레임워크가 해결하는 문제들을 직접 경험해보는 것이 목표였습니다. \n\n코드를 보니 컴포넌트 분리와 구조화에 신경을 많이 쓰신 점이 인상적입니다. 특히 `renderViewComponent`를 통해 React의 컴포넌트 시스템을 구현하려 시도하신 점이 좋았습니다. DOM 조작을 추상화하고 컴포넌트 단위로 관리하려는 접근은 올바른 방향이었습니다.\n\n다만 완성도 면에서 많이 아쉽네요. 짧지 않은 기간인지라 잘 만들어 질수도 있었겠지만 저희가 요구했던 CI 테스트가 모두 실패하고 있기에 '불합격'을 드릴 수 밖에 없습니다.\n\n개발에게 있어서 80%는 되었는데 20%는 한건 사실 안한 것과 다를게 없죠. 99%를 해도 1%의 버그때문에 서비스의 평점이 낮아지는게 개발자인 만큼 좋은 코드 이전에는 마감과 딜리버리가 최우선 역량입니다.\n\n설계에 너무 많은 시간을 투자하셨다고 하셨는데, 잘하고 싶은 마음에 많은 개발자들이 겪는 문제죠. 그렇기에 더더욱 앞으로는 먼저 동작하는 최소한의 구현을 만들고, 점진적으로 개선하는 접근으로 나아갈 수 있기를 바랍니다.\n\n언제나 마감과 딜리버리가 좋은 코드보다 중요하는거 기억해주세요!\n\n---\n\nQ) renderViewComponent의 구조와 업데이트 흐름에 대해\n\n=> 현재 구조는 명시적이어서 나쁘지 않습니다. 그러나 이 프레임워크를 쓰는 사람에게 명시적으로 호출하라고 하는 건 아니겠죠? 지금 구조만으로는 내부에서 자동으로 해줄 것인지 외부 사용자에게 명시적으로 쓰게 해주게 할지 확실치 않네요. \n\n=> 선언적이다라는 것은 내가 원하는 것만 적어주면 내부에서 알아서 한다이므로 내부에서는 이를 한번에 렌더링을 유도하는게 올바른 구조라고 생각합니다. 확신히 안 들때에는 현재 어떤 구조로 되어 있는지 한번 생각해보세요\n\n=> replaceChild는 지금으로썬 괜찮다 생각합니다. 사실 DOM을 전체 교체하는 것은 상당히 비효율적이기에 많은 프레임워크들이 변해야하는 코드만 변하도록 하는게 기술인데 1주차 과제에 그것까지 해주기를 바라는건 너무 큰 욕심이겠죠? (웃음)\n\n\n수고하셨습니다. 다음 과제에서는 먼저 테스트를 통과시키는 것을 목표로 하시고, 그 다음에 리팩토링을 진행하시길 추천드립니다. 화이팅입니다! :)",
      enrolledId: "683f18534e1c73fff2105065",
    },
    {
      _id: "6868a344a8a052ad61454403",
      result: "PASS",
      isBestPractice: false,
      name: "양창훈",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "FAIL",
        "PASS",
        "PASS",
        "PASS",
        "FAIL",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/23",
        },
      ],
      feedback:
        "안녕하세요 양창훈님, 수고하셨습니다. 이번 과제는 프레임워크 없이 순수 JavaScript로 SPA를 구현하면서 상태 관리, 라우팅, 렌더링 최적화 등의 핵심 개념을 체득하는 것이 목표였습니다. 특히 이벤트 바인딩과 재렌더링 타이밍에 대한 이해를 얻으셨다니 좋은 성과네요. \n\n사실 이러한 코딩은 프레임워크를 쓰기에 할 필요는 없지만 이러한 개발을 직접 경험하게 되면 알게 되는 이해의 선명도가 달라지는 만큼 어려웠던 경험을 해본 것이 큰 자산이 될거에요.\n\n말씀해주신대로 코드를 살펴보니 `productPage.js`의 `bindEvents` 함수에서 이벤트 리스너를 중복 등록하는 문제가 있네요. 매번 `removeEventListener` 없이 `addEventListener`만 호출하면 동일한 핸들러가 누적됩니다.\n\n이를 해결하기 위해서 React는 실제로 DOM이벤트는 한번만 위임을 하고 나머지는 컴포넌트의 여부에 따라 이벤트 핸들러를 위임하는 방식을 하고 있습니다. 다른 프레임워크들은 컴포넌트가 등록할때 이벤트를 연결하고 제거될때마다 자동으로 이벤트 핸들러를 떼어내는 방법을 쓰고 있죠.\n\n이 코드의 경우 라우트 단위로 이벤트를 연결하고 있기에 라우트가 바뀌고 bindEvents를 하기전에 모든 이벤트를 다 해제해주는 방식으로 내재화 시키는 방향으로 만들 수 있었겠네요.\n\n사실 지금 쓰고 있는 구조가 일종의 정답지인만큼 더 잘하기 위해서는 현대 프론트엔드 구조가 어떻게 되어있나 생각하시면서 구조를 만들어가면 더 이해가 잘되고 좋은 구조의 코드를 작성하실 수 있을거에요.\n\n다음은 질문 주신 내용에 대한 구체적인 답변입니다.\n\n---\n\nQ) bindEvent 중복 문제와 removeEventListener\n=> 피드백에 설명을 이미 했군요. DOM 이벤트는 하나만 쓰고 위임을 하거나 컴포넌트 등록시 이벤트를 등록하고 해제시 삭제하는 방식으로 만들면 됩니다. 대게 eventListner등록을 하고 해제하는 코드를 return해서 보관하고 있다가 일괄로 호출하는 방법을 사용합니다.\n\nQ) 컴포넌트 분리 기준\n=> 내가 현재 쓰고 있는 현대적 방식과 최대한 닯게 작성해보려고 하세요. 독특하고 유니크한 해법을 하지 않아도 됩니다. 어차피 현업에서는 오랫동안 검증된 방식으로 하게 될거잖아요? 그러니 내가 현재 쓰고 있는 프론트엔드 개념과 최대한 일치하도록 만들어 보세요.\n\nQ) 상세페이지 로딩 속도\n\n=> `render()` 함수가 여러 번 호출되거나 불필요한 DOM 재생성이 원인일 수 있습니다. 이벤트나 렌더의 중복으로 인해 불필요한 로직이 있을거라 생각합니다. 로그를 통해서 확인보시죠.\n\n=> 그리고 이러한 고민보다도 일단 시간내 요구사항을 다 만족시키는 코드를 작성하는 것을 더 우선시해서 2주차 코드는 꼭 테스트 코드가 다 통과되는 코드를 한번 만들어 봅시다! \n\n수고하셨습니다. 2주차도 화이팅입니다! :)",
      enrolledId: "6835a5664e1c73fff2ddfa55",
    },
    {
      _id: "6868a344a8a052ad61454405",
      result: "PASS",
      isBestPractice: false,
      name: "이은지",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/64",
        },
      ],
      feedback:
        "은지님 수고 많으셨습니다! \n회고문서도 잘 작성해주셨네요 ㅎㅎ\n코드 내용들도 뭔가 고민하신 흔적이 보입니다. 과제가 기대하는 이상을 해주신 부분도 있고요 ㅎㅎㅎ\n컴포넌트와 스토어등 주요 개념을 추상화해서 프레임웍을 착안하신 부분도 돋보입니다 :)\n\n- Component를 언제 어디서 cleanup/destroy 해야할 지 모르겠습니다.\n지금처럼 라우터에서 처리하면 되지 않을까 싶습니다.  그렇게하려면 자식 컴포넌트를 관리하는 부분도 컴포넌트에서 추상화되어야할 것 같아요 :)\n예를들어 배열로 관리해서 페이지 컴포넌트가 변경될때 기존 컴포넌트의 제거 메서드를 실행하고 해당 컴포넌트는 자식노드가 있으면 자식컴포넌드틀도 해댕 메서드를 실행하는 것이죠.\n\n- Store에 사용된 옵저버 패턴과 그 사용 방식이 적절한 지 모르겠습니다. 컴포넌트에서 setup에서 subscribe하고 cleanup시 unsubscribe시키고 있는데, 그게 맞는지\n넵 일반적인 옵저버패턴으로 보입니다. 사실 이부분은 준일님이 이 과제에서 기대했던 내용은 아니었던 것 같은데 초과해서 과제를 달성하셨네요 :) \n물론 장치가 여러가지가 있고 구조적으로는 다르지만 근본적으로는 뷰가 이런 원리로 만들어졌습니다!\n\n- 라우터 상태값과 메서드들을 편리하게 사용하기 위한 useRouter.js를 만들어 사용했습니다. (hook은 아니지만 hook 폴더에 있음) 좀 더 편리하고 명쾌한 방법이 없을까 고민됩니다.\n네 해당 코드는 비슷한 메서드가 반복되는 것 같은데욥. 사실 우리 과제에서는 훅이란 구조를 끼워맞출필요는 없는 것 같아요.\n저라면 그냥 라우터를 직접 사용했을것 같아요. 라우터가 없는 예외는 언제 발생하는지 지금으로서는 저는 예측이 안되네요!",
      enrolledId: "6833c8d54e1c73fff246f798",
    },
    {
      _id: "6868a344a8a052ad61454407",
      result: "PASS",
      isBestPractice: false,
      name: "정도은",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/12",
        },
      ],
      feedback:
        '안녕하세요 정도은님, 수고하셨습니다. 이번 과제는 프레임워크 없이 순수 JavaScript로 SPA를 구현하면서 React가 해결하는 문제들을 직접 경험해보는 의도를 가진 과제였어요. 회고에서 언급하신 것처럼 "React가 왜 필요한지" 명확히 체감하셨기를 바랍니다.\n\n특히 Toast 컴포넌트를 클로저로 구현하신 점이 인상적이네요. 전역 상태를 클로저로 캡슐화하여 깔끔한 API(`Toast.success()`)를 제공한 것은 훌륭한 선택입니다. CartStorage의 이벤트 시스템과 카운터 관리도 잘 구현하셨어요.\n\n다만 `productLoader.js`에서 전역 변수(`currentPage`, `isLoading`, `hasMore`)로 무한 스크롤 상태를 관리하는 부분은 개선이 필요해 보입니다. 여러 페이지에서 상품 목록을 사용한다면 상태가 꼬일 수 있으니, 클로저나 클래스로 인스턴스화하여 각 페이지가 독립적인 상태를 가지도록 하는 것이 좋겠네요.\n\n다음은 구체적인 리뷰입니다.\n\n---\n\nQ) 클래스 vs 클로저 선택 기준\n\n=> 자바스크립트는 함수형 패러다임과 객체 지향 패러다임을 둘 다 쓸 수 있기에 두 가지의 장점이 있는 멋진 언어죠.\n\n=> 단일 인스턴스면 클로저(Toast, Modal), 여러 인스턴스가 필요하면 클래스가 적합합니다. 클로저는 private 변수를 자연스럽게 만들 수 있고, 클래스는 상속과 확장이 용이합니다.\n\n=> 자바스크립트가 아무래도 class를 표현하기에 복잡한 문법 체계를 가지고 있는 만큼 상속과 확장이 필요한 다양한 객체 타입을 가져야 하는 경우 ex) Node -> Element -> HTMLElement -> HTMLDiveElement 과 같이 상속과 타입의 확장이 유리한 구조에서는 class가 훨씬 더 좋은 선택입니다.\n\n=> 그밖의 단순한 동작과 모듈등 간결함을 추구하는 코드라면 클로저 방식의 코드가 대개의 경우 더 좋습니다.\n\n=> 그렇지만 너무 이렇게만 알면 안되겠죠? 각 방식의 차이를 실제로 이해하고 적절한 본인만의 판단기준을 찾아가길 바랍니다 :)\n\n\nQ) 상태를 함수 내부에서 유지하는 방법\n\n=> 이미 알고 있는대로 클로저를 활용하여 상태를 만들고 상태와 그것을 조작하는 함수를 함께 반환하는 팩토리 패턴을 사용하면 됩니다:\n\n```js\nfunction createProductList() {\n  let state = { page: 1, loading: false };\n  return {\n    load: () => { /* state 사용 */ },\n    getState: () => ({ ...state })\n  };\n}\n```\n\n다만 이런방식은 값을 변화 했을때 이벤트를 전달하기가 어려우므로 각 함수마다 마지막에는 render() 혹은 noify()등을 호출해야 하는 단점이 있죠. \n\n그러다보니 값이 변할때마가 이벤트를 전달하는 signal과 같은 것들이 현재 표준 객체로 만들려는 시도가 있습니다. 관련해서 찾아보시면 좋겠어요.\n\n수고하셨습니다. 2주차도 화이팅입니다! :)',
      enrolledId: "682d428a0a72040b80bf93a5",
    },
    {
      _id: "6868a344a8a052ad6145440b",
      result: "PASS",
      isBestPractice: false,
      name: "이태영",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/46",
        },
      ],
      feedback:
        '안녕하세요 태영님! 1주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다.\n\n> 이런 부분은 과제 시작 전 참고 문서나 차라리 사전 스터디를 이런 부분을 하는 것이 더 좋을 것 같습니다.\n\n과제 챕터에 보면 SPA 지식뭉치 문서가 있고, 여기에 있는 내용만 참고해도 충분히 구현할 수 있는 게 많이 있답니다..! 다만 오히려 확인해야 하는 자료가 너무 많아서 탐색하기 힘들 수 있다는 생각이 드네요 ㅠㅠ\n\n> 제 생각은 학교나 학원처럼 지도와 배움이 있는 방식으로 생각을 했지만 그런 시스템으로 프로그램을 진행하고자 하는 의미보다는 \'코치\'의 의미처럼 내 자신이 진행을 하면서 코치를 받는 것으로 접근 해야 더 많은 것을 얻을 수 있겠다. 생각 했습니다.\n\n저도 이에 동의합니다 ㅎㅎ 더 정확히는, 저는 정답이 있는 교육을 지양하는 편이라서요. 경험이 제일 중요하고, 경험을 해야 나의 진짜 지식이 된다고 생각합니다.\n\n어쨌든 교육 과정이라서 최소한의 답을 제공하긴 하지만... 내가 어떤 지식을 학습할 때는 나 스스로의 경험이 무엇보다 중요하다고 생각해요!\n\n> AI가 일을 더 잘 하게 만든 방법은 만들었다기 보다 내가 어떤 코드를 작성 할 지 함수나 기타 등을 이용 할 지에 대해 이해가 있어야 AI가 더 일을 잘하게 할 수 있다 느꼈습니다.\n\n무척 좋은 인사이트네요! 내가 하고자 하는 일을 명확하게 그리고 구체적으로 설명할 수 있을 때 AI의 활용도가 높아지는 것 같아요.\n반대로, 정말 어떻게 시작해야 할지 모를 때 막막할 때도 AI에게 어느정도 제시해달라고 하면 좋답니다 ㅋㅋ\n저는 창의성을 많이 위임하고 있어요.\n\n> render.js 파일에 모든 이벤트들을 다 모아 두었는데, 이런 구조가 맞는 건지 궁금합니다.\n\n이건 선택이라고 생각해요. 관리해야할 이벤트가 많이 없을 때는 지금고 같은 구조가 좋고, 이벤트의 수가 점점 늘어날 때는 컴포넌트쪽에 위치시키는게 좋다고 생각해요.\n\n> 옵저버 패턴을 사용해 상태 관리 로직을 구현해 보았습니다. 하지만 옳은 방법인지 여부를 묻는 것 이전에 애초에 store는 어떤식으로 구조화하고 로직을 구현하는지 아주 기초적인 부분에 대한 설명 부탁 드립니다.\n\n글쎄요.. 어디까지가 기초일까요?\nstore를 상태관리라고 생각해본다면, 상태를 구조화하는 방식이 너무 다양해서요 ㅎㅎ\n다만 "값"과 "값을 변경하는 함수" 등은 꼭 필요하다고 생각해요. 여기에 더 나아가서 "상태를 변경했을 때 어떤식으로 밖에 알릴 것인가?"에 대한 장치가 필요하죠.\n\n이 장치를 내부에 만들어둘 수도 있고, 혹은 외부에서 주입받을 수도 있답니다.\n가령,  `store.addEventListener(\'change\', callback)` 이런 모습일 수도 있고, 옵저버일수도 있겠죠?\n\n> render.js 파일에 initRender 함수인데 초기 렌더링과 새로고침, 상세페이지 이동 등에 따라 처리되어야 하는 상황이 달라서 이런식으로 늘어지게 코드가 작성되었는데 이런 방법이 아닌 분리시키거나 하는 방법이 있을까요?\n\n현재 작성된 방식을 "명령형"으로 코드를 작성했다고 이야기한답니다.\n그리고 이를 개선한다면, "선언형"으로 코드를 작성할 수 있겠죠?\n\n`선언형 프로그래밍` 이라는 키워드로 검색해보면 좋답니다 ㅎㅎ\n\n```\n\n// 🔴 기존 명령형: 조건을 체크하고 직접 실행\nproductStore.subscribe(() => {\n  if (renderingDisabled) return;\n  if (isCurrentlyOnDetailPage()) return;\n  \n  const state = productStore.getState();\n  if (state.newlyLoadedProducts.length > 0 && state.isFirstLoad) {\n    appendNewProducts();\n  } else {\n    render();\n  }\n});\n\n// ===============================================\n\n// 🟢 선언형: 규칙을 정의하고 시스템이 실행\nconst renderingRules = {\n  // 렌더링 조건들\n  skipWhen: [\n    () => renderingDisabled,\n    () => isCurrentlyOnDetailPage()\n  ],\n  \n  // 렌더링 액션들  \n  actions: [\n    {\n      condition: (state) => state.newlyLoadedProducts.length > 0 && state.isFirstLoad,\n      action: () => appendNewProducts()\n    },\n    {\n      condition: () => true, // 기본값\n      action: () => render()\n    }\n  ]\n};\n\nproductStore.subscribe(() => executeRules(renderingRules, productStore.getState()));\n```\n\n> 이번 과제를 통해 코치님의 생각보다 더 기대치를 낮춰서 기초 중에 기초라고 생각하는 부분들에 대해 키워드나 참고 할 수 있는 문서 등을 알려 주실 수 있을까요? 아예 코드를 AI나 그 외 도움 없이 자신이 직접 구현 하지 못 한다면요\n\n그게 발제에 있는 자료들이라서요..!\n\n자바스크립트 기초 개념: https://www.notion.so/1-3-Javascript-2262dc3ef51480299f63d27a8d3a3136?pvs=24\nSPA를 만들기 위한 지식 뭉치: https://www.notion.so/teamsparta/1-4-SPA-2262dc3ef51480949a61f934fdae9dc5\n\n혹은 "프레임워크 없는 프론트엔드 개발" 이라는 책을 보셔도 좋습니다 ㅎㅎ\nhttps://www.yes24.com/product/goods/96639825',
      enrolledId: "6825c7b00a72040b8086a6af",
    },
    {
      _id: "6868a344a8a052ad6145440d",
      result: "PASS",
      isBestPractice: false,
      name: "이민재",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/11",
        },
      ],
      feedback:
        '안녕하세요 민재님!\n과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다.\n다만 배포된 페이지에서는 무한 스크롤이 정상적으로 동작하지 않네요 ㅠㅠ 다음엔 배포 했을 때에도 잘 동작하는지 확인 부탁드립니다!!\n\n---\n\n> 상품 리스트, 상품 상세, 장바구니가 모두 store.js의 인스턴스를 공유하고 있는데(상품 상세와 장바구니는 store를 만들지 않았지만 만들 계획..) 이 방식이 기능 간 상태 충돌을 일으키지는 않을지... 또, 장바구니 같은 경우에 로컬 스토리지와 전역 store로 상태관리를 할 필요가 있을지 궁금합니다.\n\n이럴 때는 충돌 가능성이 있는 코드를 민재님께서 아예 언급을 해주시면 좋답니다!\n\n아마 store 인스턴스를 공유한다고 해서 문제가 발생하진 않을 것 같아요. 오히려 같이 공유하고 있어야 정확하게 동작할 가능성이 높답니다 ㅎㅎ 그래서 이걸 어떻게 나눠서 정교하게 관리하는지가 중요한데, 그게 쉽진 않아요.\n\n이를 위해 redux에서는 slice 라는 개념을 도입해서 store의 관심사를 분리하여 관리하면서도 하나의 store를 통해 사용할 수 있도록 만들어주고 있답니다.\n\n여기서 중요한건, "하나의 인스턴스"여야 문제되지 않을 확률이 오히려 높다는 점이랍니다..!\n\n> 현업에서도 종종 URL 쿼리 스트링만으로 UI 상태 관리를 하는 로직을 보기도 하는데 상태 관리를 어떻게 하는 것이 가장 적절한 것일지 조언해주실 수 있을까요?\n\nurl의 상태를 따로 관리한다기보단,\n\n제가 작성한 솔루션을 보시면 \n값을 가져올 땐 항상 url에서 가져오고\n값을 설정할 땐 항상 url에 먼저 set을 하는거죠 ㅎㅎ\n\n원본은 url이고 이를 추상화해서 사용하는 방식을 상상해주시면 좋답니다.\n',
      enrolledId: "682b2fc10a72040b80322848",
    },
    {
      _id: "6868a344a8a052ad6145440f",
      result: "PASS",
      isBestPractice: false,
      name: "신홍준",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer:
            "https://github.com/hanghae-plus/front_6th_chapter1-1/compare/main...jun17183:front_6th_chapter1-1:main",
        },
      ],
      feedback:
        '안녕하세요 홍준님!\n1주차 과제 잘 진행해주셨네요 ㅎㅎ\n\n제가 과제 제출 주소 변경해달라고 요청 드렸었는데 아마 확인이 잘 안되었나봐요 ㅠㅠ\n\n현빈 매니저님께서 https://github.com/hanghae-plus/front_6th_chapter1-1/pull/77 이 링크로 채점해달라고 요청해주셔서 그렇게 진행하였습니다!\n\n다음에는 유의해서 제출해주세요~\n\n---\n\n> 실무에서는 AI는 커녕 인터넷도 안 되는 환경에서도 종종 일했던 터라 최대한 AI를 활용해 보는 것이 목표였습니다. 하지만 고기도 먹어 본 사람이 더 잘 먹는다는 것처럼 막상 사용하려니 AI와 스스로의 작업 비중이나 역할을 분명하게 나누지 못했습니다.\n\nAI를 활용하여 진행한 과정이 인상깊네요 ㅎㅎ\n저는 컨텍스트를 빠르게 초기화하여 토큰을 절약하는 방식으로 사용하고 있어요.\n대화를 계속 유지하면, 이전 대화의 기록까지 참조해서 토큰 사용량이 많아지는 문제가 있어서요 ㅠㅠ\n\n다음에 기회되면 어떤식으로 사용하는지 보여드리고 싶네요~!\n\n>  목록 페이지에서 상품 목록을 불러오기 전 url에서 검색 조건을 읽어 이를 state와 맞추는 작업을 합니다. 그럼 state가 변경될 것이고 이 state를 구독하고 있는 컴포넌트, 페이지들은 리렌더링이 됩니다. 여기서 의문이 생기는 것이, 결국 모든 기능의 중심은 state인데 정보의 원천이 url인 것이 어색합니다. 보통 실무에선 state와 url의 동기화 문제를 어떻게 해결하나요?\n\n저는 결국 상태관리의 핵심이 원천데이터 관리라고 생각해요.\nurl뿐만 아니라 api를 통해 가져오는 데이터도 원천데이터가 서버에 있는거라서.. 꼭 url에만 해당되진 않으니까요 ㅎㅎ\n\n여튼 query나 param, url 같은 것들을 주소를 통해 가져오고, 가져올 때 값으로 가져온다기보단 함수를 통해 가져오는거죠.\n이 때 저는 getter 를 적극적으로 활용하고 있어요.\n\n자세한건 솔루션 코드를 확인해주세요!\n\n> 위와 같은 렌더링 방식에서 unmount 함수는 어떻게 관리해야 할지 모르겠습니다. innerHTML을 사용하고 있기에 window 이벤트 같은 것을 제외하면 굳이 unmount 함수를 구현할 필요가 없나 싶기도 하지만, advanced.spec 테스트 "브라우저 뒤로가기/앞으로가기가 올바르게 작동한다" 항목에서\n너무 빠르게 페이지 이동이 발생하다 보니 url은 목록 페이지인데 뒤늦게 상품 페이지가 렌더링이 된 것 같아 결국 테스트 코드를 손보게 되었습니다. unmount는 언제 사용하는지, 위와 같은 문제를 unmount 함수로 어떻게 해결할 수 있을지 궁금합니다.\n\n저는 unmount가 필요한 이유가 "클린업"이라고 생각해요. 컴포넌트가 사라질 때, 페이지를 전환할 때 현재 컴포넌트나 페이지에만 필요한 기능을 없애주는거죠 ㅎㅎ\n\n가령 지금 메인페이지에서는 무한스크롤 기능이 필요한데, 상세페이지에서는 필요없어요. 이런걸 unmount 시점에 없애야 한답니다.\n\n> 옵저버 패턴을 사용해 상태 관리 로직을 구현해 보려 했습니다. 제가 구현한 코드가 옵저버 패턴에 맞게 잘 구성되었는지 검토해 주시고, 보완할 부분을 제안해 주실 수 있을까요? (예시 질문에 있던 항목이지만 제 생각과 너무 일치하여 가져왔습니다!)\n\n굳이 개선해야 한다면, 지금은 key에 옵저버가 걸려있는데요,\n가령 a와 b가 구독하고 있는 함수가 똑같다면, a와 b가 동시에 변경될 때 한 번의 알림만 보내면 될 것 같아요.\n지금은 두 번의 알림을 보내는 방식이라서, 이를 어떻게 해결할 수 있을지 고민해보면 좋답니다!\n\n그리고 key의 값이 변경될 때 옵저버를 실행하고 있는데, 값이 만약 객체거나 배열일 때는 값이 실제로 변경되지 않아도 참조하고 있는 메모리가 달라질 때에도 notify가 발생할 수 있답니다 ㅎㅎ\n\n이에 대한 고민도 필요해요!',
      enrolledId: "682983e90a72040b80d5107f",
    },
    {
      _id: "6868a344a8a052ad61454411",
      result: "PASS",
      isBestPractice: true,
      name: "박창준",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/18",
        },
      ],
      feedback:
        '창준님 첫주차 과제 훌륭하게 해주셨네요!\n작성해주신 내용에 있어서는 다 좋은 방향, 합당한 방향으로 고민을 진행해주신 것 같아요. \n"브라우저 스토리지를 pub/sub 패턴으로 구독해 상태 변경 시 모달 UI를 자동으로 갱신하도록 개선할 수 있을 것 같습니다.\n다만, 테스트 코드를 변경하지 않고 이런 로직을 도입했을 때 테스트를 통과시킬 수 있을지는 의문입니다."\n요 부분에 대해서도 저희들이 전체 수강생들의 채점을 용이하게 하기 위해 어느정도 구현을 강제하게 되는 부분도 없지 않아 있는데요. 이 부분은 쪼금 양해해주시고 여유가 있으실 때 직접 해보고 공유해주시는 것도 좋을 것 같아요 ㅎㅎ\ncursor를 통해서 복잡한 로직을 구현할때는 주석을 통해 어느정도 구현을 해야 하는 부분과 수정하지 말아야 하는 부분을 정의해주시고, 테스트를 만들어서 명확하게 제어하고 변경을 감지하는게 좋다고 많이 이야기 하는데요! 빙글빙글 도는 문제 해결책이 나온다면 AI가 그 문제를 당장 그 컨텍스트 내에서 해결하지 못한다는 증상으로 본다고 하니 새로운 커뮤니케이션을 시작하는것도 방법일 것 같아요.\n\n> Q1. 페이지별 이벤트, 상태 관리, cleanup 추상화를 어떻게 해야할까요?\n현재는 Homepage.js나 ProductDetailPage.js에서 ** 각 페이지에서 이벤트 리스너, 상태 관리, cleanup을 직접 구현하고 있습니다. 그런데 페이지가 많아질수록 공통화할 부분, 추상화할 부분, 컴포넌트화할 부분이 많아지면서 어떤 기준으로 추상화하거나 모듈화하면 좋을지 고민하고 있습니다.\n\n좋은 고민입니다! 어떻게 보면 점점 규모가 커지면서 드는 자연스러운 고민일텐데요. 기준은 사실 이미 잘 만들어진 프레임워크들을 참고하는게 좋은 것 같아요. 각 리액트 컴포넌트, 뷰 컴포넌트에서는 어떤 문제를 해결하기 위해 어떻게 추상화를 했는지와 어떤 일들을 자동으로 해주는지 등을 리스트업 해보면 될 것 같아요. 거기에는 작성해주신것처럼 이벤트 관리나 상태관리, 라이프사이클, 렌더링 로직 등등이 되겠죠! 결국의 이런 추상화는 같은 수준의 이야기를 하고 있는 동작들을 응집시키는 부분이기 때문에, 리스트업 한 동작들이 어떻게 컴포넌트에 묶이는지 고민해보면 추후에 더 도움이 되지 않을까 싶어요.\n\n> Q2. SPA에서 전역 이벤트는 어떤식으로 관리하면 좋을까요?\nApp에서 globalClickHandler()함수가 앱의 전역 이벤트(?) 관리를 하고있는데 이렇게 되면..\n\n넵 맞아요! 정확한 분석입니다. 전역에서 이벤트를 관리하려고 한다면 명확한 제어를 위한 인터페이스가 필요해보이는데요. 말씀해주신것처럼 중복이벤트가 등록되지 않게 하는 것이나 특정 상황에서만 발생하게 하는 경우도 있을거구요.  어떤 기준으로 나눌 수 있는지 구분을 해보면 좋을 것 같아요. 타입화를 시키는 것도 있을것 같고, 페이지 별로 관리를 하는 것도 방법일 수 있구요. 맵이나 셋에 저장을 하면서요 ㅎㅎ \n양이 많지 않다면 이벤트 위임정도로 처리가 가능할 것 같고, 양이 어느정도 많아지면 가장 많이 쓰는 패턴으로 이벤트 버스같은 것을 만드는 것도 방법일 수 있는데 느슨하게 관리를 하면서 문제를 해결하는 것도 좋을 것 같네요.\n\n고생하셨고 다음주도 화이팅입니다!',
      enrolledId: "6825b2810a72040b8071d8af",
    },
    {
      _id: "6868a344a8a052ad61454413",
      result: "FAIL",
      isBestPractice: false,
      name: "장루빈",
      badge: "화이트",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "FAIL",
        "FAIL",
        "PASS",
        "FAIL",
        "PASS",
        "PASS",
        "PASS",
        "FAIL",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/57",
        },
      ],
      feedback:
        '안녕하세요 장루빈님, 수고하셨습니다. 이번 과제는 프레임워크 없이 SPA를 구현하면서 내부 동작 원리를 이해하는 것이 목표였습니다. History API와 이벤트 처리의 어려움을 직접 경험하신 것은 좋은 학습경험이 되어주었을거라 기대합니다.\n\n개발자의 첫 번째 책임은 요구사항을 만족하는 작동하는 코드를 제시간에 전달하는 것입니다. 현재 PR을 보면 CI 테스트가 모두 실패하고 있고, 배포 링크도 없으며, 핵심 기능인 장바구니 모달과 토스트가 구현되지 않았습니다. 따라서 채점 기준에 미치지 못했기에 "불합격"을 드릴게요.\n\n라우터 구조가 깔끔하고 코드 분리가 잘 되어있는 것은 좋지만, 기본 기능이 작동하지 않는다면 의미가 없습니다. 실무에서는 "완벽한 구조의 미완성 코드"보다 "조금 지저분하더라도 작동하는 코드"가 우선입니다.\n\n구조와 패턴은 나중에 개선할 수 있지만, 작동하지 않는 코드는 가치가 없기에 피드백을 해드릴 수도 없어요.\n\n2주차에는 코드의 퀄리티보다도 시간내의 완성!을 제일 중요하게 생각하여 진행해주기를 기대합니다.\n\n---\n\nQ) 클래스를 사용하는 이유가 궁금합니다. 개발을 하다보면 결국 객체지향형 프로그래밍을 하게 된다는데 클래스를 사용하지 않더라도 객체 지향적으로 개발하면 되지 않나요?\n\n=> 클래스를 사용하지 않아도 객체지향적으로 개발을 할 수 있습니다. 객체란 key:value 형태의 의미있는 구조체에 상태과 상태를 변화하는 메소드를 통해서 하나의 큰 프로그램을 재사용 가능한 독립적인 모듈로 나누어 메시지의 정보 교환을 통해 프로그래밍을 한는 방법론이죠.\n\n=> 객체지향에서 중요한건 독립적인 모듈들이 메시지 교환을 통해 의미있는 요구사항을 수행한다는 점인데 이를 가능하게 하려면 서로간의 메시지 교환의 규칙이 정확해야 하고 이를 인터페이스라고 합니다. 이러한 타입과 규격 인터페이스등을 정의하는 방법으로 클래스가 필요하지요.\n\n=> js는 class가 없어도 Object를 생성할 수 있지만 타입과 상속, 데코레이션등의 표현력을 가지고 있는 것이 class라고 생각해주세요. class를 쓰는 이유는 객체지향적인 프로그래밍을 해야하는 경우에는 class가 훨씬 더 나은 표현법이니까 사용합니다.\n\n\nQ)  ai를 잘 쓰는 방법이 궁금합니다. 제가 줏대가 없는걸지도 모르겠는데 "AI한테 알려주고 시키는 것도 실력이다.", "AI가 다 하면 나는 대체 가능한 사람이 되는 건데...그러면 어떤 개발자가 되야하는가" 이런 생각이 공존하는 것 같습니다.\n제가 최근 경험을 예시로 들면 최근 프로젝트에서 shardcn이라는 component/ui를 사용하게 되면서 반복적으로 작업하는 코딩은 ai를 시켜서 작성하고 주요 로직을 구현하는 쪽으로 진행을 하려고 했는데... 그렇게 되면 다른 누군가에게 shardcn사용 경험이 있다고 말 할 수 있을까?라는 생각이 들더라고요. 이것에 대한 테오의 생각이 궁금해요\n\n=> AI가 다 할 수 있는가? 만약 AI가 다 할 수 있는 시기가 정말로 온다면 그때에는 정말로 현업에 있는 모든 개발자들이 사라지겠지요. 그렇지만 아직은 누군가는 여전히 그 AI에 다 할 수 있도록 지시를 하거나 AI가 일을 잘 할 수 있도록 만드는 역할을 해야 합니다.\n\n=> AI가 다 할 수 있는 일을 한다면 당연히 대체가 되겠지요. 물론 다행히 AI는 아직 같이 술자리도 못가고 같이 놀아줄 수는 없네요. 추억을 오랫동안 함께하지도 못합니다. 사람과의 관계라는 건 중요한 역할이지요.\n\n=> 뭐 이런 감성적인 부분이 아니더라도 AI를 활용해서 무언가의 가치를 만들어내는 사람의 가치는 부정할 수 없습니다. 앞으로는 그러한 가치를 만들 수 있는 사람이 대우를 받겠지요.\n\n=> AI에게 가치있는 무언가를 만들기 위해서는 단순히 시켜서는 되지않습니다. 가령 AI가 다 할 줄안다고 "정말 재밌는 영화 대본을 써줘" 라고 한들 정말 재밌는 대본이 나올 수 있을까요? AI가 만들어내는 생산성은 인간이 하는 일의 특정한 부분에 대단한 속도를 만들어내지만 속도가 곧 생산성은 아닙니다. 더 낫게 만들기 위해서는 검증하고 뭐가 더 나은 것인지 알아야 하고 목표를 만들고 해석하고 평가하고 재할당하는 원래 하던 일들을 해야만 달성할 수 있어요.\n\n=> 물론 영화를 만들지 않고도 영화평론가가 될 수는 있습니다. 그러나 대부분의 업무를 위한 지시는 경험이 있어야 더 잘 할 수 있더라구요. AI로 인해서 개발자의 업무는 변화하고 있는 중이라고 생각합니다. 다만 아직까지 본질적인 업무인 인간의 요구사항을 이해하고 컴퓨터에게 전달하여 그 가치를 실현하는 부분에 대해서는 크게 달라지지 않은 것 같아요. 내가 뭘 해야하는지 알고 AI를 통해서 생산성을 함꼐 올려보기를 바래요.\n\n\nQ) 얼마전 멘토링에서 FE는 생각보다 빨리 고점에 도달한다고 하셨는데... 이부분 동의 합니다. 제가 물론 고점을 찍을 수 있을지는 모르겠지만 FE는 조만간 AI로 대체가 될거라고 생각해요. 그러면 BE로 가야하는가? 라고하면 그건 너무 단순한 발상인 것 같습니다.\n개발자라는 직업으로 먹고 사는게 그렇게 전망이 좋아보이진 않습니다. 테오는 어떻게 생각하세요?\n\n=> 저는 이 일로 먹고 사는 사람이기에 전망을 비관적으로 보고 싶진 않습니다. 안타까운건 제가 그동안 배웠던 스킬들로만 먹고 살기는 힘들것 같네요. 마치 예전에는 IE버전마다 크롬과의 CSS가 다르게 나와서 그걸 잘하는게 능력이었는데 지금은 전혀 중요하지 않은 스킬이 되었죠. AI가 점점 더 내가 잘하지 않아도 되도록 해주는 역할을 담당하게 될 것이라는 점에서는 동의 합니다.\n\n=> 그렇다고 해도 FE가 AI로 전부 대체될수는 없습니다. 인간의 언어는 모호하고 막연하게 설계가 되어 있기 때문에 여기서 조금만 더 세련되게 만들어달라 라는 말을 100% 정확하게 해석할수가 원천적으로 할 수가 없습니다. 분명 누군가는 그 말을 더 구체적인 언어로 만들어야 해요. 우리가 0과1 로 혹은 기계어로 코딩을 하진 않지만 최소한 언어로는 작성해야하는 것처럼 한 단계 더 높은 레이어의 고급 언어를 가질 수는 있겠지만 지금의 자연어로는 절대 안됩니다.\n\n=> 개발자라는 직업의 가치는 저도 예측이 어렵네요. 그렇지만 분명 지금까지 현재 인간의 돈이 몰리고 있는 분야에 과학과 공학 그리고 IT의 쏠림 현상은 존재하기에 개발자라는 직업 자체가 유망하지 않을거라고 생각지는 않습니다. FE의 유망세는 잘 모르겠지만요.\n\n=> 모두가 1등이어야 하는 건 아니니 그래도 이 분야가 재밌고 즐겁다면 도전해보세요. 최우선은 자기가 제일 잘 할 수 있는지 자기 재능의 영역을 찾는 것이고 그걸 잘 모르겠다면 그래도 재밌는걸 해야 하지 않겠습니까? 잘 찾아가길 바랍니다.\n\nQ) 코드가 전반적으로 구조를 잘 짰다고 보기엔 어려운 것 같습니다. 하지만 제가 회사에서 사용하는 작성법과 크게 다르냐 하면 아닌 것 같습니다. 그런부분에서 봤을 때 구조를 잘 만들려면 어떤 부분을 고려해서 만들어야하는지 3가지만 알려줄 수 있을까요?\n\n=> 다음 번 과제는 구조보다 완성을 해오세요. 그러면 알려줄게요. (웃음) 너무 매정한것 같이 힌트를 드리자면 그리고 정답은 이미 쓰고 있는 React에게 답이 있어요. 10년에 걸쳐서 정답을 찾아온 과정이잖아요?\n\n\n수고하셨습니다. 화이팅입니다!',
      enrolledId: "682578680a72040b803edb7c",
    },
    {
      _id: "6868a344a8a052ad61454415",
      result: "FAIL",
      isBestPractice: false,
      name: "이의찬",
      badge: "화이트",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "FAIL",
        "PASS",
        "FAIL",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/15",
        },
      ],
      feedback:
        "넵 의찬님 이번에는 과제 하실 시간이 부족하셨던 것 같습니다 :)\n나중에 솔루션 코드가 나오면 코드를 살펴보시고 복기하시는 시간을 꼭 가지시면 좋을 것 같아요!\n",
      enrolledId: "682576d80a72040b803dc418",
    },
    {
      _id: "6868a344a8a052ad61454417",
      result: "PASS",
      isBestPractice: false,
      name: "이지현",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/27",
        },
      ],
      feedback:
        '안녕하세요 지현님!\n1주차 과제 잘 진행해주셨네요 ㅎㅎ 너무 고생했어요!\n\n> 어떤 우선순위로 기본 구조를 잡는가에 대해서 궁금증이 일어, 준일 코치님 멘토링때 질문을 드렸었습니다. 야근으로 인해 알려주셨던 구조를 잡지 못해 아쉬운 점이 큽니다.\n\n제가 이야기 했던게 정답은 아니라고 생각해요! 저의 경험적인 측면이니까요. 개인적으로, 나만의 경험을 만들어가는게 중요하다고 생각합니다! 이미 진행해보셨으니까 제가 제안하는 순서보다 지현님께서 "이렇게 하는게 더 좋을 것 같은데?" 라고 생각하는 리팩토링 과정이나 순서가 있으면 그대로 시도해보시는걸 추천드려요!\n\n그래야 온전한 나의 것이 된답니다!\n\n> 리팩토링 순서에 대해서 문의드립니다. 이벤트 시스템 > 컴포넌트 라이프 사이클 시스템 > 상태관리 시스템 > 관련 라우팅 시스템 순서가 괜찮을까요?\n\n굳이 저의 기준으로 순서를 정해보자면..\n\n무엇이 제일 중요한가 따져봤을 때, 저는 상태관리 시스템이라고 생각합니다 ㅎㅎ\n\n상태관리 > 라이프 사이클 > 이벤트 시스템> 라우팅 시스템\n\n이런 순서랄까..\n왜냐면 상태에서 부터 렌더링이 전파되고,\n상태를 잘 만들어놓으면 이벤트에서 상태만 변경해도 UI에 반영될 수 있으니까요 ㅎㅎ\n\n',
      enrolledId: "682566140a72040b80300e04",
    },
    {
      _id: "6868a344a8a052ad61454419",
      result: "FAIL",
      isBestPractice: false,
      name: "신희원",
      badge: "화이트",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "FAIL",
        "FAIL",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/16",
        },
      ],
      feedback:
        "희원님 수고하셨습니다!\n\nQ. 지금 폴더 구조에 대한 체계적인 개선을 하지 못하고 개발을 진행했었는데, 여기서 개선된다면 어떤 구조로 정리 해보기를 추천하시나요?\n\n지금 과제는 폴더구조가 많이 중요하진 않을 것 같아요~지금으로도 충분해보입니다. 더 개선해야할 부분은 보이지 않는 것 같아요 다른 것을 제안드릴 순 있지만 더 나은 것은 아닐것같아요. 지금도 충분합니다 :)\n\nQ. 위와 관련한 질문인데, 어떤 개념을 공부하면 좋을지 피드백 부탁드립니다.\n\n요즘은 FSD라는 방법론이 많이 논의되고 있어요.\nFSD자체가 뭐 끝판왕은 아니지만 FSD가 어떤 고민이 있었고 그 고민과 문제를 어떻게해결했는지를 이해하는 것은 큰 도움이 될 것 같습니다~\n\nQ. main.js 함수에서 이벤트에 대한 핸들러 함수를 만들었는데, 렌더링이 된 후 이벤트 위임하는 코드를 넣어줬습니다. (cursor이용) 보통은 렌더링이 된 후, 이벤트를 위임시키는 함수를 적용하는게 맞는 것인지 궁금합니다. (아직까지 AI가 짜주는 코드가 좋은 코드인지 아닌지 구분하는게 어렵습니다.)\n\n이벤트 위임(event delegation)은 렌더링 후에 적용하는 것이 맞습니다. 이는 DOM 요소가 실제로 존재해야 이벤트를 바인딩할 수 있으니까요~ 이벤트 위임이라는 기법은 상위 컨테이너에 이벤트 리스너를 붙이고, 이벤트가 발생했을 때 특정 조건(예: cursor나 dataset 속성 등)을 기반으로 이벤트 핸들러를 호출합니다. 이런 방식은 여러 개의 자식 요소가 동적으로 생성될 때 성능과 관리 측면에서 효율적이에요~ 사실 나중에 배우시겠지만 근본적으로는 리액트도 이 방법을 활용하고 있습니다!\n\n\n저도 vscode를 사용하지 않아서요 ㅜㅜ 익스텐션관련해서는 준일님에게 물어보시면 좋을 것 같아요!",
      enrolledId: "68254af40a72040b801869c8",
    },
    {
      _id: "6868a344a8a052ad6145441b",
      result: "PASS",
      isBestPractice: false,
      name: "이유진",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/71",
        },
      ],
      feedback:
        "유진님 수고하셨습니다!\n\n회고에서 말씀하신대로 이번 기회로 SPA의 기본적인 동작원리와 DOM API 활용법에 대한 이해가 높아진 것으로도 충분한 것 같습니다.\n이런 몰입의 경험을 더 많이 경험하시면 좋을 것 같습니다 :)\n이대로 이과제를 넘기시지 마시고 솔루션 코드가 나오면 코드를 살펴보시며 다시 한번 복습해주시면 좋을 것 같습니다!",
      enrolledId: "682546800a72040b80150daf",
    },
    {
      _id: "6868a344a8a052ad6145441f",
      result: "PASS",
      isBestPractice: false,
      name: "박소연",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/17",
        },
      ],
      feedback:
        '안녕하세요 박소연님! 수고하셨습니다. :) \n\n이번 과제는 프레임워크 없이 SPA의 핵심 기능들을 직접 구현하면서, 현대 프론트엔드 프레임워크들이 해결하고 있는 문제들을 깊이 이해하는 것이 목표였습니다. 우리가 그냥 쓰고 있는 도구들을 직접 만들어 보며 그 작동원리를 이해하면서 우리의 도구를 더 잘 쓸 수 있게 되기를 바랍니다.\n\n과제를 보면서 특히 Pub/Sub 패턴을 활용한 반응형 상태 관리 시스템 구현이 인상적이었습니다. React의 useState와 유사한 방식으로 구현하신 점, 그리고 이에 대한 한계점까지 명확히 인지하고 계신 점이 훌륭합니다. 또한 테스트 코드를 모두 통과시키며 요구사항을 충실히 구현하신 점도 잘하셨습니다.\n\n스스로 작성해둔 라우터의 복잡성 문제나 subscribe를 해제하는 부분이 없는 것에 대한 반성(?)도 좋았습니다. 만약 아는데 어떻게 해야할지 잘 모르겠다면, 그래도 한번 시도를 해보고 피드백을 받아 본다면 앞으로 과제할 때 조금 더 잘 피드백을 드릴 수 있겠네요\n\n회고에서 "오랜만에 신입때처럼 몰두해서 개발했다"는 말씀이 인상 깊었습니다. 이런 열정과 도전 정신이 있다면 앞으로도 계속 성장하실 수 있을 것입니다. 2주차도 화이팅입니다! :)\n\n다음은 질문 주신 내용에 대한 구체적인 답변입니다.\n\n---\n\nQ) router 함수를 어떻게 분리해야 할까요?\n\n=> 이미 스스로 주석을 하나씩 달아두었고 스스로 평가하기를 너무 많은 책임을 가지고 있다고 말하는 것처럼 책임과 하나의 책임에 대한 적절한 크기감각은 이미 있는 것 같네요. 그런 쎄함(?)을 느끼면 우선 크기를 나눠줄 생각을 먼저 합시다. 책임을 너무 잘 분리하지 않아도 좋으니 우선 주석을 달아준 그 구간을 분리해서 함수로 빼내는 일을 먼저합니다.\n\n=> 함수로 분리를 하는건 간단합니다. 우선 함수로 감싸고 밖으로 보낸다음 모든 인자만 연결하면 되죠. 심지어 이런건 VSCode에 기능으로도 제공하고 있습니다.\n\n1)\nfunction outerModule() {\n // 원래 코드\n}\nouterModule()\n\n2) 인자 맞춰주고 바깥으로..\nfunction outerModule(a,b,c) {\n // 원래 코드\n}\nouterModule(a,b,c)\n\n=> 그렇게 잘라두고 나면 조금 더 잘 보입니다. 책임에 맞게 분리했는데 괜한 분리를 했는지. 그리고 모듈을 분리하면 해당 로직을 내부에 두는게 맞는지 외부에 위임해야 하는게 맞는지 알 수 있습니다. 특히나 내가 새롭게 라우트를 만드는데 불필요하게 또 적어줘야만 하는게 있는지 정말 내가 적어주지 않으면 안되는 것들로만 구성이 되어 있는지 말이죠..\n\n설명이 엄청 길어질것 같아서 우선 다음번 과제에서는 이런 부분을 만나면 과감하게 함수를 분리해서 책임을 나눠보세요. 우선 시도를 해야 그 다음 피드백을 받을 수 있겠지요. 화이팅입니다 :)\n\n\nQ) 컴포넌트 의존성 주입 패턴 개선 방안\n\n=> 지금 주입받고 있는 공톨 모듈을 받아 줄 수 있는 Context 패턴을 고려해보세요. 의존성들을 하나의 context 객체로 묶어 전달하면 됩니다. 이런 경우 모두에게 의존하게 하는게 아니라 중간 담당자를 두면 변화를 한군데에서 관리를 할 수 있게 됩니다.\n\n```javascript\nconst context = { state, setState, actions: { openCartModal, addToCart, navigateTo } };\npage = ProductListPage(context);\n```\n\nQ) Pub/Sub 패턴 구현의 성능 최적화\n\n=> React의 경우 지금처럼 모든 상태를 1개씩 전달하나 불변성을 통해서 비교의 횟수를 줄이는 방법이고 사실 React는 성능을 희생하고 DX를 높이는 방법을 택했죠.\n\n=> React가 아닌 Vue를 비롯한 다른 모든 프레임워크들은 각 key, path별로 여러개의 pub/sub를 통해서 최소한의 업데이트만 할 수 있도록 만들고 있습니다. 하나의 setState가 아니라 여려개의 signal을 만들수 있겠죠. \n\n\nQ) Router 코드 역할 분리와 복잡성 개선\n\n=> 라우터를 단순히 라우팅만 담당하도록 하고, 페이지별 초기화 로직은 각 페이지 컴포넌트의 생명주기 메서드로 이동시키세요. 예를 들어:\n```javascript\nclass Page {\n  onMount() { /* 초기화 로직 */ }\n  onUnmount() { /* 정리 로직 */ }\n}\n```\n이렇게 하면 라우터는 단순히 페이지 전환과 생명주기 호출만 담당하게 됩니다.\n\n다 아는 패턴이죠? 만들다보면 그렇게 나오는 고민들이 이미 세련된 해법으로 우리가 잘 쓰고 있죠. 모를때에는 내가 아는 정답(!)을 참고해보세요.\n\n\n수고하셨습니다! 다음 주차도 화이팅입니다! :)',
      enrolledId: "6824c3ac0a72040b80cbc2a3",
    },
    {
      _id: "6868a344a8a052ad61454423",
      result: "PASS",
      isBestPractice: false,
      name: "유윤우",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/10",
        },
      ],
      feedback:
        '안녕하세요 유윤우님, 프레임워크 없이 SPA를 구현하시느라 정말 수고하셨습니다. 이번 과제는 React나 Vue 같은 프레임워크가 내부적으로 해결하고 있는 라우팅, 상태관리, 렌더링 최적화 등의 문제를 직접 경험해보는 것이 목표였습니다. 참고 자료 없이 순수하게 도전하신 점이 정말 인상적이네요.\n\n특히 잘하신 부분은 `createState`를 통한 전역 상태 관리 구현과 이벤트 위임 패턴의 활용입니다. `src/utils/store.js`에서 Map을 활용한 상태 저장소 구현은 간결하면서도 효과적입니다. 또한 페이지별 라이프사이클을 `onMount`/`onUnmount` 메서드로 구현하신 아이디어도 좋았습니다.\n\n조금 개선을 해야할 부분이 있다면 현대 프레임워크의 핵심 구조인 데이터와 렌더링의 책임을 완전히 분리하고 데이터가 변경이 되면 자동으로 렌더링을 해준다라는 것을 구현이 되었다면 좋았을 것 같네요. 현재는 데이터의 처리와 화면을 그리는 과정이 하나의 프레임워크로 만들어지지 않았기 때문에 코드 곳곳에서 수동으로 updateCurrent()가 여러 곳에서 호출되고 있네요.\n\n이러한 점은 개발자의 DX측면에서도 혹은 불필요한 업데이트를 여러번하게 만들 수 있는 패턴이니 setState와 render의 책임을 core로 주도록 만들어 보는 건 어떨까요?\n\n나아가 현재 렌더링, 이벤트연동, 로직처리 등의 레이어 분리 구조까지는 되어 있으나 이를 하나로 묶어주는 컴포넌트 단위로 만들 수 있는 구조가 없다보니 결과적으로 events.js가 너무 비대해졌죠.\n\n작성해야하는 코드 중 내가 꼭 이걸 써야 해? 하는 부분을 core로 넘겨주고 관련이 없는 코드가 한 군데 같이 있지 않도록 만들어주는 법을 다음번 과제를 통해 해결해보기를 바랍니다!\n\n---\n\nQ) 코어한 기능에 문제가있는데 조금만 건드려도 문제가 다발적으로 터지는 상황에서 리팩토링을 진행하시는 플로우가 궁금합니다.\n\n=> 우선 코드를 작게 만드는게 제일 중요합니다. 코드가 커질 수록 생각해야하는 경우의 수가 많죠. 그러니 문제는 없지만 코드를 작게 만드는게 제일 중요합니다. 나중에 발제로 만나게 될거라 설명하면서 너무 길어지므로 AI에게 "지금 이 코드를 순수함수로 최대한 많이 단일 책임의 의미단위로 분리해줘"라고 한번 해보시고 코드의 변화가 없이 코드를 잘게 쪼갠다는게 무슨 의미인지 아실꺼에요.\n\n=> 그 다음은 이러한 문제 없는 코드들의 순서를 통해서 코드를 만들어가면 내가 결과적으로는 큰 코드를 만들지만 작은 코드를 다루게 되면서 다발적 에러 발생을 줄일 수 있습니다.\n\n\nQ) 이벤트 위임 코드 개선 방법이 궁금합니다.\n\n=> 해당 코드는 단순히 위치의 문제입니다. 해당 코드들이 꼭 events.js에 모여있어야 할 필요는 없죠. 관련있는것들은 최대한 가까이 둔다는 원칙에 맞게 적절히 이벤트가 필요로 하는 곳에 분리를 해보세요. 그것만으로로 충분히 응집도를 높이 좋은 코드가 될거에요.\n\n\nQ) 리렌더링 플로우를 정상적으로 만들려면?\n\n=> 상태의 변경 -> 변화 감지 -> 자동 렌더링이 될 수 있도록 setState의 함수의 역할을 늘리는 방식으로 만들어야 합니다. 이 과정에서 변하지 않아도 될 부분은 유지하고 변화해야 하는 부분만 수정하는 게 프레임워크의 주요 알고리즘이고 그걸 다 구현한다는건 쉽지 않겠지만 이제 앞으로 배우게 될 부분이라 다음 과제를 기대해주세요!\n\n수고하셨습니다. 2주차도 화이팅입니다! :)',
      enrolledId: "68249f4e0a72040b80b3568e",
    },
    {
      _id: "6868a344a8a052ad61454425",
      result: "",
      isBestPractice: false,
      name: "임규원",
      badge: "화이트",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "FAIL",
        "",
        "PASS",
        "FAIL",
        "PASS",
        "PASS",
        "FAIL",
        "FAIL",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "",
        },
      ],
      feedback: "",
      enrolledId: "68247d1b0a72040b8094ff55",
    },
    {
      _id: "6868a344a8a052ad61454427",
      result: "PASS",
      isBestPractice: false,
      name: "최재환",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/42",
        },
      ],
      feedback:
        "안녕하세요 재환님!\n1주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다.\n\n> Router 클래스의 동적 라우팅\n\n동적 라우팅 구현이 쉽지 않았을텐데 잘 해주셨군요 ㅋㅋ 다만 for/if가에 대한 중첩이 많이 있어서 별도의 함수로 조금 더 추상화하면 좋았을 것 같아요!\n\n```js\ngetParams() {\n  const path = this.getCurrentPath();\n  const params = {};\n\n  for (const routePath in this.routes) {\n    if (routePath.includes(':')) {\n      const routeParts = routePath.split('/');\n      const pathParts = path.split('/');\n      \n      if (routeParts.length !== pathParts.length) {\n        continue;\n      }\n\n      const { isMatch, current } = getParam(...);\n\n      if (isMatch) {\n        return { path: current.routePath, params: current.params };\n      }\n    }\n  }\n  return { path, params };\n}\n```\n이런느낌!?\n\n> 이벤트 핸들러가 단일 함수에 모든 이벤트 처리 로직이 집중되어 가독성과 유지보수성이 떨어집니다.\n\n이에 대한 부분은 이벤트 핸들러를 직접적으로 사용하는게 아니라, 함수를 통해 간접적으로 호출할 수 있도록 해주면 좋답니다 ㅎㅎ\n\n```jsx\naddEvent('click', '.add-to-cart-btn', callback)\n```\n\n이렇게 사용하는 모습을 상상해보시면 좋아요!\n\n> E2E 및 단위 테스트의 명세와 요구사항 간의 간극이 아쉬웠습니다. 요구사항을 토대로 개발한 후 테스트의 명세를 맞추는 것이 쉽지 않았습니다.\n\n이런 어려움이 있었군요 ㅠㅠ 2주차 ~ 3주차 과제에서는 같은 어려움을 겪지 않도록 신경쓰도록 하겠습니다..!\n\n> main.js 파일 분리 계획 피드백\n\n개인적으로 A방안은 응집도가 떨어지는 방식이라고 생각해요 ㅎㅎ\n비슷한 관심사를 다루는 것들끼리 묶어놔야 응집도가 좋아지고 유지보수 할 때 편하다고 생각합니다.\n\n다만 AppController나 ProductController 를 사용하는 방식도 A에 비해선 좋지만 응집도가 높다고 생각하진 않아요.\n\n이벤트 연결을 해주는 구간과 이벤트에 필요한 함수를 정의 해주는 구간을 분리하고\n\n이벤트에 필요한 함수와 컴포넌트 코드와의 거리를 가깝게 유지하면 어느정도 해소되지 않을까 싶네요!\n\n> 문자열 기반 컴포넌트 렌더링의 개선 방안\n\nA와 B 모두 각각의 장단점이 있다고 생각합니다 ㅎㅎ\n개인적으로 B 방식을 더 선호하는데요,\n저는 \"선언형 프로그래밍\"을 해야 코드의 가독성이 좋아지고 유지보수 할 때 더 효과적이라고 생각합니다.\n\n이에 더 가까운게 B 방식인데, 만약에 A 방식처럼 하면서도 선언형 프로그래밍을 유지할 수 있는게 있다면... 그 방식을 택할 것 같아요. 다만 아직까진 못찾았어요 ㅋㅋ\n",
      enrolledId: "68245c9b0a72040b807c704a",
    },
    {
      _id: "6868a344a8a052ad61454429",
      result: "PASS",
      isBestPractice: false,
      name: "김민지",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "FAIL",
        "FAIL",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/35",
        },
      ],
      feedback:
        "민지님 첫 과제 고생많이 하셨습니다.\n회고 남겨주신걸 보니 약간 힘들어보이시는데요 ㅎㅎㅎ\n너무 자신감을 잃지 않으셨으면 좋겠네요.\n과제 자체가 양이 많기도 했고 정신이 없는 상황이 많기도 했구요.\n결국 중요한건 굉장히 많은 비즈니스 로직을 구현하는 것 보다는 민지님이 남겨주신 회고처럼 어느 부분에서 어려움을 겪었는지 다시 정확히 정리해보고 내가 사용하는 프레임워크에서는 또는 기술에서는 이걸 어떻게 해결하는지 찾아보는 것 같아요. \n문제 겪으신 부분을 리액트나 뷰에서는 이런 과정을 명확하게 하기위해 어떻게 관리하는지, 라이프 사이클은 어떻게 제어할지 그런 고민들을 해보면 좋을 것 같아요. 말씀해주신 렌더링 과정에 대한 이해도 포함이 되겠죠. 그리고 그 내용을 다시 본인의 코드로 옮기는 연습을 하는거죠. 사실 저건 해당 문제를 해결하기 위한 각 프레임워크의 해결책이고 정답은 아니니 제것에 맞게 옮기는 연습을 하는게 중요한 것 같아요.\n여담으로 저도 늘 어렵지만, 테스트 코드에서 라우터 이동을 감지 못해서 그런줄 알고 많은 시간을 쏟으셨지만 알고 보니 바인딩 이슈였던 것 처럼  문제를 명확하게 정의하는 연습도 함께 하면 더 시간을 아낄 수 있지 않을까 싶어요. 추측은 그 과정에서 배우는 것은 많겠지만 실패했을 때 낭비되는 시간이 너무 많은 것 같아서요. 문제를 명확하게 하고 움직이는 걸로 ㅎㅎ\n\n고생하셨고 충분히 잘하셨으니까 다음주도 화이팅하시구요! 이번주에 부족하다고 느끼셨던 부분들도 그냥 넘기지 말고 잘 모아둔다음 시간 여유가 생길때 꼭 해결해보는 습관 만드시면 좋겠습니다~",
      enrolledId: "68245a760a72040b807a5c2c",
    },
    {
      _id: "6868a344a8a052ad6145442b",
      result: "PASS",
      isBestPractice: false,
      name: "오하늘",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/59",
        },
      ],
      feedback:
        "하늘님 수고하셨습니다!\n\n라이프 사이클 함수는 실행 위치가 중요하기 때문에 말씀하신 대로 정해진 위치에서 반복적이지만 if문을 활용해서 체크하는 수밖에 없을 것 같아요.\n만약 정해진 위치가 없고 단순히 정해진 함수만 실행한다면\n[‘init’, ‘mount’, ‘unmount’].forEach(k => Page[key]?.()) 이런식으로 할 수 있겠죠?\n일단 저는 저렇게 생각하는데요 해당 부분은 vue의 코드를 살펴보시면 참고가 될 수 있을 것 같아요!\n어떻게든 if문을 제거해 동작하는 코드를 만들 수는 있겠지만 배보다 배꼽이 더 커보입니다. ㅎㅎ",
      enrolledId: "682457100a72040b80776d24",
    },
    {
      _id: "6868a344a8a052ad6145442d",
      result: "PASS",
      isBestPractice: false,
      name: "최용훈",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "FAIL",
        "PASS",
        "PASS",
        "PASS",
        "FAIL",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/24",
        },
      ],
      feedback:
        '안녕하세요 최용훈님, 과제 수고하셨습니다. 이번 과제는 프레임워크 없이 순수 JavaScript로 복잡한 SPA를 구현하면서, 현대 프레임워크들이 해결하는 문제들을 직접 경험해보는 것이 목표였습니다. \n\n각 파일들이 너무 커지지 않도록 역할별로 책임을 나누고 폴더와 파일을 분리를 열심히 나눠준 부분은 참 잘했습니다. 하나의 파일이 너무 커지고 책임이 많아진다면 관리를 하기 어려울테니까요.\n\n현재 코드에서는 안 써도 될 코드들 가령 render()와 같은 부분들을 자동화 할 수 있도로 코드의 책임을 안쪽으로 위임할 부분과 꼭 적어야하만 하는 상태, 템플릿, 이벤트 등을 분리하는 작업과 현재 역할과 계층으로 분리해둔 것과는 별개로 Product, Main등 Route별로, 화면별로, 데이터 별로도 모아서 관리할 수 있도록 구조를 만들어보는 것까지도 목표로 남은 주차들 잘 진행해보시기 바랍니다.\n\n---\n\nQ) 간만에 바닐라로 코드를 작성하다 보니, 디렉토리 구성과 함수 분리에 시간 투자를 하지 못했습니다.\n\n전반적으로 시간에 쫓기면서 기능 구현을 하다보니, 스스로의 코드를 찾아서 수정하는 것 조차 버겁다는 느낌이 들었습니다.. 앞으로 초기 프로젝트 설계 관점에서 기본적으로 확립할 방향과 리팩토링 진행 시, 최소한의 방향성에 대하여 피드백 부탁드립니다...!\n\n=> 우리가 만들고자 하는 과정에 이미 정답지가 있답니다 바로 React죠! 스스로 생각을 해보다가 막히게 되면 한번 그냥 interface나 모양, 구조들을 그냥 한번 따라가보세요. 왜 이렇게 만들었을까? 하면서 그 배경을 따라가다 보면 얻을 수 있는게 많을 거에요. 그간 10년간의 FE들의 시행착오의 집약체이니까요.\n\n=> 하지만 또 VDOM, 이벤트 델리케이트, hook은 상당히 추상화 기능이 깊은게 있다보니 짧은 시간 SPA를 만들어 보기에 이걸 다 만들어내기는 부담스러울수도 있죠. 그럴때는 Vue등에서 사용되는 Signal을 참고해보는 것도 좋겠습니다. React가 아닌 프레임워크는 전부 Signal을 기반으로 하고 있으니까요.\n\n=> 나머지 Router나 기타 형태들은 npm에서 가장 많이 쓰이는 라이브러리에서 특히나 사용자에게 제공하는 interface를 유지하면서 이걸 어떻게 만들 수 있을까? 이렇게 한번 생각해보시면 좋겠습니다.\n\n\nQ) 이벤트 분리와 등록/해제 시점에 대해 피드백 부탁드립니다. 렌더 함수가 돌때마다 렌더 함수의 시작, 끝에 해제/등록을 진행헀지만, 핸들러 함수가 많아질 수록, 혼란스러움이 커지는 것 같습니다...\n\n=> 이렇게 열고 닫고 하는 식의 것들이 참 많죠. 이런한 경우에는 cleanup 함수로 반환하는 방식을 자주 사용하곤 합니다. useEffect를 한번 떠올려 보세요.\n\nfunction useEventListener(target, fn, options) {\n   target.addEventListener(fn, options)\n   return () => target.removeEventListenr(fn, options)\n}\n\n와 같이 만들어 둔다면 기존에 있던 내용이 뭐든지 상관없이 다음과 같이 사용할 수 있습니다.\n\nconst cleanup = useEventListener(window, "click", () => {})\n\ncleanup() // 을 호출하면 해제 가능.\n\n\n그렇다면 이게 \n\nconst cleanups = [\n  useEventListener(window, "click", ...) \n  useEventListener(window, "click", ...) \n  useEventListener(window, "click", ...) \n  useEventListener(window, "click", ...) \n]\n\ncleanups.forEach(fn => fn()) 이런 방식이거나 심지어 이것 또한 등록하고 해제하는 것을 cleanup 방식으로 만들 수 있겠죠.\n\n위와 같이 해야할 동작을 미리 기술하고 함수로 리턴하여 lazy하게 사용할 수 있도록 만드는 방법들은 js를 잘 쓰는 자주 쓰이는 기법중에 하나니 잘 응용할 수 있으면 좋겠네요. \n\n좋은 경험이 되었기를 바랍니다. 2주차도 화이팅입니다. 수고하셨습니다.',
      enrolledId: "682334f50a72040b80ba7b91",
    },
    {
      _id: "6868a344a8a052ad6145442f",
      result: "PASS",
      isBestPractice: false,
      name: "주산들",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/14",
        },
      ],
      feedback:
        "산들님 수고하셨습니다!\n\n* 지금 폴더 구조에 대한 체계적인 개선을 하지 못하고 개발을 진행했었는데, 여기서 개선된다면 어떤 구조로 정리 해보기를 추천하시나요?\n\n저는 간단한 웹사이트를  구성할때 초기 디렉토리는\ncomponents, pages, utils, store 이정도만 구성해두고 필요하면  분기해나가는 편입니다. \n저라묜 지금 구조에서 entity라는 그룹핑은 필요 없었을 것같아요~\n\n\n* cart modal 이나 toast 같은 부분은 전역적으로 관리를 하고 싶었는데 그러려면 여기서 어떻게 작업해 보는 게 좋을까요? 어떤 파일에 넣으면서 시작해야 하나요?\n\n정말 다양한 방법이 있을 수 있을 것 같은데요.\ntoast를 예들들면 toast provider라는 컴포넌트를 루트래밸에 먼저 렌더링해둘 것 같아요. 이럴려면 render.js에서 뭔가 처리가 필요하겠죵?\n그리고 toast provider는 store의 toast등의 적절한 상태를 구독해두고 거기에 상태가 들어오면 해당 상태로 토스트를 띄우도록 처리할 것 같습니다~\n\n* 장바구니 modal을 구현할 때 일부만 리렌더링을 시킬 수 없을 것 같아(비효율적이고 성능에 좋지 못할 것 같아서) 일단은 요소의 content를 변경하는 형태로 작업을 하여 UI를 갱신하였는데, 지금의 구조에서 화면의 일부만 랜더링이 될 수 있도록 하는 최적화 로직을 추가할 수 있을까요?\n\nCartModal을 말씀하시는 것이라면 지금 구조에서는 렌더링 최적화는 굉장히 제한적일 것 같아요~ 향후 버츄어돔울 구현하는 과제를 통해 해결해보시는게 좋을 것 같습니다!\n그것이 아니라면 렌더링을 html단위가 아니라 dom api를 활용해서 렌더링해서 기존의 엘리먼트들을 업데이트해야할 것 같습니다!",
      enrolledId: "6821d2570a72040b80c25f8c",
    },
    {
      _id: "6868a344a8a052ad61454433",
      result: "FAIL",
      isBestPractice: false,
      name: "한아름",
      badge: "화이트",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "FAIL",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/67",
        },
      ],
      feedback:
        "한아름님 수고하셨습니다.\n\n* 이번 과제를 통해 전역 상태에 대해 많은 고민을 했는데, 그중 제일 고민한 부분은 장바구니 상태입니다. 장바구니의 초기 상태는 화면의 맨 처음부터 받아오고, 모든 페이지가 인자로 받아야 하는 값이라 생각되어 funciton main() 부분의 맨 상단에 작성했는데, 장바구니 상품 수가 바뀐 후 url이 바뀌면 장바구니의 상품 수가 다시 초기 상태로 돌아가는 오류가 발생했습니다. 장바구니처럼 모든 페이지에서 관리할 수 있는 상태는 어떤 방식으로 구현해야 하는지 알고 싶습니다!\n\n제가 질문을 제대로 이해하지 못하는 것 같은데요!\n과제를 보면 장바구니의 상태는 전역적으로 관리되면 좋은 것 같습니다.\n그래서 스토어를 별도로 두고 렌더링과 상관없이 장바구니 상태가 데이터로 유지될 수 있게 구현하고\n장바구니에 관심있는 UI들은 스토어의 상태를 참조하는 형태로 구현하면 될 것 같습니다!(장바구니 목록과 장바구니 아이콘 갯수등)\n\n* 전체적인 관리 구조를 어떻게 짜야 하는지 의문점이 많이 생기는 과제였다고 생각합니다. 이번 과제처럼 여러 기능이 있는 페이지를 순수 자바스크립트만으로 구현할 때 이상적인 폴더 구조, 파일 구조가 어떻게 되는지 대략적으로라도 알고 싶습니다!\n\n파일구조는 크게 중요하지 않을 것 같은데요!\n\n저는 간단한 웹사이트를  구성할때 초기 디렉토리는\ncomponents, pages, utils, store 이정도만 구성해두고 필요하면  분기해나가는 편입니다. \n\n이상적인 폴더구조는 사실 없는 것 같아요 ㅎㅎ 그때그때마다 달라서요.\n\n요즘은 FSD라는 방법론이 많이 논의되고 있어요.\nFSD자체가 뭐 끝판왕은 아니지만 FSD가 어떤 고민이 있었고 그 고민과 문제를 어떻게해결했는지를 이해하는 것은 큰 도움이 될 것 같습니다~",
      enrolledId: "68205c830a72040b80c72cf1",
    },
    {
      _id: "6868a344a8a052ad61454435",
      result: "PASS",
      isBestPractice: false,
      name: "김수현",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/39",
        },
      ],
      feedback:
        '안녕하세요 수현님~\n1주차 과제 잘 진행해주셨네요!! 너무 고생 많으셨어요.\n\n> 무한 스크롤 부분에서 스크롤이 내려올 때 다시 그 스크롤의 위치를 기억하고 render을 진행하게 되는데 이 방법 말고 다른 방법이 있을까요?\n무한 스크롤은 구현이 되지만 다시 render을 하는 점에서 너무 무겁게 느껴지고 ui 상에서 매끄럽게 이어지지 않습니다. 이 부분에 대해 다시 코드를 짜보려 했는데 시간이 부족해서 못 해봤습니다 ㅜㅜ\n\n이건 API 와의 연계가 필요해요 ㅎㅎ\n스크롤 위치와 현재 위치에 도달했을 때의 query를 기억하고,\n새로고침을 했을 때 query와 limit을 기반으로 최초에 렌더링 할 때 필요한 데이터를 API로 불러와야 합니다. \n즉, 렌더 함수만 어떻게 한다고 될 문제는 아니고 router, api 등 다양한 장치와의 연계가 필요해요.\n\n> 다만, AI가 제시하는 코드를 무조건 사용하는 것이 아니라, "이 코드가 왜 이렇게 동작하는지 이해하고 사용해야 한다"는 점도 중요하다는 걸 느꼈습니다.\n\n중요한 지점이네요 ㅎㅎ 그래서 저는 앞으로 AI를 사용할 때 기본기가 더 중요하다고 생각해요. AI가 생성하는 코드는 더 많고 다양해질 것이고, 그 코드가 서로 어떻게 상호작용하는지 연계되는지 이해하지 못하면 지금 당장의 문제는 해결할 수 있어도, 리스크가 점점 커질 수 있으니까요!\n\n',
      enrolledId: "681dd962e7dc2519a9b4585f",
    },
    {
      _id: "6868a344a8a052ad61454437",
      result: "FAIL",
      isBestPractice: false,
      name: "김소희",
      badge: "화이트",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "FAIL",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/74",
        },
      ],
      feedback:
        "소희님 이번에는 과제 하실 시간이 부족하셨던 것 같습니다 :)\n나중에 솔루션 코드가 나오면 코드를 살펴보시고 복기하시는 시간을 꼭 가지시면 좋을 것 같아요!",
      enrolledId: "67cae59e3255d88e88383b13",
    },
    {
      _id: "6868a344a8a052ad61454439",
      result: "PASS",
      isBestPractice: false,
      name: "김지혜",
      badge: "블루",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "PASS",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/72",
        },
      ],
      feedback:
        "- 컴포넌트 간 의존성 분리: 현재 Home.js와 Cart.js에서 cartStore에 직접 의존하고 있어서 테스트하기 어렵고 재사용성이 떨어집니다. 컴포넌트들이 서로 너무 밀접하게 연결되어 있어서 나중에 수정하기 어려울 것 같습니다. 컴포넌트들을 더 독립적으로 만들 수 있는 방법이 있을까요? 예를 들어 Cart 컴포넌트를 다른 프로젝트에서도 사용할 수 있도록 만들려면 어떻게 해야 할지 궁금합니다.\n\nCart컴포넌트를 일반적인 장바구나 형태로 구현해서 어느 프로젝트에서도 사용할 수 있게 만든다고하면 기본적으로 외부와의 인풋은 모두 일반적인 객체로 데이터를 전달 받을 것 같아요. \n리액트 컴포넌트가 아니기 때문에 자바스크립트 객체형태로 인터페이스를 제공하게될 것 같고요. ….  ..그런데 적다보니 궁금하신 부분은 이것이 아닌 것 같아요.\n저라면 이렇게 구현할 것 같아요. 제어의 역전이라고 하죠 SOLID 원칙중 DIP요 이것을 활용할 것 같아요.\nCart내부에서 cartStore를 직접 사용하는 것이 아니라 생성자에서 cartStore를 주입받는 것이죠.\n테스트할때는 cartStore를 임의로 모킹 객체로 주입해서 원하는 동작을 하도록 만드는 것이죠.\n디커플링에는 이런 류의 스킬이 자주 사용됩니다!\n(사실 모킹은 테스트할 때 피해야하지만 어쩔 수 없는 부분도 있는 것 같습니다.)\n\n\n- 이벤트 리스너 중복 제거: Cart.js의 bindEventListeners() 메서드에서 10개 이상의 이벤트 리스너를 개별적으로 추가하고 있는데, 이벤트 위임을 사용해서 더 효율적으로 관리하는 방법이 있을까요? 특히 data-product-id 속성을 활용한 이벤트 위임 패턴을 적용하면 코드가 더 간단해질 것 같은데, 막상 하려니 떠오르지 않았습니다. 어떤 방식으로 구현하는 것이 좋을지 조언해 주시면 좋겠습니다.\n\n말씀하셨던 대로 이벤트 위임을 사용하셔도 되는데요 결국 어디서 처리하느냐의 문제 인 것이지 코드의 복잡도는 줄어들지 않을 것 같아요.\n그런데 이벤트 위임은 따로 설명할만한 내용이 없을 것 같은데 이벤트 위임 자체가 궁금하신 것일까요?\n카트  root엘리먼트에 이벤트를 걸고 버블링을 활용해서 엘리먼트를 판별하고 data-product-id와 같은 추가 데이터를 활용해서 필요한 동작을 수행하도록 할 수 있을 것 같아요! \n하지만 그보다 더 좋은 것은 실제 리액트가 그렇듯 이벤트 위임으로 처리하지만 위임은 프레임웍 내부에서 처리하고 컴포넌트 코드래밸에서는 컴포넌트 내부에서 이벤트를 바인드하는 코드를 작성하는 것이 코드 리더빌리티가 더 좋은 것 같아요 :) \n\n- 상태 업데이트 로직 최적화: store.js에서 increaseQuantity, decreaseQuantity, toggleItemSelection 등의 메서드들이 비슷한 패턴으로 배열을 조작하고 있습니다. 이런 중복된 로직을 하나의 공통 함수(예: updateItem)로 합쳐서 코드를 더 간결하게 만들 수 있을까요? 그리고 배열을 매번 새로 만드는 것보다 불변성을 유지하면서 성능을 개선하는 방법이 있는지 궁금합니다.\n\n일반적인동작을 하는 공통함수를 만어도 되긴 하지만 저는 map 사용하는 것만 동일하고 실제로 콜백의 코드는 다르기때문에 중복이라고 보진 않습니다. 오히려 이상황에서는 말씀하신 공통합수는 map이라는 인터페이스로 배열이 이미 구현된 것이 아닌가 싶어요.\n\n배열을 매번 새로 만드는 것보다 불변성을 유지하면서 성능을 개선하는 방법이 있긴 있는데요. 이게 직접 구현은 굉장히 어렵습니다.\n그런 리스트를 퍼시스턴트 리스트라고 하는데요. 하스켈이나 리스프같은 언어가 제공하는 리스트들은 기본적으로 퍼시스턴트 리스트를 제공하고 있지만 자바스크립트는 쉽게 구현은 힘들어요 ㅎㅎ\nimmer.js라는 도구가 어느정도 유사하게 동작하도록 구현한 도구입니다. 리스트만 구현한 건 아니지만요 :)\n그리고 생각보다 배열을 새로생성하는 것은 비용이 크지 않습니다. 배열에 들어가는 데이터를 만드는 것이 비용이 크죠.\n\n- 함수명과 변수명 개선: AI의 피드백으로는 Cart.js의 templateContent(), itemCountText() 같은 함수명들이 직관성이 떨어지다고 예를 들어 templateContent()를 renderCartContent()로 바꾸는 것을 제안하는데 어떻게 생각하시는지 궁금합니다. 그리고 어떤 함수와 변수를 더 명확하게 이름 지을 수 있는 방법에 대해 조언받을 수 있을까요?\n\n이부분은 사실 너무 이야기할 것이 많아서 차라리 책을 추천하는 것이 좋을 것 같아요!\n클린코드라는 책의 두번째 챕터가 그런 내용을 다룹니다!\n그리고  함수명은 함수의 의도가 들어나는 이름이면 될 것 같습니다. 지혜님이 생각하기에는 어떤 이름이 지혜님이 작성항 코드의 의도를 드러낸다고 생각하시나요~",
      enrolledId: "679ce583ada1879bb5adddf0",
    },
    {
      _id: "6868a344a8a052ad6145443b",
      result: "FAIL",
      isBestPractice: false,
      name: "김연수",
      badge: "화이트",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "FAIL",
        "FAIL",
        "PASS",
        "FAIL",
        "FAIL",
        "FAIL",
        "PASS",
        "FAIL",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/70",
        },
      ],
      feedback:
        "안녕하세요 연수님 아쉽지만 채점을 할 수 있을 만큼의 기준이 되지 못하여서 불합격 드리도록 하곘습니다. 2주차에는 조금이라도 진행이 될 수 있기를 바래요. 수고하셨습니다.\n",
      enrolledId: "6792d9a67ea42ce47df4e27e",
    },
    {
      _id: "6868a344a8a052ad6145443d",
      result: "",
      isBestPractice: false,
      name: "정명훈",
      badge: "화이트",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "",
        },
      ],
      feedback: "",
      enrolledId: "6697caec1cfd0ff2d737c0f6",
    },
    {
      _id: "6868a344a8a052ad6145443f",
      result: "FAIL",
      isBestPractice: false,
      name: "박의근",
      badge: "화이트",
      stackToLearn: "TypeScript",
      totalAssignmentProgress: [
        "FAIL",
        "FAIL",
        "PASS",
        "FAIL",
        "",
        "",
        "FAIL",
        "FAIL",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
      ],
      answers: [
        {
          question: {
            _id: "6868a341a8a052ad6145428f",
            name: "STEP02 요구사항을 만족한 PR 링크를 제출해주세요.",
            placeholder: "PR링크를 제출해주세요.",
            createdAt: "2025-07-05T13:00:01.708Z",
            updatedAt: "2025-07-08T21:37:06.061Z",
          },
          answer: "https://github.com/hanghae-plus/front_6th_chapter1-1/pull/61",
        },
      ],
      feedback:
        "안녕하세요 박의근님, 수고하셨습니다. 이번 과제는 프레임워크 없이 순수 JavaScript로 복잡한 SPA를 구현하면서, 프레임워크가 해결해주는 문제들을 직접 경험해보는 것이 목표였습니다. 이를 통해 DOM 조작, 상태 관리, 라우팅 등의 핵심 개념을 깊이 있게 이해하셨기를 바랬습니다.\n\n아쉽지만 현재 공유해준 코드만으로는 피드백을 할 수 있는 완성도나 채점을 할 수 있는 수준이 아닌것 같아서 불합격을 드립니다. 혹시 PR을 잘못 올린거라면 알려주세요.\n\nQ) Vitest에서 전체/개별 테스트 시 결과가 다른 이유는 무엇인가요?\n\n=> 이는 테스트 간 상태 공유 문제일 가능성이 높습니다. 사실 개별테스트와 전역 테스트마다 독립된 상태를 만들어서 독립성을 만들어야 하는 데 상태에 의존하는 형태로 코딩을 하게 되면 초기 설정에서 테스트를 하는 동안 상태값이 변하게 되고 이에 의존해서 테스트 코드를 만들면 반드시 순서대로 테스트를 해야만 정상동작하는 경우가 생길 수 있습니다.\n\nQ) 웹앱은 정상 동작하나 테스트가 실패하는 경우 어떻게 접근해야 하나요?\n\n=> 테스트는 특정 DOM 구조와 타이밍을 기대합니다. FE는 특정 결과를 눈으로 보이도록 하게 하기 위해서 다양한 방법과 시간차가 존재하는데 테스트 코드는 오로지 데이터의 구조와 값의 유무로만 판단하기에 정상적인 결과라도 테스트의 정상유무를 테스트하는 방법에 따라 실패가 될 수 도 있습니다.\n\n=> 만약 본인의 결과가 문제가 없다면 테스트 코드를 그에 맞게 변경해야하는게 맞습니다. 그러나 테스트 코드가 진실의 원천이 되어야 한다면 테스트 코드에 맞게 코드를 수정을 하는 것이 맞지요. 지금 어느 코드를 기준으로 작성해야할지 또한 개발자가 결정을 해야하는 부분입니다.\n\n\nps.\nAI를 활용하지 않으면 문제 해결이 막막한 것이 과연 정상적인 상황일지.. 궁금합니다.\n\n=> 네 당연합니다. AI가 없던 시절에는 코딩을 할때 어떻게 해야하는지 하루종일 검색해가며 되는 방법을 찾았던 시절이 있었고 검색 엔지니 없던 시절에는 책과 레퍼런스를 보면서 하루종일 사람들이랑 논의하면서 왜 이럴까 고민을 하다가 답을 찾아내는게 개발자의 역할입니다.\n\n=> 설령 AI가 답을 알려주더라도 그 답이 맞는지 안 맞는지, 그 답이 우리의 경우에 맞는 답인 건지, 이걸 어떻게 적용해야하는지 고민하는 것 또한 개발자의 역할입니다.\n\n=> 막연한 상황에서 목표를 정하고 길을 찾고 답을 찾아내 문제를 해결하는 과정을 즐겨주세요! \n\n수고하셨습니다. 2주차도 화이팅입니다! :)",
      enrolledId: "671993df7e7008df3ebb7f4e",
    },
  ],
};
