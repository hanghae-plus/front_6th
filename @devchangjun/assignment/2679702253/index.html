<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>항해플러스 프론트엔드 6기 기술블로그</title>
  <link rel="icon" href="/front_6th/favicon.ico"/>
  
  <script type="module" crossorigin src="/front_6th/assets/index-C86_9DIC.js"></script>
  <link rel="stylesheet" crossorigin href="/front_6th/assets/index-Dvjhel9t.css">
</head>
<body>
<div id="root"><link rel="preload" as="image" href="https://github.com/user-attachments/assets/43d18222-7442-42c5-9566-af0808739658"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/89d9e969-1748-412a-b2b7-e633dea87bce"/><div data-slot="sidebar-wrapper" style="--sidebar-width:16rem;--sidebar-width-icon:3rem" class="group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full"><div class="min-h-screen flex w-full"><div class="group peer text-sidebar-foreground hidden md:block" data-state="expanded" data-collapsible="" data-variant="sidebar" data-side="left" data-slot="sidebar"><div data-slot="sidebar-gap" class="relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear group-data-[collapsible=offcanvas]:w-0 group-data-[side=right]:rotate-180 group-data-[collapsible=icon]:w-(--sidebar-width-icon)"></div><div data-slot="sidebar-container" class="fixed inset-y-0 z-10 hidden h-svh transition-[left,right,width] duration-200 ease-linear md:flex left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)] group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l w-64"><div data-sidebar="sidebar" data-slot="sidebar-inner" class="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"><div data-slot="sidebar-content" data-sidebar="content" class="flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden bg-card border-r border-border"><a class="p-4" href="/front_6th/" data-discover="true"><div class="flex items-center space-x-2 mb-6"><div class="w-8 h-8 bg-gradient-primary rounded-lg flex items-center justify-center"><span class="text-white font-bold text-sm">6기</span></div><h4 class="text-lg font-bold text-primary">항해플러스 프론트엔드</h4></div></a><div data-slot="sidebar-group" data-sidebar="group" class="relative flex w-full min-w-0 flex-col p-2"><div data-slot="sidebar-group-label" data-sidebar="group-label" class="ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0 text-muted-foreground px-4">학습 관리</div><div data-slot="sidebar-group-content" data-sidebar="group-content" class="w-full text-sm"><ul data-slot="sidebar-menu" data-sidebar="menu" class="flex w-full min-w-0 flex-col gap-1 px-2"><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_6th/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-users h-5 w-5" aria-hidden="true"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><path d="M16 3.128a4 4 0 0 1 0 7.744"></path><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><circle cx="9" cy="7" r="4"></circle></svg><span class="ml-3">수강생 목록</span></a></li><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_6th/assignments" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open h-5 w-5" aria-hidden="true"><path d="M12 7v14"></path><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"></path></svg><span class="ml-3">과제 목록</span></a></li></ul></div></div></div></div></div></div><div class="flex-1 min-w-0"><header class="h-12 flex items-center border-b border-border bg-card px-4"><button data-slot="sidebar-trigger" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-7 mr-4 text-white" data-sidebar="trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-panel-left" aria-hidden="true"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M9 3v18"></path></svg><span class="sr-only">Toggle Sidebar</span></button><h4 class="text-lg font-semibold "><a href="/front_6th/@devchangjun/" data-discover="true">devchangjun<!-- --> 님의 상세페이지</a> ＞ <!-- -->[8팀 박창준] Chapter 1-3. React, Beyond the Basics</h4></header><main class="p-6"><div><div class="card-wrap"><div data-slot="card" class="card text-card-foreground flex flex-col gap-6 shadow-sm mb-6 p-6 border border-gray-700 bg-gray-800 rounded-lg"><a href="https://github.com/hanghae-plus/front_6th_chapter1-3/pull/20" target="_blank"><div class="flex items-start gap-4"><div class="flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" height="32" aria-hidden="true" viewBox="0 0 24 24" width="32" fill="white" class="w-8 h-8"><path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg></div><div class="flex-1 min-w-0"><div class="flex items-center gap-2 mb-2"><h3 class="text-lg font-semibold text-white truncate">[8팀 박창준] Chapter 1-3. React, Beyond the Basics</h3></div><div class="flex items-center gap-4 text-xs text-gray-500"><span>by <!-- -->devchangjun</span><span>2025. 7. 20.</span></div></div></div></a></div></div><div class="overflow-auto"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-체크포인트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-체크포인트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 체크포인트</h2>
<h3 id="배포-링크"><a class="anchor" aria-hidden="true" tabindex="-1" href="#배포-링크"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>배포 링크</h3>
<p><a href="https://devchangjun.github.io/front_6th_chapter1-3/">https://devchangjun.github.io/front_6th_chapter1-3/</a></p>
<h3 id="기본과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기본과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기본과제</h3>
<h4 id="equalities"><a class="anchor" aria-hidden="true" tabindex="-1" href="#equalities"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>equalities</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> shallowEquals 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> deepEquals 구현 완료</li>
</ul>
<h4 id="hooks"><a class="anchor" aria-hidden="true" tabindex="-1" href="#hooks"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>hooks</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useRef 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useMemo 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useCallback 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useDeepMemo 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useShallowState 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useAutoCallback 구현 완료</li>
</ul>
<h4 id="high-order-components"><a class="anchor" aria-hidden="true" tabindex="-1" href="#high-order-components"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>High Order Components</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> memo 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> deepMemo 구현 완료</li>
</ul>
<h3 id="심화-과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#심화-과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>심화 과제</h3>
<h4 id="hooks-1"><a class="anchor" aria-hidden="true" tabindex="-1" href="#hooks-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>hooks</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> createObserver를 useSyncExternalStore에 사용하기 적합한 코드로 개선</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useShallowSelector 구현</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useStore 구현</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useRouter 구현</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useStorage 구현</li>
</ul>
<h3 id="context"><a class="anchor" aria-hidden="true" tabindex="-1" href="#context"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>context</h3>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> ToastContext, ModalContext 개선</li>
</ul>
<h2 id="과제-셀프회고"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-셀프회고"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 셀프회고</h2>
<!-- -->
<h3 id="기술적-성장"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기술적-성장"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기술적 성장</h3>
<p>이번 과제를 진행하면서 기존에 사용하였던 React 훅들이 어떤 매커니즘으로 만들어졌고, 왜 이렇게 동작을 하는지 코드레벨에서 깊이있게 이해할 수 있었던 과제였습니다.</p>
<p>특히 메모이제이션에 대해서 더 깊이 고민해볼 수 있었습니다. 예전에는 <code>useMemo</code>, <code>useCallback</code>, <code>useRef</code> 등 React에서 제공하는 훅들을 단순히 &quot;최적화를 위한 도구&quot; 정도로만 생각했었는데, 이번 과제를 통해</p>
<ul>
<li>각각의 훅이 내부적으로 어떤 동작 원리로 작동하는지</li>
<li>불필요한 리렌더링을 막기 위해 어떤 비교 전략(shallowEquals, deepEquals)이 사용되는지</li>
<li>외부 스토어/ 라우터와의 연동에서 useSyncExternalStore 훅과 연동한 구독, 알림 시스템이 어떻게 동작하는지</li>
</ul>
<p>좀 더 깊이있게 학습할 수 있었습니다.</p>
<p><strong>useSyncExternalStore</strong> 훅에 대한 학습</p>
<p>공부하다 보니 재미있는 사실을 발견했습니다.
React가 성능과 사용자 경험을 높이기 위해 <strong>동시성 렌더링</strong>을 도입했는데, 아이러니하게도 이게 상태가 찢어지는(Tearing) 문제를 만들어냈더라고요. 즉, UX 문제를 해결하려고 도입한 기능이 새로운 문제를 만든 셈이죠. 그걸 또 해결하기 위해 등장한 게 바로 <strong>useSyncExternalStore</strong>라는 훅이었고요.</p>
<blockquote>
<p>A 문제를 해결하려고 B를 도입했더니, 또 다른 문제가 생겨서 C를 만들어낸 흐름이 React의 진화 과정 자체가 하나의 문제 해결 여정처럼 느껴져서 정말 흥미로웠습니다.</p>
</blockquote>
<p>React는 단순히 새로운 기능만 쌓아가는 게 아니라 <strong>기존의 구조적 문제를 하나하나 개선해가며 점진적으로 아키텍처를 정제</strong>해가는 프레임워크라는 그런 진화과정을 엿볼 수 있었던것 같습니다.</p>
<p><code>useSyncExternalStore</code>훅 관련된 내용은
<a href="https://velog.io/@ckdwns9121/React-18%EB%B6%80%ED%84%B0-%EB%8F%84%EC%9E%85%EB%90%9C-useSyncExternalStore-%ED%9B%85-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0">React 18부터 도입된 useSyncExternalStore 훅 살펴보기</a>라는 포스팅에 정리하였습니다.</p>
<p><strong>useAutoCallback와 같은 유연한 커스텀훅을 설계하는 사고방식 습득</strong></p>
<p>과제를 진행하면서 제일 인상깊었던 코드는 <code>useAutoCallback</code>과 같은 커스텀 훅이였습니다.
이전까지는 useCallback만 사용하면 함수의 재생성을 막을 수 있다고 막연히 생각했지만, 실제로는 의존성 배열에 따라 최신 상태를 참조하지 못하는 문제가 종종 있습니다. (의존성 누락).</p>
<p>그 문제를 useRef와 useCallback을 조합해서 <strong>항상 최신 함수</strong>를 참조하면서도 <strong>함수의 참조값은 변하지 않게 만드는 패턴</strong>이 매우 유용하다는 것을 직접 구현하며 체감할 수 있었습니다.</p>
<p><code>useAutoCallback</code>은 아래와 같은 과정으로 구현하였습니다.</p>
<p><strong>1. useRef로 최신 함수 보관</strong></p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token keyword">const</span> callbackRef <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">callbackRef<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> fn<span class="token punctuation">;</span>
</span></code><div class="copied" data-code="const callbackRef = useRef&lt;T&gt;(fn);
callbackRef.current = fn;
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ul>
<li>useRef는 컴포넌트가 리렌더링되어도 동일한 ref 객체를 반환합니다.</li>
<li>callbackRef.current에 항상 최신의 fn을 할당합니다. 즉, 컴포넌트가 리렌더링될 때마다 최신의 fn이 ref에 저장됩니다.</li>
<li>이로써 콜백 함수 내부에서 항상 최신의 함수를 참조할 수 있게 구현했습니다.</li>
</ul>
<p><strong>2. useCallback으로 함수 참조를 고정</strong></p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token keyword">return</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token operator">:</span> <span class="token maybe-class-name">Parameters</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">return</span> callbackRef<span class="token punctuation">.</span><span class="token method function property-access">current</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token constant">T</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="return useCallback((...args: Parameters&lt;T&gt;) =&gt; {
  return callbackRef.current(...args);
}, []) as T;
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ul>
<li>useCallback은 의존성 배열이 <code>[]</code>(빈배열)이므로 최초 마운트 시에만 콜백을 생성하고, 이후에는 동일한 함수 참조를 반환합니다.</li>
<li>하지만 이 콜백 내부에서 직접 fn을 참조하지 않고 ref를 통해 접근하게 만들었습니다.</li>
<li>즉 콜백 함수의 참조는 고정되어 있지만  <strong>내부에서 실행되는 fn은 항상 최신</strong>입니다.</li>
</ul>
<p><strong>3. 최종 구현된 코드</strong></p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> <span class="token maybe-class-name">AnyFunction</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;../types&quot;</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">import</span> <span class="token imports"><span class="token punctuation">{</span> useCallback <span class="token punctuation">}</span></span> <span class="token keyword">from</span> <span class="token string">&quot;./useCallback&quot;</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">import</span> <span class="token imports"><span class="token punctuation">{</span> useRef <span class="token punctuation">}</span></span> <span class="token keyword">from</span> <span class="token string">&quot;./useRef&quot;</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> useAutoCallback <span class="token operator">=</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">T</span></span> <span class="token attr-name">extends</span> <span class="token attr-name">AnyFunction</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">(fn: T): T =&gt; </span><span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> callbackRef <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  callbackRef<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> fn<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token operator">:</span> <span class="token maybe-class-name">Parameters</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">return</span> callbackRef<span class="token punctuation">.</span><span class="token method function property-access">current</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token constant">T</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token plain-text">;
</span></span></code><div class="copied" data-code="import type { AnyFunction } from &quot;../types&quot;;
import { useCallback } from &quot;./useCallback&quot;;
import { useRef } from &quot;./useRef&quot;;

export const useAutoCallback = &lt;T extends AnyFunction&gt;(fn: T): T =&gt; {
  const callbackRef = useRef&lt;T&gt;(fn);
  callbackRef.current = fn;

  return useCallback((...args: Parameters&lt;T&gt;) =&gt; {
    return callbackRef.current(...args);
  }, []) as T;
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이 구현으로 인해서 <code>useCallback</code>의 단점인 <strong>state closure문제</strong>를 우회하면서도 <strong>불필요한 함수 재생성 없이 항상 최신상태를 참조</strong>할 수 있는 커스텀 훅을 구현하였습니다. 이 패턴을 활용해서 토스트에서 <code>showWithHide</code> 함수에 적용하여 <strong>타이머 리셋 문제</strong>를 개선할 수 있었습니다.</p>
<p>이렇게 상황에 따라 유연하게 <strong>필요한 훅을 재조합</strong>하거나 필요시 <strong>새롭게 구현할 수 있는</strong> 사고방식을 기르게 되었습니다.</p>
<p>또한, 토스트 UI를 Context 기반으로 구현한 <code>ToastProvider</code>를 리팩토링하면서 <strong>불필요한 리렌더링 방지</strong>와 <strong>관심사 분리</strong>의 중요성을  직접 경험해볼 수 있었습니다.</p>
<p>초기에는 상태(state)와 액션(show/hide)을 하나의 Context에 통합한 구조를 사용했는데, 이 경우 <code>message</code>가 변경되면 액션만 사용하는 컴포넌트도 불필요하게 리렌더링되는 이슈가 있었습니다. 이를 해결하기 위해 다음과 같은 리팩토링을 진행하였습니다.</p>
<p><strong>1. 상태와 액션을 별도의 Context로 분리</strong></p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token comment">// 상태만 담는 Context</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token maybe-class-name">ToastStateContext</span> <span class="token operator">=</span> <span class="token function">createContext</span><span class="token punctuation">(</span><span class="token punctuation">{</span> message<span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> type<span class="token operator">:</span> <span class="token string">&quot;success&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 액션만 담는 Context</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token maybe-class-name">ToastActionContext</span> <span class="token operator">=</span> <span class="token function">createContext</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function-variable function">show</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function-variable function">hide</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 소비하는 쪽</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">useToastState</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token function">useContext</span><span class="token punctuation">(</span><span class="token maybe-class-name">ToastStateContext</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">useToastCommand</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token function">useContext</span><span class="token punctuation">(</span><span class="token maybe-class-name">ToastActionContext</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 상태만 담는 Context
const ToastStateContext = createContext({ message: &quot;&quot;, type: &quot;success&quot; });

// 액션만 담는 Context
const ToastActionContext = createContext({ show: () =&gt; {}, hide: () =&gt; {} });

// 소비하는 쪽
export const useToastState = () =&gt; useContext(ToastStateContext);
export const useToastCommand = () =&gt; useContext(ToastActionContext);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이전에는 하나의 Context에 <code>message</code>, <code>show()</code>, <code>hide()</code>등 모든걸 넣었는데 상태와 액션을 분리해 <strong>필요한 값만 구독해서</strong> 불필요한 렌더링을 방지하였습니다.</p>
<p><strong>2. <code>value</code> 객체는 <code>useMemo</code>로 메모이제이션</strong></p>
<p>기존 코드는 <code>value</code>에 객체 리터럴을 바로 넘기는 방식이였습니다.</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ToastActionContext.Provider</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> show<span class="token punctuation">,</span> hide <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span></code><div class="copied" data-code="&lt;ToastActionContext.Provider value={{ show, hide }}&gt;
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이 객체는 매번 렌더링할 때 <strong>새로운 객체</strong>로 생성됩니다. 즉</p>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token punctuation">{</span> show<span class="token punctuation">,</span> hide <span class="token punctuation">}</span> <span class="token operator">!==</span> <span class="token punctuation">{</span> show<span class="token punctuation">,</span> hide <span class="token punctuation">}</span> <span class="token comment">// 참조값 다름</span>
</span></code><div class="copied" data-code="{ show, hide } !== { show, hide } // 참조값 다름
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이렇게 값은 같아도 참조하고 있는 메모리 주소가 다르기 때문에 이 컨텍스트를 사용하는 <strong>모든 하위 컴포넌트</strong>가 리렌더링이 되는 문제가 있었습니다.</p>
<p>그래서 <code>useMemo</code>를 활용해서 <code>show</code>와 <code>hide</code> 함수가 불필요하게 재생성되지 않도록 고정시켰습니다.</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">{</span> show<span class="token punctuation">,</span> hide <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token function">createActions</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>dispatch<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="  const { show, hide } = useMemo(() =&gt; createActions(dispatch), [dispatch]);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>3. showWithHide를 useAutoCallback으로 고정된 참조 + 최신상태를 보장하게 구현</strong></p>
<p>위에서 언급한 <code>useAutoCallback</code>을 통해 아래와 같이 리팩토링하였습니다.</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token keyword">const</span> showWithHide <span class="token operator">=</span> <span class="token function">useAutoCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span>message<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> type<span class="token operator">:</span> <span class="token maybe-class-name">ToastType</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token function">show</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token function">hideAfter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// debounce(hide)</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="const showWithHide = useAutoCallback((message: string, type: ToastType) =&gt; {
  show(message, type);
  hideAfter(); // debounce(hide)
});
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이 함수는 다음과 같은 이점을 가집니다.</p>
<ul>
<li>외부에 전달되는 showWithHide는 항상 동일한 참조값을 유지하므로, useMemo 등에서 안전하게 사용 가능합니다.</li>
<li>내부에서 ref를 통해 최신 <code>show</code>, <code>hideAfter</code>를 참조하므로 <strong>클로저에 의한 stale 상태 문제</strong>를 방지할 수 있습니다.</li>
<li>결과적으로 <code>show()</code>를 연속으로 호출한다 해도 <code>debound</code>가 <strong>정상적으로 리셋</strong> 되면서 가장 마지막 호출 기준으로 토스트 메시지가 닫히게 됩니다.</li>
</ul>
<h3 id="학습-효과-분석"><a class="anchor" aria-hidden="true" tabindex="-1" href="#학습-효과-분석"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>학습 효과 분석</h3>
<p><strong>1. 리액트는 왜 얕은비교 방식을 채택했을까?</strong></p>
<p>React는 상태 비교에서 기본적으로 **얕은 비교(shallow comparison)**를 사용합니다. 이는 단순히 &quot;성능 때문에 그렇다&quot;는 얘기보단 어떤 철학적인 설계에 가깝다고 생각했습니다.</p>
<ul>
<li>깊은 비교를 하게되면 객체가 중첩될수록 비교 비용이 기하급수적으로 늘어납니다.</li>
<li>반면 얕은 비교는 <code>===</code> 연산 및 한 레벨의 비교로 끝나기 때문에 <strong>예측 가능하고 빠릅니다.</strong></li>
<li>React는 불변성을 지키는 방식으로 상태를 다루도록 유도하는데 얕은 비교만으로 상태 변경 여부를 판단할 수 있게 만들었습니다.</li>
</ul>
<p>즉 React는 개발자에게 불변성 유지를 책임지게 하고, 프레임워크는 그 위에서 가볍고 빠른 비교를 제공하는 방식을 택했다고 생각합니다. 이로 인해 컴포넌트 리렌더링 판단, memo, useMemo, useCallback 같은 훅의 최적화가 모두 얕은 비교를 기준으로 설계되었다고 합니다.</p>
<p><strong>2. useAutoEffect, useAutoMemo와 같은 훅은 만들 수 없을까?</strong></p>
<p>이번 과제에서 <code>useAutoCallback</code>을 구현하면서 <strong>참조는 고정하면서 항상 내부에서 최신상태를 받아올 수 있는 훅</strong>도 만들 수 있지않을까? <strong>그것을 만들면 완전 혁신아니야!?</strong> 라는 기대도 했습니다.</p>
<p>이 아이디어를 기반으로 <code>useAutoEffect</code> 같은 훅을 상상해봤습니다. 예를 들어, 의존성 배열 없이도 최신 상태를 반영하는 effect 훅을 만들 수 있다면 매번 의존성 배열을 일일이 나열하지 않아도 돼서 굉장히 편리할 것 같았습니다.</p>
<p>그래서 아래와 같은 시도를 했습니다.</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">useAutoEffect</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function-variable function">effectFn</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  ref<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> effectFn<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">return</span> ref<span class="token punctuation">.</span><span class="token method function property-access">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="const useAutoEffect = (effectFn: () =&gt; void) =&gt; {
  const ref = useRef(effectFn);
  ref.current = effectFn;

  useEffect(() =&gt; {
    return ref.current();
  }, []);
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>문제점</strong></p>
<ul>
<li>보기엔 ref.current가 항상 최신 effectFn을 참조하므로 괜찮아 보이지만, 실제로는 이 useEffect는 컴포넌트 마운트 시 단 한 번만 실행됩니다</li>
<li>즉, 이후 effectFn이 바뀌어도 다시 실행되지 않게 때문에 때문에 ref.current가 최신이든 아니든 다시 실행되지 않는 문제점이 있었습니다.</li>
</ul>
<p>마찬가지로 <code>useAutoMemo</code>도 만들어볼 수 있을 것 같았지만</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token keyword">const</span> useAutoMemo <span class="token operator">=</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">T</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">(factory: () =&gt; T): T =&gt; </span><span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  ref<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> factory<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> ref<span class="token punctuation">.</span><span class="token method function property-access">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token plain-text">;
</span></span></code><div class="copied" data-code="const useAutoMemo = &lt;T&gt;(factory: () =&gt; T): T =&gt; {
  const ref = useRef(factory);
  ref.current = factory;

  return useMemo(() =&gt; ref.current(), []);
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>문제점</strong></p>
<ul>
<li>useMemo(..., [])는 초기 마운트 시 <strong>한 번만 실행</strong>되며 그 이후에는 ref가 최신이더라도 factory는 다시 평가되지 않습니다.</li>
<li>결국 매번 팩토리함수를 다시 실행해야하는데 이는 메모이제이션이 아니라 <strong>매번 새로운 결과를 재생성</strong>하는 것이기 때문에 메모이제이션의 목적을 달성하지 못했습니다.</li>
</ul>
<p>이 훅들을 구현해보면서 <code>useAutoCallback</code>은 <strong>언제 실행될지</strong>를 <strong>사용자가 제어</strong>하기 때문에 최신 상태 참조에 의미가 있었지만, 제가 시도하려 했던 useAutoEffect, useAutoMemo는 <strong>React가 정한 타이밍</strong>에 실행되는 훅이기 때문에 내부에 최신 참조(ref)가 있어도 그 <strong>타이밍이 고정되어 있어서</strong> 최신 상태를 반영할 수 없는 구조적인 한계가 있다는것을 깨달았습니다.</p>
<p><strong>3. useShallowSelector의 동작 원리 분석</strong>
useShallowSelector의 동작 원리가 잘 이해 되지 않아서 천천히 디버깅해보며 학습한 내용을 정리하였습니다.</p>
<p><strong>흐름 상세 설명</strong></p>
<ol>
<li><strong>컴포넌트</strong>가 <code>useStore</code>(또는 <code>useRouter</code>)를 호출할 때, selector 함수를 함께 전달합니다.</li>
<li><code>useStore</code> 내부에서 <code>useShallowSelector(selector)</code>를 호출하여, selector 기반의 shallowSelector 함수를 만듭니다.</li>
<li><code>useSyncExternalStore</code>를 통해 store의 subscribe로 상태 변화를 구독합니다.</li>
<li>store의 상태가 바뀌면, subscribe에 등록된 콜백이 실행되어 컴포넌트가 다시 shallowSelector(state)를 호출합니다.</li>
<li>shallowSelector는 selector(state)로 값을 뽑고, 이전 값과 shallowEquals로 비교합니다.</li>
<li>값이 다르면 prevSelectedRef를 갱신하고 새 값을 반환하여 컴포넌트가 리렌더링됩니다.</li>
<li>값이 같으면 이전 값을 그대로 반환하여 불필요한 리렌더링을 방지합니다.</li>
</ol>
<p>이 흐름을 시각화 하였습니다.</p>
<pre class="language-mermaid"><code class="language-mermaid code-highlight"><span class="code-line"><span class="token keyword">sequenceDiagram</span>
</span><span class="code-line">  <span class="token keyword">participant</span> 컴포넌트
</span><span class="code-line">  <span class="token keyword">participant</span> useStore
</span><span class="code-line">  <span class="token keyword">participant</span> useShallowSelector
</span><span class="code-line">  <span class="token keyword">participant</span> store
</span><span class="code-line">  <span class="token keyword">participant</span> shallowEquals
</span><span class="code-line">
</span><span class="code-line">  컴포넌트<span class="token arrow operator">-&gt;&gt;</span>useStore<span class="token operator">:</span> selector 전달하며 호출
</span><span class="code-line">  useStore<span class="token arrow operator">-&gt;&gt;</span>useShallowSelector<span class="token operator">:</span> selector 전달
</span><span class="code-line">  useStore<span class="token arrow operator">-&gt;&gt;</span>store<span class="token operator">:</span> subscribe 등록
</span><span class="code-line">  useStore<span class="token arrow operator">-&gt;&gt;</span>store<span class="token operator">:</span> getState<span class="token punctuation">(</span><span class="token punctuation">)</span>로 상태 조회
</span><span class="code-line">  useStore<span class="token arrow operator">-&gt;&gt;</span>useShallowSelector<span class="token operator">:</span> shallowSelector<span class="token text string">(state)</span> 호출
</span><span class="code-line">  useShallowSelector<span class="token arrow operator">-&gt;&gt;</span>shallowEquals<span class="token operator">:</span> 이전 값과 selector<span class="token text string">(state)</span> 결과 비교
</span><span class="code-line">  <span class="token keyword">alt</span> 값이 다름
</span><span class="code-line">    shallowEquals<span class="token arrow operator">--&gt;&gt;</span>useShallowSelector<span class="token operator">:</span> false
</span><span class="code-line">    useShallowSelector<span class="token arrow operator">--&gt;&gt;</span>useStore<span class="token operator">:</span> 새 값 반환 <span class="token text string">(prevSelectedRef 갱신)</span>
</span><span class="code-line">    useStore<span class="token arrow operator">--&gt;&gt;</span>컴포넌트<span class="token operator">:</span> 새 값 전달, 리렌더링 발생
</span><span class="code-line">  <span class="token keyword">else</span> 값이 같음
</span><span class="code-line">    shallowEquals<span class="token arrow operator">--&gt;&gt;</span>useShallowSelector<span class="token operator">:</span> true
</span><span class="code-line">    useShallowSelector<span class="token arrow operator">--&gt;&gt;</span>useStore<span class="token operator">:</span> 이전 값 반환
</span><span class="code-line">    useStore<span class="token arrow operator">--&gt;&gt;</span>컴포넌트<span class="token operator">:</span> 이전 값 전달, 리렌더링 없음
</span><span class="code-line">  <span class="token keyword">end</span>
</span><span class="code-line">  store<span class="token arrow operator">--&gt;&gt;</span>useStore<span class="token operator">:</span> 상태 변경 시 notify <span class="token text string">(구독자 콜백 호출)</span>
</span><span class="code-line">  useStore<span class="token arrow operator">-&gt;&gt;</span>useShallowSelector<span class="token operator">:</span> shallowSelector<span class="token text string">(state)</span> 재호출 <span class="token text string">(이전과 동일 흐름 반복)</span>
</span><span class="code-line">
</span><span class="code-line">
</span></code><div class="copied" data-code="sequenceDiagram
  participant 컴포넌트
  participant useStore
  participant useShallowSelector
  participant store
  participant shallowEquals

  컴포넌트-&gt;&gt;useStore: selector 전달하며 호출
  useStore-&gt;&gt;useShallowSelector: selector 전달
  useStore-&gt;&gt;store: subscribe 등록
  useStore-&gt;&gt;store: getState()로 상태 조회
  useStore-&gt;&gt;useShallowSelector: shallowSelector(state) 호출
  useShallowSelector-&gt;&gt;shallowEquals: 이전 값과 selector(state) 결과 비교
  alt 값이 다름
    shallowEquals--&gt;&gt;useShallowSelector: false
    useShallowSelector--&gt;&gt;useStore: 새 값 반환 (prevSelectedRef 갱신)
    useStore--&gt;&gt;컴포넌트: 새 값 전달, 리렌더링 발생
  else 값이 같음
    shallowEquals--&gt;&gt;useShallowSelector: true
    useShallowSelector--&gt;&gt;useStore: 이전 값 반환
    useStore--&gt;&gt;컴포넌트: 이전 값 전달, 리렌더링 없음
  end
  store--&gt;&gt;useStore: 상태 변경 시 notify (구독자 콜백 호출)
  useStore-&gt;&gt;useShallowSelector: shallowSelector(state) 재호출 (이전과 동일 흐름 반복)


"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>4. 실제 ProductList에 메모이제이션을 도입하여 성능 측정</strong></p>
<p>이 컴포넌트는 무한 스크롤 구조로, 스크롤이 일정 위치에 도달할 때마다 새로운 데이터를 계속 fetching 해오는 구조입니다.
<code>products</code> 상태가 갱신될 때마다 <code>ProductList</code>가 리렌더링되고, 그에 따라 내부의 <code>ProductCard</code>들도 전부 리렌더링 되는 문제가 있었습니다.</p>
<p><strong>성능 측정 시나리오</strong></p>
<ul>
<li>무한스크롤을 10번해서 데이터 받아오기 (current=10이 될때까지)</li>
<li><strong>React Profier</strong>를 이용해 이 과정을 측정합니다.</li>
</ul>








































<table><thead><tr><th>항목</th><th>메모이제이션 전</th><th>메모이제이션 후</th></tr></thead><tbody><tr><td><strong>이미지</strong></td><td><img src="https://github.com/user-attachments/assets/43d18222-7442-42c5-9566-af0808739658" alt="메모 전"/></td><td><img src="https://github.com/user-attachments/assets/89d9e969-1748-412a-b2b7-e633dea87bce" alt="메모 후"/></td></tr><tr><td><strong>최대 렌더링 시간</strong></td><td><code>13.5s for 96.2ms</code> – 프레임 드랍 위험 있음</td><td><code>12.3s for 27.4ms</code> – 개선됨, 여전히 최적화 여지 있음</td></tr><tr><td><strong>렌더링 방식</strong></td><td><code>ProductCard</code>가 매번 전부 리렌더링됨 (<code>key=...</code>)</td><td><code>MemoizedComponent</code>로 감싸진 컴포넌트들은 대부분 <code>&lt;0.1ms</code>, 재렌더링 회피됨</td></tr><tr><td><strong>렌더링 시간 분포</strong></td><td>대부분 <code>0.3~0.5ms</code>씩 소모되는 카드들이 20개 이상 → 누적 비용 큼</td><td>대부분 <code>&lt;0.1ms</code>로 스킵되며 누적 비용이 대폭 감소</td></tr><tr><td><strong>ProductList</strong></td><td>여전히 매번 리렌더링 (state 변경 영향)</td><td>불필요한 리렌더링 없음</td></tr><tr><td><strong>성능 요약</strong></td><td>memo 미적용 시, 무한스크롤에 따른 전체 컴포넌트 재렌더링 발생, FPS 저하</td><td>memo 적용으로 동일 props인 컴포넌트 재사용 → CPU 사용량 및 프레임 시간 감소</td></tr></tbody></table>
<p>메모이제이션을 적용하지 않았을 때는 <code>ProductCard</code>가 props가 같음에도 <strong>모두 다시 렌더링되어 96.2ms에 달하는 프레임</strong>이 발생했고,
이는 사용자가 스크롤을 내릴 때 프레임 드랍이나 버벅임을 느낄 수 있는 수준입니다.</p>
<p>반면,  memo를 적용한 후에는 동일 props를 가진 카드들이 렌더링을 건너뛰게 되면서 <strong>전체 렌더링 시간은 27.4ms로 약 3.5배 이상 감소</strong>했습니다. 특히 각 ProductCard 컴포넌트가 &lt;0.1ms 수준으로 최적화되어 있어 불필요한 리렌더링이 일어나지 않았음을 확인할 수 있었습니다.</p>
<p>메모이제이션을 적용한 코드는 <a href="https://github.com/devchangjun/front_6th_chapter1-3/blob/main/packages/app/src/entities/products/components/ProductList.tsx#L85">여기</a>서 확인할 수 있습니다.</p>
<h3 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h3>
<p>React의 훅을 직접 단계별로 구현해보면서 동작원리를 자세히 익힐 수 있어서 좋았습니다.</p>
<h2 id="학습-갈무리"><a class="anchor" aria-hidden="true" tabindex="-1" href="#학습-갈무리"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>학습 갈무리</h2>
<h3 id="리액트의-렌더링이-어떻게-이루어지는지-정리해주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리액트의-렌더링이-어떻게-이루어지는지-정리해주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리액트의 렌더링이 어떻게 이루어지는지 정리해주세요.</h3>
<p><a href="https://github.com/devchangjun/front_6th_chapter1-3/issues/1">리액트의 렌더링은 어떻게 이루어질까?</a>에 정리하였습니다.</p>
<h3 id="메모이제이션에-대한-나의-생각을-적어주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#메모이제이션에-대한-나의-생각을-적어주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>메모이제이션에 대한 나의 생각을 적어주세요.</h3>
<p>React에서 <code>useMemo</code>, <code>useCallback</code>, <code>memo</code>와 같은 메모이제이션 도구는 <strong>성능 최적화를 위한 수단이지, 반드시 적용해야 하는 규칙은 아니라고 생각합니다.</strong></p>
<p>개발자들 사이에서 자주 나오는 얘기 중 하나는 다음과 같은 토론입니다.</p>
<blockquote>
<p><strong>&quot;일단 다 적용하고 보자&quot; vs &quot;성능 이슈가 생겼을 때 최적화하자&quot;</strong></p>
</blockquote>
<p>저는 이 중에서 <strong>성능 이슈가 발생했을 때 최적화하자</strong>에 가깝습니다.</p>
<p>실제로 React useMemo의 공식문서에도 아래와 같은 내용이 있습니다.</p>
<blockquote>
<p>If your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.
Optimizing with useMemo  is only valuable in a few cases</p>
</blockquote>
<p>❌ 무분별한 메모이제이션의 문제점</p>
<p><strong>1. 의존성 배열 실수</strong>
<code>useMemo(() =&gt; ..., [a, b])</code>처럼 작성했을 때, 의존성 하나만 빠져도 <strong>오래된 값을 계속 참조</strong>하게 됩니다. 특히 협업 중 리팩토링 시, 눈에 띄지 않는 버그로 발전하기 쉽습니다.</p>
<p><strong>2. 디버깅과 테스트 복잡도 증가</strong>
stale value와 관련된 버그는 눈에 띄지 않기 때문에 추적이 어렵고, 테스트 코드에서도 예외적인 흐름을 만들어냅니다.</p>
<p><strong>3. 불필요한 메모리 사용과 렌더링 최적화 실패</strong>
모든 것을 메모이제이션한다고 해서 항상 성능이 좋아지는 것은 아닙니다. 오히려 메모이제이션 오버헤드가 렌더링 비용보다 커질 수도 있다고 생각합니다.</p>
<blockquote>
<p>따라서 무분별한 메모이제이션은 코드 품질을 떨어뜨릴 수 있으며, <strong>선택적이고 명확한 목적 아래에서만 사용해야한다는 것이 저의 생각입니다.</strong></p>
</blockquote>
<p>✅ 내가 따르는 메모이제이션 원칙</p>
<p><strong>불변성을 지켜야 하는 상황에서만 메모이제이션을 쓴다.</strong>
예: Context의 value 객체, 복잡한 계산 로직 등</p>
<p><strong>렌더링 병목이 실제로 관측되는 경우에만 메모이제이션을 적용한다.</strong>
예: 수천 개의 리스트 렌더링, 연산이 무거운 경우 등</p>
<p><strong>불필요한 최적화는 하지 않는다.</strong>
나중에 코드를 이해하는 사람에게는 오히려 방해 요소가 될 수 있다.</p>
<p>메모이제이션은 &quot;언제든 쓰면 좋은 도구&quot;가 아니라 &quot;쓸 줄 아는 사람이 신중하게 선택해야 하는 칼&quot;이라고 생각합니다.</p>
<p>이 관점을 바탕으로 실무나 과제에서도 메모이제이션 도구를 <strong>무분별하게 남용하지 않고, 필요한 곳에만 적절히 적용하는 습관</strong>을 가지려 하고 있습니다.</p>
<h3 id="컨텍스트와-상태관리에-대한-나의-생각을-적어주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#컨텍스트와-상태관리에-대한-나의-생각을-적어주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>컨텍스트와 상태관리에 대한 나의 생각을 적어주세요.</h3>
<p>많은 사람들이 React의 Context를 전역 상태 관리 도구로만 이해하지만 실제로는 의존성 주입(DI) 시스템에 더 가까운 개념이라고 생각합니다. Context는 상위 컴포넌트에서 특정 값을 설정해 하위 컴포넌트로 직접 전달할 수 있게 해주며, 이 구조는 전통적인 DI 패턴과 매우 유사합니다. 실제로 많은 라이브러리들이 이 구조를 적극적으로 활용하고 있습니다.</p>
<p><strong>1. ThemeProvider</strong></p>
<p>하위의 모든 Component에서 <code>theme</code>객체를 참조할 수 있게 해주는 구조로 전형적인 설정값 주입의 대표적인 예시입니다.</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ThemeProvider</span></span> <span class="token attr-name">theme</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>myTheme<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">App</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ThemeProvider</span></span><span class="token punctuation">&gt;</span></span>
</span></code><div class="copied" data-code="&lt;ThemeProvider theme={myTheme}&gt;
  &lt;App /&gt;
&lt;/ThemeProvider&gt;
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>2. TanStack Query – QueryClientProvider</strong></p>
<p>API 캐싱과 상태 관리를 담당하는 QueryClient를 트리 전체에 주입하여 하위 컴포넌트에서는 별도의 설정 없이 useQuery, useMutation 등의 훅을 통해 해당 클라이언트를 자동으로 참조하고 사용할 수 있게됩니다.</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">QueryClientProvider</span></span> <span class="token attr-name">client</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>queryClient<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">App</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">QueryClientProvider</span></span><span class="token punctuation">&gt;</span></span>
</span></code><div class="copied" data-code="&lt;QueryClientProvider client={queryClient}&gt;
  &lt;App /&gt;
&lt;/QueryClientProvider&gt;
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>3.  i18next – I18nextProvider</strong></p>
<p>번역 객체(i18n 인스턴스)를 하위 컴포넌트에 주입해서 어디서든 다국어 기능을 사용할 수 있게 합니다.</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">I18nextProvider</span></span> <span class="token attr-name">i18n</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>i18n<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">App</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">I18nextProvider</span></span><span class="token punctuation">&gt;</span></span>
</span></code><div class="copied" data-code="&lt;I18nextProvider i18n={i18n}&gt;
  &lt;App /&gt;
&lt;/I18nextProvider&gt;
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이러한 패턴들은 모두 다음과 같은 공통점을 가집니다</p>
<ul>
<li>상위에서 특정 객체나 설정값을 생성</li>
<li>Provider로 컴포넌트 트리에 주입</li>
<li>하위에서 Hook이나 Context로 접근하여 사용</li>
</ul>
<p>이것은 전형적인 의존성 주입 패턴이며, React의 Context가 전역 상태 관리 도구라기보다 애플리케이션의 <strong>구성 요소</strong>를 주입하는 용도에 더 적합하다는 걸 보여주는 대표적인 예시들입니다.</p>
<p><strong>결론</strong></p>
<blockquote>
<p>Context는 &quot;전역 상태 관리&quot;보다는, &quot;외부에서 설정값이나 서비스 객체를 주입&quot;하는 데 더 적합한 도구다.</p>
</blockquote>
<ul>
<li>자주 바뀌는 상태를 Context로 관리하면 불필요한 리렌더링이 많아지고 성능 저하가 발생할 수 있다.</li>
<li>반면, 잘 변하지 않는 값(API client, config, 다국어 객체 등)은 Context로 주입하면 props drilling 없이 효율적으로 전달할 수 있다.</li>
</ul>
<h2 id="리뷰-받고-싶은-내용"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리뷰-받고-싶은-내용"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리뷰 받고 싶은 내용</h2>
<h3 id="q1-업무를-진행하실-때-메모이제이션을-다-해놓은-편인가요-아니면-성능-이슈가-발생했을-때-적용하시나요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#q1-업무를-진행하실-때-메모이제이션을-다-해놓은-편인가요-아니면-성능-이슈가-발생했을-때-적용하시나요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Q1. 업무를 진행하실 때 메모이제이션을 다 해놓은 편인가요? 아니면 성능 이슈가 발생했을 때 적용하시나요?</h3>
<h3 id="q2-만약-성능이슈가-발생해서-메모이제이션을-적용하신-경험이-있다면-한번-소개해주시면-감사합니다"><a class="anchor" aria-hidden="true" tabindex="-1" href="#q2-만약-성능이슈가-발생해서-메모이제이션을-적용하신-경험이-있다면-한번-소개해주시면-감사합니다"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Q2. 만약 성능이슈가 발생해서 메모이제이션을 적용하신 경험이 있다면 한번 소개해주시면 감사합니다!</h3>
<h3 id="q3-컨텍스트와-상태관리에-대한-코치님의-생각도-궁금합니다"><a class="anchor" aria-hidden="true" tabindex="-1" href="#q3-컨텍스트와-상태관리에-대한-코치님의-생각도-궁금합니다"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Q3. 컨텍스트와 상태관리에 대한 코치님의 생각도 궁금합니다.</h3></div></div><div class="overflow-auto mt-9"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h2>
<p>안녕하세요 창준! 수고했어요~ 이번 과제는 React의 내장 훅들을 직접 구현하면서 프레임워크의 내부 동작 원리를 깊이 이해하는 것이 목표였습니다. 창준님의 PR을 보면서 정말 깊은 탐구와 열정이 느껴지는 학습을 했다는게 느껴졌네요!</p>
<p>단순히 과제를 완료하는 것을 넘 성능 측정과 최적화까지 직접 경험해본 부분 칭찬합니다 특히 무한 스크롤에서 메모이제이션 적용 전후의 렌더링 시간을 React Profiler로 측정하여 96.2ms에서 27.4ms로 약 3.5배 개선한 실험은 정말 훌륭했습니다. 개발은 이렇게 항상 직접 해보면서 내가 체험적으로 느껴보는게 참 중요한 학습이라고 생각하는데 정말 잘했습니다!</p>
<p>useSyncExternalStore의 등장 배경에 대한 이해도 인상적이었습니다. React의 동시성 렌더링이 상태 찢어짐 문제를 만들고, 이를 해결하기 위해 새로운 훅이 등장했다는 진화 과정을 파악하신 것은 좋은 인사이트입니다. 컴퓨터 공학은 언제나 필요에 의해 진화를 해왔기에 그 배경과 서사를 이해한다는게 개발 공부에 큰 도움이 되죠!</p>
<p>이렇게 서사와 배경을 정확히 알게 되면 메모이제이션에 대한 본인의 철학도 취향이 아닌 확신을 통해 만들어지게 되는 것 같아요. 창준의 경우 무분별한 적용보다는 성능 이슈가 실제로 발생했을 때 신중하게 적용하는 접근을 하는 것에 대한 확신과 근거가 생겼기를 바랍니다.</p>
<p>이번 과제를 통해 React가 제공하는 편리한 API들 뒤에 숨어있는 복잡한 문제들을 직접 체험하셨을 거예요. 특히 &quot;메모이제이션은 만능이 아니다&quot;라는 깨달음과 함께 구조적 개선의 중요성을 인식하신 점이 훌륭합니다.</p>
<hr/>
<p>Q1. 업무를 진행하실 때 메모이제이션을 다 해놓은 편인가요? 아니면 성능 이슈가 발생했을 때 적용하시나요?</p>
<p>=&gt; 개인적인 취향 내지는 철학에 관련된 질문이라고 이해하고 개인적인 답변을 하자면 저는 useMemo식의 메모제이션을 가급적 잘 쓰지 않으려고 합니다. 리렌더링의 이유가 달라지는 컴포넌트를 쪼개고 컴포넌트에 props를 통한 memo를 거는 방법을 선호합니다.</p>
<p>Q2. 만약 성능이슈가 발생해서 메모이제이션을 적용하신 경험이 있다면 한번 소개해주시면 감사합니다!</p>
<p>=&gt; 저는 어플리케이션류는 React를 주로 쓰지 않았고 제가 해봤던 React의 경우는 주로 대시보드 형 페이지라 성능이슈가 발생해본 경험이 없네요.</p>
<p>Q3. 컨텍스트와 상태관리에 대한 코치님의 생각도 궁금합니다.</p>
<p>=&gt; Context는 값이 변경이 되면 전체를 리렌더링을 발생시키기에 상태관리로는 부적합합니다. 자주 변하지 않을 값 그렇지만 변하면 다시 전체를 그려내야하는 값을 보관하거나 값을 격리하는데 유리하죠. 테마라던가 언어, 혹은 각종설정값이나 전역객체들이요.</p>
<p>=&gt; 상태관리는 말 그대로 뷰와 상태를 분리하고자는 개념에서 나온것이기에 Context로 상태관리를 구현할 수 있는 있지만 별개의 개념으로 다루는 것이 맞다고 생각을 합니다. 그리고 상태관리의 store를 격리하기 위해서는 context의 도움이 필요하겠죠.</p>
<p>수고하셨습니다. 깊이를 탐구하는 지난 몇 주간의 Deep dive 경험이 즐거운 시간과 함께 탐구하는 방법에 대한 시야를 넓혀주는 계기가 되었기를 바래요. 앞으로 하게 될 클린코드 챕터에서도 이런 탐구 정신을 마음껏 발휘해보시기 바랍니다. 화이팅입니다!</p></div></div><div class="mt-9"></div></div></main></div></div></div></div>
</body>
</html>
