<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>항해플러스 프론트엔드 6기 기술블로그</title>
  <link rel="icon" href="/front_6th/favicon.ico"/>
  
    <title>김지혜 - [4팀 김지혜] Chapter 1-3. React, Beyond the Basics</title>
    <meta name="description" content="김지혜님의 [4팀 김지혜] Chapter 1-3. React, Beyond the Basics 과제 상세보기" />
    <meta name="keywords" content="항해플러스, 프론트엔드, 기술블로그, React, JavaScript, 김지혜, [4팀 김지혜] Chapter 1-3. React, Beyond the Basics" />
    <meta property="og:title" content="김지혜 - [4팀 김지혜] Chapter 1-3. React, Beyond the Basics" />
    <meta property="og:description" content="김지혜님의 [4팀 김지혜] Chapter 1-3. React, Beyond the Basics 과제 상세보기" />
    <meta property="og:image" content="/assignment-og.png" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="김지혜 - [4팀 김지혜] Chapter 1-3. React, Beyond the Basics" />
    <meta name="twitter:description" content="김지혜님의 [4팀 김지혜] Chapter 1-3. React, Beyond the Basics 과제 상세보기" />
    <meta name="twitter:image" content="/assignment-og.png" />
  
  <script type="module" crossorigin src="/front_6th/assets/index-S6z1r9QJ.js"></script>
  <link rel="stylesheet" crossorigin href="/front_6th/assets/index-BXO68frB.css">
</head>
<body>
<div id="root"><div data-slot="sidebar-wrapper" style="--sidebar-width:16rem;--sidebar-width-icon:3rem" class="group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full"><div class="min-h-screen flex w-full"><div class="group peer text-sidebar-foreground hidden md:block" data-state="expanded" data-collapsible="" data-variant="sidebar" data-side="left" data-slot="sidebar"><div data-slot="sidebar-gap" class="relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear group-data-[collapsible=offcanvas]:w-0 group-data-[side=right]:rotate-180 group-data-[collapsible=icon]:w-(--sidebar-width-icon)"></div><div data-slot="sidebar-container" class="fixed inset-y-0 z-10 hidden h-svh transition-[left,right,width] duration-200 ease-linear md:flex left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)] group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l w-64"><div data-sidebar="sidebar" data-slot="sidebar-inner" class="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"><div data-slot="sidebar-content" data-sidebar="content" class="flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden bg-card border-r border-border"><a class="p-4" href="/front_6th/" data-discover="true"><div class="flex items-center space-x-2 mb-6"><div class="w-8 h-8 bg-gradient-primary rounded-lg flex items-center justify-center"><span class="text-white font-bold text-sm">6기</span></div><h4 class="text-lg font-bold text-primary">항해플러스 프론트엔드</h4></div></a><div data-slot="sidebar-group" data-sidebar="group" class="relative flex w-full min-w-0 flex-col p-2"><div data-slot="sidebar-group-label" data-sidebar="group-label" class="ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0 text-muted-foreground px-4">학습 관리</div><div data-slot="sidebar-group-content" data-sidebar="group-content" class="w-full text-sm"><ul data-slot="sidebar-menu" data-sidebar="menu" class="flex w-full min-w-0 flex-col gap-1 px-2"><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_6th/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-users h-5 w-5" aria-hidden="true"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><path d="M16 3.128a4 4 0 0 1 0 7.744"></path><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><circle cx="9" cy="7" r="4"></circle></svg><span class="ml-3">수강생 목록</span></a></li><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_6th/assignments/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open h-5 w-5" aria-hidden="true"><path d="M12 7v14"></path><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"></path></svg><span class="ml-3">과제 목록</span></a></li></ul></div></div></div></div></div></div><div class="flex-1 min-w-0"><header class="h-12 flex items-center border-b border-border bg-card px-4"><button data-slot="sidebar-trigger" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-7 mr-4 text-white" data-sidebar="trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-panel-left" aria-hidden="true"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M9 3v18"></path></svg><span class="sr-only">Toggle Sidebar</span></button><h4 class="text-lg font-semibold "><a href="/front_6th/@adds9810/" data-discover="true">adds9810<!-- --> 님의 상세페이지</a> ＞ <!-- -->[4팀 김지혜] Chapter 1-3. React, Beyond the Basics</h4></header><main class="p-6"><div><div class="card-wrap"><div data-slot="card" class="card text-card-foreground flex flex-col gap-6 shadow-sm mb-6 p-6 border border-gray-700 bg-gray-800 rounded-lg"><a href="https://github.com/hanghae-plus/front_6th_chapter1-3/pull/48" target="_blank"><div class="flex items-start gap-4"><div class="flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" height="32" aria-hidden="true" viewBox="0 0 24 24" width="32" fill="white" class="w-8 h-8"><path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg></div><div class="flex-1 min-w-0"><div class="flex items-center gap-2 mb-2"><h3 class="text-lg font-semibold text-white truncate">[4팀 김지혜] Chapter 1-3. React, Beyond the Basics</h3></div><div class="flex items-center gap-4 text-xs text-gray-500"><span>by <!-- -->adds9810</span><span>2025. 7. 23.</span></div></div></div></a></div></div><div class="overflow-auto"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-체크포인트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-체크포인트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 체크포인트</h2>
<h3 id="배포-링크"><a class="anchor" aria-hidden="true" tabindex="-1" href="#배포-링크"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>배포 링크</h3>
<p><a href="https://adds9810.github.io/front_6th_chapter1-3/">https://adds9810.github.io/front_6th_chapter1-3/</a></p>
<h3 id="기본과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기본과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기본과제</h3>
<h4 id="equalities"><a class="anchor" aria-hidden="true" tabindex="-1" href="#equalities"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>equalities</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> shallowEquals 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> deepEquals 구현 완료</li>
</ul>
<h4 id="hooks"><a class="anchor" aria-hidden="true" tabindex="-1" href="#hooks"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>hooks</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useRef 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useMemo 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useCallback 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useDeepMemo 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useShallowState 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useAutoCallback 구현 완료</li>
</ul>
<h4 id="high-order-components"><a class="anchor" aria-hidden="true" tabindex="-1" href="#high-order-components"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>High Order Components</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> memo 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> deepMemo 구현 완료</li>
</ul>
<h3 id="심화-과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#심화-과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>심화 과제</h3>
<h4 id="hooks-1"><a class="anchor" aria-hidden="true" tabindex="-1" href="#hooks-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>hooks</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> createObserver를 useSyncExternalStore에 사용하기 적합한 코드로 개선</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useShallowSelector 구현</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useStore 구현</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useRouter 구현</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useStorage 구현</li>
</ul>
<h3 id="context"><a class="anchor" aria-hidden="true" tabindex="-1" href="#context"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>context</h3>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> ToastContext, ModalContext 개선</li>
</ul>
<h2 id="과제-셀프회고"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-셀프회고"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 셀프회고</h2>
<p>이번 과제는 React를 그냥 쓰기만 하던 라이브러리에서 진짜 어떻게 돌아가는지 알 수 있게 해준 과제였습니다. 강의에서 배워서 알고있던 useRef, useMemo 같은 것들을 useState부터 하나하나 직접 만들어보면서, 이런 기능들이 왜 만들어졌는지 알 수 있었습니다.
useSyncExternalStore 써서 외부 상태 연결하고, Context API 쓸 때 성능 문제 생기는 것도 경험해보면서 최적화가 왜 중요한지 알게 됐습니다.
이 모든 과정이 그냥 따로따로 알던 지식들을 하나로 연결해주고, React가 실제로 어떻게 작동하는지 깊게 이해할 수 있게 해줬습니다. 또한 AI 사용하는 방식도 1, 2주차에는 무작정 의존하던 것에서 이번에는 문서 보고 시도한 다음에 AI한테 질문하는 식으로 더 나아졌습니다.</p>
<h3 id="기술적-성장"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기술적-성장"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기술적 성장</h3>
<ol>
<li><strong>React 훅의 내부 동작 원리 이해</strong></li>
</ol>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token comment">// packages/lib/src/hooks/useRef.ts - 렌더링 되어도 참조값 유지</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>initialValue<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span> current<span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">}</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>ref<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> current<span class="token operator">:</span> initialValue <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">return</span> ref<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// packages/lib/src/hooks/useMemo.ts - 의존성 비교 기반 메모이제이션</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">useMemo</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token function-variable function">factory</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">,</span> _deps<span class="token operator">:</span> <span class="token maybe-class-name">DependencyList</span><span class="token punctuation">,</span> _equals <span class="token operator">=</span> shallowEquals<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// 1. 이전 의존성과 결과를 저장할 ref 생성</span>
</span><span class="code-line">  <span class="token keyword">const</span> prevDeps <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span>DependencyList<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> prevResult <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// 2. 현재 의존성과 이전 의존성 비교</span>
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevResult<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">_equals</span><span class="token punctuation">(</span>prevDeps<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">,</span> _deps<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">// 3. 의존성이 변경된 경우 factory(새로운 값을 계산) 함수 실행 및 결과 저장</span>
</span><span class="code-line">    prevDeps<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> _deps<span class="token punctuation">;</span>
</span><span class="code-line">    prevResult<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// 4. 메모이제이션된 값 반환</span>
</span><span class="code-line">  <span class="token keyword">return</span> prevResult<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// packages/lib/src/hooks/useRef.ts - 렌더링 되어도 참조값 유지
export function useRef&lt;T&gt;(initialValue: T): { current: T } {
  const [ref] = useState(() =&gt; ({ current: initialValue }));
  return ref;
}

// packages/lib/src/hooks/useMemo.ts - 의존성 비교 기반 메모이제이션
export function useMemo&lt;T&gt;(factory: () =&gt; T, _deps: DependencyList, _equals = shallowEquals): T {
  // 1. 이전 의존성과 결과를 저장할 ref 생성
  const prevDeps = useRef&lt;DependencyList&gt;([]);
  const prevResult = useRef&lt;T | null&gt;(null);

  // 2. 현재 의존성과 이전 의존성 비교
  if (prevResult.current === null || !_equals(prevDeps.current, _deps)) {
    // 3. 의존성이 변경된 경우 factory(새로운 값을 계산) 함수 실행 및 결과 저장
    prevDeps.current = _deps;
    prevResult.current = factory();
  }

  // 4. 메모이제이션된 값 반환
  return prevResult.current;
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>강의에서 배웠던 훅들을 직접 구현해보니 <strong>useState 기반으로 동작한다는 것</strong>을 알게 되었습니다.</p>
<ol start="2">
<li><strong>useAutoCallback 패턴</strong></li>
</ol>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token comment">// packages/lib/src/hooks/useAutoCallback.ts</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> useAutoCallback <span class="token operator">=</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">T</span></span> <span class="token attr-name">extends</span> <span class="token attr-name">AnyFunction</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">(fn: T): T =&gt; </span><span class="token punctuation">{</span>
</span><span class="code-line"> <span class="token comment">// 콜백함수가 참조하는 값은 항상 렌더링 시점에 최신화</span>
</span><span class="code-line">  <span class="token keyword">const</span> fnRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  fnRef<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> fn<span class="token punctuation">;</span> 
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// 항상 같은 함수 반환</span>
</span><span class="code-line">  <span class="token keyword">const</span> stableCallback <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">return</span> fnRef<span class="token punctuation">.</span><span class="token method function property-access">current</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 빈 의존성 배열로 참조 고정</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> stableCallback <span class="token keyword">as</span> <span class="token constant">T</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token plain-text">;
</span></span></code><div class="copied" data-code="// packages/lib/src/hooks/useAutoCallback.ts
export const useAutoCallback = &lt;T extends AnyFunction&gt;(fn: T): T =&gt; {
 // 콜백함수가 참조하는 값은 항상 렌더링 시점에 최신화
  const fnRef = useRef(fn);
  fnRef.current = fn; 

  // 항상 같은 함수 반환
  const stableCallback = useCallback((...args: unknown[]) =&gt; {
    return fnRef.current(...args);
  }, []); // 빈 의존성 배열로 참조 고정

  return stableCallback as T;
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>&quot;참조는 고정하되 최신 값은 참조&quot;라는 까다로운 요구사항을 <code>useRef</code> + <code>useCallback</code> 조합으로 해결하는 패턴을 알게 되었습니다.</p>
<ol start="3">
<li><strong>Observer 패턴과 useSyncExternalStore 연동</strong></li>
</ol>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token comment">// packages/lib/src/createObserver.ts</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">createObserver</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> listeners <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set<span class="token operator">&lt;</span>Listener<span class="token operator">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token function-variable function">unsubscribe</span> <span class="token operator">=</span> <span class="token punctuation">(</span>fn<span class="token operator">:</span> <span class="token maybe-class-name">Listener</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    listeners<span class="token punctuation">.</span><span class="token method function property-access">delete</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token function-variable function">subscribe</span> <span class="token operator">=</span> <span class="token punctuation">(</span>fn<span class="token operator">:</span> <span class="token maybe-class-name">Listener</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    listeners<span class="token punctuation">.</span><span class="token method function property-access">add</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 리스너 등록</span>
</span><span class="code-line">    <span class="token comment">// 구독 취소 함수 반환</span>
</span><span class="code-line">    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token function">unsubscribe</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token function-variable function">notify</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> listeners<span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token function">listener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">{</span> subscribe<span class="token punctuation">,</span> notify <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// packages/lib/src/createObserver.ts
export const createObserver = () =&gt; {
  const listeners = new Set&lt;Listener&gt;();

  const unsubscribe = (fn: Listener) =&gt; {
    listeners.delete(fn);
  };

  const subscribe = (fn: Listener) =&gt; {
    listeners.add(fn); // 리스너 등록
    // 구독 취소 함수 반환
    return () =&gt; {
      unsubscribe(fn);
    };
  };

  const notify = () =&gt; listeners.forEach((listener) =&gt; listener());
  return { subscribe, notify };
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>useSyncExternalStore와 호환되려면 <strong><code>subscribe</code> 함수가 구독 취소 함수를 반환해야 한다는 스펙</strong>을 학습했습니다.</p>
<p><strong>기존 지식의 재발견/심화:</strong></p>
<ul>
<li><strong>메모이제이션</strong>: 강의에서 배웠던 <code>useMemo</code>, <code>useCallback</code>의 실제 구현 방식 이해
이론적으로만 알고 있던 메모이제이션이 실제로는 <code>useRef</code>를 사용해서 이전 값과 현재 값을 비교하고, 의존성이 변경되었을 때만 새로운 값을 계산하는 방식으로 동작한다는 것을 직접 구현해보며 이해할 수 있었다. 특히 <code>shallowEquals</code> 함수를 사용해서 의존성 배열을 비교하는 부분에서, 단순히 <code>===</code> 비교가 아닌 얕은 비교를 통해 객체의 내용을 비교하는 것이 중요하다는 것을 체감했습니다.</li>
<li><strong>함수 참조 안정성</strong>: 이론으로만 알고 있던 개념을 실제로 구현하며 체감
React에서 함수 참조가 불안정하면 하위 컴포넌트가 불필요하게 리렌더링된다는 이론을 알고 있었지만, 실제로 <code>ToastProvider</code>에서 함수들이 매번 새로 생성되어 <code>ProductCard</code>가 계속 리렌더링되는 문제를 겪어보면서 그 심각성을 직접 체감했다. 특히 <code>Context value</code>로 전달되는 함수들의 참조 안정성이 얼마나 중요한지, 그리고 <code>useMemo</code>, <code>useCallback</code>, <code>useAutoCallback</code>을 적절히 조합해서 사용해야 한다는 것을 실제 문제 해결 과정에서 깊이 이해할 수 있었습니다.</li>
</ul>
<p><strong>구현 과정에서의 기술적 도전과 해결:</strong>
<code>useAutoCallback</code>을 만들 때 타입 때문에 고생했습니다. 처음에는 타입을 몰라서 이렇게 코드만 적었었습니다.:</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token comment">// 초기 코드 - 타입 에러 발생</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">useAutoCallback</span> <span class="token operator">=</span> <span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> fnRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  fnRef<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> fn<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">const</span> stableCallback <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">return</span> fnRef<span class="token punctuation">.</span><span class="token method function property-access">current</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> stableCallback<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 초기 코드 - 타입 에러 발생
export const useAutoCallback = (fn) =&gt; {
  const fnRef = useRef(fn);
  fnRef.current = fn;

  const stableCallback = useCallback((...args) =&gt; {
    return fnRef.current(...args);
  }, []);

  return stableCallback;
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>그런데 TypeScript에서 타입 에러가 나서 제네릭이라는 걸 처음 써봤는데, 함수의 타입을 미리 정해놓지 않고 나중에 정할 수 있게 하는 건데, 이게 생각보다 복잡했습니다.</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token comment">// 수정한 코드</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> useAutoCallback <span class="token operator">=</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">T</span></span> <span class="token attr-name">extends</span> <span class="token attr-name">AnyFunction</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">(fn: T): T =&gt; </span><span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// 콜백함수가 참조하는 값은 항상 렌더링 시점에 최신화</span>
</span><span class="code-line">  <span class="token keyword">const</span> fnRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  fnRef<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> fn<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// 대신 항상 동일한 참조를 유지해야 한다 (useCallback 활용)</span>
</span><span class="code-line">  <span class="token comment">// 어떤 인자가 올지 모르니 (...args: unknown[])로 모두 받아서 전달</span>
</span><span class="code-line">  <span class="token keyword">const</span> stableCallback <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">return</span> fnRef<span class="token punctuation">.</span><span class="token method function property-access">current</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// 반환 타입을 T로 맞춰주기 위해 as T 사용</span>
</span><span class="code-line">  <span class="token keyword">return</span> stableCallback <span class="token keyword">as</span> <span class="token constant">T</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token plain-text">;
</span></span></code><div class="copied" data-code="// 수정한 코드
export const useAutoCallback = &lt;T extends AnyFunction&gt;(fn: T): T =&gt; {
  // 콜백함수가 참조하는 값은 항상 렌더링 시점에 최신화
  const fnRef = useRef(fn);
  fnRef.current = fn;

  // 대신 항상 동일한 참조를 유지해야 한다 (useCallback 활용)
  // 어떤 인자가 올지 모르니 (...args: unknown[])로 모두 받아서 전달
  const stableCallback = useCallback((...args: unknown[]) =&gt; {
    return fnRef.current(...args);
  }, []);

  // 반환 타입을 T로 맞춰주기 위해 as T 사용
  return stableCallback as T;
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>처음에는 <code>unknown[]</code>라는 타입을 봤을 때 &quot;이게 뭐지?&quot; 싶었습니다. unknown은 &quot;아무 타입이나 될 수 있다&quot;는 뜻인데, 배열로 만들어서 함수의 인자들을 받는 거였다. 근데 이걸 다시 원래 함수의 타입으로 바꿔줘야 하는데, TypeScript가 자동으로 해주지 않아서 <code>as T</code>라는 타입 단언을 써야 했습니다.
이렇게 해서 &quot;참조는 고정하되 최신 값은 참조&quot;라는 요구사항을 만족할 수 있었습니다. 강의에서 배운 개념들이지만 실제로 구현해보니까 하나하나가 다 어려웠습니다. 이후로도 <code>shallowEquals</code>나 <code>createObserver</code> 같은 다른 함수들을 만들 때도 비슷한 타입 에러들을 종종 마주쳤는데, 하나씩 해결해나가면서 TypeScript를 조금씩 이해할 수 있게 되었습니다.</p>
<h3 id="자랑하고-싶은-코드"><a class="anchor" aria-hidden="true" tabindex="-1" href="#자랑하고-싶은-코드"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>자랑하고 싶은 코드</h3>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> useAutoCallback <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">AnyFunction</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>fn<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// 콜백함수가 참조하는 값은 항상 렌더링 시점에 최신화</span>
</span><span class="code-line">  <span class="token keyword">const</span> fnRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  fnRef<span class="token punctuation">.</span>current <span class="token operator">=</span> fn<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// 대신 항상 동일한 참조를 유지해야 한다 (useCallback 활용)</span>
</span><span class="code-line">  <span class="token comment">// ...args 어떤 인자든 그대로 실행</span>
</span><span class="code-line">  <span class="token comment">// 어떤 인자가 올지 모르니 (...args: unknown[])로 모두 받아서 전달</span>
</span><span class="code-line">  <span class="token keyword">const</span> stableCallback <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">return</span> fnRef<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// 반환 타입을 T로 맞춰주기 위해 as T 사용</span>
</span><span class="code-line">  <span class="token keyword">return</span> stableCallback <span class="token keyword">as</span> <span class="token constant">T</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span></code><div class="copied" data-code="export const useAutoCallback = &lt;T extends AnyFunction&gt;(fn: T): T =&gt; {
  // 콜백함수가 참조하는 값은 항상 렌더링 시점에 최신화
  const fnRef = useRef(fn);
  fnRef.current = fn;

  // 대신 항상 동일한 참조를 유지해야 한다 (useCallback 활용)
  // ...args 어떤 인자든 그대로 실행
  // 어떤 인자가 올지 모르니 (...args: unknown[])로 모두 받아서 전달
  const stableCallback = useCallback((...args: unknown[]) =&gt; {
    return fnRef.current(...args);
  }, []);

  // 반환 타입을 T로 맞춰주기 위해 as T 사용
  return stableCallback as T;
};

"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>&quot;참조는 고정하되 최신 값은 참조&quot;라는 까다로운 요구사항을 useRef + useCallback 조합으로 해결한 부분이 가장 만족스럽습니다. 처음에는 타입 때문에 고생했지만, 제네릭과 unknown[], as T 타입 단언을 사용해서 TypeScript의 복잡한 타입 시스템을 해결할 수 있었습니다.</p>
<h3 id="개선이-필요하다고-생각하는-코드"><a class="anchor" aria-hidden="true" tabindex="-1" href="#개선이-필요하다고-생각하는-코드"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>개선이 필요하다고 생각하는 코드</h3>
<p><strong>useMemo 과도한 사용</strong></p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// packages/app/src/components/toast/ToastProvider.tsx - 현재 5번의 useMemo 사용</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token punctuation">{</span> show<span class="token punctuation">,</span> hide <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">createActions</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>dispatch<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> hideAfter <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">debounce</span><span class="token punctuation">(</span>hide<span class="token punctuation">,</span> <span class="token constant">DEFAULT_DELAY</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>hide<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> showWithHide <span class="token operator">=</span> <span class="token function">useAutoCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 내부에서 useMemo 사용</span>
</span><span class="code-line"><span class="token keyword">const</span> commandValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> show<span class="token operator">:</span> showWithHide<span class="token punctuation">,</span> hide <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>showWithHide<span class="token punctuation">,</span> hide<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> stateValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> message<span class="token operator">:</span> state<span class="token punctuation">.</span>message<span class="token punctuation">,</span> type<span class="token operator">:</span> state<span class="token punctuation">.</span>type <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>state<span class="token punctuation">.</span>message<span class="token punctuation">,</span> state<span class="token punctuation">.</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// packages/app/src/components/toast/ToastProvider.tsx - 현재 5번의 useMemo 사용
const { show, hide } = useMemo(() =&gt; createActions(dispatch), [dispatch]);
const hideAfter = useMemo(() =&gt; debounce(hide, DEFAULT_DELAY), [hide]);
const showWithHide = useAutoCallback((...args) =&gt; { ... }); // 내부에서 useMemo 사용
const commandValue = useMemo(() =&gt; ({ show: showWithHide, hide }), [showWithHide, hide]);
const stateValue = useMemo(() =&gt; ({ message: state.message, type: state.type }), [state.message, state.type]);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>E2E 테스트 통과 과정에서 하나씩 메모이제이션을 추가하다 보니 이렇게 됐는데, useMemo를 이렇게 많이 써도 되는 건지 잘 모르겠습니다. 특히 { message: state.message, type: state.type } 같은 경우도 useMemo로 감싸야 하는 건지, 그리고 이런 식으로 계속 메모이제이션을 추가하는 게 올바른 방법인지 판단이 서지 않습니다. 더 나은 구조가 있다면 개선하고 싶습니다.</p>
<h3 id="학습-효과-분석"><a class="anchor" aria-hidden="true" tabindex="-1" href="#학습-효과-분석"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>학습 효과 분석</h3>
<p><strong>가장 큰 배움이 있었던 부분</strong></p>
<ul>
<li><strong>리렌더링 과정의 이해</strong>: 이론으로만 알고 있던 React의 리렌더링 과정을 직접 겪어보면서 깊이 이해할 수 있었습니다. 특히 <code>ToastProvider</code>에서 함수들이 매번 새로 생성되어 <code>ProductCard</code>가 불필요하게 리렌더링되는 문제를 해결하면서, Context value의 참조 안정성이 얼마나 중요한지 알게 되었습니다.</li>
<li><strong>메모이제이션의 중요성</strong>: 단순히 <code>useMemo</code>나 <code>useCallback</code>을 사용하는 것이 아니라, 모든 불안정한 참조를 하나씩 메모이제이션해야 한다는 것을 배웠습니다. 하나라도 빠뜨리면 전체가 다시 리렌더링되는 경험을 통해 메모이제이션의 중요성을 깊이 이해할 수 있었습니다.</li>
</ul>
<p><strong>추가 학습이 필요한 영역</strong></p>
<ul>
<li><strong>타입스크립트 고급 기능</strong>: 제네릭과 타입 단언을 사용하면서 TypeScript의 복잡한 타입 시스템에 대한 이해가 부족하다는 것을 느꼈습니다. 특히 <code>unknown[]</code> 타입과 <code>as T</code> 타입 단언을 사용할 때 타입 안전성에 대한 고민이 필요할 것 같습니다.</li>
<li><strong>성능 최적화 감각</strong>: 언제 메모이제이션을 사용해야 하는지, 어떤 부분에서 성능 이슈가 발생할 수 있는지에 대한 경험과 감각이 부족하다는 것을 깨달았습니다. E2E 테스트를 통해서만 문제를 발견할 수 있었던 점이 아쉬웠습니다. 실제 개발 과정에서 미리 예측하고 최적화하는 감각을 기르고 싶습니다.</li>
</ul>
<p><strong>실무 적용 가능성</strong></p>
<ul>
<li><strong>상태 관리 라이브러리 이해</strong>: 직접 상태 관리 라이브러리를 구현해보면서 Zustand나 Redux 같은 라이브러리들이 내부적으로 어떻게 동작하는지 이해할 수 있었습니다. 이는 실제 프로젝트에서 상태 관리 라이브러리를 선택하고 사용할 때 도움이 될 것 같습니다.</li>
<li><strong>커스텀 훅 설계</strong>: <code>useAutoCallback</code>, <code>useShallowSelector</code> 같은 커스텀 훅을 직접 구현하면서 재사용 가능한 로직을 설계하는 방법을 배웠습니다. 이는 실제 프로젝트에서 공통 로직을 추상화할 때 유용할 것 같습니다.</li>
</ul>
<h3 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h3>
<p><strong>과제에서 좋았던 부분:</strong></p>
<ul>
<li><strong>단계별 구현</strong>: useRef → useMemo → useCallback 순서로 의존성을 가진 구현이 학습에 효과적이었습니다.</li>
<li><strong>실제 동작하는 애플리케이션</strong>: 단순한 예제가 아닌 실제 쇼핑몰을 통한 학습이 재밌었습니다.</li>
<li><strong>E2E 테스트</strong>: 실제 성능 문제를 발견할 수 있는 현실적인 테스트가 도움되었습니다.</li>
<li><strong>자립적인 학습 경험</strong>: 1, 2주차에 비해 AI에 무작정 의존하지 않고 조언이나 공유해주신 문서를 보고 ai에게 물어보며 해결을 해서 이전보다 기억에 더 남았습니다. 특히 useSyncExternalStore나 Observer 패턴 같은 개념들을 직접 찾아보고 이해하려고 노력한 게 도움이 되었습니다.</li>
</ul>
<p><strong>과제에서 어려웠던 부분:</strong></p>
<ul>
<li><strong>메모이제이션 기준</strong>: 가이드를 보고 상황에 맞게 적용하는 것도 제 능력인데, 아직 그런 경험과 감각이 부족해서 언제 useMemo를 사용해야 하는지를 잘 몰랐던 것 같습니다.</li>
<li><strong>타입 에러</strong>: TypeScript 활용을 잘 못해 관련 에러 해결에 시간이 많이 소요되었습니다.</li>
</ul>
<h2 id="학습-갈무리"><a class="anchor" aria-hidden="true" tabindex="-1" href="#학습-갈무리"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>학습 갈무리</h2>
<h3 id="리액트의-렌더링이-어떻게-이루어지는지-정리해주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리액트의-렌더링이-어떻게-이루어지는지-정리해주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리액트의 렌더링이 어떻게 이루어지는지 정리해주세요.</h3>
<p>리액트의 렌더링은 컴포넌트의 <code>state</code>나 <code>props</code>가 변경될 때 발생하며, 크게 세 단계로 이루어집니다.</p>
<ol>
<li><strong>렌더(Render) 단계</strong>:
<ul>
<li>state/props 변경, 부모 컴포넌트 리렌더링, 또는 <code>forceUpdate</code> 호출 시 렌더링이 실행됩니다.</li>
<li>React는 컴포넌트 함수를 호출하여 어떤 UI를 그려야 할지 결정하고, 그 결과로 가상돔(Virtual DOM) 객체가 만들어 집니다. 이 과정은 실제 DOM을 변경하지 않으므로 비용이 저렴합니다.</li>
</ul>
</li>
<li><strong>조정(Reconciliation) 단계</strong>:
<ul>
<li>새로 생성된 가상돔과 이전 가상돔을 비교하여 변경된 부분을 찾아냅니다.(Diffing)</li>
<li>React는 효율적인 Diffing 알고리즘을 사용하여 최소한의 변경사항을 계산합니다.</li>
</ul>
</li>
<li><strong>커밋(Commit) 단계</strong>:
<ul>
<li>조정 단계에서 찾아낸 변경사항들을 실제 DOM에 한 번에 적용하여 UI를 업데이트 합니다.
이 과정은 실제 브라우저가 화면을 새로 그려(렌더링 유발) 비용이 가장 크게 발생합니다.</li>
</ul>
</li>
</ol>
<p>이러한 과정을 최적화하기 위해 React는 <code>memo</code>, <code>useMemo</code>, <code>useCallback</code>과 같은 도구를 제공합니다. 이들은 렌더 단계에서 props나 의존성이 변경되지 않았을 경우, 이전 렌더 결과를 재사용하여 불필요한 가상돔 생성 및 Diffing 과정을 건너뛰게 해줍니다.</p>
<h3 id="메모이제이션에-대한-나의-생각을-적어주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#메모이제이션에-대한-나의-생각을-적어주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>메모이제이션에 대한 나의 생각을 적어주세요.</h3>
<p>메모이제이션은 &quot;비용이 비싼 연산의 결과를 저장해두고, 동일한 입력에 대해서는 저장된 결과를 재사용하는 기술&quot;이라고 생각합니다.</p>
<ul>
<li>
<p><strong>필요한 시점</strong>:</p>
<ul>
<li>복잡하고 무거운 계산이 포함된 함수의 반복 호출을 피하고 싶을 때 (useMemo).</li>
<li>자식 컴포넌트에 함수(콜백)를 props로 전달할 때, 불필요한 리렌더링을 방지하기 위해 함수의 참조 동등성을 유지해야 할 때 (useCallback).</li>
<li>컴포넌트의 props가 변경되지 않았음에도 부모의 리렌더링 때문에 불필요하게 다시 렌더링되는 것을 막고 싶을 때 (React.memo).</li>
</ul>
</li>
<li>
<p><strong>장점과 단점</strong>:</p>
<ul>
<li>장점: 불필요한 연산과 렌더링을 줄여 애플리케이션의 성능을 크게 향상시킬 수 있습니다.</li>
<li>단점: 메모리를 추가로 사용하여 이전 값과 의존성을 저장해야 하므로, 메모리 사용량이 늘어납니다. 또한, 모든 곳에 메모이제이션을 적용하면 오히려 의존성 비교 비용 때문에 성능이 저하되거나 코드가 복잡해질 수 있습니다.</li>
</ul>
</li>
</ul>
<p>결론적으로, 메모이제이션은 성능 저하가 실제로 발생하는 지점을 프로파일링 도구로 측정한 후, 꼭 필요한 곳에 전략적으로 사용하는 것이 중요합니다.(그렇지만 저는 이번 과제에서 남발한게 아닌가 하는 느낌;;;)</p>
<h3 id="컨텍스트와-상태관리에-대한-나의-생각을-적어주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#컨텍스트와-상태관리에-대한-나의-생각을-적어주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>컨텍스트와 상태관리에 대한 나의 생각을 적어주세요.</h3>
<p>컨텍스트와 상태관리는 &quot;컴포넌트 트리 전반에 걸쳐 흩어져 있는 데이터를 효율적으로 관리하고 공유하기 위한 솔루션&quot;이라고 생각합니다.</p>
<ul>
<li>
<p><strong>필요한 이유</strong>:</p>
<ul>
<li>Prop Drilling 해결: 여러 단계의 자식 컴포넌트로 props를 계속해서 내려주는 &#x27;Prop Drilling&#x27; 문제를 해결하고, 필요한 컴포넌트가 데이터에 직접 접근할 수 있게 해줍니다.</li>
<li>상태의 중앙화: 애플리케이션의 상태를 한 곳에서 관리하여 데이터 흐름을 예측 가능하고 디버깅하기 쉽게 만듭니다.</li>
</ul>
</li>
<li>
<p><strong>장점과 단점</strong>:</p>
<ul>
<li>장점: 코드 구조가 단순해지고, 상태 관리가 용이해지며, 컴포넌트 간의 결합도를 낮출 수 있습니다.</li>
<li>단점: React Context API는 컨텍스트 값이 변경되면 해당 컨텍스트를 구독하는 모든 컴포넌트가 리렌더링되는 문제가 있습니다. 이는 성능 저하의 원인이 될 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong>주의점 및 해결책</strong>:</p>
</li>
</ul>
<ol>
<li><strong>Context 분리의 중요성</strong></li>
</ol>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token comment">// 잘못된 예: 모든 것을 하나의 Context에</span>
</span><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ToastContext</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> show<span class="token punctuation">,</span> hide<span class="token punctuation">,</span> message<span class="token punctuation">,</span> type <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">// 올바른 예: 용도별로 분리
</span></span><span class="code-line"><span class="token plain-text"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ToastCommandContext</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> show<span class="token punctuation">,</span> hide <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ToastStateContext</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> message<span class="token punctuation">,</span> type <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span></code><div class="copied" data-code="// 잘못된 예: 모든 것을 하나의 Context에
&lt;ToastContext value={{ show, hide, message, type }}&gt;

// 올바른 예: 용도별로 분리
&lt;ToastCommandContext value={{ show, hide }}&gt;
  &lt;ToastStateContext value={{ message, type }}&gt;
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ol start="2">
<li><strong>Provider value 메모이제이션</strong></li>
</ol>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token comment">// 문제: 매번 새로운 객체 생성</span>
</span><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ToastCommandContext</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> show<span class="token operator">:</span> showWithHide<span class="token punctuation">,</span> hide <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">// 해결: 메모이제이션
</span></span><span class="code-line"><span class="token plain-text">const commandValue = useMemo(() =&gt; (</span><span class="token punctuation">{</span> show<span class="token operator">:</span> showWithHide<span class="token punctuation">,</span> hide <span class="token punctuation">}</span><span class="token plain-text">), [showWithHide, hide]);
</span></span><span class="code-line"><span class="token plain-text">const stateValue = useMemo(() =&gt; (</span><span class="token punctuation">{</span> message<span class="token operator">:</span> state<span class="token punctuation">.</span><span class="token property-access">message</span><span class="token punctuation">,</span> type<span class="token operator">:</span> state<span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token punctuation">}</span><span class="token plain-text">), [state.message, state.type]);
</span></span><span class="code-line"><span class="token plain-text"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ToastCommandContext</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>commandValue<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ToastStateContext</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>stateValue<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span></code><div class="copied" data-code="// 문제: 매번 새로운 객체 생성
&lt;ToastCommandContext value={{ show: showWithHide, hide }}&gt;

// 해결: 메모이제이션
const commandValue = useMemo(() =&gt; ({ show: showWithHide, hide }), [showWithHide, hide]);
const stateValue = useMemo(() =&gt; ({ message: state.message, type: state.type }), [state.message, state.type]);
&lt;ToastCommandContext value={commandValue}&gt;
  &lt;ToastStateContext value={stateValue}&gt;
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>상태관리 라이브러리 직접 구현 경험:</strong>
Observer 패턴을 기반으로 한 상태 관리 시스템을 구현하면서:</p>
<ul>
<li>useSyncExternalStore와의 호환성을 고려해야 한다는 것</li>
<li>subscribe 함수가 구독 취소 함수를 반환해야 한다는 것</li>
</ul>
<p><strong>Context vs 상태관리 라이브러리:</strong></p>
<ul>
<li>Context: React 내장, 간단한 전역 상태에 적합</li>
<li>상태관리 라이브러리: 복잡한 상태 로직, 성능 최적화에 유리</li>
</ul>
<p>이번 과제를 통해 둘 다 결국 &quot;상태 변경 시 구독자들에게 알림&quot;이라는 동일한 패턴을 사용한다는 것을 알게 되었습니다.</p>
<h2 id="리뷰-받고-싶은-내용"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리뷰-받고-싶은-내용"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리뷰 받고 싶은 내용</h2>
<ul>
<li><strong>ToastProvider에서 useMemo 과도한 사용</strong> : 해당 페이지에서 useMemo를 5번 사용하고 있는데 과도하게 사용되고 있다고 생각하지만 다른 방법을 모르겠습니다. 어찌저찌 요구사항과 테스트 통과를 위해 구현해내긴 했으나 더 좋은 방법이 있을지 궁금합니다.</li>
<li><strong>useAutoCallback 패턴이 올바른지</strong> : useRef와 useCallback을 조합해서 만든 건데, 이런 패턴이 실제로 쓰이는 방법인지 궁금합니다. 다른 더 좋은 방법이 있을까요?</li>
</ul></div></div><div class="overflow-auto mt-9"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h2>
<p>안녕하세요 지혜님! 3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다.</p>
<blockquote>
<p>&quot;참조는 고정하되 최신 값은 참조&quot;라는 까다로운 요구사항을 useRef + useCallback 조합으로 해결한 부분이 가장 만족스럽습니다. 처음에는 타입 때문에 고생했지만, 제네릭과 unknown[], as T 타입 단언을 사용해서 TypeScript의 복잡한 타입 시스템을 해결할 수 있었습니다.</p>
</blockquote>
<p>ref와 callback 등을 같이 사용하는 과정이 지혜님께 큰 챌린지였군요..! 그럼에도 불구하고 잘 학습하고 계셔서 다행이네요 ㅎㅎ</p>
<blockquote>
<p>E2E 테스트 통과 과정에서 하나씩 메모이제이션을 추가하다 보니 이렇게 됐는데, useMemo를 이렇게 많이 써도 되는 건지 잘 모르겠습니다. 특히 { message: state.message, type: state.type } 같은 경우도 useMemo로 감싸야 하는 건지, 그리고 이런 식으로 계속 메모이제이션을 추가하는 게 올바른 방법인지 판단이 서지 않습니다. 더 나은 구조가 있다면 개선하고 싶습니다.</p>
</blockquote>
<p>지금은 state를 메모이제이션 하지 않아도 무방해보여요. 잘 보면 state.message와 state.type 중 하나만 변화하는 경우가 없답니다. 둘의 변화가 똑같이 발생하는거죠.</p>
<p>메모이제이션을 하지 않아도 어차피 똑같은 메모리를 가르키게 된달까..? 그렇습니다.
그래서 다만 state를 2개 이상 사용하여 조합하는 값이 있을 때에는 useMemo를 사용하면 좋답니다!</p>
<blockquote>
<p>ToastProvider에서 useMemo 과도한 사용 : 해당 페이지에서 useMemo를 5번 사용하고 있는데 과도하게 사용되고 있다고 생각하지만 다른 방법을 모르겠습니다. 어찌저찌 요구사항과 테스트 통과를 위해 구현해내긴 했으나 더 좋은 방법이 있을지 궁금합니다.</p>
</blockquote>
<p>솔루션 코드도 살펴보시면 5번 정도 사용하고 있답니다 ㅎㅎ 저는 지금이 최선의 모습이라고 생각해요!
다만 state를 아예 contextValue로 사용하고 있기 때문에 메모이제이션을 해주지 않아도 무방해보이네요..!</p>
<blockquote>
<p>useAutoCallback 패턴이 올바른지 : useRef와 useCallback을 조합해서 만든 건데, 이런 패턴이 실제로 쓰이는 방법인지 궁금합니다. 다른 더 좋은 방법이 있을까요?</p>
</blockquote>
<p>실제로 쓰일 수 있답니다 ㅎㅎ
이를 대체할 수 잇는 더 좋은 방법? 에 대해 질문을 주신거라면... 아직은 잘 모르겠어요.</p>
<p>어떤 상황에 사용할 수 있는지는 제가 이야기 드리기보단 지혜님께서 추후에 필요할 때 &quot;이런게 있구나!?&quot; 라고 떠올리고 사용할 수 있는 순간이 있으리라 생각해요.</p></div></div><div class="mt-9"></div></div></main></div></div></div></div>
</body>
</html>
