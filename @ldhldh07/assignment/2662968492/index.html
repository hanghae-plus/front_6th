<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>항해플러스 프론트엔드 6기 기술블로그</title>
  <link rel="icon" href="/front_6th/favicon.ico"/>
  
  <script type="module" crossorigin src="/front_6th/assets/index-D-trimLw.js"></script>
  <link rel="stylesheet" crossorigin href="/front_6th/assets/index-CfASphmw.css">
</head>
<body>
<div id="root"><link rel="preload" as="image" href="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/react/react-original.svg"/><link rel="preload" as="image" href="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/vuejs/vuejs-original.svg"/><div data-slot="sidebar-wrapper" style="--sidebar-width:16rem;--sidebar-width-icon:3rem" class="group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full"><div class="min-h-screen flex w-full"><div class="group peer text-sidebar-foreground hidden md:block" data-state="expanded" data-collapsible="" data-variant="sidebar" data-side="left" data-slot="sidebar"><div data-slot="sidebar-gap" class="relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear group-data-[collapsible=offcanvas]:w-0 group-data-[side=right]:rotate-180 group-data-[collapsible=icon]:w-(--sidebar-width-icon)"></div><div data-slot="sidebar-container" class="fixed inset-y-0 z-10 hidden h-svh transition-[left,right,width] duration-200 ease-linear md:flex left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)] group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l w-64"><div data-sidebar="sidebar" data-slot="sidebar-inner" class="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"><div data-slot="sidebar-content" data-sidebar="content" class="flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden bg-card border-r border-border"><a class="p-4" href="/front_6th/" data-discover="true"><div class="flex items-center space-x-2 mb-6"><div class="w-8 h-8 bg-gradient-primary rounded-lg flex items-center justify-center"><span class="text-white font-bold text-sm">6기</span></div><h4 class="text-lg font-bold text-primary">항해플러스 프론트엔드</h4></div></a><div data-slot="sidebar-group" data-sidebar="group" class="relative flex w-full min-w-0 flex-col p-2"><div data-slot="sidebar-group-label" data-sidebar="group-label" class="ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0 text-muted-foreground px-4">학습 관리</div><div data-slot="sidebar-group-content" data-sidebar="group-content" class="w-full text-sm"><ul data-slot="sidebar-menu" data-sidebar="menu" class="flex w-full min-w-0 flex-col gap-1 px-2"><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_6th/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-users h-5 w-5" aria-hidden="true"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><path d="M16 3.128a4 4 0 0 1 0 7.744"></path><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><circle cx="9" cy="7" r="4"></circle></svg><span class="ml-3">수강생 목록</span></a></li><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_6th/assignments" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open h-5 w-5" aria-hidden="true"><path d="M12 7v14"></path><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"></path></svg><span class="ml-3">과제 목록</span></a></li></ul></div></div></div></div></div></div><div class="flex-1 min-w-0"><header class="h-12 flex items-center border-b border-border bg-card px-4"><button data-slot="sidebar-trigger" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-7 mr-4 text-white" data-sidebar="trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-panel-left" aria-hidden="true"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M9 3v18"></path></svg><span class="sr-only">Toggle Sidebar</span></button><h4 class="text-lg font-semibold "><a href="/front_6th/@ldhldh07/" data-discover="true">ldhldh07<!-- --> 님의 상세페이지</a> ＞ <!-- -->[9팀 임두현] Chapter 1-2. 프레임워크 없이 SPA 만들기</h4></header><main class="p-6"><div><div class="card-wrap"><div data-slot="card" class="card text-card-foreground flex flex-col gap-6 shadow-sm mb-6 p-6 border border-gray-700 bg-gray-800 rounded-lg"><a href="https://github.com/hanghae-plus/front_6th_chapter1-2/pull/30" target="_blank"><div class="flex items-start gap-4"><div class="flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" height="32" aria-hidden="true" viewBox="0 0 24 24" width="32" fill="white" class="w-8 h-8"><path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg></div><div class="flex-1 min-w-0"><div class="flex items-center gap-2 mb-2"><h3 class="text-lg font-semibold text-white truncate">[9팀 임두현] Chapter 1-2. 프레임워크 없이 SPA 만들기</h3></div><div class="flex items-center gap-4 text-xs text-gray-500"><span>by <!-- -->ldhldh07</span><span>2025. 7. 14.</span></div></div></div></a></div></div><div class="overflow-auto"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-체크포인트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-체크포인트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 체크포인트</h2>
<h3 id="배포-링크"><a class="anchor" aria-hidden="true" tabindex="-1" href="#배포-링크"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>배포 링크</h3>
<p><a href="https://ldhldh07.github.io/front_6th_chapter1-2/">https://ldhldh07.github.io/front_6th_chapter1-2/</a></p>
<h3 id="기본과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기본과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기본과제</h3>
<h4 id="가상돔을-기반으로-렌더링하기"><a class="anchor" aria-hidden="true" tabindex="-1" href="#가상돔을-기반으로-렌더링하기"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>가상돔을 기반으로 렌더링하기</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> createVNode 함수를 이용하여 vNode를 만든다.</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> normalizeVNode 함수를 이용하여 vNode를 정규화한다.</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> createElement 함수를 이용하여 vNode를 실제 DOM으로 만든다.</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 결과적으로, JSX를 실제 DOM으로 변환할 수 있도록 만들었다.</li>
</ul>
<h4 id="이벤트-위임"><a class="anchor" aria-hidden="true" tabindex="-1" href="#이벤트-위임"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>이벤트 위임</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 노드를 생성할 때 이벤트를 직접 등록하는게 아니라 이벤트 위임 방식으로 등록해야 한다</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 동적으로 추가된 요소에도 이벤트가 정상적으로 작동해야 한다</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 이벤트 핸들러가 제거되면 더 이상 호출되지 않아야 한다</li>
</ul>
<h3 id="심화-과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#심화-과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>심화 과제</h3>
<h4 id="diff-알고리즘-구현"><a class="anchor" aria-hidden="true" tabindex="-1" href="#diff-알고리즘-구현"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Diff 알고리즘 구현</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 초기 렌더링이 올바르게 수행되어야 한다</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> diff 알고리즘을 통해 변경된 부분만 업데이트해야 한다</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 새로운 요소를 추가하고 불필요한 요소를 제거해야 한다</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 요소의 속성만 변경되었을 때 요소를 재사용해야 한다</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 요소의 타입이 변경되었을 때 새로운 요소를 생성해야 한다</li>
</ul>
<h2 id="과제-셀프회고"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-셀프회고"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 셀프회고</h2>
<h3 id="기술적-성장"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기술적-성장"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기술적 성장</h3>
<p>2주차 과제는 1주차 과제와는 다른 해결과정을 요구했습니다. 1주차는 자유도가 높고 렌더링, 이벤트 위임과 관련된 동작을 구현해보는 과정에서 직접 로직을 구성하고 프로젝트 전체의 아키텍쳐를 짜는 경험을 제공했습니다.</p>
<p>반면 2주차는 어느정도 정해진 로직을 구현해야했습니다.
그래서 이번 과제에서 학습 포인트를 두가지로 잡았습니다.</p>
<ul>
<li>SPA의 로직을 이해한다</li>
<li>정해진 로직을 바닐라 JS 코드로 구현하는 능력을 기른다.</li>
</ul>
<h4 id="ai-활용-과정"><a class="anchor" aria-hidden="true" tabindex="-1" href="#ai-활용-과정"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>AI 활용 과정</h4>
<p>해당 방향성에 맞게 AI를 활용하는 방식 또한 달랐습니다.</p>
<p>docs를 만들어서 현재 진행사항이나 rule 그리고 전체적인 계획을 기록해서 ai가 보다 큰 관점에서 대답할 수 있도록 하는 것은 유지했습니다.
추가적으로 아래와 같이 지침을 정했습니다.</p>
<ul>
<li>직접 코드를 작성하거나 알려주지 않도록 했습니다. 그리고 단계별로 논리를 진행할 수 있도록 방향성을 말해달라 했습니다.</li>
<li>실제 기존 SPA 기술들이 작동하는 방식을 참고해서 적용해달라고 했습니다.</li>
<li>문제 해결 또한 원인을 분석하고 그 원인만 파악해달라고 했습니다.</li>
<li>추가적으로 이슈가 생겼을 경우 그 트러블슈팅 과정을 정리해서 문서로 남기도록 했습니다.</li>
</ul>
<p>이는 이번 과제가 동작 로직을 이해하는 것에 중점이 있다 생각했고 이를 위해서는 어느정도 직접 고민하고 작성해야 생각했기 때문입니다.</p>
<p>최대한 직접 코딩을 하고자 하였고, 적당한 고민 후에는 고민한 내용을 공유하고 그에 맞게 제시된 방향성으로 새롭게 로직을 만들어 나가는 식으로 진행했습니다.</p>
<h3 id="학습-효과-분석"><a class="anchor" aria-hidden="true" tabindex="-1" href="#학습-효과-분석"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>학습 효과 분석</h3>
<h4 id="spa의-동작"><a class="anchor" aria-hidden="true" tabindex="-1" href="#spa의-동작"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>SPA의 동작</h4>
<p>직접 코드를 작성하고 동작을 시켜보니 가상돔이 필요한 이유를 알 수 있었습니다.</p>
<p>가상DOM diff 로직중에서 렌더링 최적화에 기여한다고 판단되는 로직들이 있었습니다.</p>
<ul>
<li>속성만 변경될 경우 타입은 유지한채 속성만 변경(updateAttribute)</li>
</ul>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword">function</span> <span class="token function">updateAttributes</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> newProps<span class="token punctuation">,</span> oldProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> attributes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token spread operator">...</span><span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>newProps <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token spread operator">...</span><span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>oldProps <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  attributes<span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">attribute</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">const</span> newValue <span class="token operator">=</span> newProps<span class="token operator">?.</span><span class="token punctuation">[</span>attribute<span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">const</span> oldValue <span class="token operator">=</span> oldProps<span class="token operator">?.</span><span class="token punctuation">[</span>attribute<span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">    
</span><span class="code-line">    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">!==</span> oldValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token comment">// 값이 다를 때만 DOM 조작 수행</span>
</span><span class="code-line">      <span class="token comment">// 같으면 아무것도 하지 않아서 불필요한 setAttribute 방지</span>
</span><span class="code-line">      
</span><span class="code-line">      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>attribute<span class="token punctuation">.</span><span class="token method function property-access">startsWith</span><span class="token punctuation">(</span><span class="token string">&quot;on&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token comment">// 이벤트 핸들러 변경 처리</span>
</span><span class="code-line">      <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">==</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token comment">// 속성 제거</span>
</span><span class="code-line">      <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token comment">// 속성 설정</span>
</span><span class="code-line">      <span class="token punctuation">}</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">    <span class="token comment">// newValue === oldValue인 경우 완전히 스킵</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// updateElement에서 호출</span>
</span><span class="code-line"><span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>newNode<span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token operator">===</span> oldNode<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// 같은 타입이면 요소 재사용하고 속성만 업데이트</span>
</span><span class="code-line">  <span class="token function">updateAttributes</span><span class="token punctuation">(</span>targetElement<span class="token punctuation">,</span> newNode<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">,</span> oldNode<span class="token punctuation">.</span><span class="token property-access">props</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// 다른 타입이면 요소 전체 교체</span>
</span><span class="code-line">  parentElement<span class="token punctuation">.</span><span class="token method function property-access">replaceChild</span><span class="token punctuation">(</span>newChildElement<span class="token punctuation">,</span> targetChildElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="function updateAttributes(target, newProps, oldProps) {
  const attributes = new Set([...Object.keys(newProps || {}), ...Object.keys(oldProps || {})]);

  attributes.forEach((attribute) =&gt; {
    const newValue = newProps?.[attribute];
    const oldValue = oldProps?.[attribute];
    
    if (newValue !== oldValue) {
      // 값이 다를 때만 DOM 조작 수행
      // 같으면 아무것도 하지 않아서 불필요한 setAttribute 방지
      
      if (attribute.startsWith(&quot;on&quot;)) {
        // 이벤트 핸들러 변경 처리
      } else if (newValue == null) {
        // 속성 제거
      } else {
        // 속성 설정
      }
    }
    // newValue === oldValue인 경우 완전히 스킵
  });
}

// updateElement에서 호출
if (newNode.type === oldNode.type) {
  // 같은 타입이면 요소 재사용하고 속성만 업데이트
  updateAttributes(targetElement, newNode.props, oldNode.props);
} else {
  // 다른 타입이면 요소 전체 교체
  parentElement.replaceChild(newChildElement, targetChildElement);
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ul>
<li>특수 속성 직접 접근 수정</li>
</ul>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword">const</span> specialProperties <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;checked&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;selected&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;disabled&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;readOnly&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">==</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>specialProperties<span class="token punctuation">.</span><span class="token method function property-access">includes</span><span class="token punctuation">(</span>attribute<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    target<span class="token punctuation">[</span>attribute<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token comment">// DOM property에 직접 접근, setAttribute보다 빠름</span>
</span><span class="code-line">  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
</span><span class="code-line">    target<span class="token punctuation">.</span><span class="token method function property-access">removeAttribute</span><span class="token punctuation">(</span>attribute<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token comment">// 일반 속성은 attribute 제거</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>specialProperties<span class="token punctuation">.</span><span class="token method function property-access">includes</span><span class="token punctuation">(</span>attribute<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    target<span class="token punctuation">[</span>attribute<span class="token punctuation">]</span> <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token comment">// Boolean 속성은 property로 직접 설정</span>
</span><span class="code-line">    <span class="token comment">// target.checked = true가 target.setAttribute(&#x27;checked&#x27;, &#x27;true&#x27;)보다 빠름</span>
</span><span class="code-line">  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
</span><span class="code-line">    target<span class="token punctuation">.</span><span class="token method function property-access">setAttribute</span><span class="token punctuation">(</span>attribute<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token comment">// 일반 속성은 setAttribute 사용</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="const specialProperties = [&quot;checked&quot;, &quot;selected&quot;, &quot;disabled&quot;, &quot;readOnly&quot;];

if (newValue == null) {
  if (specialProperties.includes(attribute)) {
    target[attribute] = false;
    // DOM property에 직접 접근, setAttribute보다 빠름
  } else {
    target.removeAttribute(attribute);
    // 일반 속성은 attribute 제거
  }
} else {
  if (specialProperties.includes(attribute)) {
    target[attribute] = newValue;
    // Boolean 속성은 property로 직접 설정
    // target.checked = true가 target.setAttribute(&#x27;checked&#x27;, &#x27;true&#x27;)보다 빠름
  } else {
    target.setAttribute(attribute, newValue);
    // 일반 속성은 setAttribute 사용
  }
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ul>
<li>자식 노드 업데이트 순서로 인한 최적화</li>
</ul>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword">const</span> newChildren <span class="token operator">=</span> newNode<span class="token punctuation">.</span><span class="token property-access">children</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> oldChildren <span class="token operator">=</span> oldNode<span class="token punctuation">.</span><span class="token property-access">children</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> commonLength <span class="token operator">=</span> <span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token method function property-access">min</span><span class="token punctuation">(</span>newChildren<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">,</span> oldChildren<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 1단계: 공통 길이만큼 기존 요소들 재사용</span>
</span><span class="code-line"><span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> commonLength<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token function">updateElement</span><span class="token punctuation">(</span>targetElement<span class="token punctuation">,</span> newChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> oldChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token comment">// 기존 DOM 요소를 최대한 재사용</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 2단계: 초과하는 기존 요소들 삭제 (역순)</span>
</span><span class="code-line"><span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>oldChildren<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">&gt;</span> newChildren<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> oldChildren<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> newChildren<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    targetElement<span class="token punctuation">.</span><span class="token method function property-access">removeChild</span><span class="token punctuation">(</span>targetElement<span class="token punctuation">.</span><span class="token property-access">childNodes</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token comment">// 뒤에서부터 삭제해야 인덱스가 안 꼬임</span>
</span><span class="code-line">    <span class="token comment">// 앞에서부터 삭제하면 removeChild 후 인덱스가 변경됨</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 3단계: 새로운 요소들 추가</span>
</span><span class="code-line"><span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>newChildren<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">&gt;</span> oldChildren<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> oldChildren<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    targetElement<span class="token punctuation">.</span><span class="token method function property-access">appendChild</span><span class="token punctuation">(</span><span class="token function">createElement</span><span class="token punctuation">(</span>newChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token comment">// 새로 생성이 필요한 요소들만 createElement 호출</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="const newChildren = newNode.children || [];
const oldChildren = oldNode.children || [];
const commonLength = Math.min(newChildren.length, oldChildren.length);

// 1단계: 공통 길이만큼 기존 요소들 재사용
for (let i = 0; i &lt; commonLength; i++) {
  updateElement(targetElement, newChildren[i], oldChildren[i], i);
  // 기존 DOM 요소를 최대한 재사용
}

// 2단계: 초과하는 기존 요소들 삭제 (역순)
if (oldChildren.length &gt; newChildren.length) {
  for (let i = oldChildren.length - 1; i &gt;= newChildren.length; i--) {
    targetElement.removeChild(targetElement.childNodes[i]);
    // 뒤에서부터 삭제해야 인덱스가 안 꼬임
    // 앞에서부터 삭제하면 removeChild 후 인덱스가 변경됨
  }
}

// 3단계: 새로운 요소들 추가
if (newChildren.length &gt; oldChildren.length) {
  for (let i = oldChildren.length; i &lt; newChildren.length; i++) {
    targetElement.appendChild(createElement(newChildren[i]));
    // 새로 생성이 필요한 요소들만 createElement 호출
  }
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ul>
<li>이벤트 위임 방식</li>
</ul>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword">const</span> prevContainers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token function">setupEventListeners</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>prevContainers<span class="token punctuation">.</span><span class="token method function property-access">has</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token comment">// 같은 root에 중복으로 이벤트 등록하는 것 방지</span>
</span><span class="code-line">  
</span><span class="code-line">  prevContainers<span class="token punctuation">.</span><span class="token method function property-access">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  registeredEvents<span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">eventType</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    root<span class="token punctuation">.</span><span class="token method function property-access">addEventListener</span><span class="token punctuation">(</span>eventType<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token keyword">let</span> currentTarget <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">;</span>
</span><span class="code-line">      
</span><span class="code-line">      <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span>currentTarget <span class="token operator">&amp;&amp;</span> currentTarget <span class="token operator">!==</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword">const</span> elementEvents <span class="token operator">=</span> eventStore<span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span>currentTarget<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>elementEvents <span class="token operator">&amp;&amp;</span> elementEvents<span class="token punctuation">.</span><span class="token method function property-access">has</span><span class="token punctuation">(</span>eventType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">          <span class="token comment">// 해당 요소에 등록된 핸들러가 있으면 실행</span>
</span><span class="code-line">          <span class="token keyword">const</span> handlers <span class="token operator">=</span> elementEvents<span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span>eventType<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">          handlers<span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">handler</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token function">handler</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token punctuation">}</span>
</span><span class="code-line">        currentTarget <span class="token operator">=</span> currentTarget<span class="token punctuation">.</span><span class="token property-access">parentElement</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token comment">// 이벤트 버블링을 활용해 부모로 올라가며 핸들러 찾기</span>
</span><span class="code-line">      <span class="token punctuation">}</span>
</span><span class="code-line">    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token function">addEvent</span><span class="token punctuation">(</span><span class="token parameter">element<span class="token punctuation">,</span> eventType<span class="token punctuation">,</span> handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  registeredEvents<span class="token punctuation">.</span><span class="token method function property-access">add</span><span class="token punctuation">(</span>eventType<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token comment">// 실제 addEventListener는 하지 않고 Map에만 저장</span>
</span><span class="code-line">  <span class="token comment">// root에 위임된 리스너가 나중에 이 Map을 참조해서 핸들러 실행</span>
</span><span class="code-line">  
</span><span class="code-line">  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>eventStore<span class="token punctuation">.</span><span class="token method function property-access">has</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">// 기존 요소에 새 이벤트 추가</span>
</span><span class="code-line">  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">// 새 요소에 첫 이벤트 등록</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="const prevContainers = new WeakSet();

setupEventListeners(root) {
  if (prevContainers.has(root)) return;
  // 같은 root에 중복으로 이벤트 등록하는 것 방지
  
  prevContainers.add(root);
  registeredEvents.forEach((eventType) =&gt; {
    root.addEventListener(eventType, (event) =&gt; {
      let currentTarget = event.target;
      
      while (currentTarget &amp;&amp; currentTarget !== root) {
        const elementEvents = eventStore.get(currentTarget);
        if (elementEvents &amp;&amp; elementEvents.has(eventType)) {
          // 해당 요소에 등록된 핸들러가 있으면 실행
          const handlers = elementEvents.get(eventType);
          handlers.forEach((handler) =&gt; handler(event));
        }
        currentTarget = currentTarget.parentElement;
        // 이벤트 버블링을 활용해 부모로 올라가며 핸들러 찾기
      }
    });
  });
}

addEvent(element, eventType, handler) {
  registeredEvents.add(eventType);
  // 실제 addEventListener는 하지 않고 Map에만 저장
  // root에 위임된 리스너가 나중에 이 Map을 참조해서 핸들러 실행
  
  if (eventStore.has(element)) {
    // 기존 요소에 새 이벤트 추가
  } else {
    // 새 요소에 첫 이벤트 등록
  }
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>실제 DOM을 전체 재렌더링한다면 element 생성 -&gt; 속성 설정 -&gt; 내용 설정 -&gt; appendChild와 같은 단계를 거쳐 새롭게 element를 만들고 전체를 다시 갈아끼워야 합니다.</p>
<p>대신하여 이루어지는 가상 DOM에서는 어떤 식으로 최적화를 하는지 직접 작성함으로서 체감할 수 있었습니다.</p>
<h4 id="vnode의-데이터-구조"><a class="anchor" aria-hidden="true" tabindex="-1" href="#vnode의-데이터-구조"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>vNode의 데이터 구조</h4>
<p>이 최적화의 바탕이 되는것은 vNode의 객체 구조입니다.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token comment">// src/lib/createVNode.js</span>
</span><span class="code-line"><span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">createVNode</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> props<span class="token punctuation">,</span> <span class="token spread operator">...</span>children</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token literal-property property">type</span><span class="token operator">:</span> type<span class="token punctuation">,</span>                    <span class="token comment">// 함수 혹은 타입</span>
</span><span class="code-line">    <span class="token literal-property property">props</span><span class="token operator">:</span> props<span class="token punctuation">,</span>                  <span class="token comment">// 속성</span>
</span><span class="code-line">    <span class="token literal-property property">children</span><span class="token operator">:</span> children<span class="token punctuation">.</span><span class="token method function property-access">flat</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">filter</span><span class="token punctuation">(</span><span class="token spread operator">...</span><span class="token punctuation">)</span>  <span class="token comment">// 평탄화된 자식요소</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// src/lib/createVNode.js
export function createVNode(type, props, ...children) {
  return {
    type: type,                    // 함수 혹은 타입
    props: props,                  // 속성
    children: children.flat(2).filter(...)  // 평탄화된 자식요소
  };
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ul>
<li>객체 구조로서 생성 및 수정이 빠름</li>
<li>메모리가 가벼움</li>
</ul>
<p>이 객체 구조로 인해 diff로 비교를 빠르게 할 수 있고 실제로 바뀐 부분만 찾아내어 실제 DOM 조작을 할 수 있습니다.
과제를 수행하면서 초기에 이 vNode의 구조를 파악하는 것이 핵심이었습니다. 관련한 로직들을 개발할 때 이 구조를 계속 떠올리고 이 구조를 만들거나 혹은 조작하려면 어떤식으로 작동해야 할지 고민해야 했습니다. 특히 type에 함수가 들어가며 그 함수를 동작시키는 개념을 이해해야 했습니다.</p>
<h3 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h3>
<!-- -->
<p>처음에 언급했던 두가지 중 spa동작에 대한 이해도는 높아졌습니다.
반면 자바스크립트 코드 작성에 대해서는 기본 자바스크립트 문법도 많이 잊어버리고 있었고, 아직 좀 더 발전해야겠다는 생각이 들었습니다.</p>
<h4 id="가상dom--실제dom-구분하기"><a class="anchor" aria-hidden="true" tabindex="-1" href="#가상dom--실제dom-구분하기"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>가상DOM / 실제DOM 구분하기</h4>
<p>과제에서 신경써야 할 부분은 가상DOM을 처리해야할 때와 실제DOM을 처리해야할 때였습니다.</p>
<ul>
<li>타입, 속성, 내용 등의 객체 정보를 이용해서 비교하는 로직 -&gt; 가상 DOM</li>
<li>해당 diff로 알아낸 조작을 실행할 때  -&gt; 실제 DOM</li>
</ul>
<p>간단한 분류지만 맥락을 잡기 전에는 어쩔때 실제 DOM을 호출하고, 조작하는 메소드를 써야할지, 어쩔때 가상 DOM에 해당하는 함수를 적용해서 비교를 해야할지 혼란스러운 경우가 있었습니다. 그 혼란을 해결하는 과정에서 SPA의 리렌더링 로직에 대한 이해도가 높아졌습니다.</p>
<p>사용하는 속성과 메소드들도 각자 달랐습니다.</p>
<ul>
<li>className / class</li>
<li>children / childNOde</li>
<li>on{이벤트명}/{이벤트명}</li>
<li>특수속성들</li>
</ul>
<p>이 구분을 이해하고 적용하는 것에 시간이 들고 가장 학습이 많이 되었습니다.</p>
<h4 id="자식-노드-반복-순서"><a class="anchor" aria-hidden="true" tabindex="-1" href="#자식-노드-반복-순서"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>자식 노드 반복 순서</h4>
<p>diff 알고리즘을 구현하는 데 있어서 가장 이해하기 위해 노력한 부분은 자식 노드를 반복하는 순서였습니다.
인덱스를 제거하고 추가하는 복잡한 동작 속에서 순회방식을 어떻게 해야 모든 자식 노드들을 기존 인덱스에 맞게 재정렬할 수 있을 지는 흥미롭고 알아가는 재미가 있는 과정이었습니다.</p>
<p>처음에는 큰 고민없이 0부터 반복을 수행했지만 index를 참조를 못하는 오류가 발생했습니다. 참조 뿐 아니라 이 현상은 sort 변화로 인한 재배열이나 무한스크롤 시 예상치 못한 동작을 유발했습니다.</p>
<p>본래의 순서로 요소를 제거하고 순회할 시 오작동하는 현상은 알고리즘에서도 많이 접한 현상입니다. 그래서 두번째로는 역순으로 해서 보다 오류가 적었지만 마찬가지로 제대로 작동하지 않았습니다.</p>
<p>올바른 순서는 다음과 같았습니다:</p>
<ul>
<li>공통 길이만큼 기존 요소 재사용 - diff 알고리즘으로 변경된 부분만 업데이트</li>
<li>초과하는 기존 요소들을 역순으로 삭제 - DOM 인덱스 변화를 방지</li>
<li>새로운 요소들을 순차적으로 추가 - 새로 생성이 필요한 요소만 처리</li>
</ul>
<p>특히 2단계의 역순 삭제가 중요했는데, 순차 삭제 시 removeChild 후 배열 인덱스가 변경되어 잘못된 요소를 삭제하는 문제가 발생했습니다. 이런 세밀한 DOM 조작 로직을 직접 구현하면서 브라우저 API의 특성과 배열 인덱스 관리 또한 배울 수 있었습니다.</p>
<h4 id="기존-프레임워크라이브러리의-동작-이해"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기존-프레임워크라이브러리의-동작-이해"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기존 프레임워크/라이브러리의 동작 이해</h4>
<p>과제를 하면서 가상DOM에 대한 이해도가 높아지고 사용경험이 있는 기존 툴들의 동작 방식을 읽으니 이해도가 높아지고 재밌었습니다.
실제 코드를 작성하는 방식과 연결지어서 어떻게 동작하는지 파악하고자 했습니다.</p>
<a href="https://react.dev/learn/preserving-and-resetting-state">
  <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/react/react-original.svg" width="50" height="50"/>
</a>
<a href="https://ko.vuejs.org/guide/extras/rendering-mechanism.html">
  <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/vuejs/vuejs-original.svg" width="50" height="50"/>
</a>
<h5 id="렌더링-최적화"><a class="anchor" aria-hidden="true" tabindex="-1" href="#렌더링-최적화"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>렌더링 최적화</h5>
<p>React</p>
<blockquote>
<p>React의 Fiber 아키텍처: React는 Fiber를 통해 렌더링 작업을 작은 단위로 나누어 우선순위를 부여하고, 메인 스레드를 블로킹하지 않고 중단 가능한 렌더링을 제공합니다.</p>
</blockquote>
<p>Vue</p>
<blockquote>
<p>Vue의 반응형 시스템: Vue는 의존성 추적을 통해 컴포넌트가 실제로 사용하는 데이터만 관찰하고, 해당 데이터 변경 시에만 정확한 컴포넌트를 재렌더링합니다.</p>
</blockquote>
<h5 id="자식-노드-순회-알고리즘"><a class="anchor" aria-hidden="true" tabindex="-1" href="#자식-노드-순회-알고리즘"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>자식 노드 순회 알고리즘</h5>
<p>React</p>
<blockquote>
<p>React의 Key 기반 Reconciliation: React는 key prop을 통해 요소의 identity를 추적하여, 순서가 바뀌어도 같은 요소를 인식하고 재사용할 수 있습니다.</p>
</blockquote>
<p>Vue</p>
<blockquote>
<p>Vue의 양방향 diff 알고리즘: Vue는 양쪽 끝에서부터 비교를 시작하여 중간으로 좁혀가는 방식으로, 단순한 앞뒤 추가/삭제를 빠르게 처리합니다.</p>
</blockquote>
<h2 id="리뷰-받고-싶은-내용"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리뷰-받고-싶은-내용"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리뷰 받고 싶은 내용</h2>
<!-- -->
<p>updateElement는 케이스를 분리해서 동작을 처리하는 로직이 주가 되는 함수입니다.
이런 경우 함수의 가독성을 높이기 위해 헬퍼 함수를 따로 분리하여 정의하고 각 경우의 수마다 적용하는 방식을 선호합니다.
하지만 너무 이른 시점에 해당 작업을 수행하면 생산성이 떨어지고 , 과도하게 사용할 경우 오히려 복잡도가 올라가는 경험도 있었습니다.</p>
<p>단순히 가독성 복잡도뿐이 아니라, 테스트 가능성, 유지보수성, 팀 개발 관점에서 함수 분리의 기준과 시점을 어떻게 판단하시는지, 그리고 과도한 분리로 인한 코드 파편화를 방지하는 방법에 대해 의견을 듣고 싶습니다.</p></div></div><div class="overflow-auto mt-9"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h2>
<p>두현님 한 주 고생 많으셨어요~
작성해주신 회고 잘 읽었고 덕분에 저도 고민의 흔적들을 따라가볼수 있어서 좋았네요! 직접적으로 지침을 넣어서 명확한 학습방향을 만드시고 공부하셨던 것도 좋았던 것 같습니다.</p>
<p>PR에 남겨주셨던 궁금하셨던 내용 이야기를 이어서 해보면요.</p>
<blockquote>
<p>단순히 가독성 복잡도뿐이 아니라, 테스트 가능성, 유지보수성, 팀 개발 관점에서 함수 분리의 기준과 시점을 어떻게 판단하시는지, 그리고 과도한 분리로 인한 코드 파편화를 방지하는 방법에 대해 의견을 듣고 싶습니다.</p>
</blockquote>
<p>여러 원칙들과 선배들이 이야기 한 규칙들이 있겠지만, 사실 정답은 없는 것 같아요. 우리들은 깔끔한 코드를 명확한 규칙 내에 정리되게 작성하고 싶어하지만 현실에서는 그런 코드를 작성하는게 사실상 불가능하거든요.
그럼에도 개인적으로 이런 분리, 추상화 고민이 들때는 재사용이 실제로 발생하는 시점이 임박하거나 실제로 상상속에서 벌어지고만 있다면 구현하지 않는 편인것 같아요. 그리고 실제로 사용하게 되더라도 중복으로 구현되도록(복사를 아마 하겠죠?) 사용한 다음 주석으로 명확하게 개선이 필요하다고 남기고 추후에 별도 작업으로 분리해서 테스트와 함께 검증하면서 해결하는 편입니다. 내가 아무리 확실한 미래일지라도 상상하는 그 미래 상황에 맞춰 구현을 하고 코드를 나누다보면 늘 문제가 생기고 확장성이 사라졌던 것 같아요. 필요한 만큼 현재 시점에 맞게 딱 그정도만 구현을 한다음 필요해지면 더 구현해나가면 되지 않을 까 싶습니다 ㅎㅎ 모든 규칙에 있어서요.</p>
<p>고생하셨고 다음 주 과제도 화이팅입니다!</p></div></div><div class="mt-9"></div></div></main></div></div></div></div>
</body>
</html>
