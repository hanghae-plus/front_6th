<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="/front_6th/favicon.ico"/>
  
    <title>[5팀 이지훈] Chapter 1-3. React, Beyond the Basics - 이지훈 | 항해플러스 프론트엔드 6기</title>
    <meta name="description" content=" [항해플러스 프론트엔드 6기] 이지훈님이 제출한 [5팀 이지훈] Chapter 1-3. React, Beyond the Basics 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="keywords" content="항해플러스, 프론트엔드, 개발자교육, React, TypeScript, JavaScript, 기술면접, 웹개발, 이지훈, [5팀 이지훈] Chapter 1-3. React, Beyond the Basics, 과제상세, 코드리뷰, 피드백, Pull Request" />
    <meta property="og:title" content="[5팀 이지훈] Chapter 1-3. React, Beyond the Basics - 이지훈 | 항해플러스 프론트엔드 6기" />
    <meta property="og:description" content=" [항해플러스 프론트엔드 6기] 이지훈님이 제출한 [5팀 이지훈] Chapter 1-3. React, Beyond the Basics 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta property="og:image" content="/defaultThumbnail.jpg" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="[5팀 이지훈] Chapter 1-3. React, Beyond the Basics - 이지훈 | 항해플러스 프론트엔드 6기" />
    <meta name="twitter:description" content=" [항해플러스 프론트엔드 6기] 이지훈님이 제출한 [5팀 이지훈] Chapter 1-3. React, Beyond the Basics 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="twitter:image" content="/defaultThumbnail.jpg" />
  
  <script type="module" crossorigin src="/front_6th/assets/index-DtEqFcg_.js"></script>
  <link rel="stylesheet" crossorigin href="/front_6th/assets/index-BXO68frB.css">
</head>
<body>
<div id="root"><link rel="preload" as="image" href="https://velog.velcdn.com/images/jihoon0330/post/2c74bf9c-9531-4dfd-a3e2-7b7baa707d56/image.png"/><link rel="preload" as="image" href="https://velog.velcdn.com/images/jihoon0330/post/02ecb358-94a6-4fa0-a559-5376a1e93232/image.png"/><link rel="preload" as="image" href="https://velog.velcdn.com/images/jihoon0330/post/aeb62192-8670-4192-bb0b-d287b8bade06/image.png"/><div data-slot="sidebar-wrapper" style="--sidebar-width:16rem;--sidebar-width-icon:3rem" class="group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full"><div class="min-h-screen flex w-full"><div class="group peer text-sidebar-foreground hidden md:block" data-state="expanded" data-collapsible="" data-variant="sidebar" data-side="left" data-slot="sidebar"><div data-slot="sidebar-gap" class="relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear group-data-[collapsible=offcanvas]:w-0 group-data-[side=right]:rotate-180 group-data-[collapsible=icon]:w-(--sidebar-width-icon)"></div><div data-slot="sidebar-container" class="fixed inset-y-0 z-10 hidden h-svh transition-[left,right,width] duration-200 ease-linear md:flex left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)] group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l w-64"><div data-sidebar="sidebar" data-slot="sidebar-inner" class="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"><div data-slot="sidebar-content" data-sidebar="content" class="flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden bg-card border-r border-border"><a class="p-4" href="/front_6th/" data-discover="true"><div class="flex items-center space-x-2 mb-6"><div class="w-8 h-8 bg-gradient-primary rounded-lg flex items-center justify-center"><span class="text-white font-bold text-sm">6기</span></div><h4 class="text-lg font-bold text-primary">항해플러스 프론트엔드</h4></div></a><div data-slot="sidebar-group" data-sidebar="group" class="relative flex w-full min-w-0 flex-col p-2"><div data-slot="sidebar-group-label" data-sidebar="group-label" class="ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0 text-muted-foreground px-4">학습 관리</div><div data-slot="sidebar-group-content" data-sidebar="group-content" class="w-full text-sm"><ul data-slot="sidebar-menu" data-sidebar="menu" class="flex w-full min-w-0 flex-col gap-1 px-2"><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_6th/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-users h-5 w-5" aria-hidden="true"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><path d="M16 3.128a4 4 0 0 1 0 7.744"></path><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><circle cx="9" cy="7" r="4"></circle></svg><span class="ml-3">수강생 목록</span></a></li><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_6th/assignments/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open h-5 w-5" aria-hidden="true"><path d="M12 7v14"></path><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"></path></svg><span class="ml-3">과제 목록</span></a></li></ul></div></div></div></div></div></div><div class="flex-1 min-w-0"><header class="h-12 flex items-center border-b border-border bg-card px-4"><button data-slot="sidebar-trigger" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-7 mr-4 text-white" data-sidebar="trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-panel-left" aria-hidden="true"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M9 3v18"></path></svg><span class="sr-only">Toggle Sidebar</span></button><h4 class="text-lg font-semibold "><a href="/front_6th/@JiHoon-0330/" data-discover="true">JiHoon-0330<!-- --> 님의 상세페이지</a> ＞ <!-- -->[5팀 이지훈] Chapter 1-3. React, Beyond the Basics</h4></header><main class="p-6"><div><div class="card-wrap"><div data-slot="card" class="card text-card-foreground flex flex-col gap-6 shadow-sm mb-6 p-6 border border-gray-700 bg-gray-800 rounded-lg"><a href="https://github.com/hanghae-plus/front_6th_chapter1-3/pull/14" target="_blank"><div class="flex items-start gap-4"><div class="flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" height="32" aria-hidden="true" viewBox="0 0 24 24" width="32" fill="white" class="w-8 h-8"><path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg></div><div class="flex-1 min-w-0"><div class="flex items-center gap-2 mb-2"><h3 class="text-lg font-semibold text-white truncate">[5팀 이지훈] Chapter 1-3. React, Beyond the Basics</h3></div><div class="flex items-center gap-4 text-xs text-gray-500"><span>by <!-- -->JiHoon-0330</span><span>2025. 7. 19.</span></div></div></div></a></div></div><div class="overflow-auto"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-체크포인트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-체크포인트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 체크포인트</h2>
<h3 id="배포-링크"><a class="anchor" aria-hidden="true" tabindex="-1" href="#배포-링크"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>배포 링크</h3>
<!-- -->
<p><a href="https://hanghae-plus.github.io/front_6th_chapter1-3/">https://hanghae-plus.github.io/front_6th_chapter1-3/</a></p>
<h3 id="기본과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기본과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기본과제</h3>
<h4 id="equalities"><a class="anchor" aria-hidden="true" tabindex="-1" href="#equalities"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>equalities</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> shallowEquals 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> deepEquals 구현 완료</li>
</ul>
<h4 id="hooks"><a class="anchor" aria-hidden="true" tabindex="-1" href="#hooks"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>hooks</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useRef 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useMemo 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useCallback 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useDeepMemo 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useShallowState 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useAutoCallback 구현 완료</li>
</ul>
<h4 id="high-order-components"><a class="anchor" aria-hidden="true" tabindex="-1" href="#high-order-components"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>High Order Components</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> memo 구현 완료</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> deepMemo 구현 완료</li>
</ul>
<h3 id="심화-과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#심화-과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>심화 과제</h3>
<h4 id="hooks-1"><a class="anchor" aria-hidden="true" tabindex="-1" href="#hooks-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>hooks</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> createObserver를 useSyncExternalStore에 사용하기 적합한 코드로 개선</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useShallowSelector 구현</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useStore 구현</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useRouter 구현</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> useStorage 구현</li>
</ul>
<h3 id="context"><a class="anchor" aria-hidden="true" tabindex="-1" href="#context"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>context</h3>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> ToastContext, ModalContext 개선</li>
</ul>
<h2 id="과제-셀프회고"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-셀프회고"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 셀프회고</h2>
<!-- -->
<p>이번 주차 과제를 진행한 방식이다.</p>
<ol>
<li>빠르게 구현하기</li>
<li>리팩토링/학습</li>
<li>과제 이외의 부분 생각해보기</li>
</ol>
<p>1주차의 경우엔 학습을 하면서 코드를 갈아엎는 경우가 많았고, 코드를 갈아엎는데 시간을 많이 소비한 나머지 제출 마지막 날까지 기능을 구현에만 집중을 했다.</p>
<p>2주차의 경우엔 매일 학습을 한 내용을 정리했다. 글을 정리하는 과정에서 시간을 많이 사용했고 시간 안에 과제를 다 할 수 있을까? 라는 생각이 들기도 했다.</p>
<p>빠르게 구현 -&gt; 리팩토링 및 학습 -&gt; 과제 이외의 부분을 생각해보는 플로우는 빠르게 구현하기 때문에 과제 제출에 대한 부담감이 적을 것 같았고, 과제 전체 내용을 경험 한 뒤이기 때문에 좀 더 큰 그림을 그리며 학습이 가능할 것 이라 생각했다.</p>
<blockquote>
<p>3주차 과제 진행 방식은 7팀 박의근님의 2주차 회고글을 보고 아이디어를 얻었다.
<img src="https://velog.velcdn.com/images/jihoon0330/post/2c74bf9c-9531-4dfd-a3e2-7b7baa707d56/image.png" alt="의근님 글 캡쳐"/>
<a href="https://velog.io/@bug_y_not/%EC%96%B4%EB%95%A0%EC%96%B4-7%EC%9B%94-%EC%85%8B%EC%A7%B8-%EC%A3%BC">7팀 박의근님 2주차 회고글</a></p>
</blockquote>
<p>덕분에 이번 주차는 월요일에 기능 구현을 모두 끝낼 수 있었다.
<img src="https://velog.velcdn.com/images/jihoon0330/post/02ecb358-94a6-4fa0-a559-5376a1e93232/image.png" alt="빠르게 구현하기"/></p>
<p>그동안 리액트를 써왔기 때문에 막히는 부분이 없을 거라 생각했는데, 생각보다 막히는 부분이 많이 있었다. 테스트 코드를 통과했지만 잘못 알고있는 부분도 있었다. 이런 과정을 겪으면서 잘못 알고 있는 부분을 최소화 하기 위해 꾸준한 공부가 필요하다고 느꼈다.</p>
<hr/>
<!-- -->
<!-- -->
<h3 id="새로-학습한-개념"><a class="anchor" aria-hidden="true" tabindex="-1" href="#새로-학습한-개념"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>새로 학습한 개념</h3>
<h4 id="-와-objectis-의-차이점과-리액트에서-objectis-를-사용하는-이유"><a class="anchor" aria-hidden="true" tabindex="-1" href="#-와-objectis-의-차이점과-리액트에서-objectis-를-사용하는-이유"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>&#x27;===&#x27; 와 &#x27;Object.is&#x27; 의 차이점과 리액트에서 &#x27;Object.is&#x27; 를 사용하는 이유</h4>
<p>리액트에서 값이 변경되었는지 비교할 때 <code>Object.is</code> 를 사용하는 것은 모르고 있었다. 문서를 살펴보니 문서상에 <code>Object.is</code> 를 사용한다고 명시되어 있어서 알게 되었다. 두 비교 연산자의 차이점은 숫자를 비교하는 부분에서 차이가 있었다.</p>

























<table><thead><tr><th style="text-align:left"></th><th style="text-align:left"><code>Object.is(value1, value2)</code></th><th style="text-align:left"><code>value1 === value2</code></th></tr></thead><tbody><tr><td style="text-align:left"><code>NaN</code></td><td style="text-align:left"><code>Object.is(NaN, NaN)</code>은 <code>true</code>를 반환한다.</td><td style="text-align:left"><code>NaN === NaN</code>은 <code>false</code>를 반환한다.</td></tr><tr><td style="text-align:left"><code>+0</code>/<code>-0</code></td><td style="text-align:left"><code>Object.is(+0, -0)</code>은 <code>false</code>를 반환한다.</td><td style="text-align:left"><code>+0 === -0</code>은 <code>true</code>를 반환한다.</td></tr><tr><td style="text-align:left">사용 목적</td><td style="text-align:left"><code>NaN</code>과 부호 있는 0을 정확히 구분하여 완전한 값 동등성을 판단할 때 사용된다.</td><td style="text-align:left">타입과 값이 동일한지 판단하는 일반적인 비교 연산자다.</td></tr></tbody></table>
<hr/>
<h4 id="비교-표를-기준으로-objectis-가-더-알맞은-이유"><a class="anchor" aria-hidden="true" tabindex="-1" href="#비교-표를-기준으로-objectis-가-더-알맞은-이유"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>비교 표를 기준으로 Object.is 가 더 알맞은 이유:</h4>
<ul>
<li>NaN 이 NaN 으로 바뀐 경우 UI 나 계산 로직이 달라지는 부분은 없기 때문에 값이 바뀌었다 판단하는건 불필요하다.</li>
<li>0 이라는 숫자도 부호에 따라 다른 계산 값을 가진다. 결과 값 업데이트가 필요하다.</li>
</ul>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span> <span class="token comment">// Infinity</span>
</span><span class="code-line"><span class="token number">1</span> <span class="token operator">/</span> <span class="token operator">-</span><span class="token number">0</span>  <span class="token comment">// -Infinity</span>
</span><span class="code-line"><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">toLocaleString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;0&quot;</span>
</span><span class="code-line"><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">toLocaleString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;-0&quot;</span>
</span><span class="code-line"><span class="token known-class-name class-name">Intl</span><span class="token punctuation">.</span><span class="token method function property-access"><span class="token maybe-class-name">NumberFormat</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">format</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// &quot;0&quot;</span>
</span><span class="code-line"><span class="token known-class-name class-name">Intl</span><span class="token punctuation">.</span><span class="token method function property-access"><span class="token maybe-class-name">NumberFormat</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">format</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// &quot;-0&quot;</span>
</span></code><div class="copied" data-code="1 / 0 // Infinity
1 / -0  // -Infinity
(0).toLocaleString() // &quot;0&quot;
(-0).toLocaleString() // &quot;-0&quot;
Intl.NumberFormat().format(0) // &quot;0&quot;
Intl.NumberFormat().format(-0) // &quot;-0&quot;
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<blockquote>
<p>메이저 버전이 업데이트 될 때 마다 문서 다시 한 번 읽어보기!
<code>===</code> 연산자의 경우 수학적인 개념에 초점이 맞춰져 있다고 한다.
<code>Object.is</code> 연산자의 경우 값 자체를 비교하는 것에 초점이 맞춰져 있다고 한다.</p>
</blockquote>
<hr/>
<h3 id="기존-지식의-재발견"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기존-지식의-재발견"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기존 지식의 재발견</h3>
<h4 id="usedeepmemo-useautocallback"><a class="anchor" aria-hidden="true" tabindex="-1" href="#usedeepmemo-useautocallback"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>useDeepMemo, useAutoCallback</h4>
<p>useMemo, useCallback, memo 화 같은 것들을 왜 필요한 경우에만 사용하길 권장하는지 이해할 수 있었다. 값을 비교하는 과정이 추가되는데 이게 오히려 더 비싼 작업일 수 있다.
useMemo, useCallback 과 같은 훅을 이용할 때 커스텀하게 값일 비교하는 훅을 만드는 것은 생각해보지 못한 것 같다. 리액트에서 제공하는 훅들을 그대로 사용하지 않고 상황에 알맞게 변형해서 사용할 수 있을 것 같다.</p>
<h4 id="setstate"><a class="anchor" aria-hidden="true" tabindex="-1" href="#setstate"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>setState</h4>
<p>setState 를 사용할 때 이전 값을 그대로 리턴하는 경우 참조가 유지되어 리렌더링이 발생하지 않는 것을 알게 되었다.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prev</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword control-flow">if</span><span class="token punctuation">(</span> <span class="token spread operator">...</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">// 참조가 유지됨</span>
</span><span class="code-line">    <span class="token keyword control-flow">return</span> prev
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword control-flow">return</span> <span class="token spread operator">...</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span>
</span></code><div class="copied" data-code="setState((prev) =&gt; {
  if( ... ) {
    // 참조가 유지됨
    return prev
  }

  return ...
})
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h4 id="createelement"><a class="anchor" aria-hidden="true" tabindex="-1" href="#createelement"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>createElement</h4>
<p>memo.ts 파일에서 JSX 작성하는 대신 리액트 엘리먼트를 생성해야 했다.
처음엔 함수를 그대로 호출하는 형태로 작성을 했다.
테스트를 통과해서 잘못된 줄 모르고 있다가 다른 사람들의 코드를 보고 잘못된 걸 깨달았다.</p>
<p>우선 올바른 방법은 createElement 를 사용해줘야 JSX 를 사용한 것과 동일하게 실행할 수 있다.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token function"><span class="token maybe-class-name">Component</span></span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token comment">// x</span>
</span><span class="code-line"><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token maybe-class-name">Component</span><span class="token punctuation">,</span> props<span class="token punctuation">)</span> <span class="token comment">// o</span>
</span></code><div class="copied" data-code="Component(props) // x
createElement(Component, props) // o
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>2주차 과제에서 진행한 JSX 를 변환하는 과정을 생각해 보면 이해하기 쉽다.</p>
<p>createElement 사용하는 것이 올바른 방법인 것은 알았지만, 함수를 호출하는 방식도 테스트는 통과 했기에 어떻게 다른지 궁금했다.</p>
<p>리액트 프로젝트를 하나 생성해 테스트를 진행했다.</p>
<ol>
<li>
<p>UI 만 렌더링 하는 경우
UI 만 렌더링 하는 경우는 테스트 코드와 동일한 환경이다. 이 때는 JSX 를 사용한 것과 동일하게 동작하는 것 처럼 보인다.</p>
</li>
<li>
<p>테스트 컴포넌트 내부에서 훅을 사용하는 경우
상위 컴포넌트에서, 테스트 컴포넌트 내부에 선언한 훅을 사용중인 것으로 인식이 된다. 이때 조건부로 함수를 호출하면 이전 렌더링과 훅 개수가 다르다는 오류 메세지가 나온다.
<img src="https://velog.velcdn.com/images/jihoon0330/post/aeb62192-8670-4192-bb0b-d287b8bade06/image.png" alt="훅 개수가 다름"/></p>
</li>
</ol>
<p>함수를 호출하는 것은 컴포넌트로 동작하지 않기 때문에 컴포넌트 생명주기와 관련된 부분에서 오류가 발생한다.
테스트를 통과할 수 있었던 이유는 단순히 JSX 만 리턴하는 역할이었기 때문이다.</p>
<p>관련된 내용은 공식 문서에서도 자세하게 나와있다. <a href="https://ko.react.dev/reference/rules/react-calls-components-and-hooks#never-call-component-functions-directly">React 컴포넌트 함수를 직접 호출하지 마세요</a></p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Person</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// useState 훅은 Person 을 함수로 호출했기 때문에 부모 컴포넌트인 App 컴포넌트에서 선언한 것처럼 동작한다.</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> setName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token spread operator">...</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">App</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prev</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> prev <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
</span><span class="code-line">      <span class="token punctuation">{</span><span class="token comment">/* Person 함수를 호출하면 컴포넌트로 인식되지 않는다. JSX 를 변환하는 과정이 없기 때문 */</span><span class="token punctuation">}</span>
</span><span class="code-line">      <span class="token punctuation">{</span><span class="token comment">/* Person 함수를 호출하면서 함수 내부가 실행된다. 이때 App 컴포넌트에서 Person 내부에 선언한 훅을 실행하는 것으로 인식이 된다. */</span><span class="token punctuation">}</span>
</span><span class="code-line">      <span class="token punctuation">{</span>count <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token function"><span class="token maybe-class-name">Person</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword null nil">null</span><span class="token punctuation">}</span>
</span><span class="code-line">      <span class="token operator">&lt;</span>button type<span class="token operator">=</span><span class="token string">&quot;button&quot;</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>
</span><span class="code-line">        <span class="token operator">+</span>
</span><span class="code-line">      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
</span><span class="code-line">    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="function Person() {
  // useState 훅은 Person 을 함수로 호출했기 때문에 부모 컴포넌트인 App 컴포넌트에서 선언한 것처럼 동작한다.
  const [name, setName] = useState(&quot;&quot;);

  return (
    &lt;div&gt;...&lt;/div&gt;
  );
}

function App() {
  const [count, setCount] = useState(0);

  const handleClick = () =&gt; {
    setCount((prev) =&gt; prev + 1);
  };

  return (
    &lt;div&gt;
      {/* Person 함수를 호출하면 컴포넌트로 인식되지 않는다. JSX 를 변환하는 과정이 없기 때문 */}
      {/* Person 함수를 호출하면서 함수 내부가 실행된다. 이때 App 컴포넌트에서 Person 내부에 선언한 훅을 실행하는 것으로 인식이 된다. */}
      {count &gt; 0 ? Person() : null}
      &lt;button type=&quot;button&quot; onClick={handleClick}&gt;
        +
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<!-- -->
<!-- -->
<hr/>
<h3 id="코드를-작성하면서-고민한-부분들"><a class="anchor" aria-hidden="true" tabindex="-1" href="#코드를-작성하면서-고민한-부분들"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>코드를 작성하면서 고민한 부분들</h3>
<h4 id="useref-구현"><a class="anchor" aria-hidden="true" tabindex="-1" href="#useref-구현"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>useRef 구현</h4>
<p>useRef 를 구현하면서 일반적인 초기화 방식을 사용했다. useRef 함수에서 이미 계산된 값을 인자로 받기 때문에 지연 초기화가 필요 없다고 생각을 했다. 다른 분들의 코드를 살펴보니 지연 초기화를 하신 분들이 많아서 나도 지연 초기화를 해야 하나 생각이 들었다.</p>
<p>useState 에서 지연 초기화가 등장한 이유를 다시 생각해 봤다.</p>
<blockquote>
<p>createInitialTodos()의 결과는 초기 렌더링에만 사용되지만, 여전히 모든 렌더링에서 이 함수를 호출합니다. 이는 큰 배열을 생성하거나 값비싼 계산을 수행하는 경우 낭비일 수 있습니다.</p>
</blockquote>
<p>리액트에서 지연 초기화는 값비싼 계산을 수행하는 경우와, 큰 배열을 생성하는 경우 권장된다.
useRef 함수에서는 initialValue 값을 그대로 할당하고 있기 때문에 작은 객체를 생성한다고 판단이 되었다. 만약 initialValue 라는 값에 매우 큰 배열이 들어오더라도 자바스크립트에서는 참조를 전달하기 때문에 useRef 함수 내에서 매우 큰 배열이 생성되지는 않기 때문에 지연 초기화를 쓰지 않기로 결정했다.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token parameter">initialValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>value<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">current</span><span class="token operator">:</span> initialValue <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword control-flow">return</span> value<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="export function useRef(initialValue) {
  const [value] = useState({ current: initialValue });
  return value;
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h4 id="useshallowstate-구현하기"><a class="anchor" aria-hidden="true" tabindex="-1" href="#useshallowstate-구현하기"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>useShallowState 구현하기</h4>
<p>기존 set 함수의 형태를 만족하기 위해 인자로 값과 함수 모두 받을 수 있도록 만들었다.
useState 의 set 함수는 같은 참조를 반환하기 때문에 useAutoCallback 을 사용했다.
구현을 하면서 타입추론이 가능한 코드를 작성하기 위한 고민을 했습니다.</p>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> useShallowState <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>initialValue<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">,</span> Dispatch<span class="token operator">&lt;</span>SetStateAction<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">]</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// useState를 사용하여 상태를 관리하고, shallowEquals를 사용하여 상태 변경을 감지하는 훅을 구현합니다.</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>value<span class="token punctuation">,</span> _setValue<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>initialValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> setValue <span class="token operator">=</span> <span class="token function">useAutoCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token operator">:</span> SetStateAction<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token function">_setValue</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token keyword">const</span> next <span class="token operator">=</span> <span class="token function">isFunction</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">value</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span> <span class="token operator">:</span> value<span class="token punctuation">;</span>
</span><span class="code-line">      <span class="token keyword">return</span> <span class="token function">shallowEquals</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">?</span> prev <span class="token operator">:</span> next<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">[</span>value<span class="token punctuation">,</span> setValue<span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">isFunction</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>value<span class="token operator">:</span> SetStateAction<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> value <span class="token keyword">is</span> <span class="token punctuation">(</span>prev<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token keyword">typeof</span> value <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="export const useShallowState = &lt;T&gt;(initialValue: T): [T, Dispatch&lt;SetStateAction&lt;T&gt;&gt;] =&gt; {
  // useState를 사용하여 상태를 관리하고, shallowEquals를 사용하여 상태 변경을 감지하는 훅을 구현합니다.
  const [value, _setValue] = useState(initialValue);
  const setValue = useAutoCallback((value: SetStateAction&lt;T&gt;) =&gt; {
    _setValue((prev) =&gt; {
      const next = isFunction(value) ? value(prev) : value;
      return shallowEquals(prev, next) ? prev : next;
    });
  });

  return [value, setValue];
};

function isFunction&lt;T&gt;(value: SetStateAction&lt;T&gt;): value is (prev: T) =&gt; T {
  return typeof value === &quot;function&quot;;
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h4 id="zustand-와-비교해보기"><a class="anchor" aria-hidden="true" tabindex="-1" href="#zustand-와-비교해보기"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>zustand 와 비교해보기</h4>
<p>직접 작성한 useShallowSelector 코드와 zustand 의 <a href="https://github.com/pmndrs/zustand/blob/main/src/react/shallow.ts#L4C17-L4C27">useShallow</a> 코드를 비교했다.</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token comment">// zustand</span>
</span><span class="code-line"><span class="token keyword">const</span> prev <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access">useRef</span><span class="token operator">&lt;</span><span class="token constant">U</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 내 코드</span>
</span><span class="code-line"><span class="token keyword">const</span> prevState <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">S</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// zustand
const prev = React.useRef&lt;U&gt;(undefined);

// 내 코드
const prevState = useRef&lt;S | null&gt;(null);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>zustand 의 경우 초기값을 undefined 로 설정했고 나는 null 로 설정했다.
자바스크립트에서 undefined 는 변수가 선언 되었지만 아직 값이 할당되지 않은 상태를 나타낸다. null 의 경우 null 이라는 값이 할당된 상태이다. 이전 상태를 저장하는 prev 의 초기값으로 아직 값이 할당되지 않은 상태를 나타낸다면 undefined 를 사용하는 것이 알맞아 보였다.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token comment">// zustand</span>
</span><span class="code-line"><span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">const</span> next <span class="token operator">=</span> <span class="token function">selector</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token keyword control-flow">return</span> <span class="token function">shallow</span><span class="token punctuation">(</span>prev<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span>
</span><span class="code-line">      <span class="token operator">?</span> <span class="token punctuation">(</span>prev<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token keyword module">as</span> <span class="token constant">U</span><span class="token punctuation">)</span>
</span><span class="code-line">      <span class="token operator">:</span> <span class="token punctuation">(</span>prev<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> next<span class="token punctuation">)</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 내 코드</span>
</span><span class="code-line"><span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>state<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token parameter"><span class="token constant">S</span></span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> currentState <span class="token operator">=</span> <span class="token function">selector</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>prevState<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">===</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">// 초기 값 설정 의도</span>
</span><span class="code-line">    prevState<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> currentState<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword control-flow">return</span> prevState<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">shallowEquals</span><span class="token punctuation">(</span>prevState<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">,</span> currentState<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    prevState<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> currentState<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword control-flow">return</span> prevState<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword control-flow">return</span> prevState<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// zustand
return (state) =&gt; {
    const next = selector(state)
    return shallow(prev.current, next)
      ? (prev.current as U)
      : (prev.current = next)
  }

// 내 코드
return (state: T): S =&gt; {
  const currentState = selector(state);

  if (prevState.current === null) {
    // 초기 값 설정 의도
    prevState.current = currentState;
    return prevState.current;
  }

  if (!shallowEquals(prevState.current, currentState)) {
    prevState.current = currentState;
    return prevState.current;
  }

  return prevState.current;
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>zustand 에서는 이전 값과 새로운 값을 비교하는 과정만 존재한다. 내 코드에서는 초기값 설정과 비교하는 과정이 분리되어 있다. 입력 받은 state 값이 null 일수도 있기 때문에 사실상 초기 값 설정이라는 부분이 의미가 없다는 걸 알게 되었다. zustand 에서 값을 할당하면서 return 을 하는 방식으로 코드를 작성했는데, 주관적으로 할당과 리턴을 분리하는게 이해하기 쉽다고 생각한다.</p>
<p>최종적으로는 아래와 같이 코드를 수정했다.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword module">export</span> <span class="token keyword">const</span> useShallowSelector <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">S</span> <span class="token operator">=</span> <span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">selector</span><span class="token operator">:</span> <span class="token maybe-class-name">Selector</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">S</span><span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// 이전 상태를 저장하고, shallowEquals를 사용하여 상태가 변경되었는지 확인하는 훅을 구현합니다.</span>
</span><span class="code-line">  <span class="token keyword">const</span> prevState <span class="token operator">=</span> useRef<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword nil">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>state<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token parameter"><span class="token constant">S</span></span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">const</span> currentState <span class="token operator">=</span> <span class="token function">selector</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">shallowEquals</span><span class="token punctuation">(</span>prevState<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">,</span> currentState<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token keyword control-flow">return</span> prevState<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token keyword module">as</span> <span class="token constant">S</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">    prevState<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> currentState<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword control-flow">return</span> prevState<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="export const useShallowSelector = &lt;T, S = T&gt;(selector: Selector&lt;T, S&gt;) =&gt; {
  // 이전 상태를 저장하고, shallowEquals를 사용하여 상태가 변경되었는지 확인하는 훅을 구현합니다.
  const prevState = useRef&lt;S&gt;(undefined);

  return (state: T): S =&gt; {
    const currentState = selector(state);

    if (shallowEquals(prevState.current, currentState)) {
      return prevState.current as S;
    }

    prevState.current = currentState;
    return prevState.current;
  };
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h4 id="context-사용할-때-리렌더링-최소화-하기"><a class="anchor" aria-hidden="true" tabindex="-1" href="#context-사용할-때-리렌더링-최소화-하기"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Context 사용할 때 리렌더링 최소화 하기</h4>
<p>value 값이 참조를 유지할 수 있도록 useMemo 를 사용해 <code>{ show: showWithHide, hide, ...state }</code> 값을 캐싱한다. 의존성 배열에 showWithHide, hide, state 값을 넣어줘야 한다.</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">   show<span class="token operator">:</span> showWithHide<span class="token punctuation">,</span>
</span><span class="code-line">   hide<span class="token punctuation">,</span>
</span><span class="code-line">   <span class="token spread operator">...</span>state<span class="token punctuation">,</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>showWithHide<span class="token punctuation">,</span> hide<span class="token punctuation">,</span> state<span class="token punctuation">.</span><span class="token property-access">message</span><span class="token punctuation">,</span> state<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="useMemo(() =&gt; {
   show: showWithHide,
   hide,
   ...state,
}, [showWithHide, hide, state.message, state.type]);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>showWithHide, hide 는 함수이기 때문에 useCallback 을 이용해 따로 최적화가 필요하다. 최적화를 위해 아래와 같이 계속 의존성 배열에 값을 넣고, 의존성 배열에서 비교를 위해 참조를 유지하도록 만드는 작업을 반복해야 한다.</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token comment">// show, hideAfter 참조를 유지하기 위해 또 다른 작업 ..</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">const</span> showWithHide<span class="token operator">:</span> <span class="token maybe-class-name">ShowToast</span> <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token function">show</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token function">hideAfter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>show<span class="token punctuation">,</span> hideAfter<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// show, hideAfter 참조를 유지하기 위해 또 다른 작업 ..

const showWithHide: ShowToast = useCallback((...args) =&gt; {
  show(...args);
  hideAfter();
}, [show, hideAfter]);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>과제를 진행하면서 만든 useAutoCallback 훅을 사용하면 의존성 배열 없이 최신 상태의 함수를 사용하면서 참조를 유지할 수 있어 간단하게 작성이 가능하다.</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token keyword">const</span> showWithHide<span class="token operator">:</span> <span class="token maybe-class-name">ShowToast</span> <span class="token operator">=</span> <span class="token function">useAutoCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token function">show</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token function">hideAfter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="const showWithHide: ShowToast = useAutoCallback((...args) =&gt; {
  show(...args);
  hideAfter();
});
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이렇게 참조를 유지하도록 만들어도 장바구니 담기를 누르면 불필요한 리렌더링이 발생한다. 문제는 show, hide 를 호출하는 과정에서 state 값이 바뀌기 때문이다. 장바구니 추가 모달을 띄울 때 useCartAddCommand 훅을 사용하는 컴포넌트에서 state 의 값을 사용하지 않기 때문에, state 값과, 액션 함수들을 별개의 컨텍스트로 분리해 최적화를 진행할 수 있다.</p>
<p>최종적으로 아래와 같은 형태로 최적화를 진행했다.</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token comment">// 컨텍스트를 분리</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token maybe-class-name">ToastStateContext</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">createContext</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token punctuation">{</span>
</span></span></span><span class="code-line"><span class="token generic-function"><span class="token generic class-name">  message<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
</span></span></span><span class="code-line"><span class="token generic-function"><span class="token generic class-name">  type<span class="token operator">:</span> ToastType<span class="token punctuation">;</span>
</span></span></span><span class="code-line"><span class="token generic-function"><span class="token generic class-name"><span class="token punctuation">}</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>initialState<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token maybe-class-name">ToastCommandContext</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">createContext</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token punctuation">{</span>
</span></span></span><span class="code-line"><span class="token generic-function"><span class="token generic class-name">  show<span class="token operator">:</span> ShowToast<span class="token punctuation">;</span>
</span></span></span><span class="code-line"><span class="token generic-function"><span class="token generic class-name">  hide<span class="token operator">:</span> Hide<span class="token punctuation">;</span>
</span></span></span><span class="code-line"><span class="token generic-function"><span class="token generic class-name"><span class="token punctuation">}</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token function-variable function">show</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token function-variable function">hide</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token maybe-class-name">ToastProvider</span> <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> children <span class="token punctuation">}</span><span class="token operator">:</span> <span class="token maybe-class-name">PropsWithChildren</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token spread operator">...</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// 참조 유지</span>
</span><span class="code-line">  <span class="token keyword">const</span> showWithHide<span class="token operator">:</span> <span class="token maybe-class-name">ShowToast</span> <span class="token operator">=</span> <span class="token function">useAutoCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token function">show</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token function">hideAfter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// 액션 객체의 참조를 유지</span>
</span><span class="code-line">  <span class="token keyword">const</span> memorizedCommand <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> show<span class="token operator">:</span> showWithHide<span class="token punctuation">,</span> hide <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>showWithHide<span class="token punctuation">,</span> hide<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ToastCommandContext</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>memorizedCommand<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ToastStateContext</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>state<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">        </span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">        </span><span class="token punctuation">{</span>visible <span class="token operator">&amp;&amp;</span> <span class="token function">createPortal</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Toast</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">,</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">body</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ToastStateContext</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ToastCommandContext</span></span><span class="token punctuation">&gt;</span></span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// 컨텍스트를 분리
const ToastStateContext = createContext&lt;{
  message: string;
  type: ToastType;
}&gt;(initialState);
const ToastCommandContext = createContext&lt;{
  show: ShowToast;
  hide: Hide;
}&gt;({
  show: () =&gt; null,
  hide: () =&gt; null,
});

export const ToastProvider = memo(({ children }: PropsWithChildren) =&gt; {
  ...

  // 참조 유지
  const showWithHide: ShowToast = useAutoCallback((...args) =&gt; {
    show(...args);
    hideAfter();
  });

  // 액션 객체의 참조를 유지
  const memorizedCommand = useMemo(() =&gt; ({ show: showWithHide, hide }), [showWithHide, hide]);

  return (
    &lt;ToastCommandContext value={memorizedCommand}&gt;
      &lt;ToastStateContext value={state}&gt;
        {children}
        {visible &amp;&amp; createPortal(&lt;Toast /&gt;, document.body)}
      &lt;/ToastStateContext&gt;
    &lt;/ToastCommandContext&gt;
  );
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<blockquote>
<p><a href="https://ko.react.dev/reference/react/useContext#optimizing-re-renders-when-passing-objects-and-functions">객체와 함수를 전달할 때 리렌더링 최적화하기</a>
zustand 를 사용하는 경우 하나의 컨텍스트를 사용하면서 리렌더링 최적화가 되는 걸로 알고 있는데, 하나의 컨텍스트를 최적화 하는 방법도 찾아보면 도움이 될 것 같다.</p>
</blockquote>
<hr/>
<!-- -->
<!-- -->
<h3 id="학습-효과-분석"><a class="anchor" aria-hidden="true" tabindex="-1" href="#학습-효과-분석"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>학습 효과 분석</h3>
<!-- -->
<ul>
<li>컴포넌트를 함수로 호출하는 실수는 앞으로 하지 않을 것 같다.</li>
<li>useMemo, useCallback 과 같은 훅은 제공하는 형태로만 사용을 해왔는데, 이번 과제에서 만든 useDeepMemo, useAutoCallback 과 같은 훅들을 만들면 코드를 더 단순하게 만들 수 있을 것 같다.</li>
<li>setState 를 사용할 때</li>
<li>이번에 구현해본 훅 이외에 다른 훅들도 어떻게 구현할 수 있을지 학습하면 좋을 것 같다.</li>
<li>추천 도서 읽어보기
<ul>
<li>오프 코치님 추천: <a href="https://product.kyobobook.co.kr/detail/S000214977649">전문가를 위한 리액트</a>, <a href="https://product.kyobobook.co.kr/detail/S000212233308">리액트 훅을 활용한 마이크로 상태 관리</a></li>
<li>8팀 유열님 추천: <a href="https://product.kyobobook.co.kr/detail/S000210725203">모던 리액트 Deep Dive</a></li>
</ul>
</li>
</ul>
<hr/>
<h3 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h3>
<!-- -->
<ul>
<li>어떤 훅을 이용해 해당 기능을 구현하세요 라는 힌트가 있는 부분은 구현이 상대적으로 쉬웠습니다.</li>
<li>memo 를 ts 파일로 다루는 부분에서 createElement 를 사용하라는 힌트가 없어서 학습에 도움이 된 것 같습니다.</li>
<li>토스트 context 를 최적화 하는 부분도 과제에서 정해진 방법이 없어서 최적화를 위한 다양한 방법을 찾아볼 수 있었습니다.</li>
</ul>
<hr/>
<h2 id="학습-갈무리"><a class="anchor" aria-hidden="true" tabindex="-1" href="#학습-갈무리"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>학습 갈무리</h2>
<!-- -->
<!-- -->
<h3 id="리액트-렌더링-과정"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리액트-렌더링-과정"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리액트 렌더링 과정</h3>
<p>리액트는 컴포넌트를 화면에 그릴 때 트리거 -&gt; 렌더링 -&gt; 커밋 과정을 거친다.</p>
<h3 id="1-트리거"><a class="anchor" aria-hidden="true" tabindex="-1" href="#1-트리거"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. 트리거</h3>
<p>트리거는 2가지가 존재한다.</p>
<ol>
<li>초기 렌더링</li>
<li>상태 변화에 대한 렌더링</li>
</ol>
<h4 id="초기-렌더링"><a class="anchor" aria-hidden="true" tabindex="-1" href="#초기-렌더링"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>초기 렌더링</h4>
<pre class="language-jsx"><code class="language-jsx code-highlight"><span class="code-line"><span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">createRoot</span><span class="token punctuation">(</span><span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">&#x27;root&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">root<span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Image</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="const root = createRoot(document.getElementById(&#x27;root&#x27;));
root.render(&lt;Image /&gt;);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>createRoot 함수를 사용해 브라우저 DOM 노드 안에 React 컴포넌트를 표시하는 루트를 생성한다. 루트를 생성한 후 root.render 를 호출해 초기 렌더링을 트리거 할 수 있다.</p>
<h4 id="상태-변화에-대한-렌더링"><a class="anchor" aria-hidden="true" tabindex="-1" href="#상태-변화에-대한-렌더링"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>상태 변화에 대한 렌더링</h4>
<p>state 를 업데이트 하면 자동으로 렌더링이 트리거 된다.</p>
<h3 id="2-렌더링"><a class="anchor" aria-hidden="true" tabindex="-1" href="#2-렌더링"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. 렌더링</h3>
<p>리액트에서 렌더링은 컴포넌트를 호출하는 것을 의미한다.
초기 렌더링은 루트 컴포넌트를 호출하게 되고, 이후 상태 변화에 대한 렌더링은 state 가 바뀌어 렌더링을 트리거한 컴포넌트를 호출한다. 컴포넌트가 다른 컴포넌트를 반환하면 해당 컴포넌트도 다시 호출된다. 이것이 부모 컴포넌트가 렌더링 될 때 자식 컴포넌트도 렌더링 되는 이유다.</p>
<p>렌더링 과정을 좀 더 구체적으로 표현하면
JSX 문법 -&gt; 컴파일러를 통한 변환 -&gt; ReactElement 생성 -&gt; FiberNode 로 확장 -&gt; 재조정 -&gt; 변경사항 적용을 위한 스케쥴러 실행 과정을 거친다.</p>
<blockquote>
<p>JSX 문법은 컴파일러를 통해 ReactElement 를 생성하는 자바스크립트 코드로 변환된다. ReactElement 는 type, key, props, ref 등 컴포넌트에 필요한 정보를 담고 있다.
FiberNode는 ReactElement의 정보를 바탕으로, 트리 구조(부모, 자식, 형제 노드 참조), 컴포넌트의 상태, 훅, 라이프사이클 정보, 렌더링 작업에 필요한 다양한 메타데이터를 추가적으로 포함하는 가상 DOM 노드이다.
효율적인 재조정을 위해 useMemo, useCallback, memo 를 사용할 수 있다.</p>
</blockquote>
<h3 id="3-커밋"><a class="anchor" aria-hidden="true" tabindex="-1" href="#3-커밋"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3. 커밋</h3>
<p>렌더링 이후 실제 DOM 을 수정하는 것을 커밋이라고 부른다.
초기 렌더링의 경우 Node.appendChild() 매서드를 사용해 생성한 모든 DOM 노드를 화면에 표시한다. 리렌더링의 경우 차이가 발생한 부분만 DOM 에 적용된다.</p>
<p>페인트 이전에 useLayoutEffect 가 동기적으로 실행된다.
페인트 이후 useEffect 가 실행된다.</p>
<blockquote>
<p><a href="https://ko.react.dev/learn/render-and-commit">렌더링 그리고 커밋</a>
<a href="https://goidle.github.io/">React 톺아보기</a></p>
</blockquote>
<h3 id="컴포넌트-라이프사이클-훅"><a class="anchor" aria-hidden="true" tabindex="-1" href="#컴포넌트-라이프사이클-훅"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>컴포넌트 라이프사이클 훅</h3>
<h4 id="마운트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#마운트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>마운트</h4>
<p>useState 초기화
페인트 전 useLayoutEffect 동기적 실행
페인트 이후 useEffect 실행</p>
<h4 id="업데이트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#업데이트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>업데이트</h4>
<p>의존성 배열에 따라 useLayoutEffect, useEffect 실행</p>
<h4 id="언마운트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#언마운트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>언마운트</h4>
<p>useLayoutEffect, useEffect 클린업 실행</p>
<hr/>
<h3 id="메모이제이션에-대한-나의-생각을-적어주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#메모이제이션에-대한-나의-생각을-적어주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>메모이제이션에 대한 나의 생각을 적어주세요.</h3>
<!-- -->
<p>리액트는 가상 DOM 비교를 통해 변화된 부분만 DOM 을 업데이트 한다. 변화를 확인하는 방법으로 Object.is 매서드를 사용해 값을 비교한다. 이 과정에서 객체, 배열, 함수 등은 참조 값을 비교하게 되는데 컴포넌트가 리렌더링 되는 과정에서 새로운 참조가 생성되고, 값이 달라졌다 판단하게 된다. 이때 참조를 유지시키기 위해 메모이제이션이 필요하다.</p>
<p>메모이제이션을 사용했을 때 장점은 참초를 유지할 수 있다는 점이다. 참조를 유지하게 되면 의존성 배열, memo 등 값을 비교하는 과정에서 값이 변하지 않도록 판단하게 만들 수 있다. 단점으로는 참조를 유지시키는 useMemo, useCallback과 같은 훅들도 의존하는 값이 변했는지 비교하는 과정을 거치게 되는데, 불필요하게 사용할 경우 불필요한 비교 연산이 발생하게 된다.</p>
<p>메모이제이션을 사용하지 않고, 비교에 필요한 값을 개별로 넣는 방법을 사용할 수 있다.</p>
<pre class="language-jsx"><code class="language-jsx code-highlight"><span class="code-line"><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> memoization <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token arrow operator">=&gt;</span> state<span class="token punctuation">,</span> <span class="token punctuation">[</span>state<span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">,</span> state<span class="token punctuation">.</span><span class="token property-access">age</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token arrow operator">=&gt;</span><span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token spread operator">...</span>
</span><span class="code-line">  <span class="token comment">// 객체를 메모이제이션</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>memoization<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="const [state, setState] = useState({name:&quot;&quot;, age:0});
const memoization = useMemo(()=&gt; state, [state.name, state.age]);

useEffect(()=&gt;{
  ...
  // 객체를 메모이제이션
}, [memoization]);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<pre class="language-jsx"><code class="language-jsx code-highlight"><span class="code-line"><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token arrow operator">=&gt;</span><span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token spread operator">...</span>
</span><span class="code-line">  <span class="token comment">// 객체를 메모이제이션 하지 않고, 필요한 값을 개별로 넣는다.</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>state<span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">,</span> state<span class="token punctuation">.</span><span class="token property-access">age</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="const [state, setState] = useState({name:&quot;&quot;, age:0});

useEffect(()=&gt;{
  ...
  // 객체를 메모이제이션 하지 않고, 필요한 값을 개별로 넣는다.
}, [state.name, state.age]);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>컨텍스트를 사용해 리렌더링이 발생하는 경우 컨텍스트 분리, 메모이제이션을 통한 최적화를 진행할 수 있다. 만약 상태를 더 좁은 범위로 격리할 수 있다면, 컴포넌트 내부 상태로 분리 -&gt; 필요한 시점에 컨텍스트 업데이트 와 같은 방법으로 최적화를 할 수 있다.</p>
<hr/>
<h3 id="컨텍스트와-상태관리에-대한-나의-생각을-적어주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#컨텍스트와-상태관리에-대한-나의-생각을-적어주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>컨텍스트와 상태관리에 대한 나의 생각을 적어주세요.</h3>
<!-- -->
<blockquote>
<p>컨텍스트 + useState 사용하는 것을 가정한다.</p>
</blockquote>
<p>컨텍스트는 props 로 값을 전달하지 않아도, 값을 읽을 수 있게 해준다. props 를 전달하는 방식은 컴포넌트에 필요한 정보를 명시할 수 있는 점에서 좋은 방식이지만, 때론 해당 컴포넌트에서 불필요한 값도 전달을 목적으로 받아야 하는 경우가 발생한다. 이런 경우 컴포넌트 추가/삭제가 어려워 질 수 있고, 재사용성이 떨어진다. 또한 props 만 전달하는 중간 컴포넌트들이 불필요한 리렌더링을 해야할 수 있다. 컨텍스트는 이런 상황에서 대안이 될 수 있다.</p>
<blockquote>
<p>불필요한 props 전달의 경우 컴포넌트를 children 으로 전달하는 방법으로도 개선할 수 있다. 리액트 공식 문서에서는 컨텍스트를 사용하기 전 JSX 를 children 으로 전달하는 것을 고려하도록 권장한다.
<a href="https://ko.react.dev/learn/passing-data-deeply-with-context#before-you-use-context">Context를 사용하기 전에 고려할 것</a></p>
</blockquote>
<p>컨텍스트를 사용할 때 컨텍스트 값이 변경되면 값을 구독중인 컴포넌트들이 모두 리렌더링 되기 때문에 불필요한 리렌더링이 발생하지 않도록 주의해야 한다. 메모이제이션을 사용해 참조를 유지하도록 최적화를 할 수 있고, 자주 변경되는 값과, 자주 변경되지 않는 값을 별도의 컨텍스트로 분리하는 방법으로 최적화를 진행할 수 있다.</p>
<hr/>
<h2 id="리뷰-받고-싶은-내용"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리뷰-받고-싶은-내용"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리뷰 받고 싶은 내용</h2>
<!-- -->
<ol>
<li>
<p>자주 사용하는 커스텀훅이 있는지 궁금합니다. useAutoCallback 처럼 기존 훅을 더 쉽게 사용할 수 있도록 만든 훅들이 있을까요?</p>
</li>
<li>
<p>메모이제이션을 사용하다 보면 결국 모든 값을 메모이제이션 해야 하는 상황들이 발생하는 것 같은데, 모든 컴포넌트와 값들에 메모이제이션을 적용하는건 어떻게 생각하시나요? 물론 불필요한 비교 과정은 비효율 적이지만, 코드를 지속적으로 유지보수하면서 메모이제이션을 알맞게 사용하기 어렵다 느껴져서 질문 드립니다.</p>
</li>
</ol></div></div><div class="overflow-auto mt-9"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h2>
<p>지훈님 고생하셨습니다!
농담처럼 재미때문이라고 말씀해주시기는 하는데 저번 주에 말씀드린 것처럼 함께 팀원분들 특히 정석님과 함께 성장해나가는 모습이 너무 보기 좋네요 ㅎㅎ
필요하신 부분 딱딱 코드도 깔끔하게 코드도 작성해주셨고, 학습한 내용도 문서로 잘 남겨주셨네요 :+1 이 방식은 학습하는데 정말 도움이 많이 될 것 같아요.
지금까지 정리한 내용을 기반으로 하나의 rules를 만들어서 앞으로 AI로 생성하는 코드의 규칙을 만들어 올바르게 생성하게 할 수도 있을 것 같구요 ㅎㅎ</p>
<p>작성해주셨던 질문 답변 드려보면요!</p>
<blockquote>
<p>자주 사용하는 커스텀훅이 있는지 궁금합니다. useAutoCallback 처럼 기존 훅을 더 쉽게 사용할 수 있도록 만든 훅들이 있을까요?</p>
</blockquote>
<p>당시에는 이런 저장소들을 많이 참고하고 사용하고 했었는데요.</p>
<ul>
<li><a href="https://github.com/streamich/react-use">https://github.com/streamich/react-use</a></li>
<li><a href="https://github.com/rehooks/awesome-react-hooks">https://github.com/rehooks/awesome-react-hooks</a></li>
</ul>
<p>이런 유틸성 훅들을 가져다가 구현적 이점을 많이 누렸던 것 같아요 ㅎㅎ 이미 알고 계실거 같지만 아직 모르시다면 요거 참고해보면 좋지 않을까!</p>
<blockquote>
<p>메모이제이션을 사용하다 보면 결국 모든 값을 메모이제이션 해야 하는 상황들이 발생하는 것 같은데, 모든 컴포넌트와 값들에 메모이제이션을 적용하는건 어떻게 생각하시나요? 물론 불필요한 비교 과정은 비효율 적이지만, 코드를 지속적으로 유지보수하면서 메모이제이션을 알맞게 사용하기 어렵다 느껴져서 질문 드립니다.</p>
</blockquote>
<p>음..! 우선 저는 모든 값을 메모이제이션 해야하는 상황이 그렇게 막 오지는 않을 것 같은데요. 과거에는 모든 코드에 메모이제이션을 하는 파와 절대 하지않는다 파(?)로 나뉘어져서 막 논쟁이 있었던 것 같은데, 최근에는 그런 사람들이 많이 사라진 것 같아요. 일반적으로 저희가 따르는 최적화 논리대로 섣부른 최적화는 하지 않되, 성능적으로 이슈가 발생하는 지점이 생긴다면 그 지점에 대해서 파악한 뒤 그 부분만 국지적으로 처리하는게 적절한 사용 방법인 것 같아요. 내부적으로 이미 처리가 어느정도 되어있고 최근 들어서는 모든걸 해결해주는 관점에서 개발을 하는 것은 아니지만 컴파일러의 발전도 지속되고 있잖아요. 필요한 부분이 발견되면 그 때 적용하는 형태로 하면 좋을 것 같습니다.</p>
<p>이번주도 고생하셨고 다음주도 이번주처럼 화이팅 하시고 뿌숴주세요!</p></div></div><div class="mt-9"></div></div></main></div></div></div></div>
<script src="https://www.googletagmanager.com/gtag/js?id=G-6J8QP7YK1E"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-6J8QP7YK1E');
</script>
</body>
</html>
