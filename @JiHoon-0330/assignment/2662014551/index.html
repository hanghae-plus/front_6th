<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>항해플러스 프론트엔드 6기 기술블로그</title>
  <link rel="icon" href="/front_6th/favicon.ico"/>
  
  <script type="module" crossorigin src="/front_6th/assets/index-C86_9DIC.js"></script>
  <link rel="stylesheet" crossorigin href="/front_6th/assets/index-Dvjhel9t.css">
</head>
<body>
<div id="root"><link rel="preload" as="image" href="https://velog.velcdn.com/images/jihoon0330/post/3d31515a-95c4-4368-8891-4df83b45f233/image.png"/><link rel="preload" as="image" href="https://velog.velcdn.com/images/jihoon0330/post/fe93884f-385b-4de7-b560-0bfe13775521/image.png"/><link rel="preload" as="image" href="https://velog.velcdn.com/images/jihoon0330/post/d5fdb5fb-d4f5-47ad-8601-bb20dd91101d/image.png"/><div data-slot="sidebar-wrapper" style="--sidebar-width:16rem;--sidebar-width-icon:3rem" class="group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full"><div class="min-h-screen flex w-full"><div class="group peer text-sidebar-foreground hidden md:block" data-state="expanded" data-collapsible="" data-variant="sidebar" data-side="left" data-slot="sidebar"><div data-slot="sidebar-gap" class="relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear group-data-[collapsible=offcanvas]:w-0 group-data-[side=right]:rotate-180 group-data-[collapsible=icon]:w-(--sidebar-width-icon)"></div><div data-slot="sidebar-container" class="fixed inset-y-0 z-10 hidden h-svh transition-[left,right,width] duration-200 ease-linear md:flex left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)] group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l w-64"><div data-sidebar="sidebar" data-slot="sidebar-inner" class="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"><div data-slot="sidebar-content" data-sidebar="content" class="flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden bg-card border-r border-border"><a class="p-4" href="/front_6th/" data-discover="true"><div class="flex items-center space-x-2 mb-6"><div class="w-8 h-8 bg-gradient-primary rounded-lg flex items-center justify-center"><span class="text-white font-bold text-sm">6기</span></div><h4 class="text-lg font-bold text-primary">항해플러스 프론트엔드</h4></div></a><div data-slot="sidebar-group" data-sidebar="group" class="relative flex w-full min-w-0 flex-col p-2"><div data-slot="sidebar-group-label" data-sidebar="group-label" class="ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0 text-muted-foreground px-4">학습 관리</div><div data-slot="sidebar-group-content" data-sidebar="group-content" class="w-full text-sm"><ul data-slot="sidebar-menu" data-sidebar="menu" class="flex w-full min-w-0 flex-col gap-1 px-2"><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_6th/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-users h-5 w-5" aria-hidden="true"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><path d="M16 3.128a4 4 0 0 1 0 7.744"></path><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><circle cx="9" cy="7" r="4"></circle></svg><span class="ml-3">수강생 목록</span></a></li><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_6th/assignments" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open h-5 w-5" aria-hidden="true"><path d="M12 7v14"></path><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"></path></svg><span class="ml-3">과제 목록</span></a></li></ul></div></div></div></div></div></div><div class="flex-1 min-w-0"><header class="h-12 flex items-center border-b border-border bg-card px-4"><button data-slot="sidebar-trigger" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-7 mr-4 text-white" data-sidebar="trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-panel-left" aria-hidden="true"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M9 3v18"></path></svg><span class="sr-only">Toggle Sidebar</span></button><h4 class="text-lg font-semibold "><a href="/front_6th/@JiHoon-0330/" data-discover="true">JiHoon-0330<!-- --> 님의 상세페이지</a> ＞ <!-- -->[5팀 이지훈] Chapter 1-2. 프레임워크 없이 SPA 만들기 (2)</h4></header><main class="p-6"><div><div class="card-wrap"><div data-slot="card" class="card text-card-foreground flex flex-col gap-6 shadow-sm mb-6 p-6 border border-gray-700 bg-gray-800 rounded-lg"><a href="https://github.com/hanghae-plus/front_6th_chapter1-2/pull/18" target="_blank"><div class="flex items-start gap-4"><div class="flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" height="32" aria-hidden="true" viewBox="0 0 24 24" width="32" fill="white" class="w-8 h-8"><path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg></div><div class="flex-1 min-w-0"><div class="flex items-center gap-2 mb-2"><h3 class="text-lg font-semibold text-white truncate">[5팀 이지훈] Chapter 1-2. 프레임워크 없이 SPA 만들기 (2)</h3></div><div class="flex items-center gap-4 text-xs text-gray-500"><span>by <!-- -->JiHoon-0330</span><span>2025. 7. 13.</span></div></div></div></a></div></div><div class="overflow-auto"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-체크포인트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-체크포인트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 체크포인트</h2>
<h3 id="배포-링크"><a class="anchor" aria-hidden="true" tabindex="-1" href="#배포-링크"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>배포 링크</h3>
<p><a href="https://hanghae-plus.github.io/front_6th_chapter1-2/">https://hanghae-plus.github.io/front_6th_chapter1-2/</a></p>
<h3 id="기본과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기본과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기본과제</h3>
<h4 id="가상돔을-기반으로-렌더링하기"><a class="anchor" aria-hidden="true" tabindex="-1" href="#가상돔을-기반으로-렌더링하기"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>가상돔을 기반으로 렌더링하기</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> createVNode 함수를 이용하여 vNode를 만든다.</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> normalizeVNode 함수를 이용하여 vNode를 정규화한다.</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> createElement 함수를 이용하여 vNode를 실제 DOM으로 만든다.</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 결과적으로, JSX를 실제 DOM으로 변환할 수 있도록 만들었다.</li>
</ul>
<h4 id="이벤트-위임"><a class="anchor" aria-hidden="true" tabindex="-1" href="#이벤트-위임"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>이벤트 위임</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 노드를 생성할 때 이벤트를 직접 등록하는게 아니라 이벤트 위임 방식으로 등록해야 한다</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 동적으로 추가된 요소에도 이벤트가 정상적으로 작동해야 한다</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 이벤트 핸들러가 제거되면 더 이상 호출되지 않아야 한다</li>
</ul>
<h3 id="심화-과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#심화-과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>심화 과제</h3>
<h4 id="diff-알고리즘-구현"><a class="anchor" aria-hidden="true" tabindex="-1" href="#diff-알고리즘-구현"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Diff 알고리즘 구현</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 초기 렌더링이 올바르게 수행되어야 한다</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> diff 알고리즘을 통해 변경된 부분만 업데이트해야 한다</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 새로운 요소를 추가하고 불필요한 요소를 제거해야 한다</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 요소의 속성만 변경되었을 때 요소를 재사용해야 한다</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 요소의 타입이 변경되었을 때 새로운 요소를 생성해야 한다</li>
</ul>
<h2 id="과제-셀프회고"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-셀프회고"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 셀프회고</h2>
<!-- -->
<p>1주차 때 과제를 다 끝내고 회고를 진행하려고 하다 보니 내가 어떤 고민을 했고, 어떻게 해결하려고 글로 쓰려니 어려움을 느꼈다. 그래서 2주차 부터는 과제를 진행하면서 고민한 내용들을 그날 그날 적어보는 것을 목표로 했다.</p>
<p><a href="https://github.com/JiHoon-0330/front_6th_chapter1-2/issues">과제를 진행하면서 남겼던 글들</a></p>
<p>마침 같은 팀인 정석님이 동기부여를 원하셔서 매일 학습 내용 적기를 공유하기도 했다.</p>
<p>실제로 매일 학습 내용을 공유해준 5팀 최고 👍</p>
<p><img src="https://velog.velcdn.com/images/jihoon0330/post/3d31515a-95c4-4368-8891-4df83b45f233/image.png" alt="TIL"/></p>
<p>기본 과제에선 테스트코드에 알맞은 코드를 작성하고, 작성하는 과정에서 JSX를 가상돔으로 만들기 위해 어떤 일들이 필요한지 학습을 하는 방향으로 공부를 진행했다. 코드를 작성하는 부분에서는 구현 난이도가 높지 않아 코드 스타일이나, 어떤 매서드를 사용할지와 같은 부분에 집중을 했다.</p>
<p>심화 과제는 생각보다 어렵게 느껴졌다. 비교를 해야 한다는 건 알았지만, children 값을 비교하고 DOM 에 적용시키는 부분이 조금 막막했던 것 같다. 개수가 다를 수 있는 부분과, 텍스트와 엘리먼트인 경우 어떻게 하면 좋을지? 텍스트인데 길이가 다른 경우 등등..</p>
<p>그래서 Gemini를 활용해 DOM 추가/변경/삭제 하는 API 목록을 얻어서 정리하는 시간을 가졌다.
심화 과제에서 엘리먼트 노드를 다루기 위해 필요한 매서드들은 <code>appendChild</code>, <code>removeChild</code>, <code>replaceChild</code> 3종류가 있었고, 리액트 처럼 목록을 key로 관리한다면 <code>insertBefore</code> 매서드가 추가로 필요할 것 같다.</p>
<p>추가/삭제/변경을 하는 코드를 작성하고, 유닛 테스트도 다 통과를 한 시점에 베이직에서 통과했던 e2e 테스트를 실패해 서비스를 실행해보니</p>
<p><img src="https://velog.velcdn.com/images/jihoon0330/post/fe93884f-385b-4de7-b560-0bfe13775521/image.png" alt="오류 이미지"/></p>
<p>총 {스켈레톤} 340개 와 같은 화면이 나왔다. 당황..</p>
<p>이후에도 아래와 같이 상품이 하나씩 보이는 오류가 있었다.</p>
<p><img src="https://velog.velcdn.com/images/jihoon0330/post/d5fdb5fb-d4f5-47ad-8601-bb20dd91101d/image.png" alt="오류 이미지2"/></p>
<p>이런 문제를 겪다 보니 심화 과제를 진행하면서 디버깅이 많이 익숙해졌다.</p>
<p>문제는 엘리먼트를 추가할 때 원래 위치보다 더 상위 요소에 추가를 하고 있었던 것과, newNode, oldNode 값이 존재하는지와 비교하는 과정에 빠트린 부분이 있는 것이 원인이었다.</p>
<p>심화 과제를 쉽게 푸는 팀원들을 보고 스스로 부족한 영역을 인지하게 된 것 같다. 개인적으로 이런 알고리즘 문제가 어려운 것 같다.</p>
<h3 id="기술적-성장"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기술적-성장"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기술적 성장</h3>
<!-- -->
<h4 id="setattribute-와-property"><a class="anchor" aria-hidden="true" tabindex="-1" href="#setattribute-와-property"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>setAttribute 와 property</h4>
<p>setAttribute 는 요소에 문자열로 된 값만을 설정할 수 있고, boolean 값을 다루는 속성의 경우 키 값의 존재 여부만 파악하기 때문에 setAttribute(&quot;disabled&quot;, &quot;false&quot;); 로 설정하면 disabled 값이 true 가 된다는 것을 과거엔 그냥 지나쳤던 것 같은데, 이번에 props 를 설정하면서 확실하게 알게 되었다. 추가적으로 요소 노드 인터페이스에 존재하는 값들은 setAttribute 를 사용하지 않고 설정하는 것이 권장되고, 성능이 더 좋다는 것도 알게 되었다.</p>
<blockquote>
<p>테스트 코드 돌리면서 왜 실패하는지 파악하기 어려웠다.</p>
</blockquote>
<h4 id="xss-공격"><a class="anchor" aria-hidden="true" tabindex="-1" href="#xss-공격"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>XSS 공격</h4>
<p>href, src 와 같이 URL 관련 속성을 사용할 때 XSS 공격을 주의해야 하는 것을 배웠다.
실행 가능한 자바스크립트 코드로 해석하고 실행하도록 설계 된 부분에 보안을 유지할 수 있는 장치를 추가해야 한다. 헌재 프로젝트에서는 href, src 값을 할당할 때 URL 생성자를 통해 올바른 url 형태인지 검사하고, &#x27;javascript:&#x27; 프로토콜일시 오류를 던지도록 만들었다.</p>
<blockquote>
<p>추가로 알게 된 사실은 <code>data:image/png;base64</code> 형태의 값도 URL 생성자에 사용할 수 있다.
css 에서 사용하는 url 값 에도 적용이 가능하다고 한다.</p>
</blockquote>
<p>innerHTML 의 경우도 문자열을 파싱하는 과정에서 XSS 공격을 주의해야 한다. 단순히 텍스트를 설정하는 경우 textContent 를 사용하는 것이 좋다.</p>
<blockquote>
<p>텍스트 노드를 생성할 때와, nodeValue 사용해 값을 할당 하는 것도 XSS 방어에 도움이 된다.</p>
</blockquote>
<h4 id="dom-노드"><a class="anchor" aria-hidden="true" tabindex="-1" href="#dom-노드"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DOM 노드</h4>
<p>이번에 DOM 노드를 다루면 좀 더 세밀한 제어가 가능한 것을 경험했다.
텍스트 노드 라는 것이 존재한다는 것은 알았지만, 보통 innerHTML 이나, textContent 같은 것들을 사용했는데 텍스트를 노드 단위로 조작하는 것을 경험하게 되었다.</p>
<p>추가적으로 알게 된 사실은 텍스트 노드를 생성할 때 <code>document.createTextNode()</code> 와 같은 방식으로 생성할 수도 있지만, <code>Text</code> 라는 생성자를 통해서도 직접 생성이 가능하다는 걸 알게 되었다. 이외에도 Element 노드를 제외한 다른 노드들도 생성자를 통해 생성이 가능했고, Element 노드의 경우 <code>document.createElement()</code> 매서드를 직접적으로 대체하는 생성자는 없다는 걸 알게 되었다.</p>
<blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API">The HTML DOM API</a> 페이지에서 목록에 있는 각 요소들을 들어가보면 생성자가 있는 요소와 없는 요소가 있는데, 아마 모든 요소의 생성자가 구현된 상태가 아니기 때문이 아닐까 추측된다.</p>
</blockquote>
<h4 id="목록의-업데이트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#목록의-업데이트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>목록의 업데이트</h4>
<p>현재 방식에선 목록을 업데이트 할 때 index 에 해당하는 값 끼리 비교를 해서 업데이트를 진행하는데, 최상단에 데이터가 추가된 경우 모든 목록을 새로 생성해야 하는 단점이 있었다. 리액트에서 배열을 사용해 렌더링을 할 때 key 값을 꼭 유니크하게 넣어줘야 하는 이유를 유추해 볼 수 있었다.</p>
<h4 id="버블링이-되지-않는-이벤트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#버블링이-되지-않는-이벤트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>버블링이 되지 않는 이벤트</h4>
<p>focus, blur 와 같은 이벤트 들은 버블링을 지원하지 않는 걸 알게 되었다.
버블링을 사용하려면 <code>focusin</code> 같은 버블링을 지원하는 이벤트를 사용하거나, 캡쳐를 활성화 해 캡쳐링 단계에서 위임을 할 수 있다.</p>
<h4 id="이벤트매니저-stoppropagation-고려하기"><a class="anchor" aria-hidden="true" tabindex="-1" href="#이벤트매니저-stoppropagation-고려하기"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>이벤트매니저 stopPropagation 고려하기</h4>
<p>이벤트를 메모리 효율적으로 관리하기 위해 최상위 객체에 이벤트리스너를 설정할 수 있다. 하지만 stopPropagation 와 같은 매서드를 사용하기 위해선 별도로 구현을 해주어야 한다.</p>
<p>1주차에선 셀렉터만을 이용해 이벤트 관리를 했는데, id 값 처럼 페이지에서 유일한 값을 사용하지 않으면 부모-자식 관계를 파악하기 어려웠고, stopPropagation 와 같은 매서드를 구현하는데 한계가 있다고 느꼈다.</p>
<blockquote>
<p>1주차 과제에서는 셀렉터를 이용해 이벤트가 발생한 요소와, 이벤트를 등록한 요소를 비교했다.
eventType 에 해당하는 셀렉터와 핸들러 쌍을 배열이나, Set에 저장한 다음 반복문을 돌며 이벤트가 발생한 요소가 셀렉터와 같거나 자식 요소이면 핸들러를 실행하는 방식이다.
이 방식에선 문제가 있었는데, 중첩된 요소에 같은 eventType 에 해당하는 이벤트가 등록되면 중복 호출된다는 점이다.</p>
<pre class="language-html"><code class="language-html code-highlight"><span class="code-line"><span class="token comment">&lt;!-- 상품카드에 클릭 이벤트 설정 --&gt;</span>
</span><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>상품카드<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</span><span class="code-line"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>...<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</span><span class="code-line"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">&gt;</span></span>
</span><span class="code-line"> <span class="token comment">&lt;!-- 장바구니담기 버튼에 클릭 이벤트 설정 --&gt;</span>
</span><span class="code-line"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>button<span class="token punctuation">&quot;</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>장바구니담기<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>장바구니 담기<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</span><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</span></code><div class="copied" data-code="&lt;!-- 상품카드에 클릭 이벤트 설정 --&gt;
&lt;div id=&quot;상품카드&quot;&gt;
 &lt;img src=&quot;...&quot; /&gt;
 &lt;h3&gt;...&lt;/h3&gt;
 &lt;!-- 장바구니담기 버튼에 클릭 이벤트 설정 --&gt;
 &lt;button type=&quot;button&quot; id=&quot;장바구니담기&quot;&gt;장바구니 담기&lt;/button&gt;
&lt;/div&gt;
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line">$root<span class="token punctuation">.</span><span class="token method function property-access">addEventListener</span><span class="token punctuation">(</span>eventType<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line"> <span class="token keyword control-flow">for</span><span class="token punctuation">(</span> <span class="token string">&quot;저장한 셀렉터와 핸들러 쌍들..&quot;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">   <span class="token keyword control-flow">if</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">.</span><span class="token method function property-access">closest</span><span class="token punctuation">(</span>셀렉터<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">     <span class="token doc-comment comment">/**
</span></span><span class="code-line"><span class="token doc-comment comment">      * 장바구니담기 버튼을 클릭했을 때 
</span></span><span class="code-line"><span class="token doc-comment comment">      * 상품카드와, 장바구니담기 핸들러 모두 실행된다.
</span></span><span class="code-line"><span class="token doc-comment comment">      */</span>
</span><span class="code-line">     <span class="token function">핸들러</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
</span><span class="code-line">   <span class="token punctuation">}</span>
</span><span class="code-line"> <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="$root.addEventListener(eventType, (e) =&gt; {
 for( &quot;저장한 셀렉터와 핸들러 쌍들..&quot; ) {
   if(e.target.closest(셀렉터)) {
     /**
      * 장바구니담기 버튼을 클릭했을 때 
      * 상품카드와, 장바구니담기 핸들러 모두 실행된다.
      */
     핸들러(e)
   }
 }
});
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>자식 요소를 배열의 앞쪽에 위치시키고, 조건을 만족하는 경우 반복문에서 빠져 나온다면 중복 호출은 방지할 수 있다. 단점은 페이지 전체가 렌더링 되지 않고, 일부만 변경되는 경우 배열의 순서를 지키기 어렵다 생각한다. 또한 id를 제외한 값은 중복이 가능하기 때문에 셀렉터 만으로 부모-자식 관계를 알기 어렵다.</p>
</blockquote>
<p>2주차 과제에선 요소를 키로 사용하는 방법을 사용했다. 요소를 키로 사용하는 방법의 장점은 여러 요소가 있을 때 부모-자식 관계가 명확해 진다는 점이다.</p>
<p>우선 1주차와 같은 형태로 코드를 작성한다.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line">$root<span class="token punctuation">.</span><span class="token method function property-access">addEventListener</span><span class="token punctuation">(</span>eventType<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">[</span>element<span class="token punctuation">,</span> handler<span class="token punctuation">]</span> <span class="token keyword">of</span> eventsRecord<span class="token punctuation">[</span>eventType<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span><span class="token method function property-access">contains</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token function">handler</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="$root.addEventListener(eventType, (e) =&gt; {
  for (const [element, handler] of eventsRecord[eventType]) {
    if (element.contains(e.target)) {
      handler(e);
    }
  }
});
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이벤트 처리에 필요한 요소를 정렬하는 기능을 추가한다.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword">function</span> <span class="token function">getDeepestContainingElements</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> eventsMap</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword control-flow">return</span> <span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token keyword module">from</span><span class="token punctuation">(</span>eventsMap<span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token comment">// 저장한 element 가 e.target 과 같거나 부모인 경우만 필터링 한다.</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token method function property-access">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>element<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> element<span class="token punctuation">.</span><span class="token method function property-access">contains</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token method function property-access">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token comment">// 자식 요소가 앞으로 오도록 정렬한다.</span>
</span><span class="code-line">      <span class="token keyword">const</span> aElement <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">      <span class="token keyword">const</span> bElement <span class="token operator">=</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>aElement<span class="token punctuation">.</span><span class="token method function property-access">contains</span><span class="token punctuation">(</span>bElement<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword control-flow">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
</span><span class="code-line">      <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>bElement<span class="token punctuation">.</span><span class="token method function property-access">contains</span><span class="token punctuation">(</span>aElement<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token keyword control-flow">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
</span><span class="code-line">      <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">      <span class="token keyword control-flow">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="function getDeepestContainingElements(target, eventsMap) {
  return Array.from(eventsMap)
    // 저장한 element 가 e.target 과 같거나 부모인 경우만 필터링 한다.
    .filter(([element]) =&gt; element.contains(target))
    .sort((a, b) =&gt; {
      // 자식 요소가 앞으로 오도록 정렬한다.
      const aElement = a[0];
      const bElement = b[0];

      if (aElement.contains(bElement)) {
        return 1;
      }

      if (bElement.contains(aElement)) {
        return -1;
      }

      return 0;
    });
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>기존 stopPropagation 매서드와 동일한 역할을 할 수 있도록 새로운 값을 덮어썼다.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line">$root<span class="token punctuation">.</span><span class="token method function property-access">addEventListener</span><span class="token punctuation">(</span>eventType<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">let</span> isStopped <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">defineProperty</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token string">&quot;stopPropagation&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token function-variable function">value</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">      isStopped <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">const</span> deepestElements <span class="token operator">=</span> <span class="token function">getDeepestContainingElements</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">,</span> eventsRecord<span class="token punctuation">[</span>eventType<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> handler<span class="token punctuation">]</span> <span class="token keyword">of</span> deepestElements<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>isStopped<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token comment">// 자식 요소에서 stopPropagation 매서드를 호출한 경우 부모 요소의 핸들러 실행을 멈춘다.</span>
</span><span class="code-line">      <span class="token keyword control-flow">break</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token function">handler</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="$root.addEventListener(eventType, (e) =&gt; {
  let isStopped = false;
  Object.defineProperty(e, &quot;stopPropagation&quot;, {
    value: () =&gt; {
      isStopped = true;
    },
  });

  const deepestElements = getDeepestContainingElements(e.target, eventsRecord[eventType]);
  for (const [, handler] of deepestElements) {
    if (isStopped) {
      // 자식 요소에서 stopPropagation 매서드를 호출한 경우 부모 요소의 핸들러 실행을 멈춘다.
      break;
    }

    handler(e);
  }
});
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="코드-품질"><a class="anchor" aria-hidden="true" tabindex="-1" href="#코드-품질"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>코드 품질</h3>
<!-- -->
<h4 id="createvnode-평탄화-구현하기"><a class="anchor" aria-hidden="true" tabindex="-1" href="#createvnode-평탄화-구현하기"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>createVNode 평탄화 구현하기</h4>
<p>평탄화 이후 렌더링 가능한 항목만 필터링 하는 과정을 한 번의 순회를 통해 작업하고 싶었다.
검색 결과 <code>Array.flat</code> 매서드의 경우 속도가 느리다 라는 말이 있었다. 성능 밴치마크를 봤을 때 현재는 이 논의가 있던 시기보다는 개선이 된 것 같지만, 가상 돔에서 많은 배열을 다뤄야 한다면 성능에서 이점이 있을 거라 생각했다.</p>
<blockquote>
<p>네이티브 flat 보다 빠르다고 나와있는 es-toolkit 의 flatten 함수를 참고했다.
<a href="https://github.com/toss/es-toolkit/blob/main/src/array/flatten.ts">es-toolkit flatten 구현 코드</a></p>
</blockquote>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword">function</span> <span class="token function">flattenRenderableChildren</span><span class="token punctuation">(</span><span class="token parameter">children</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token function-variable function">flatten</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isNotRenderable</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> value<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token function">flatten</span><span class="token punctuation">(</span>value<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">      <span class="token punctuation">}</span>
</span><span class="code-line">    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
</span><span class="code-line">      result<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token function">flatten</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword control-flow">return</span> result<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="function flattenRenderableChildren(children) {
  const result = [];

  const flatten = (value) =&gt; {
    if (isNotRenderable(value)) {
      return;
    }

    if (Array.isArray(value)) {
      for (let i = 0; i &lt; value.length; i++) {
        flatten(value[i]);
      }
    } else {
      result.push(value);
    }
  };

  flatten(children);
  return result;
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h4 id="createelement-요소-생성하기-코드-스타일"><a class="anchor" aria-hidden="true" tabindex="-1" href="#createelement-요소-생성하기-코드-스타일"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>createElement 요소 생성하기 (코드 스타일)</h4>
<p>Element 노드를 생성할 때 <code>document.createElement()</code> 방식을 사용해야 하기 때문에, 다른 노드를 생성할 때도 document 매서드를 사용해 일관성을 지켰다. 개별 노드나, 생성자를 지원하는 엘리먼트를 다룰 땐 생성자를 사용해 볼 수 있을 것 같다.</p>
<h4 id="자식-요소-업데이트-하기-개선이-필요한-부분"><a class="anchor" aria-hidden="true" tabindex="-1" href="#자식-요소-업데이트-하기-개선이-필요한-부분"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>자식 요소 업데이트 하기 (개선이 필요한 부분)</h4>
<p>updateElement 함수에서 vNode 의 children 값을 반복문으로 돌 때 요소를 삭제하는 경우 i 의 값을 유지하면서 maxChildrenLength 값을 줄이고 있는데, 나중에 다시 봤을 때 이 부분 코드가 이해하기 어려울 것 같다.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">updateElement</span><span class="token punctuation">(</span><span class="token parameter">parentElement<span class="token punctuation">,</span> newNode<span class="token punctuation">,</span> oldNode<span class="token punctuation">,</span> index <span class="token operator">=</span> <span class="token number">0</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token spread operator">...</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// updateElement 함수 내부에서</span>
</span><span class="code-line">  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">let</span> maxChildrenLength <span class="token operator">=</span> <span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token method function property-access">max</span><span class="token punctuation">(</span>newNode<span class="token punctuation">.</span><span class="token property-access">children</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">,</span> oldNode<span class="token punctuation">.</span><span class="token property-access">children</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> maxChildrenLength<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">const</span> newChild <span class="token operator">=</span> newNode<span class="token punctuation">.</span><span class="token property-access">children</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">const</span> oldChild <span class="token operator">=</span> oldNode<span class="token punctuation">.</span><span class="token property-access">children</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>newChild <span class="token operator">&amp;&amp;</span> oldChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token comment">// 삭제 한 다음 dom이 현재 i 값에 위치하기 때문에 증가시키지 않는다</span>
</span><span class="code-line">      <span class="token comment">// 반복하는 횟수만 중요하기 때문에 i 값을 유지하면서 newChild, oldChild 에 할당하는 값은 신경쓰지 않음</span>
</span><span class="code-line">      <span class="token function">updateElement</span><span class="token punctuation">(</span>currentDomNode<span class="token punctuation">,</span> <span class="token keyword null nil">null</span><span class="token punctuation">,</span> oldChild<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">      maxChildrenLength <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token function">updateElement</span><span class="token punctuation">(</span>currentDomNode<span class="token punctuation">,</span> newChild<span class="token punctuation">,</span> oldChild<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">      i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="export function updateElement(parentElement, newNode, oldNode, index = 0) {
  ...

  // updateElement 함수 내부에서
  let i = 0;
  let maxChildrenLength = Math.max(newNode.children.length, oldNode.children.length);
  while (i &lt; maxChildrenLength) {
    const newChild = newNode.children[i];
    const oldChild = oldNode.children[i];
    if (!newChild &amp;&amp; oldChild) {
      // 삭제 한 다음 dom이 현재 i 값에 위치하기 때문에 증가시키지 않는다
      // 반복하는 횟수만 중요하기 때문에 i 값을 유지하면서 newChild, oldChild 에 할당하는 값은 신경쓰지 않음
      updateElement(currentDomNode, null, oldChild, i);
      maxChildrenLength -= 1;
    } else {
      updateElement(currentDomNode, newChild, oldChild, i);
      i += 1;
    }
  }
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>반복문을 아래와 같이 분리하면 조금 더 의도가 명확해 지는 것 같은데, 어떻게 생각하시나요?</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">updateElement</span><span class="token punctuation">(</span><span class="token parameter">parentElement<span class="token punctuation">,</span> newNode<span class="token punctuation">,</span> oldNode<span class="token punctuation">,</span> index <span class="token operator">=</span> <span class="token number">0</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token spread operator">...</span>
</span><span class="code-line">  <span class="token method function property-access">removeChildren</span><span class="token punctuation">(</span>currentDomNode<span class="token punctuation">,</span> newNode<span class="token punctuation">,</span> oldNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token function">updateChildren</span><span class="token punctuation">(</span>currentDomNode<span class="token punctuation">,</span> newNode<span class="token punctuation">,</span> oldNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 함수로 선언</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">function</span> <span class="token function">removeChildren</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> newNode<span class="token punctuation">,</span> oldNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> newChildrenLength <span class="token operator">=</span> newNode<span class="token punctuation">.</span><span class="token property-access">children</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> oldChildrenLength <span class="token operator">=</span> oldNode<span class="token punctuation">.</span><span class="token property-access">children</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>newChildrenLength <span class="token operator">&gt;=</span> oldChildrenLength<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">const</span> count <span class="token operator">=</span> oldChildrenLength <span class="token operator">-</span> newChildrenLength<span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    parent<span class="token punctuation">.</span><span class="token method function property-access">removeChild</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token property-access">childNodes</span><span class="token punctuation">[</span>newChildrenLength<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">function</span> <span class="token function">updateChildren</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> newNode<span class="token punctuation">,</span> oldNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> newNode<span class="token punctuation">.</span><span class="token property-access">children</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">const</span> newChild <span class="token operator">=</span> newNode<span class="token punctuation">.</span><span class="token property-access">children</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">const</span> oldChild <span class="token operator">=</span> oldNode<span class="token punctuation">.</span><span class="token property-access">children</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token function">updateElement</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> newChild<span class="token punctuation">,</span> oldChild<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="export function updateElement(parentElement, newNode, oldNode, index = 0) {
  ...
  removeChildren(currentDomNode, newNode, oldNode);
  updateChildren(currentDomNode, newNode, oldNode);
}

// 함수로 선언

function removeChildren(parent, newNode, oldNode) {
  const newChildrenLength = newNode.children.length;
  const oldChildrenLength = oldNode.children.length;

  if (newChildrenLength &gt;= oldChildrenLength) {
    return;
  }

  const count = oldChildrenLength - newChildrenLength;
  for (let i = 0; i &lt; count; i++) {
    parent.removeChild(parent.childNodes[newChildrenLength]);
  }
}

function updateChildren(parent, newNode, oldNode) {
  for (let i = 0; i &lt; newNode.children.length; i++) {
    const newChild = newNode.children[i];
    const oldChild = oldNode.children[i];
    updateElement(parent, newChild, oldChild, i);
  }
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="학습-효과-분석"><a class="anchor" aria-hidden="true" tabindex="-1" href="#학습-효과-분석"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>학습 효과 분석</h3>
<!-- -->
<ul>
<li>리액트를 사용하면 XSS 방어가 가능하다는 것을 막연하게 알고는 있었는데, 직접 돔을 조작하면서 내부적으로 신경써야 하는 점들을 알게 되었다.</li>
<li>이벤트 위임의 제약에 대해 생각해 볼 수 있었다. 리액트에선 이벤트 처리를 위해 어떤 방법을 사용하는지 추가 학습이 필요할 것 같다.</li>
</ul>
<h3 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h3>
<!-- -->
<ul>
<li>테스트 코드가 꼼꼼하게 되어있어서 좋았습니다.</li>
<li>JSX 의 변환에 대해 생각해 볼 수 있어 좋았습니다.</li>
<li>과제를 진행하면서 리액트의 내부 동작에 대해 더 알아보고 싶다는 호기심이 생겨서 긍정적인 부분이라 생각합니다.</li>
</ul>
<h2 id="리뷰-받고-싶은-내용"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리뷰-받고-싶은-내용"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리뷰 받고 싶은 내용</h2>
<!-- -->
<p>성능을 고려하는 기준을 어떻게 잡으면 좋을까요? 과제에서 <code>flat().filter()</code> 두 번 순회하는 작업을 한 번 순회하는 작업으로 만들면서 이 부분에서는 이런 이유 떄문에 이렇게 작성해야 한다는 기준을 잡지는 못했습니다. 실무에서 함수 단위의 성능 개선을 위한 기준이 있으신가요?</p>
<blockquote>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword">function</span> <span class="token function">flattenRenderableChildren</span><span class="token punctuation">(</span><span class="token parameter">children</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line"> <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"> <span class="token keyword">const</span> <span class="token function-variable function">flatten</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">   <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token function">isNotRenderable</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">     <span class="token keyword control-flow">return</span><span class="token punctuation">;</span>
</span><span class="code-line">   <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">   <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">     <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> value<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">       <span class="token function">flatten</span><span class="token punctuation">(</span>value<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">     <span class="token punctuation">}</span>
</span><span class="code-line">   <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
</span><span class="code-line">     result<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">   <span class="token punctuation">}</span>
</span><span class="code-line"> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"> <span class="token function">flatten</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"> <span class="token keyword control-flow">return</span> result<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="function flattenRenderableChildren(children) {
 const result = [];

 const flatten = (value) =&gt; {
   if (isNotRenderable(value)) {
     return;
   }

   if (Array.isArray(value)) {
     for (let i = 0; i &lt; value.length; i++) {
       flatten(value[i]);
     }
   } else {
     result.push(value);
   }
 };

 flatten(children);
 return result;
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
</blockquote>
<hr/>
<p>이벤트 위임을 하면서 각 요소에 이벤트리스너를 설정한 것과 동일한 환경을 구현하고 싶었습니다.
반복문을 돌면서 이벤트가 발생한 타겟의 부모 핸들러를 호출 하는 것과, <code>stopPropagation</code> 기능을 구현하기 위해 이벤트 발생시 이벤트 타겟의 부모 요소들을 필터링 하고, 정렬하는 과정을 거치게 됩니다.</p>
<p>지금 생각으로는 이벤트를 추가할 때 정렬해서 저장하는 것과, 이벤트가 발생할 때 정렬해서 사용하는 방법이 있을 것 같은데, 현재 쇼핑몰과 같은 서비스에서 어떤 방법이 더 효율적이라 생각 하시나요?</p>
<p>아니면 해당 기능을 구현하기 위해 코치님이 생각하신 더 효율적인 방법이 있는지 궁금합니다</p>
<blockquote>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line">$root<span class="token punctuation">.</span><span class="token method function property-access">addEventListener</span><span class="token punctuation">(</span>eventType<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line"> <span class="token keyword">let</span> isStopped <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</span><span class="code-line"> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">defineProperty</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token string">&quot;stopPropagation&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
</span><span class="code-line">   <span class="token function-variable function">value</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">     isStopped <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</span><span class="code-line">   <span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line"> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"> <span class="token keyword">const</span> deepestElements <span class="token operator">=</span> <span class="token function">getDeepestContainingElements</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">,</span> eventsRecord<span class="token punctuation">[</span>eventType<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"> <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> handler<span class="token punctuation">]</span> <span class="token keyword">of</span> deepestElements<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">   <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>isStopped<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">     <span class="token comment">// 자식 요소에서 stopPropagation 매서드를 호출한 경우 부모 요소의 핸들러 실행을 멈춘다.</span>
</span><span class="code-line">     <span class="token keyword control-flow">break</span><span class="token punctuation">;</span>
</span><span class="code-line">   <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">   <span class="token function">handler</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"> <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="$root.addEventListener(eventType, (e) =&gt; {
 let isStopped = false;
 Object.defineProperty(e, &quot;stopPropagation&quot;, {
   value: () =&gt; {
     isStopped = true;
   },
 });

 const deepestElements = getDeepestContainingElements(e.target, eventsRecord[eventType]);
 for (const [, handler] of deepestElements) {
   if (isStopped) {
     // 자식 요소에서 stopPropagation 매서드를 호출한 경우 부모 요소의 핸들러 실행을 멈춘다.
     break;
   }

   handler(e);
 }
});
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
</blockquote>
<hr/>
<p>focus 이벤트와 같이 버블링을 지원하지 않는 이벤트의 경우 개별 요소에 이벤트리스너를 설정하는 것과, focusin 처럼 버블링을 지원하는 이벤트로 변경해 위임을 하는 것 어떤 것을 더 선호하시나요?</p></div></div><div class="overflow-auto mt-9"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h2>
<p>지훈님 회고가 엄청 알차네요!
한 주를 어떻게 보내셨는지 가늠할 수 있는 좋은 자료 인 것 같습니다. 고생하셨어요 ㅎㅎ
과제에 대해서는 명확하게 필요한 부분 잘 작성해주셨고 문서에 남겨주신 것들 살펴보면 알 수 있듯이 할 수 있는 여러 고민들에 대해 답변도 구체적으로 남겨져 있고 함께 성장하려고 하시는 모습도 너무 좋네요. (특히 정석님에 대한 그..)</p>
<p>코드 품질 부분에서 이야기를 주시기도 했고 질문 주신 함수 성능 최적화 시점에 대한 최적화 부분을 먼저 답변드려보면요.</p>
<p>먼저 중요할 수 있는 로직 부분이니 이미 알고 있는 여러 지식들도 활용하는 것 좋았습니다. 다만, 개인적인 관점으로 약간 얘기를 다르게 해보면 최적화 관점에서 필요한 부분은 맞지만, 이슈가 발생한 지점이 있었는지 궁금하긴해요!
실제 브라우저에서 제공하는 API를 사용하지 않고 직접 구현해서 사용한다면 해당 부분에 대해 명확한 이슈가 발생하고 나서 수정을 하는 것도 늦지 않거든요 ㅎㅎ 말씀해주신 것처럼 브라우저에서 해당 이슈를 인지하고 속도를 빠르게 하는 최적화를 하고 있다면 관리적 이슈가 늘어나는 부분이니까요. 절대 지금의 코드가 잘못되었다는 것은 아니지만, 우리가 최적화를 하는 시점에 대해서는 고민을 해보는것도 추후에 좋지 않을까! 싶긴 합니다.</p>
<p>우리가 원칙으로 알고 있는 것처럼 섣부른 최적화는 실제 앱에 성능이 되지 않고 가독성이 안좋아지는 결과를 낳으니까요.  그대로 사용한다면 가독성 측면에서도 유리해지는 지점도 있으니까 그런 부분을 함께 챙겨주시면 좋을 것 같습니다. (아무튼 접근은 좋았습니다!)</p>
<blockquote>
<p>위임 환경 구현</p>
</blockquote>
<p>이 부분도 사실은 최적화 시점에 관련된 이야기 인 것 같은데요.
이미 정답을 추측해보실 수 있는것처럼, 지훈님이 작성해주신 이 프레임워크가 만약 &#x27;쇼핑몰이 아닌 여러 곳에서 사용할 수 있는 가능성이 있다&#x27; 라는 관점의 개발일지 &#x27;쇼핑몰에 적합한 프레임워크다&#x27;라는 관점으로 접근할 지가 필요할 것 같아요. 만약 전자라면 범용적인 시나리오에 모두 적합한 최적화 방식을 선택해야 하고, 쇼핑몰에서만 사용해야 한다면 지금은 등록은 적고, 발생은 빈번하기 때문에 발생 했을 때 어떻게 유리하게 처리할 수 있는지 시간복잡도를 계산하고 사용한다면 좋지 않을까 싶네요!
리액트에서는 fiber tree를 사용해 이벤트 등록 시점에 최적화를 수행하는 것으로 알고 있는데, 이런 관점에서도 한 번 고민해보면 좋을 것 같네요.</p>
<blockquote>
<p>focus 이벤트와 같이 버블링을 지원하지 않는 이벤트의 경우 개별 요소에 이벤트리스너를 설정하는 것과, focusin 처럼 버블링을 지원하는 이벤트로 변경해 위임을 하는 것 어떤 것을 더 선호하시나요?</p>
</blockquote>
<p>저희가 별도로 이벤트 시스템을 구축해 관리를 하는 장점이 여기에도 속할 수 있을 것 같은데요. 제가 알고 있기로는 리액트도 내부적으로 해당 이벤트를 위임 가능하도록 매핑해 처리를 하는 것으로 알고 있어요. 동일한 동작을 만들고 이벤트에 대한 구현 일관성을 유지하고 사용자가 사용하기 편하도록 처리할 수 있어서 그런 것 같은데요. 저희의 과제 목표가 리액트와 유사한 구조를 만드는것이니 변경해 위임을 하는 형태로 구현해본다면 더 공부가 될 것 같습니다 ㅎㅎ</p>
<p>고생하셨고 다음 주도 화이팅입니다!!</p></div></div><div class="mt-9"></div></div></main></div></div></div></div>
</body>
</html>
