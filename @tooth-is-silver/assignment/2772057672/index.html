<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>항해플러스 프론트엔드 6기 기술블로그</title>
  <link rel="icon" href="/front_6th/favicon.ico"/>
  
  <script type="module" crossorigin src="/front_6th/assets/index-S6z1r9QJ.js"></script>
  <link rel="stylesheet" crossorigin href="/front_6th/assets/index-BXO68frB.css">
</head>
<body>
<div id="root"><link rel="preload" as="image" href="https://github.com/user-attachments/assets/e196c2ff-db86-4103-9c2f-a8013ab5d968"/><div data-slot="sidebar-wrapper" style="--sidebar-width:16rem;--sidebar-width-icon:3rem" class="group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full"><div class="min-h-screen flex w-full"><div class="group peer text-sidebar-foreground hidden md:block" data-state="expanded" data-collapsible="" data-variant="sidebar" data-side="left" data-slot="sidebar"><div data-slot="sidebar-gap" class="relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear group-data-[collapsible=offcanvas]:w-0 group-data-[side=right]:rotate-180 group-data-[collapsible=icon]:w-(--sidebar-width-icon)"></div><div data-slot="sidebar-container" class="fixed inset-y-0 z-10 hidden h-svh transition-[left,right,width] duration-200 ease-linear md:flex left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)] group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l w-64"><div data-sidebar="sidebar" data-slot="sidebar-inner" class="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"><div data-slot="sidebar-content" data-sidebar="content" class="flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden bg-card border-r border-border"><a class="p-4" href="/front_6th/" data-discover="true"><div class="flex items-center space-x-2 mb-6"><div class="w-8 h-8 bg-gradient-primary rounded-lg flex items-center justify-center"><span class="text-white font-bold text-sm">6기</span></div><h4 class="text-lg font-bold text-primary">항해플러스 프론트엔드</h4></div></a><div data-slot="sidebar-group" data-sidebar="group" class="relative flex w-full min-w-0 flex-col p-2"><div data-slot="sidebar-group-label" data-sidebar="group-label" class="ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0 text-muted-foreground px-4">학습 관리</div><div data-slot="sidebar-group-content" data-sidebar="group-content" class="w-full text-sm"><ul data-slot="sidebar-menu" data-sidebar="menu" class="flex w-full min-w-0 flex-col gap-1 px-2"><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_6th/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-users h-5 w-5" aria-hidden="true"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><path d="M16 3.128a4 4 0 0 1 0 7.744"></path><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><circle cx="9" cy="7" r="4"></circle></svg><span class="ml-3">수강생 목록</span></a></li><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_6th/assignments/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open h-5 w-5" aria-hidden="true"><path d="M12 7v14"></path><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"></path></svg><span class="ml-3">과제 목록</span></a></li></ul></div></div></div></div></div></div><div class="flex-1 min-w-0"><header class="h-12 flex items-center border-b border-border bg-card px-4"><button data-slot="sidebar-trigger" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-7 mr-4 text-white" data-sidebar="trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-panel-left" aria-hidden="true"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M9 3v18"></path></svg><span class="sr-only">Toggle Sidebar</span></button><h4 class="text-lg font-semibold "><a href="/front_6th/@tooth-is-silver/" data-discover="true">tooth-is-silver<!-- --> 님의 상세페이지</a> ＞ <!-- -->[3팀 이가은] Chapter 🦍 3-2. 프론트엔드 테스트 코드 🦍</h4></header><main class="p-6"><div><div class="card-wrap"><div data-slot="card" class="card text-card-foreground flex flex-col gap-6 shadow-sm mb-6 p-6 border border-gray-700 bg-gray-800 rounded-lg"><a href="https://github.com/hanghae-plus/front_6th_chapter3-2/pull/20" target="_blank"><div class="flex items-start gap-4"><div class="flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" height="32" aria-hidden="true" viewBox="0 0 24 24" width="32" fill="white" class="w-8 h-8"><path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg></div><div class="flex-1 min-w-0"><div class="flex items-center gap-2 mb-2"><h3 class="text-lg font-semibold text-white truncate">[3팀 이가은] Chapter 🦍 3-2. 프론트엔드 테스트 코드 🦍</h3></div><div class="flex items-center gap-4 text-xs text-gray-500"><span>by <!-- -->tooth-is-silver</span><span>2025. 8. 25.</span></div></div></div></a></div></div><div class="overflow-auto"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h1 id="8주차-과제-체크포인트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#8주차-과제-체크포인트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>8주차 과제 체크포인트</h1>
<h2 id="기본-과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기본-과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기본 과제</h2>
<h3 id="필수"><a class="anchor" aria-hidden="true" tabindex="-1" href="#필수"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>필수</h3>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 반복 유형 선택
<ul>
<li>일정 생성 또는 수정 시 반복 유형을 선택할 수 있다.</li>
<li>반복 유형은 다음과 같다: 매일, 매주, 매월, 매년
<ul>
<li>31일에 매월을 선택한다면 -&gt; 매월 마지막이 아닌, 31일에만 생성하세요.</li>
<li>윤년 29일에 매년을 선택한다면 -&gt; 29일에만 생성하세요!</li>
</ul>
</li>
</ul>
</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 반복 일정 표시
<ul>
<li>캘린더 뷰에서 반복 일정을 시각적으로 구분하여 표시한다.
<ul>
<li>아이콘을 넣든 태그를 넣든 자유롭게 해보세요!</li>
</ul>
</li>
</ul>
</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 반복 종료
<ul>
<li>반복 종료 조건을 지정할 수 있다.</li>
<li>옵션: 특정 날짜까지, 특정 횟수만큼, 또는 종료 없음 (예제 특성상, 2025-06-30까지)</li>
</ul>
</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 반복 일정 단일 수정
<ul>
<li>반복일정을 수정하면 단일 일정으로 변경됩니다.</li>
<li>반복일정 아이콘도 사라집니다.</li>
</ul>
</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 반복 일정 단일 삭제
<ul>
<li>반복일정을 삭제하면 해당 일정만 삭제합니다.</li>
</ul>
</li>
</ul>
<details>
<summary>선택 (작업X)</summary>
- [ ] 반복 간격 설정
  - 각 반복 유형에 대해 간격을 설정할 수 있다.
  - 예: 2일마다, 3주마다, 2개월마다 등
- [ ] 예외 날짜 처리:
  - 반복 일정 중 특정 날짜를 제외할 수 있다.
  - 반복 일정 중 특정 날짜의 일정을 수정할 수 있다.
- [ ] 요일 지정 (주간 반복의 경우):
  - 주간 반복 시 특정 요일을 선택할 수 있다.
- [ ] 월간 반복 옵션:
  - 매월 특정 날짜에 반복되도록 설정할 수 있다.
  - 매월 특정 순서의 요일에 반복되도록 설정할 수 있다.
- [ ] 반복 일정 전체 수정 및 삭제
  - 반복 일정의 모든 일정을 수정할 수 있다.
  - 반복 일정의 모든 일정을 삭제할 수 있다.
</details>
<hr/>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 이 앱에 적합한 테스트 전략을 만들었나요?</li>
</ul>
<h3 id="각-팀원들의-테스트-전략은"><a class="anchor" aria-hidden="true" tabindex="-1" href="#각-팀원들의-테스트-전략은"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>각 팀원들의 테스트 전략은?</h3>
<h1 id="팀원들과-함께-전략을-쌓고-심화과제-진행했습니다"><a class="anchor" aria-hidden="true" tabindex="-1" href="#팀원들과-함께-전략을-쌓고-심화과제-진행했습니다"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>팀원들과 함께 전략을 쌓고 심화과제 진행했습니다!</h1>
<h1 id="기능-회귀-테스트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기능-회귀-테스트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기능 회귀 테스트</h1>
<img width="3378" height="1868" alt="image" src="https://github.com/user-attachments/assets/e196c2ff-db86-4103-9c2f-a8013ab5d968"/>
<h3 id="합의된-테스트-전략과-그-이유는-무엇인가요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#합의된-테스트-전략과-그-이유는-무엇인가요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>합의된 테스트 전략과 그 이유는 무엇인가요?</h3>
<blockquote>
<p>&quot;회귀테스트 중심의 안정성 보장 전략&quot;</p>
</blockquote>
<p>회귀 테스트는 새로운 기능 추가나 리팩터링이 기존 기능을 깨뜨리지 않았는지 보장하는 것이 핵심 목적입니다. 단순히 &quot;전체 테스트&quot;가 아니라 기존 기능 유지에 초점을 맞춘 안전망 역할을 합니다.</p>
<h3 id="핵심-전략"><a class="anchor" aria-hidden="true" tabindex="-1" href="#핵심-전략"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>핵심 전략</h3>
<ol>
<li>
<p>회귀테스트 중심 접근</p>
<ul>
<li>새로운 기능 추가 시 기존 기능이 깨지지 않았음을 보장</li>
<li>기능 간 상호작용 검증에 집중</li>
<li>통합적인 관점에서의 기능 검증</li>
</ul>
</li>
<li>
<p>기존 기능 유지 보장</p>
<ul>
<li>스키마 변경과 필드 추가에 대한 대응</li>
<li>새로운 필드나 로직 추가 시 기존 로직의 안정성 보장</li>
<li>연관 기능들의 정상 동작 검증</li>
</ul>
</li>
<li>
<p>실제 사용자 시나리오 중심 테스트</p>
<ul>
<li>이전 기능 재테스트가 아닌 기능 간 상호작용 검증</li>
<li>실제 사용자 플로우를 시뮬레이션하는 realistic한 테스트 구현</li>
</ul>
</li>
</ol>
<h2 id="선택-이유"><a class="anchor" aria-hidden="true" tabindex="-1" href="#선택-이유"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>선택 이유</h2>
<h3 id="문제-상황"><a class="anchor" aria-hidden="true" tabindex="-1" href="#문제-상황"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>문제 상황</h3>
<p>신규 기능 개발 진행 과정에서 기존 기능과 테스트 코드의 안정성을 보완하기 위해 회귀 테스트 도입을 검토하게 되었습니다. 그러나 팀원들 간 회귀 테스트에 대한 이해도가 상이하여 명확한 개념 정립이 필요한 상황이었습니다.</p>
<p>특히 회귀 테스트의 필요성에 대한 근본적인 의문이 제기되었습니다. 한 팀원이 &quot;회귀 테스트가 새로운 기능을 붙일 때 안정성을 주는 것과 전체 테스트를 하는 것과 차이가 무엇인지&quot;, &quot;회귀 테스트는 꼭 신규 기능 붙일 때만 의미 있는 건가요?&quot;라는 질문을 던지면서 팀 차원의 논의가 시작되었습니다.</p>
<p>또한 회귀 테스트의 유형 선택에 대한 고민도 있었습니다. 시각적 회귀 테스트(Storybook의 크로마틱을 활용한 UI 기준 테스트)를 진행할 것인지, 아니면 기능 회귀 테스트(유닛테스트와 함께 사용하는 방식)를 진행할 것인지에 대한 결정이 필요했습니다. UI 픽셀 기반 회귀 테스트 전략의 필요성에 대해서는 팀 내에서 크게 필요하다는 의견이 없어, 기능 회귀 테스트 중심으로 논의를 진행하기로 했습니다.</p>
<h3 id="주요-논의-과정"><a class="anchor" aria-hidden="true" tabindex="-1" href="#주요-논의-과정"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>주요 논의 과정</h3>
<p><strong>1단계: 회귀 테스트의 본질적 의미 탐구</strong>
앞서 제기된 질문에 대한 답변으로, 회귀 테스트는 새 기능이 아니라 <strong>기존 기능이 깨지지 않았는지 확인하는 것</strong>에 목적이 있다는 점이 강조되었습니다. 기능을 추가할 때 흔히 발생하는 문제는 이미 수정한 기능이 롤백되거나 다른 부분에 사이드이펙트를 주는 것인데, 이를 방지하는 것이 회귀 테스트의 핵심 역할이라고 정의했습니다.</p>
<p>&quot;기능 A, B를 개발한 후 다시 테스트하는 것이 회귀 테스트인가?&quot;라는 근본적인 질문부터 시작하여, 단순한 기능 재테스트와 회귀 테스트의 차이점을 명확히 구분하고자 했습니다.</p>
<p>이러한 논의 과정에서 회귀 테스트와 전체 테스트 간의 명확한 차이점을 정리했습니다:</p>



































<table><thead><tr><th>구분</th><th>회귀테스트<br/>(Regression Test)</th><th>전체테스트<br/>(Full Test Suite)</th></tr></thead><tbody><tr><td><strong>목적</strong></td><td>기존 기능이 여전히 잘 작동하는지 확인</td><td>애플리케이션의 모든 기능을 검증</td></tr><tr><td><strong>실행 시점</strong></td><td>코드 변경 후</td><td>정기적 또는 릴리스 전</td></tr><tr><td><strong>테스트 범위</strong></td><td>변경 영향을 받을 수 있는 기존 기능들</td><td>모든 기능 (신규 + 기존)</td></tr><tr><td><strong>실행 시간</strong></td><td>⚡ 빠름 (일부 테스트만)</td><td>⏱️ 오래 걸림 (모든 테스트)</td></tr><tr><td><strong>주요 관심사</strong></td><td>기존 기능의 <strong>안정성</strong></td><td>애플리케이션의 <strong>완전성</strong></td></tr></tbody></table>
<p>이러한 비교 분석을 통해 회귀 테스트가 단순히 &quot;전체 테스트&quot;가 아니라 <strong>안정성을 보장하는 안전망</strong> 역할을 한다는 점을 명확히 했습니다.</p>
<p><strong>2단계: 구체적 목적과 적용 예시 도출</strong>
스키마 변경이나 새로운 필드 추가 시에도 기존 기능이 그대로 유지되는지 확인하는 것이 회귀 테스트의 주요 목적이라고 정의했습니다. 구체적인 테스트 시나리오를 통해 개념을 명확히 했습니다:</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token comment">// 예시</span>
</span><span class="code-line"><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">&#x27;기존 반복 계산 로직이 excludeDates 추가 후에도 동일하게 동작한다&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">&#x27;weekday 기능 추가 이후에도 기본 주간/월간/연간 로직은 동일하게 동작한다&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 예시
describe(&#x27;기존 반복 계산 로직이 excludeDates 추가 후에도 동일하게 동작한다&#x27;);
describe(&#x27;weekday 기능 추가 이후에도 기본 주간/월간/연간 로직은 동일하게 동작한다&#x27;);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>3단계: 팀 차원의 핵심 가치 합의</strong>
논의를 통해 도출된 회귀 테스트의 핵심 가치는 다음과 같습니다:</p>
<ul>
<li>기존 기능의 유지 보장:
새로운 기능 추가 시 기존 기능이 정상 동작하는지 확인</li>
<li>연관 기능 검증:
여러 기능이 동작할 때 기존 동작 중 연관된 기능들의 정상 동작 확인</li>
<li>안전망 역할:
새 기능 추가 시 사이드이펙트 방지 및 소프트웨어 전체 안정성 개선</li>
</ul>
<h3 id="최종-수립-전략"><a class="anchor" aria-hidden="true" tabindex="-1" href="#최종-수립-전략"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>최종 수립 전략</h3>
<p><strong>회귀 테스트 유형 결정</strong>
시각적 회귀 테스트보다는 기능 회귀 테스트에 집중하기로 결정했습니다. 이는 현재 프로젝트의 신규 기능 개발 특성상 기능적 안정성이 더 중요하다고 판단했기 때문입니다.</p>
<p><strong>회귀 테스트 작성 방향</strong>
단순한 기능 재테스트가 아닌 기능 간 상호작용 검증에 중점을 두기로 했습니다. 새로운 필드나 로직 추가 시 기존 로직의 안정성을 보장하고, 통합적인 관점에서 기능을 검증하는 것을 목표로 설정했습니다.</p>
<p><strong>실무적 고려사항</strong>
&quot;단일 일정 생성 기능 검증&quot;과 같이 이미 존재하는 테스트 코드와의 중복 문제도 함께 검토하여, 효율적인 테스트 코드 작성 방안을 모색했습니다.</p>
<hr/>
<h3 id="추가로-작성된-테스트-코드는-어떤-것들이-있나요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#추가로-작성된-테스트-코드는-어떤-것들이-있나요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>추가로 작성된 테스트 코드는 어떤 것들이 있나요?</h3>
<p>파일 위치 : <code>src/__tests__/회귀테스트.spec.tsx</code> <a href="https://github.com/hanghae-plus/front_6th_chapter3-2/blob/deeba7f6e1f6da2e6c4a51971575e2a1656daff8/src/__tests__/%ED%9A%8C%EA%B7%80%ED%85%8C%EC%8A%A4%ED%8A%B8.spec.tsx">여진석 PR</a></p>
<p><strong>&#x27;회귀테스트: 반복일정과 기존 단일일정 충돌 검사&#x27;</strong></p>
<ol>
<li>
<p>반복일정 생성 시 기존 단일일정과 충돌하는 경우 경고가 표시된다</p>
<ul>
<li>목적: 반복일정 기능 추가 후 기존 충돌 검사 로직이 정상 동작하는지 검증</li>
<li>검증: &#x27;일정 겹침 경고&#x27; 메시지와 구체적인 충돌 정보 표시 확인</li>
</ul>
</li>
<li>
<p>반복일정의 특정 날짜가 기존 일정과 충돌하지 않는 경우 정상 생성된다</p>
<ul>
<li>목적: 충돌하지 않는 반복일정이 정상적으로 생성되는지 검증</li>
<li>검증: 충돌 경고 없이 정상 생성 및 성공 메시지 확인</li>
</ul>
</li>
</ol>
<p><strong>&#x27;회귀테스트: 검색 기능</strong></p>
<ol>
<li>
<p>반복일정이 검색 기능에 정상적으로 포함된다</p>
<ul>
<li>목적: 반복일정과 단일일정이 검색 기능에서 올바르게 동작하는지 검증</li>
<li>검증: 검색 조건에 맞는 반복일정들이 모두 표시되는지 확인</li>
</ul>
</li>
<li>
<p>반복일정이 있는 상태에서 검색 결과가 없으면 적절한 메시지를 표시한다</p>
<ul>
<li>목적: 반복일정 환경에서 검색 결과가 없을 때의 UI 동작 검증</li>
<li>검증: &quot;검색 결과가 없습니다.&quot; 메시지 표시 확인</li>
</ul>
</li>
</ol>
<p><strong>&#x27;회귀테스트: 알림 기능</strong></p>
<ol>
<li>반복일정에 대한 알림이 각 일정마다 정상 동작한다
<ul>
<li>목적: 반복일정의 각 인스턴스별로 알림 기능이 정상 동작하는지 검증</li>
<li>검증: 개별 반복일정에 대한 정확한 알림 메시지 표시 확인</li>
</ul>
</li>
</ol>
<hr/>
<h2 id="과제-셀프회고"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-셀프회고"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 셀프회고</h2>
<!-- -->
<h3 id="기술적-성장"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기술적-성장"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기술적 성장</h3>
<!-- -->
<p>면접 준비로 인해 Full AI 바이브코딩을 진행해본 주차였습니다. TDD의 개념을 Claude Code에 적용하고 코드를 하나씩 검수하면서 실무 관리자의 입장을 이해할 수 있었습니다. 무엇보다 중요한건, 내가 얼마나 테스트 코드를 이해하고 있으며 Claude Code가 만들어준 코드를 얼만큼 증빙하고 이해할 수 있는지가 핵심이었던 것 같습니다.</p>
<p>이번 과제를 통해 TDD 방법론에 대한 이해가 크게 향상되었습니다. 특히 RED 단계에서 단순한 import 오류가 아닌 논리적으로 잘못된 구현으로 테스트를 실패시키는 것의 중요성을 깨달았습니다. Claude Code의 thinking 모드로 RED/GREEN/리팩토링 단계를 거쳐 진행되는 프로세스를 확인하고 적용시키면서 TDD의 본질적인 목적을 명확히 이해할 수 있었습니다.</p>
<p>복잡한 날짜 로직 구현에서 많은 도전을 경험했습니다. 윤년의 2월 29일 처리나 31일 매월 반복 시 해당 일이 없는 달을 건너뛰는 로직 등은 예상보다 복잡했지만, 작은 단위로 나누어 차근차근 해결해 나가는 과정이 매우 의미 있었습니다.</p>
<h3 id="코드-품질"><a class="anchor" aria-hidden="true" tabindex="-1" href="#코드-품질"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>코드 품질</h3>
<!-- -->
<p>가장 만족스러웠던 구현은 <code>isValidRecurrenceDate()</code> 함수를 통한 날짜 유효성 검증 로직이었습니다. 복잡한 날짜 계산을 안전하게 처리할 수 있었고, 함수형 프로그래밍 스타일로 작성한 <code>isNotTargetEvent</code> 헬퍼 함수도 가독성과 재사용성 측면에서 좋은 결과를 보여주었습니다.</p>
<p>다만 아쉬운 부분이 있습니다. 반복 종료일 설정에서 캘린더 아이콘 클릭 방식을 완전히 구현하지 못했고, <code>medium.integration.spec.tsx</code>에 반복 유형 선택 확인 테스트도 추가해야 합니다. 또한 현재는 unit 테스트 중심으로만 구현했는데, E2E 테스트의 필요성에 대해서도 더 고민해봐야 할 것 같습니다.</p>
<p>AI와 함께 코딩하면서 가장 고민했던 부분은 테스트 코드 생성의 접근 방식이었습니다. &quot;모든 요구사항을 한 번에 구현 후 테스트로 검증&quot;보다는 &quot;단계별 요구사항 구현 후 단계별로 테스트로 검증&quot; 방식을 선택했는데, 이 결정이 테스트 코드 작성 과정을 더욱 안정적으로 만들어 주었습니다. 매 단계마다 <code>pnpm test</code>를 실행하여 기존 기능에 사이드이펙트가 없는지 확인하고, AI의 코드를 절대 신뢰할 수 없는(?) 습관도 정착되었습니다.</p>
<h3 id="학습-효과-분석"><a class="anchor" aria-hidden="true" tabindex="-1" href="#학습-효과-분석"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>학습 효과 분석</h3>
<!-- -->
<p>가장 큰 배움은 TDD의 RED-GREEN-REFACTOR 사이클에서 각 단계의 명확한 목적을 이해하게 되었습니다. 단순히 테스트를 작성하고 통과시키는 것이 아니라, 각 단계가 왜 필요한지, 어떤 방식으로 진행해야 하는지를 고민하며 진행하였습니다. 또한 팀원들과 회귀 테스트의 개념과 실무 활용 방안에 대해 토론하면서, 테스트가 단순한 검증 도구가 아닌 개발 전략의 핵심임을 깨달았습니다.</p>
<p>앞으로 더 학습이 필요한 영역들도 명확해졌습니다. React Testing Library를 활용한 더 정교한 통합 테스트 작성 방법을 익히고 싶고, 캘린더 컴포넌트 같은 복잡한 UI 요소를 어떻게 효과적으로 테스트할 수 있을지도 고민해봐야겠습니다. E2E 테스트와 unit 테스트 사이의 균형잡힌 전략을 수립하는 것도 필요합니다. 또한, E2E/unit 테스트에 대한 이해는 명확하나 통합테스트에 대한 이해도가 낮은 것 같아 이 부분도 추가 공부가 필요해보입니다.</p>
<p>실무 적용 가능성은 매우 높다고 생각합니다. TDD를 통한 안정적인 기능 개발 프로세스는 어떤 프로젝트에서든 도움이 될 것이고, AI 도구를 활용한 코드 리뷰 및 품질 관리 방식도 실제 팀 개발에서 충분히 활용할 수 있을 것이라 생각합니다. 오프 코치님이 QnA시간에 공유해주신 BMAD를 통한 agent 방식도 적용해보려고 합니다. 특히 회귀 테스트 중심의 개발 문화는 기존 기능을 보호하면서도 새로운 기능을 안전하게 추가할 수 있는 좋은 방법론이라고 확신합니다.</p>
<h3 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h3>
<!-- -->
<p>과제를 진행하면서 몇 가지 애매했던 부분들이 있었습니다. 반복 종료일 설정에서 처음에는 input 방식으로 시도했지만 <code>repeatEndDate</code>에 정확한 값이 들어가지 않아서 캘린더 아이콘 클릭 방식으로 전환해야 했는데, 어떤 방식으로 진행하는게 더 좋을지 고민하는 시간이 길었습니다. 이에 대해 발제 자료에 라이브러리를 사용할 때의 예시 코드를 들어주거나 했으면 저처럼 테스트 코드를 처음 접하는 수강생들도 이해하기 쉬웠을 것 같다는 생각이 듭니다!</p>
<p>하지만 전반적으로 과제의 구성은 매우 좋았습니다. 체크박스 형태로 요구사항이 명확하게 제시되어 있어서 진행 상황을 단계별로 진행할 수 있었고, TDD 방법론을 강제하여 테스트 주도 개발을 자연스럽게 경험할 수 있었습니다. 특히 팀원과의 개발 방식 논의를 통해 협업 경험을 쌓을 수 있었던 심화 가제와, Claude Code 같은 AI 도구를 활용하여 현대적인 개발 프로세스를 체험할 수 있었던 점이 가장 큰 수확이었습니다. 회귀 테스트 전략 수립을 위해 논의한 내용들이 실무에도 충분히 적용 될 수 있는 부분이라 생각되었습니다. 배움에서 끝낼 것이 아닌 실무 적용까지 고려할 수 있었던 주차였던 것 같아 현업에서 테스트 코드가 없다면 혼자서 주도적으로 진행할 수 있을거란 자신감이 생겼습니다.</p>
<h2 id="리뷰-받고-싶은-내용"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리뷰-받고-싶은-내용"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리뷰 받고 싶은 내용</h2>
<!-- -->
<ul>
<li>
<p>RED 테스트 코드 이해도
이번 과제에서 TDD 방식을 적용하면서 RED-GREEN-REFACTOR 사이클을 거쳐 개발했는데, 특히 RED 단계에서 &quot;논리적으로 잘못된 구현&quot;으로 테스트를 실패시키는 방법이 올바른 TDD 접근인지 궁금합니다. 예를 들어 unit테스트 코드 작성시 실제 구현하여 테스트가 실패하도록 한 것이 적절한 RED 단계 구현이었는지 궁금합니다.</p>
</li>
<li>
<p>요청사항의 기능 테스트 코드 작업 방식에 대해
팀원과 개발 방식을 논의할 때 기본 과제 테스트 코드 작성시 &quot;모든 요구사항을 한 번에 구현 후 검증&quot; vs &quot;단계별 요구사항 구현&quot; 중에서 후자를 선택했습니다. 그 이유는 AI에게 맡기다보니 단계적으로 컨텍스트를 나눠서 작업하려고 했기 때문입니다. 하지만 실무에서는 팀원들과 작업할 때 어떤 접근 방식이 더 효과적인지, 그리고 프로젝트 규모나 팀 구성에 따라 어떤 기준으로 진행해야할지는 고민이 됩니다.</p>
</li>
<li>
<p>함수 분리 기준과 이름
복잡한 날짜 로직(윤년 처리, 31일 매월 반복 등)을 구현하면서 <code>isValidRecurrenceDate()</code>와 <code>getNextRecurrenceDate()</code> 함수로 나누어 작업했는데, 현재의 함수 분리 기준과 명명이 적절할까요? 초기에는 <code>repeat</code>으로 작업하였으나 AI추천해준 명명으로 변경하였습니다. 전 챕터의 클린코드 기준을 적용해서 좀 더 명확한 함수명으로 바꾸었어야했을까요? 또한 날짜 처리 로직에서 더 안전하고 가독성 좋은 구현 방법이 있는지도 궁금합니다.</p>
</li>
</ul>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token comment">// 배열 형식으로 뽑아서 사용하다보니 가독성 저하</span>
</span><span class="code-line"><span class="token function">expect</span><span class="token punctuation">(</span>recurringEvents<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>date<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span><span class="token string">&#x27;2024-01-31&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token function">expect</span><span class="token punctuation">(</span>recurringEvents<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>date<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span><span class="token string">&#x27;2024-03-31&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token function">expect</span><span class="token punctuation">(</span>recurringEvents<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>date<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span><span class="token string">&#x27;2024-05-31&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 배열 형식으로 뽑아서 사용하다보니 가독성 저하
expect(recurringEvents[0].date).toBe(&#x27;2024-01-31&#x27;);
expect(recurringEvents[1].date).toBe(&#x27;2024-03-31&#x27;);
expect(recurringEvents[2].date).toBe(&#x27;2024-05-31&#x27;);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ul>
<li>테스트의 경계
현재 unit 테스트 위주로 구현했는데, 캘린더 애플리케이션 특성상 UI 인터랙션이 중요한 부분들(반복 유형 선택, 캘린더 아이콘 클릭 등)에 대해서는 어느 정도까지 통합 테스트나 E2E 테스트를 추가하는 것이 적절할까요? 작은 기능에 지금도 충분히 테스트가 많다고 생각하는데 unit, 통합테스트, E2E까지 추가하여 비대해지는 것이 당연한 것인지, 그만큼 시간을 들여서 작성해야 테스트로 충분한 검증을 할 수 있는 것인지 궁금합니다.</li>
</ul></div></div><div class="overflow-auto mt-9"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h2>
<p>undefined</p></div></div><div class="mt-9"></div></div></main></div></div></div></div>
</body>
</html>
